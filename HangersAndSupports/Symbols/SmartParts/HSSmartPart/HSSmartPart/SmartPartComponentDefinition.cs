//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//   Copyright (c) 2013, Intergraph Corporation. All rights reserved.
//
//   SmartPartComponentDefinition.cs
//   Author       :  
//   Creation Date:  
//   Description:

//   Change History:
//   dd.mmm.yyyy     who     change description
//   -----------     ---     ------------------
//   27/Dec/2012     BS      Initial Creation   
//   25/Mar/2013    Sridhar,Rajeswari,Hema,Vijaya,Vijay,Pradeep,Manikanth    DI-CP-228142  Modify the error handling for delivered H&S symbols  
//   07/June/2013   Manikanth TR-CP-234520 Implemented TDL Issues 
//   08/08/2013     Vijay     DM-CP-238272 [TR]Some Bergen-Power Restraint parts cause TDL warning 
//   19/03/2014     NDR       CR-CP-244105 Add Constant and Variable Springs to Anvil PH 2010 Catalog - Phase 2
//   25-03-2014     Havish    CR-CP-240075  Check-in new Grout Smart Part into V2015. 
//   22.04.2014     PVK       DM-CP-250839  [TR] Change the existing Strut parts as per customer requirement to 2015
//   15-may-2014    Vinod     DI-CP-249570  Add missing smart parts in Anvil2010 catalog 
//   11-aug-2014    PVK       DM-CP-259377	Create and add Spreader Beam SmartPart (.NET)
//   11-Aug-2014    Ramya     TR-CP-256377  Additional input values are retrieved from catalog part in smart parts   
//   27-Aug-2014    Siva      TR-CP-251283  Additional shape input for shoe to control the leg space.  
//   17-Oct-2014    Vinay     CR-CP-253367  Add Insulation Aspect to DummyLeg SmartPart  
//   12-11-2014     Chethan   DI-CP-263659  Improvise to add End plates to Spreader beam smart part
//   02-12-2014     PVK       DI-CP-253817	Fix priority 2 items to .net SmartParts as a result of new testing  
//   16-12-2014     Chethan   TR-CP-257959  Seonghwa Supporting Type Pipe Clamp with Extension Pipe parts fail with errors  
//   12-12-2014     PVK       TR-CP-264951	Resolve P3 coverity issues found in November 2014 report
//   09-02-2015     Siva      TR-CP-260035  Grout SmartPart is difficult to use     
//   09-02-2015     PVK       TR-CP-257909	JIMC Eye Nut toggle to incorrect placement point
//   13-02-2015     Chethan   DI-CP-263820  Fix priority 3 items to .net SmartParts as a result of new testing
//   02-04-2015   Chethan  CR-CP-270224  Create and Add PlatePipeClamp SmartPart (.NET)  
//   28-04-2015      PVK	 Resolve Coverity issues found in April
//   07-05-2015      PVK	 TR-CP-266590	Insulation Aspect of Dummy Leg SmartPart Incorrect
//   13-05-2015      PVK	 TR-CP-262762	Constant Spring SmartPart fails with incorrect message
//   10-06-2015      PVK	 TR-CP-274155	SmartPart TDL Errors should be corrected.
//   10-06-2015      PVK	 TR-CP-273182	GetPropertyValue in HSSmartPart should handle null value exception thrown by CLR
//   16-07-2015      PVK     Resolve coverity issues found in July 2015 report
//   18-09-2015     Awesome   TR-CP-273849  Resolved Surface of Elliptical Repad SmartPart not persisted 
//   26-Oct-2015     PVK      Resolve coverity issues found in Octpber 2015 report
//   30-11=2015      VDP     Integrate the newly developed SmartParts into Product(DI-CP-282644)
//   18.12.2015      VDP     DI-CP-285917 	Rename PipeStanchion SmartPart to PipeSaddle 
//   28.01.2016      JRM     CR-CP-281046  	Added InsulationInputs for new insulation part
//   04.02.2016      VDP     TR-CP-287704   Few Hilti Anchors are not placing due to same output names
//   07.04.2016      PVK                    Made Changes to Clevis
//   03.05.2016      PVK      TR-CP-294043 	Error and not able to place Variable Stanchion Dummy leg smart parts 
//   06.06.2016      PVK     TR-CP-296065	Fix new coverity issues found in H&S Content 
//   05.08.2016      PVK     TR-CP-298998	Guide SmartPart gives a warning when it shouldn't
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Text;
using Ingr.SP3D.Common.Middle;
using Ingr.SP3D.Common.Middle.Services;
using Ingr.SP3D.ReferenceData.Middle;
using Ingr.SP3D.ReferenceData.Middle.Services;
using Ingr.SP3D.Structure.Middle.Services;
using Ingr.SP3D.Support.Middle;
namespace Ingr.SP3D.Content.Support.Symbols
{
    public class SmartPartComponentDefinition : HangerComponentSymbolDefinition
    {
        private static string previousSizeTableName;
        private static string previousTravelTableName;
        private static string previousLoadTableName;
        private static string previousSize;
        private static double previousTotalTravel;
        private static double previousLoad;
        public static bool isSpringPlacedFirstTime = true;
        private static ReadOnlyCollection<PropertyValue> sizeAttributes;
        private static ReadOnlyCollection<PropertyValue> travelAttributes;
        private static ReadOnlyCollection<PropertyValue> loadAttributes;
        private static ReadOnlyCollection<BusinessObject> loadParts;
        private static ReadOnlyCollection<BusinessObject> travelParts;
        private static ReadOnlyCollection<BusinessObject> sizeParts;
        /// <summary>
        /// Defines the Nut input parameter type.
        /// </summary>
        public struct NutInputs
        {
            /// <summary>
            /// ShapeType The graphic shape to use for the nut or washer. Codelist hsShapeType 1 – Round,2 - Square, 3 - Hex.
            /// </summary>
            public int ShapeType;
            /// <summary>
            /// The outside dimension of the nut or washer.
            /// </summary>
            public double ShapeWidth1;
            /// <summary>
            /// The “other” outside dimension of the nut or washer.If zero, negative, or undefined, this attribute is ignored. Also ignored for Hex shape.   
            /// </summary>
            public double ShapeWidth2;
            /// <summary>
            ///The length of the nut or washer.
            /// </summary>
            public double ShapeLength;
        }
        /// <summary>
        /// Defines the Turnbuckle input parameter type.
        /// </summary>
        public struct TurnbuckleInputs
        {
            /// <summary>
            /// Inside distance between two end nuts. Can be zero.
            /// </summary>
            public double Opening1;
            /// <summary>
            /// The thickness of the end nut shapes. Both ends are the same size.If zero, the end nut shapes are not displayed.
            /// </summary>
            public double Length2;
            /// <summary>
            /// Width of the side blocks. If zero, the blocks will not be displayed.
            /// </summary>
            public double Width2;
            /// <summary>
            ///Length of the side blocks. If zero, the blocks will not be displayed.
            /// </summary>
            public double Thickness2;
            /// <summary>
            ///Opening between the two size blocks. Ignored if the block is not displayed.
            /// </summary>
            public double Opening2;
            /// <summary>
            ///Diameter of optional round center tube. If zero, the center tube is not displayed.
            ///The tube is the same length as Opening1, and fits between the two end nut shapes.
            ///Generally used without side blocks but can both be used at the same time.
            /// </summary>
            public double Diameter1;
            /// <summary>
            ///The Nut input parameter type.
            /// </summary>
            public NutInputs Nut;
        }
        /// <summary>
        /// Defines the Hole Port Input parameter type.
        /// </summary>
        public struct HolePortInputs
        {
            /// <summary>
            /// The Rotation about X
            /// </summary>
            public double Rotx;
            /// <summary>
            /// The Rotation about Y
            /// </summary>
            public double Roty;
            /// <summary>
            /// The Rotation about X
            /// </summary>
            public double Rotz;
            /// <summary>
            /// The position X
            /// </summary>
            public double PosX;
            /// <summary>
            /// The position Y
            /// </summary>
            public double PosY;
            /// <summary>
            /// The size
            /// </summary>
            public double Size;
        }

        /// <summary>
        /// Defines the Plate input parameter type.
        /// </summary>
        public struct PlateInputs
        {
            /// <summary>
            /// The Width of basic rectangular plate 
            /// </summary>
            public double width1;
            /// <summary>
            /// The length of basic rectangular plate 
            /// </summary>
            public double length1;
            /// <summary>
            /// The thickness of basic rectangular plate 
            /// </summary>
            public double thickness1;
            /// <summary>
            /// The shape to use for the top left corner of the plate 
            /// </summary>
            public int tlCornerType;
            /// <summary>
            /// Horizontal dimension of the top left corner 
            /// </summary>
            public double tlCornerX;
            /// <summary>
            /// Vertical dimension of the top left corner 
            /// </summary>
            public double tlCornerY;
            /// <summary>
            /// Radius to use for the left corner shape
            /// </summary>
            public double tlCornerRad;
            /// <summary>
            /// The shape to use for the top right corner of the plate
            /// </summary>
            public int trCornerType;
            /// <summary>
            /// Horizontal dimension of the top right corner 
            /// </summary>
            public double trCornerX;
            /// <summary>
            /// Vertical dimension of the top right corner 
            /// </summary>
            public double trCornerY;
            /// <summary>
            /// Radius to use for the right corner shape
            /// </summary>
            public double trCornerRad;
            /// <summary>
            /// The shape to use for the bottom left corner of the plate
            /// </summary>
            public int blCornerType;
            /// <summary>
            /// Horizontal dimension of the bottom left corner 
            /// </summary>
            public double blCornerX;
            /// <summary>
            /// Vertical dimension of the bottom left corner 
            /// </summary>
            public double blCornerY;
            /// <summary>
            /// Radius to use for the left corner shape
            /// </summary>
            public double blCornerRad;
            /// <summary>
            /// The shape to use for the bottom right corner of the plate
            /// </summary>
            public int brCornerType;
            /// <summary>
            /// Horizontal dimension of the bottom right corner
            /// </summary>
            public double brCornerX;
            /// <summary>
            /// Vertical dimension of the bottom right corner
            /// </summary>
            public double brCornerY;
            /// <summary>
            /// Radius to use for the right corner shape
            /// </summary>
            public double brCornerRad;
            /// <summary>
            /// Radius of curved end, concave shape in top edge
            /// </summary>
            public double curvedEndRad;
            /// <summary>
            /// Horizontal offset of curve center point. 
            /// </summary>
            public double curvedEndX;
            /// <summary>
            /// Vertical offset of curve center point
            /// </summary>
            public double curvedEndY;
            /// <summary>
            /// Hole1Diameter of Hole Plate
            /// /// </summary>
            public double Hole1Diameter;
            /// <summary>
            /// Horizontal offset for Hole1Diameter
            /// </summary>
            public double Hole1HInset;
            /// <summary>
            /// Vertical Offset for Hole1Diameter
            /// </summary>
            public double Hole1VInset;
            /// <summary>
            /// Creates either a convex or concave shape. 1 for concave, 2 for convex.
            /// </summary>
            public int curvedEndType;
        }
        /// <summary>
        /// Data type to hold the Standard Shape Data in hs_Plates_AddPlateShape graphic function
        /// </summary>
        public struct PlateCorner
        {
            /// <summary>
            /// The s name
            /// </summary>
            public String name;
            /// <summary>
            /// The d xstart
            /// </summary>
            public Double startX;     // X, Y of where to start the corner
            /// <summary>
            /// The d ystart
            /// </summary>
            public Double startY;
            /// <summary>
            /// The d xdir
            /// </summary>
            public Double dirX;       // +1/-1 for direction to move the points from the corner
            /// <summary>
            /// The d ydir
            /// </summary>
            public Double dirY;
            /// <summary>
            /// The i corner type
            /// </summary>
            public int CornerType;
            /// <summary>
            /// The d corner X
            /// </summary>
            public Double CornerX;
            /// <summary>
            /// The d corner Y
            /// </summary>
            public Double CornerY;
            /// <summary>
            /// The d corner RAD
            /// </summary>
            public Double CornerRad;
            /// <summary>
            /// The d alpha
            /// </summary>
            public Double Alpha;      // For angle calculations
            /// <summary>
            /// The d beta
            /// </summary>
            public Double Beta;
            /// <summary>
            /// The d xpoint
            /// </summary>
            public Double pointX;     // Calculated tangent points for drawing geometry
            /// <summary>
            /// The d ypoint
            /// </summary>
            public Double pointY;
            /// <summary>
            /// The i points
            /// </summary>
            public int Points;
            /// <summary>
            /// The b X rounded
            /// </summary>
            public bool RoundedX;
            /// <summary>
            /// The b Y rounded
            /// </summary>
            public bool RoundedY;
        }
        /// <summary>
        /// Defines the inputs for the ClevisHanger shape.
        /// </summary>
        public struct ClevisHangerInputs
        {
            /// <summary>
            /// The slope of the pipe that the part is being used on
            /// </summary>
            public double Angle1;
            /// <summary>
            /// Defines the shape of the top. 
            /// </summary>
            public int ClevisTopShp;
            /// <summary>
            /// Defines the shape of the bottom. 
            /// </summary>
            public int ClevisBotShp;
            /// <summary>
            /// The distance from the pipe centerline to where the end of the rod that attaches to the clevis would be.
            /// </summary>
            public double RodTakeOut;
            /// <summary>
            /// The distance from the pipe centerline to the top of the clevis.
            /// </summary>
            public double Height1;
            /// <summary>
            /// The total inside diameter of the clevis hanger.
            /// </summary>
            public double Diameter1;
            /// <summary>
            /// The width of the top portion of the clevis hanger.
            /// </summary>
            public double Width1;
            /// <summary>
            /// The thickness of the top portion of the clevis hanger.
            /// </summary>
            public double Thickness1;
            /// <summary>
            /// The width of the bottom portion of the clevis hanger.
            /// </summary>
            public double Width2;
            /// <summary>
            /// The thickness of the bottom portion of the clevis hanger.
            /// </summary>
            public double Thickness2;
            /// <summary>
            /// The diameter of the bolt.
            /// </summary>
            public double Pin1Diameter;
            /// <summary>
            /// Length of the bolt.
            /// </summary>
            public double Pin1Length;
            /// <summary>
            /// The height of the bolt.  Measured from the pipe centerline to the centerline of the bolt.
            /// </summary>
            public double Height2;
            /// <summary>
            /// The height from the lowest part of the top section to the flat spot on top.
            /// </summary>
            public double Height3;
            /// <summary>
            /// The height from the lowest part of the top section to the corner where the top angles in.
            /// </summary>
            public double Height4;
            /// <summary>
            /// The length of the top flat spot.
            /// </summary>
            public double Length1;
            /// <summary>
            /// The top inside length.
            /// </summary>
            public double Length2;
            /// <summary>
            /// The length of the lower flat spot.  
            /// </summary>
            public double Length3;
            /// <summary>
            /// The height from the pipe centerline to the top-most edge of the bottom section.
            /// </summary>
            public double Height5;
            /// <summary>
            /// The height from the pipe centerline to the top-edge of the angled section.  
            /// </summary>
            public double Height6;
            /// <summary>
            /// The height from the pipe centerline to the bottom of the angled section
            /// </summary>
            public double Height7;
            /// <summary>
            /// The thickness, from the inside edge of the clevis, of the liner.
            /// </summary>
            public double Thickness3;
            /// <summary>
            /// The height from the pipe centerline to the top of the liner.
            /// </summary>
            public double Height8;
            /// <summary>
            /// The overall thickness if the liner is actually a wrap.
            /// </summary>
            public double Thickness4;
            /// <summary>
            ///The diameter of the bolt.
            /// </summary>
            public double Pin2Diameter;
            /// <summary>
            /// Length of the spacer/Roller.
            /// </summary>
            public double Pin2Length;
            /// <summary>
            ///The Larger diameter of the roller.
            /// </summary>
            public double Diameter2;
        }
        /// <summary>
        /// Defines the inputs for the welded beam attachment.
        /// </summary>
        public struct WBABoltInputs
        {
            /// <summary>
            /// Inside gap between the two sides. Can be zero but not negative.
            /// </summary>
            public double Gap1;
            /// <summary>
            /// Thickness of the two sides. Must be positive.
            /// </summary>
            public double Thickness1;
            /// <summary>
            /// Total height of the sides, including the base. Must be positive.
            /// </summary>
            public double Height1;
            /// <summary>
            /// Width of the sides. Must be positive.
            /// </summary>
            public double Width1;
            /// <summary>
            /// Left-to-right offset of sides from the bolt center.
            /// If zero, the sides are centered. Must be positive. 
            /// The edge of the side is located the specified amount away from the bolt centerline.
            /// </summary>
            public double Offset1;
            /// <summary>
            /// Width of the base. Must be positive. If zero, use Width1.
            /// </summary>
            public double Width2;
            /// <summary>
            /// Length of the base. Must be positive. If zero, use Gap1 plus 2 x Thickness1.
            /// </summary>
            public double Length2;
            /// <summary>
            /// Thickness of the base. Must be positive. If zero, use Thickness1.
            /// </summary>
            public double Thickness2;
            /// <summary>
            /// Left-to-right offset of base from the bolt center. 
            /// If zero, the base is centered.Must be positive. 
            /// The edge of the base is located the specified amount away from the bolt centerline.
            /// </summary>
            public double Offset2;
            /// <summary>
            /// The Gap2
            /// </summary>
            public double Gap2;
            /// <summary>
            /// Width of the plate. If zero or negative, the plate is not drawn.
            /// </summary>
            public double Width3;
            /// <summary>
            /// Length of the plate. If zero or negative, the plate is not drawn.
            /// </summary>
            public double Length3;
            /// <summary>
            /// Thickness of the plate. If zero, the plate is not drawn. 
            /// If positive, the inside face of the plate is on the outside face of the BASE. 
            /// If negative, the outside face of the plate is on the outside face of the BASE ( so the plate is embedded into the BASE). 
            /// The surface port is always located on the most outward face of the plate or BASE.
            /// </summary>
            public double Thickness3;
            /// <summary>
            /// Left-to-right offset of the plate from the bolt center. 
            /// If zero, the plate is centered. 
            /// If positive, the edge of the plate is located the specified amount away from the bolt centerline.
            /// </summary>
            public double Offset3;
            /// <summary>
            /// Diameter of bolt / pin. If zero, the pin is not drawn. 
            /// This diameter may also be used as the connection diameter. 
            /// AIR’s that join a WBABolt to an EyeNut would read the Pin1Diameter property from the WBABolt and pass it into the PinDiameter prompt of the EyeNut.
            /// </summary>
            public double Pin1Diameter;
            /// <summary>
            /// Length of bolt / pin. If, zero, the pin is not drawn. The length is always centered on the port location.
            /// </summary>
            public double Pin1Length;
            /// <summary>
            /// Height of the bolt centerline, relative to the top of the BASE. Determines the location of the bolt graphic and of the port.
            /// </summary>
            public double Height2;
            /// <summary>
            /// The shape to use for the top left corner of the plate shape.
            /// </summary>
            public int TLCornerType;
            /// <summary>
            /// Horizontal dimension of the corner shape. 
            /// </summary>
            public double TLCornerX;
            /// <summary>
            /// Vertical dimension of the corner shape. 
            /// </summary>
            public double TLCornerY;
            /// <summary>
            /// Radius to use for the corner shape. 
            /// </summary>
            public double TLCornerRadius;
            /// <summary>
            ///  The shape to use for the top right corner of the plate shape.
            /// </summary>
            public int TRCornerType;
            /// <summary>
            /// Horizontal dimension of the corner shape. 
            /// </summary>
            public double TRCornerX;
            /// <summary>
            /// Vertical dimension of the corner shape. 
            /// </summary>
            public double TRCornerY;
            /// <summary>
            /// Radius to use for the corner shape. 
            /// </summary>
            public double TRCornerRadius;
        }
        /// <summary>
        /// Defines the inputs for the welded beam attachment.
        /// </summary>
        public struct WBAHoleInputs
        {
            /// <summary>
            /// The WBAHoleConfig
            /// </summary>
            public int WBAHoleConfig;
            /// <summary>
            /// Vertical offset of the hole port from the lowest edge of the WBA (Height1). 
            /// If zero, the hole port would be flush with the lowest edge of the WBA. Must be positive. 
            /// </summary>
            public double Offset1;
            /// <summary>
            /// Inside gap between the two sides. Can be zero but not negative. If zero the sides should not be shown.
            /// </summary>
            public double Gap1;
            /// <summary>
            /// Thickness of each of the two sides. Must be positive. If zero the sides should not be shown.
            /// </summary>
            public double Thickness1;
            /// <summary>
            /// Total height of the sides, including the base. 
            /// Must be positive. Height1 is the total height of the WBA Hole, not including the height of the extra rod connection.
            /// If a base plate or top feature is included its height is included in H1, not added to it.  Also if the bottom is specified so that is overlaps the sides, its thickness does 
            /// </summary>
            public double Height1;
            /// <summary>
            /// Width of the sides. Must be positive.
            /// </summary>
            public double Width1;
            /// <summary>
            /// Front-to-back offset of sides from the hole center. I
            /// f zero, the sides, top and bottom are centered. 
            /// Must be positive. The edge of the side is located the specified amount away from the hole centerline.
            /// </summary>
            public double Offset2;
            /// <summary>
            /// Width of the bottom. If less than Width1, use Width1.
            /// </summary>
            public double Width2;
            /// <summary>
            /// Length of the bottom. If less than Gap1, use Gap1. 
            /// If greater than Gap1, subtract Thickness2 from Height1 of the sides and let the bottom overlap the side.
            /// </summary>
            public double Length1;
            /// <summary>
            ///Thickness of the bottom. Must be positive. If zero, use Thickness1. Note that this thickness is not added to Height1.
            /// </summary>
            public double Thickness2;
            /// <summary>
            /// Width of the top. If zero, use Width1.
            /// </summary>
            public double Width3;
            /// <summary>
            /// Length of the top. If negative, do not show a top graphic. 
            /// If less than Gap1 then draw the ears inside of U. If Greater than Gap1 + 2xThickness1 draw the top as ‘Ears’.
            /// </summary>
            public double Length2;
            /// <summary>
            /// Thickness of the top. Must be positive. If zero, use Thickness1. Note that this thickness is not added to Height1.
            /// </summary>
            public double Thickness3;
            /// <summary>
            /// Width of the plate. If zero or negative, the plate is not drawn. If shape = round then ignore Width4
            /// </summary>
            public double Width4;
            /// <summary>
            /// Length of the plate. If zero or negative, the plate is not drawn. If shape = round then length4 is the diameter of the plate.
            /// </summary>
            public double Length3;
            /// <summary>
            /// Thickness of the plate. Must be positive. If zero, the plate is not drawn. 
            /// If positive, the lower face of the concrete plate is on the upper face of the top, or sides if there is no top. 
            /// The surface port is always located on the most upper face of the concrete plate, top or Sides. Note that this thickness is not added to Height1.
            /// </summary>
            public double Thickness4;
            /// <summary>
            /// Left-to-right offset of the plate from the hole center. If zero, the plate is centered. 
            /// If positive, the edge of the plate is located the specified amount away from the hole centerline.
            /// </summary>
            public double Offset3;
            /// <summary>
            /// The graphic shape to use for the side base plate graphic.
            /// </summary>
            public int SimpShapeType;
            /// <summary>
            ///The outside dimension of the extra rod connection shape.
            /// </summary>
            public double Width5;
            /// <summary>
            /// The thickness of the extra rod connection shape, from the lower face of the base plate, to the lower face of the extra rod connection.  
            /// Negative values are allowed.  
            /// If less than 0 the thickness will start at the upper surface of the bottom, of base plate, and extend up. If zero then do not show the extra rod connection.
            /// </summary>
            public double Thickness5;
            /// <summary>
            /// The graphic shape to use for the extra rod connection graphic.
            /// </summary>
            public int ShapeType;
        }
        /// <summary>
        /// Defines the inputs for the Strap shape.
        /// </summary>
        public struct StrapInputs
        {
            /// <summary>
            /// Inside distance between the legs of the strap. Must be greater than PipeOD. 
            /// Determines the spacing of the vertical legs of the strap as well as the bend radius for the curved part of the strap. 
            /// The nominal bend radius equals half the StrapWidthInside dimension.
            /// </summary>
            public double StrapWidthInside;
            /// <summary>
            /// Inside height from the base of the strap to the top.
            /// </summary>
            public double StrapHeightInside;
            /// <summary>
            /// Thickness of the rectangular stock used to make the strap. If zero, none of the strap shape is drawn.
            /// </summary>
            public double StrapThickness;
            /// <summary>
            /// Width of the rectangular stock used to make the strap. If zero, none of the strap shape is drawn.
            /// </summary>
            public double StrapStockWidth;
            /// <summary>
            /// Adds a flat spot in the curved part of the strap. Must be less than or equal to StrapWidthInside.
            /// </summary>
            public double StrapFlatSpot;
            /// <summary>
            /// Top gap, between outside of pipe and inside of strap. 
            /// Affects the vertical position of the center of the bend radius for the curved part of the strap.
            /// </summary>
            public double StrapTopGap;
            /// <summary>
            /// Width to the outside of the wings, if any. If zero, or less than StrapWidthInside plus twice the StrapThickness, then wings are not drawn. 
            /// Also affects position of gussets.
            /// </summary>
            public double StrapWidthWings;
            /// <summary>
            /// The effects this has are:
            /// 1. Strap graphic stops at the tangent point on the right side, as shown.
            /// 2. Wing, bolts and gussets are only included on the left side
            /// </summary>
            public int StrapOneSided;
            /// <summary>
            /// For split clamp-type tubing straps, creates a gap at the top and splits the strap into two graphics.
            /// Can be zero or positive. If both this and StrapSplitExtension are zero, the strap is one-piece.
            /// </summary>
            public double StrapSplitGap;
            /// <summary>
            /// Length of the tabs for split clamp-type tubing straps.
            /// From the top inside of the strap to the end of the tabs. Must be greater than the strap stock thickness to be visible.
            /// </summary>
            public double StrapSplitExtension;
        } /// <summary>
        /// Defines the ElbowLug input parameter type.
        /// </summary>
        public struct ElbowLugInputs
        {
            /// <summary>
            /// Specifies the radius of the elbow where the part is placed.
            /// </summary>
            public double ElbowRadius;
            /// <summary>
            /// Specifies the distance between the face of the elbow and the center.
            /// </summary>
            public double FaceToCenter;
            /// <summary>
            /// Specifies the graphic shape used for the top of the lug.
            /// </summary>
            public int TopShape;
            /// <summary>
            ///Specifies the angle between the top curve start and end point.
            /// </summary>
            public double Angle1;
            /// <summary>
            ///Specifies the distance between the horizontal pipe center line and the top lug port.
            /// </summary>
            public double RodTakeOut;
            /// <summary>
            ///Specifies the top width of the elbow lug.
            /// </summary>
            public double Width1;
            /// <summary>
            ///Specifies the bottom width of the elbow lug.
            /// </summary>
            public double Width2;
            /// <summary>
            ///Specifies the thickness of the lug.
            /// </summary>
            public double Thickness1;
            /// <summary>
            ///Specifies the angle of the left tapered portion.
            /// </summary>
            public double Angle2;
            /// <summary>
            ///Specifies the angle of the right tapered portion.
            /// </summary>
            public double Angle3;
            /// <summary>
            /// Specifies the angle of the bottom tapered portion.
            /// </summary>
            public double Angle4;
            /// <summary>
            ///Specifies the gap between lug components of a double lug.
            /// </summary>
            public double Gap1;
            /// <summary>
            ///Specifies the offset of the stiffener between the two components of a double lug.
            /// </summary>
            public double StiffenerOffset;
            /// <summary>
            ///Specifies the height of the stiffener between the two components of a double lug.
            /// </summary>
            public double StiffenerHeight;
            /// <summary>
            ///Specifies the length of the stiffener between the two components of a double lug.
            /// </summary>
            public double StiffenerLength;
            /// <summary>
            ///Specifies the distance between the top port and the top of the lug.
            /// </summary>
            public double Offset1;
            /// <summary>
            ///Specifies the length of the chamfered edges.
            /// </summary>
            public double ChamfLength;
            /// <summary>
            ///Specifies the length of the Tapered edges.
            /// </summary>
            public double TaperLength;
            /// <summary>
            ///Specifies the required radius of the bottom arc of the elbow lug.
            /// </summary>
            public double ActualRadius;
            /// <summary>
            /// Diameter of the Pin,If zero or negative, the pin is not drawn.
            /// </summary>
            public double Pin1Diameter;
            /// <summary>
            /// Length of the Pin,If, zero or negative, the pin is not drawn.
            /// </summary>
            public double Pin1Length;
        }
        /// <summary>
        /// Defines the inputs for the Arc shape.
        /// </summary>
        public struct ArcInputs
        {
            /// <summary>
            /// The Start Angle.
            /// </summary>
            public double StartAngle;
            /// <summary>
            /// The End Angle.
            /// </summary>
            public double EndAngle;
            /// <summary>
            /// The Radius.
            /// </summary>
            public double Radius;

        }
        /// <summary>
        /// Defines the inputs for the Line.
        /// </summary>
        public struct LineInputs
        {
            /// <summary>
            /// The StartX.
            /// </summary>
            public double StartX;
            /// <summary>
            /// The StartY.
            /// </summary>
            public double StartY;
            /// <summary>
            /// The StartZ.
            /// </summary>
            public double StartZ;
            /// <summary>
            /// The EndX.
            /// </summary>
            public double EndX;
            /// <summary>
            /// The EndX.
            /// </summary>
            public double EndY;
            /// <summary>
            /// The EndX.
            /// </summary>
            public double EndZ;

        }

        /// <summary>
        /// Defines the inputs required to construct ouputs of a Pin. 
        /// </summary>
        public struct PinInputs
        {
            /// <summary>
            /// Diameter of the Pin,If zero or negative, the pin is not drawn.
            /// </summary>
            public double PinDiameter;
            /// <summary>
            /// Length of the Pin,If, zero or negative, the pin is not drawn.
            /// </summary>
            public double PinLength;
            /// <summary>
            /// Diameter of the Cotter Pin..
            /// </summary>
            public double CotterDiameter;
            /// <summary>
            /// Length of the Cotter Pin
            /// </summary>
            public double CotterLength;
            /// <summary>
            /// Offset of the Cotter Pin.
            /// </summary>
            public double CotterOffset;
        }

        /// <summary>
        /// Defines the inputs for the Guide.
        /// </summary>
        public struct GuideInputs
        {
            /// <summary>
            /// Width of base plate.Width1 is required if Thickness1 > 0
            /// </summary>
            public double Width1;
            /// <summary>
            /// Depth of base plate Length1 is required if Thickness2 > 0
            /// </summary>
            public double Length1;
            /// <summary>
            /// Thickness of base plate,If Thickness1 < 0, the Base plate is not included 
            /// </summary>
            public double Thickness1;
            /// <summary>
            /// Distance between edges of horizontal and vertical plate.
            /// </summary>
            public double Offset1;
            /// <summary>
            /// Width of vertical plate.
            /// </summary>
            public double Width2;
            /// <summary>
            /// Length of vertical plate
            /// </summary>
            public double Length2;
            /// <summary>
            /// Thickness of vertical plate.Required if vertical Steel is not used .Required if vertical steel is used and section configuration is vertical
            /// </summary>
            public double Thickness2;
            /// <summary>
            /// The offset the horizontal section from the connection point.
            /// </summary>
            public double Offset2;
            /// <summary>
            ///Gap between two vertical plates or between the cardinal points of the steel sections.
            /// </summary>
            public double Gap1;
            /// <summary>
            /// Section standard for vertical plate.
            /// </summary>
            public string VerPlSecStand;
            /// <summary>
            /// Section size for vertical plate
            /// </summary>
            public string VerPlSecSize;
            /// <summary>
            /// Section type for vertical plate 
            /// </summary>
            public string VerPlSecType;
            /// <summary>
            /// Width of horizontal plate
            /// </summary>
            public double Width3;
            /// <summary>
            /// Depth of horizontal plate
            /// </summary>
            public double Length3;
            /// <summary>
            /// Thickness of horizontal plate
            /// </summary>
            public double Thickness3;
            /// <summary>
            /// Section standard for horizontal plate
            /// </summary>
            public string HorPlSecStand;
            /// <summary>
            ///Section size for horizontal plate
            /// </summary>
            public string HorPlSecSize;
            /// <summary>
            /// Section type for horizontal plate 
            /// </summary>
            public string HorPlSecType;
            /// <summary>
            /// This attribute will use YES/NO codelist.
            ///YES – Base plate and vertical plate will be one solid shape
            ///NO –Separate solid shapes will be used to create base plate and vertical plate
            /// </summary>
            public int SolidBaseVerPl;
            /// <summary>
            /// This attribute will use YES/NO codelist.
            ///YES – Vertical and horizontal plate will be one solid shape
            ///NO –Separate solid shapes will be used to create horizontal and vertical plate
            /// </summary>
            public int SolidVerHorPl;
            /// <summary>
            /// Rotation angle of the first vertical section along its longitudinal axis
            /// </summary>
            public double Angle1;
            /// <summary>
            /// Rotation angle of the second vertical section along its longitudinal axis.
            /// </summary>
            public double Angle2;
            /// <summary>
            /// Rotation angle of the first Horizontal section along its longitudinal axis.
            /// </summary>
            public double Angle3;
            /// <summary>
            /// Rotation angle of the second Horizontal section along its longitudinal axis.
            /// </summary>
            public double Angle4;
            /// <summary>
            /// Cardinal point of the first vertical section. Determines the connection point of the steel section
            ///For Details, see the CrossSectionCardinalPoints codelist in the Allcodelists.xls
            /// </summary>
            public int Connection1;
            /// <summary>
            ///Cardinal point of the second vertical section
            ///Determines the connection point of the steel section
            ///For Details, see the CrossSectionCardinalPoints codelist in the Allcodelists.xls
            /// </summary>
            public int Connection2;
            /// <summary>
            /// Cardinal point of the first Horizontal section.
            /// Determines the connection point of the steel section
            /// For Details, see the CrossSectionCardinalPoints codelist in the Allcodelists.xls
            /// </summary>
            public int Connection3;
            /// <summary>
            /// Cardinal point of the second Horizontal section. 
            /// Determines the connection point of the steel section
            ///For Details, see the CrossSectionCardinalPoints codelist in the Allcodelists.xls
            /// </summary>
            public int Connection4;
            /// <summary>
            /// Determines if the first vertical steel section is mirrored about the specified cardinal point.If not specified, the section is not mirrored
            /// </summary>
            public int Mirrored1;
            /// <summary>
            /// Determines if the second vertical steel section is mirrored about the specified cardinal point.If not specified, the  section is not mirrored
            /// </summary>
            public int Mirrored2;
            /// <summary>
            /// If the vertical steel section is vertical or horizontal If SecConfig is Horizontal Length2 is required. If SecConfig is Vertical Thickness2 is required.
            /// </summary>
            public int SecConfig;
            /// <summary>
            /// Offset of X centre point.
            /// </summary>
            public double CPXoffset;
            /// <summary>
            /// Offset of Y centre point
            /// </summary>
            public double CPYoffset;
            /// <summary>
            /// Specifies the Height of the guide
            /// </summary>
            public double GuideHeight;
        }

        /// <summary>
        /// Defines the inputs for the slide plate.
        /// </summary>
        public struct SlidePlateInputs
        {
            /// <summary>
            /// The Width of plate 1.
            /// </summary>
            public double Width1;
            /// <summary>
            /// The Width of plate 2.
            /// </summary>
            public double Width2;
            /// <summary>
            /// The Width of plate 3.
            /// </summary>
            public double Width3;
            /// <summary>
            /// The Width of plate 4.
            /// </summary>
            public double Width4;
            /// <summary>
            /// The Width of plate 5.
            /// </summary>
            public double Width5;
            /// <summary>
            /// The Width of plate 6.
            /// </summary>
            public double Width6;

            /// <summary>
            /// Depth of plate 1.
            /// </summary>
            public double Height1;
            /// <summary>
            /// Depth of plate 2.
            /// </summary>
            public double Height2;
            /// <summary>
            /// Depth of plate 3.
            /// </summary>
            public double Height3;
            /// <summary>
            /// Depth of plate 4.
            /// </summary>
            public double Height4;
            /// <summary>
            /// Depth of plate 5.
            /// </summary>
            public double Height5;
            /// <summary>
            /// Depth of plate 6.
            /// </summary>
            public double Height6;

            /// <summary>
            /// Thickness of plate 1
            /// </summary>
            public double Thickness1;
            /// <summary>
            /// Thickness of plate 2
            /// </summary>
            public double Thickness2;
            /// <summary>
            /// Thickness of plate 3
            /// </summary>
            public double Thickness3;
            /// <summary>
            /// Thickness of plate 4
            /// </summary>
            public double Thickness4;
            /// <summary>
            /// Thickness of plate 5
            /// </summary>
            public double Thickness5;
            /// <summary>
            /// Thickness of plate 6
            /// </summary>
            public double Thickness6;

            /// <summary>
            /// Distance in X direction between slide plate part local (0,0,0) and plate1 (0,0,0)
            /// </summary>
            public double XPl1;
            /// <summary>
            /// Distance in X direction between slide plate part local (0,0,0) and plate2 (0,0,0)
            /// </summary>
            public double XPl2;
            /// <summary>
            /// Distance in X direction between slide plate part local (0,0,0) and plate3 (0,0,0)
            /// </summary>
            public double XPl3;
            /// <summary>
            /// Distance in X direction between slide plate part local (0,0,0) and plate4 (0,0,0)
            /// </summary>
            public double XPl4;
            /// <summary>
            /// Distance in X direction between slide plate part local (0,0,0) and plate5 (0,0,0)
            /// </summary>
            public double XPl5;
            /// <summary>
            /// Distance in X direction between slide plate part local (0,0,0) and plate6 (0,0,0)
            /// </summary>
            public double XPl6;

            /// <summary>
            /// Distance in Y direction between slide plate part local (0,0,0) and plate1 (0,0,0)
            /// </summary>
            public double YPl1;
            /// <summary>
            /// Distance in Y direction between slide plate part local (0,0,0) and plate2 (0,0,0)
            /// </summary>
            public double YPl2;
            /// <summary>
            /// Distance in Y direction between slide plate part local (0,0,0) and plate3 (0,0,0)
            /// </summary>
            public double YPl3;
            /// <summary>
            /// Distance in Y direction between slide plate part local (0,0,0) and plate4 (0,0,0)
            /// </summary>
            public double YPl4;
            /// <summary>
            /// Distance in Y direction between slide plate part local (0,0,0) and plate5 (0,0,0)
            /// </summary>
            public double YPl5;
            /// <summary>
            /// Distance in Y direction between slide plate part local (0,0,0) and plate6 (0,0,0)
            /// </summary>
            public double YPl6;

            /// <summary>
            /// Distance in Z direction between slide plate part local (0,0,0) and plate1 (0,0,0)
            /// </summary>
            public double ZPl1;
            /// <summary>
            /// Distance in Z direction between slide plate part local (0,0,0) and plate2 (0,0,0)
            /// </summary>
            public double ZPl2;
            /// <summary>
            /// Distance in Z direction between slide plate part local (0,0,0) and plate3 (0,0,0)
            /// </summary>
            public double ZPl3;
            /// <summary>
            /// Distance in Z direction between slide plate part local (0,0,0) and plate4 (0,0,0)
            /// </summary>
            public double ZPl4;
            /// <summary>
            /// Distance in Z direction between slide plate part local (0,0,0) and plate5 (0,0,0)
            /// </summary>
            public double ZPl5;
            /// <summary>
            /// Distance in Z direction between slide plate part local (0,0,0) and plate6 (0,0,0)
            /// </summary>
            public double ZPl6;

            /// <summary>
            /// Diameter of the pipe
            /// </summary>
            public double PipeDia;
            /// <summary>
            /// Height of the Shoe
            /// </summary>
            public double ShoeHeight;

        }

        /// <summary>
        /// Defines the inputs for the Swivel Ring.
        /// </summary>
        public struct SwivelInputs
        {
            /// <summary>
            /// Outside diameter of rod that attaches to the swivel ring.
            /// The rod is NOT included in this part’s graphics. Does NOT affect the graphics.
            /// </summary>
            public double RodDiameter;
            /// <summary>
            /// The distance from the pipe centerline to the bottom of the rod. 
            /// This will be the location of the rod end port. It is required. Must be > 0.5 * PipeOD
            /// </summary>
            public double RodTakeOut;
            /// <summary>
            /// The outside diameter of the pipe.It is required.Must be > 0
            /// </summary>
            public double PipeOD;
            /// <summary>
            /// The distance from the rod centerline to the edge of the lower top flange.
            /// </summary>
            public double Width1;
            /// <summary>
            /// The distance from the rod centerline to the edge of the upper top flange.
            /// </summary>
            public double Width2;
            /// <summary>
            /// The width of the Band or Ring. Must be > 0
            /// </summary>
            public double Width3;
            /// <summary>
            /// The thickness of the Band or Ring. Must be > 0
            /// </summary>
            public double Thickness1;
            /// <summary>
            /// The distance from the pipe centerline to the bottom face of the lower flange. 
            /// Must be > 0.5 * PipeOD
            /// </summary>
            public double Height1;
            /// <summary>
            /// The inside diameter of the band if it differs from the PipeOD. 
            /// If <= PipeOD then use PipeOD as the inside diameter of the Band or Ring.
            /// </summary>
            public double Diameter1;
            /// <summary>
            /// The distance between the two bolt ears for the J Hanger Type. 
            /// If Gap1 <= 0 then this is not a J Hanger so do not use Gap1
            /// </summary>
            public double Gap1;
            /// <summary>
            /// The distance from the inside edge of the band to the outer edge of the upper bolt ear for the J Hanger type.
            /// </summary>
            public double Width4;
            /// <summary>
            /// The height of the top rod connection. Optional for standard or J Hanger type.
            /// </summary>
            public double Height2;
            /// <summary>
            /// The diameter of the top rod connection. Optional for standard or J Hanger type. 
            /// Required for Adjustable Ring Type. Must be > RodDiameter
            /// </summary>
            public double Diameter2;
            /// <summary>
            /// The thickness of the wrap from the outside of the band to the outside of the wrap.
            /// </summary>
            public double Thickness2;
            /// <summary>
            /// Thickness of plate 2The diameter of the bolt. For J Hanger Type.
            /// If <= 0 then use RodDiameter
            /// </summary>
            public double Pin1Diameter;
            /// <summary>
            /// The length of the Bolt.Required for J Hanger Type.
            /// If <= 0 then use Gap1 + 2 * Pin1Diameter
            /// </summary>
            public double Pin1Length;
            /// <summary>
            /// The distance from the pipe centerline to the structure port. 
            /// Required for J Hanger Type. There will be no graphics for the hole.
            /// </summary>
            public double Height3;
        }
        /// <summary>
        /// Defines the Shoe input parameter type.
        /// </summary>

        public struct ShoeInputs
        {
            /// <summary>
            /// Attribute used to specify which shoe shape to use.  User will enter shoe name here that is associated to a certain shoe in auxiliary table.
            /// </summary>
            public int ShoeType;
            /// <summary>
            /// The height of the shoe from the bottom of the pipe to the bottom of the shoe, including all plates, guides, pads.
            /// </summary>
            public double ShoeHeight;
            /// <summary>
            /// The entire width of the shoe Overrides the ShoeShape width
            /// </summary>
            public double ShoeWidth;
            /// <summary>
            /// The slope angle of the pipe supported by the shoe
            /// </summary>
            public double SlopeAngle;
            ///  <summary>
            /// Length of the shoe. Must be greater than zero.Shoe length includes the thickness of end plates when end plates are added.
            /// </summary>
            public double ShoeLength;
            ///  /// <summary>
            /// Thickness of the shoe. Must be greater than zero.
            /// </summary>
            public double ShoeThickness1;
            /// <summary>
            /// Defines the Shoe input parameter type.
            /// </summary>
            public double ShoeThickness2;
            /// <summary>
            /// Defines the Shoe input parameter type.
            /// </summary>
            public double TopPlateThickness;

            /// <summary>
            /// The top plate length
            /// </summary>
            public double TopPlateLength;

            /// <summary>
            /// The top plate height
            /// </summary>
            public double TopPlateHeight;

            /// <summary>
            /// The top plate offset
            /// </summary>
            public double TopPlateOffset;

            /// <summary>
            /// The top plate gap
            /// </summary>
            public double TopPlateGap;

            /// <summary>
            /// The shoe spacing
            /// </summary>
            public double ShoeSpacing;

            /// <summary>
            /// The leg lower spacing
            /// </summary>
            public double LegLowerSpacing;

            /// <summary>
            /// The section name
            /// </summary>
            public String SectionName;

            /// <summary>
            /// The section type
            /// </summary>
            public String SectionType;

            /// <summary>
            /// The section standard
            /// </summary>
            public String SectionStandard;

            /// <summary>
            /// The has extension
            /// </summary>
            public Boolean HasExtension;

            /// <summary>
            /// The extension type
            /// </summary>
            public int ExtensionType;

            /// <summary>
            /// The vertical plate length
            /// </summary>
            public double VerticalPlateLength;

            /// <summary>
            /// The horizontal plate length
            /// </summary>
            public double HorizontalPlateLength;

            /// <summary>
            /// The leg height
            /// </summary>
            public double LegHeight;

            /// <summary>
            /// The continous
            /// </summary>
            public int Continous;

            /// <summary>
            /// The extension plate axial offset
            /// </summary>
            public double ExtensionPlateAxialOffset;

            /// <summary>
            /// The steel cpoint
            /// </summary>
            public int SteelCpoint;

            /// <summary>
            /// The steel angle
            /// </summary>
            public double SteelAngle;

            /// <summary>
            /// The shoe spacing from
            /// </summary>
            public int ShoeSpacingFrm;

        }
        public struct SpreaderBeamInputs
        {
            /// <summary>
            /// Attribute used to specify diameter of the route to use.  User will enter diameter here.
            /// </summary>
            public double Diameter1;
            /// <summary>
            /// The height of the shoe from the bottom of the pipe to the top of the spreader beam, including all plates, guides, pads.
            /// </summary>
            public double ShoeHeight;
            /// <summary>
            /// Attribute used to specify placement position of the top attachment. It is a codelisted value. 1-Centre, 2-Edge, 3-Both Centre and Edge
            /// </summary>
            public int TopPlacementType;
            /// <summary>
            /// Attribute used to specify placement position of the bottom attachment. It is a codelisted value. 1-Centre, 2-Edge, 3-Both Centre and Edge
            /// </summary>
            public int BotPlacementType;
            ///  <summary>
            /// Attribute used to specify the top attachment type. It is a codelisted value. 1-Lug, 2-WBA Bolt, 3-Ubolt, 4-Plate, 5-WBA Hole
            /// </summary>, 
            public int TopAtt;
            ///  <summary>
            /// Attribute used to specify top attachment shape to be used
            /// </summary>
            public string TopShape;
            ///  <summary>
            /// Attribute used to specify the middle attachment type. It is a codelisted value. 1-Lug, 2-WBA Bolt, 3-Ubolt, 4-Plate, 5-WBA Hole
            /// </summary>
            public int MiddleAtt;
            ///  /// <summary>
            /// Attribute used to specify middle attachment shape to be used
            /// </summary>
            public string MiddleShape;
            /// <summary>
            /// Attribute used to specify the bottom attachment type. It is a codelisted value. 1-Lug, 2-WBA Bolt, 3-Ubolt, 4-Plate, 5-WBA Hole
            /// </summary>
            public int BottomAtt;
            /// <summary>
            /// Attribute used to specify bottom attachment shape to be used
            /// </summary>
            public string BottomShape;
            /// <summary>
            /// Attribute used to specify the top connection type. It is a codelisted value. 1-Clevis, 2-Eye Nut, 3-Swvel Hanger, 4-Welded Beam Attachment
            /// </summary>
            public int TopCon;
            /// <summary>
            /// Attribute used to specify top connection shape to be used
            /// </summary>
            public string TopConShape;
            /// <summary>
            /// Attribute used to specify the middle connection type. It is a codelisted value. 1-Clevis, 2-Eye Nut, 3-Swvel Hanger, 4-Welded Beam Attachment
            /// </summary>
            public int MiddleCon;
            /// <summary>
            /// Attribute used to specify top connection shape to be used
            /// </summary>
            public string MidConShape;
            /// <summary>
            /// Attribute used to specify the bottom connection type. It is a codelisted value. 1-Clevis, 2-Eye Nut, 3-Swvel Hanger, 4-Welded Beam Attachment
            /// </summary>
            public int BottomCon;
            /// <summary>
            /// Attribute used to specify top connection shape to be used
            /// </summary>
            public string BotConShape;
            /// <summary>
            /// Attribute used to specify the top offset defintion type. It is a codelisted value. 1-From Centre, 2-From Edge
            /// </summary>
            public int TopOffsetDef;
            /// <summary>
            /// Attribute used to specify the top offset value on right hand side
            /// </summary>
            public double TopOff1;
            /// <summary>
            /// Attribute used to specify the top offset value on left hand side
            /// </summary>
            public double TopOff2;
            /// <summary>
            /// Attribute used to specify the bottom offset defintion type. It is a codelisted value. 1-From Centre, 2-From Edge
            /// </summary>
            public int BotOffsetDef;
            /// <summary>
            /// Attribute used to specify the top offset value on right hand side
            /// </summary>
            public double BottomOff1;
            /// <summary>
            /// Attribute used to specify the top offset value on left hand side
            /// </summary>
            public double BottomOff2;
            /// <summary>
            /// Attribute used to specify the middle offset defintion type. It is a codelisted value. 1-From Centre, 2-From Edge
            /// </summary>
            public int MiddleOffsetDef;
            /// <summary>
            /// Attribute used to specify the top offset value on left hand side
            /// </summary>
            public double MiddleOff;
            /// <summary>
            /// Attribute used to specify the top attachment orientation type. It is a codelisted value. 1-Perpendicular, 2-Aligned
            /// </summary>
            public int TopAtt1Orient;
            /// <summary>
            /// Attribute used to specify the middle attachment orientation type. It is a codelisted value. 1-Perpendicular, 2-Aligned
            /// </summary>
            public int MidAtt1Orient;
            /// <summary>
            /// Attribute used to specify the bottom attachment orientation type. It is a codelisted value. 1-Perpendicular, 2-Aligned
            /// </summary>
            public int BotAtt1Orient;
            /// <summary>
            /// Attribute used to specify the top attachment orientation type. It is a codelisted value. 1-Perpendicular, 2-Aligned
            /// </summary>
            public int TopAtt2Orient;
            /// <summary>
            /// Attribute used to specify the top attachment orientation type. It is a codelisted value. 1-Perpendicular, 2-Aligned
            /// </summary>
            public int MidAtt2Orient;
            /// <summary>
            /// Attribute used to specify the top attachment orientation type. It is a codelisted value. 1-Perpendicular, 2-Aligned
            /// </summary>
            public int BotAtt2Orient;
            /// <summary>
            /// Attribute used to specify the top connection orientation type. It is a codelisted value. 1-0 degree, 2-90 degree, 3-180 degree, 4-270 degree
            /// </summary>
            public int TopCon1Rot;
            /// <summary>
            /// Attribute used to specify the top connection orientation type. It is a codelisted value. 1-0 degree, 2-90 degree, 3-180 degree, 4-270 degree
            /// </summary>
            public int TopCon2Rot;
            /// <summary>
            /// Attribute used to specify the middle connection orientation type. It is a codelisted value. 1-0 degree, 2-90 degree, 3-180 degree, 4-270 degree
            /// </summary>
            public int MidCon1Rot;
            /// <summary>
            /// Attribute used to specify the middle connection orientation type. It is a codelisted value. 1-0 degree, 2-90 degree, 3-180 degree, 4-270 degree
            /// </summary>
            public int MidCon2Rot;
            /// <summary>
            /// Attribute used to specify the bottom connection orientation type. It is a codelisted value. 1-0 degree, 2-90 degree, 3-180 degree, 4-270 degree
            /// </summary>
            public int BotCon1Rot;
            /// <summary>
            /// Attribute used to specify the bottom connection orientation type. It is a codelisted value. 1-0 degree, 2-90 degree, 3-180 degree, 4-270 degree
            /// </summary>
            public int BotCon2Rot;
            /// <summary>
            /// Attribute used to specify the length of the spreader beam
            /// </summary>
            public double Length;
            /// <summary>
            /// Attribute used to specify the steel name
            /// </summary>
            public string SteelName;
            /// <summary>
            /// Attribute used to specify the steel type
            /// </summary>
            public string SteelType;
            /// <summary>
            /// Attribute used to specify the steel standard
            /// </summary>
            public string SteelStandard;
            /// <summary>
            /// Attribute used to specify the steel angle
            /// </summary>
            public double SteelAngle;
            /// <summary>
            /// Attribute used to specify the steel cardinal point
            /// </summary>
            public int SteelCpoint;
            /// <summary>
            /// Attribute used to specify the name of the stiffener plate to be used
            /// </summary>
            public string Stiffener;
            /// <summary>
            /// Specifies the quantity of stiffener plates laterally.See the multi-position spec for more details
            /// </summary>
            public double Multi1Qty;
            /// <summary>
            /// Defines how to locate the stiffener plates laterally. Allowed options are by center or by edge
            /// </summary>
            public double Multi1LocateBy;
            /// <summary>
            /// Specifies the spacing of the location based of the locate-by attribute. See the multi-position spec for more details
            /// </summary>
            public double Multi1Location;
            /// <summary>
            /// Attribute used to specify the name of the End plates to be used
            /// </summary>
            public string SpreaderBeamEndPlate;
            /// <summary>
            /// Specifies the spacing of the location based of the locate-by attribute. See the multi-position spec for more details
            /// </summary>
            public double EndPlateVerticalOffset;
            /// <summary>
            /// Specifies the spacing between two channels of back to back section
            /// </summary>
            public double BBGap;
        }
        /// <summary>
        /// Defines the inputs for the SteelMember.
        /// </summary>
        public struct SteelMember
        {
            // Names and Descriptions

            /// <summary>
            /// The section standard
            /// </summary>
            public string sectionStandard;

            /// <summary>
            /// The section type
            /// </summary>
            public string sectionType;

            /// <summary>
            /// The section name
            /// </summary>
            public string sectionName;

            /// <summary>
            /// The section description
            /// </summary>
            public string sectionDescription;

            /// <summary>
            /// The part number
            /// </summary>
            public string partNumber;
            // Dimensions and Data

            /// <summary>
            /// The unit weight
            /// </summary>
            public Double unitWeight;

            /// <summary>
            /// The depth
            /// </summary>
            public Double depth;

            /// <summary>
            /// The width
            /// </summary>
            public Double width;

            /// <summary>
            /// The web thickness
            /// </summary>
            public Double webThickness;

            /// <summary>
            /// The web depth
            /// </summary>
            public Double webDepth;

            /// <summary>
            /// The flange thickness
            /// </summary>
            public Double flangeThickness;

            /// <summary>
            /// The flange width
            /// </summary>
            public Double flangeWidth;

            /// <summary>
            /// The centroid X
            /// </summary>
            public Double centroidX;

            /// <summary>
            /// The centroid Y
            /// </summary>
            public Double centroidY;
            // Back to Back Data

            /// <summary>
            /// The b2 b_ config
            /// </summary>
            public int B2B_Config;

            /// <summary>
            /// The b2 b_ spacing
            /// </summary>
            public Double B2B_Spacing;

            /// <summary>
            /// The b2 b_ single flange width
            /// </summary>
            public Double B2B_SingleFlangeWidth;
            // HSS

            /// <summary>
            /// The HS s_ nominal wall thickness
            /// </summary>
            public Double HSS_NominalWallThickness;

            /// <summary>
            /// The HS s_ design wall thickness
            /// </summary>
            public Double HSS_DesignWallThickness;
            // HSSR

            /// <summary>
            /// The HSS r_ ratio widthper thickness
            /// </summary>
            public Double HSSR_RatioWidthperThickness;

            /// <summary>
            /// The HSS r_ ratio heightper thickness
            /// </summary>
            public Double HSSR_RatioHeightperThickness;
            // HSSC

            /// <summary>
            /// The HSS c_ outer diameter
            /// </summary>
            public Double HSSC_OuterDiameter;

            /// <summary>
            /// The HSS c_ ratio depth per thickness
            /// </summary>
            public Double HSSC_RatioDepthPerThickness;
            // Flanged Bolt Gage

            /// <summary>
            /// The F b_ flange gage
            /// </summary>
            public Double FB_FlangeGage;

            /// <summary>
            /// The F b_ web gage
            /// </summary>
            public Double FB_WebGage;
            // Angle Bolt Gage

            /// <summary>
            /// The A b_ long side gage
            /// </summary>
            public Double AB_LongSideGage;

            /// <summary>
            /// The A b_ long side gage1
            /// </summary>
            public Double AB_LongSideGage1;

            /// <summary>
            /// The A b_ long side gage2
            /// </summary>
            public Double AB_LongSideGage2;

            /// <summary>
            /// The A b_ short side gage
            /// </summary>
            public Double AB_ShortSideGage;

            /// <summary>
            /// The A b_ short side gage1
            /// </summary>
            public Double AB_ShortSideGage1;

            /// <summary>
            /// The A b_ short side gage2
            /// </summary>
            public Double AB_ShortSideGage2;
        }

        /// <summary>
        /// Defines the inputs for the DummyLeg shape.
        /// </summary>
        public struct DummyLegShapeInputs
        {
            /// <summary>
            /// Specifies the classification of the shape
            /// </summary>
            public int dummyShape;
            /// <summary>
            /// Total height of the Dummy Leg 1 shape, not including the base plate.  
            /// </summary>
            public double dummyHeight;
            /// <summary>
            /// The Width of the Dummy Leg 1 shape. Must be positive. 
            /// </summary>
            public double dummyWidth;
            /// <summary>
            /// The depth of the Dummy Leg 1 shape. Must be positive. 
            /// </summary>
            public double dummyDepth;
            /// <summary>
            /// Attribute used to specify steel section name. 
            /// </summary>
            public string steelName;
            /// <summary>
            /// Attribute used to specify steel section type name. 
            /// </summary>
            public string steelType;
            /// <summary>
            /// Attribute used to specify steel section standard. 
            /// </summary>
            public string steelStandard;
            /// <summary>
            ///Specifies the rotation angle of the steel section along its x-axis
            /// </summary>
            public double steelAngle;
            /// <summary>
            ///Specifies the cardinal point of the steel section
            /// </summary>
            public int steelCpoint;
            /// <summary>
            ///Attribute that allows user to specify the base plate shape
            /// </summary>
            public string plateShape;
            /// <summary>
            /// Attribute used to specify steel section diameter
            /// </summary>
            public double diameter;
            /// <summary>
            /// Attribute used to specify Number of Bolts
            /// </summary>
            public int includeBolts;
            /// <summary>
            /// Attribute used to specify pindiameter
            /// </summary>
            public double pinDia;
            /// <summary>
            /// Attribute used to specify pinlength
            /// </summary>
            public double pinLen;
            /// <summary>
            ///Attribute used to specify Boltinputs
            /// </summary>
            public BoltRowInputs BoltRow1;
        }
        /// <summary>
        /// Defines the Standard Port input parameter type.
        /// </summary>
        public struct StandardPortInputs
        {
            /// <summary>
            /// The X offset
            /// </summary>
            public double XOffset;
            /// <summary>
            /// The Y offset
            /// </summary>
            public double YOffset;
            /// <summary>
            /// The Z offset
            /// </summary>
            public double ZOffset;
            /// <summary>
            /// The Rotation about X
            /// </summary>
            public double Rotx;
            /// <summary>
            /// The Rotation about Y
            /// </summary>
            public double Roty;
            /// <summary>
            /// The Rotation about X
            /// </summary>
            public double Rotz;
        }
        /// <summary>
        /// Data type to hold the Route port Data, for reading from XLS
        /// </summary>
        public struct RoutePortInputs
        {
            /// <summary>
            /// The Route port diameter
            /// </summary>
            public double RPDiameter;
            /// <summary>
            /// The Route port offsetfrom pipe CL
            /// </summary>
            public double RPOffsetfromPipeCL;
            /// <summary>
            /// The Route port offset along pipe CL
            /// </summary>
            public double RPOffsetAlongPipeCL;
            /// <summary>
            /// The Route port rotation around pipe
            /// </summary>
            public double RPRotationAroundPipe;
            /// <summary>
            /// The Route port adjust plate length
            /// </summary>
            public long RPAdjustPlateLength;
            /// <summary>
            /// The X offset
            /// If we get here then the succka is unique
            /// </summary>
            public double XOffset;
            /// <summary>
            /// The Y offset
            /// </summary>
            public double YOffset;
            /// <summary>
            /// The Z offset
            /// </summary>
            public double ZOffset;
        }
        /// <summary>
        /// Defines the inputs for the Stanchion shape.
        /// </summary>
        public struct StanchionShapeInputs
        {
            /// <summary>
            /// Attribute used to specify stanShape
            /// </summary>
            public int stanShape;
            /// <summary>
            /// Attribute used to specify stanHeight
            /// </summary>
            public double stanHeight;
            /// <summary>
            /// Attribute used to specify stanWidth
            /// </summary>
            public double stanWidth;
            /// <summary>
            /// Attribute used to specify stanDepth
            /// </summary>
            public double stanDepth;
            /// <summary>
            /// Attribute used to specify steelName
            /// </summary>
            public string steelName;
            /// <summary>
            /// Attribute used to specify steelType
            /// </summary>
            public string steelType;
            /// <summary>
            /// Attribute used to specify steelStandard
            /// </summary>
            public string steelStandard;
            /// <summary>
            /// Attribute used to specify steelAngle
            /// </summary>
            public double steelAngle;
            /// <summary>
            ///Attribute used to specify steelCpoint
            /// </summary>
            public int steelCpoint;
            /// <summary>
            ///Attribute used to specify plate1Shape
            /// </summary>
            public string plate1Shape;
            /// <summary>
            /// Attribute used to specify plate2Shape
            /// </summary>
            public string plate2Shape;
            /// <summary>
            /// Attribute used to specify includeBolts
            /// </summary>
            public int includeBolts;
            /// <summary>
            /// Attribute used to specify pinDia
            /// </summary>
            public double pinDia;
            /// <summary>
            ///Attribute used to specify pinLen
            /// </summary>
            public double pinLen;
            /// <summary>
            /// Attribute used to specify Boltinputs
            /// </summary>
            public BoltRowInputs BoltRow1;
        }
        /// <summary>
        /// Defines inputs for the Grout Shape.
        /// </summary>
        public struct GroutInputs
        {
            /// <summary>
            /// </summary>
            public int ShapeType;
            /// </summary>
            /// </summary>
            public double BottomWidth1;
            /// </summary>
            /// </summary>
            public double BottomWidth2;
            /// </summary>
            /// </summary>
            public double TopWidth1;
            /// </summary>
            /// </summary>
            public double TopWidth2;
            /// </summary>
            /// </summary>
            public double GroutHeight;
            /// </summary>
            /// </summary>
            public double GroutDensity;
        }
        /// <summary>
        /// For rotating Holeport
        /// </summary>
        /// <param name="myPort">PortInputs</param>
        /// <param name="xAxis">Axis1</param>
        /// <param name="zAxis">Axis2</param>
        /// <Code>HoleRotatePort(holePorts[i], xaxis, zaxis);</Code>
        public void HoleRotatePort(HolePortInputs myPort, Vector xAxis, Vector zAxis)
        {
            try
            {
                if (HgrCompareDoubleService.cmpdbl(myPort.Rotx, 0) == false)
                {
                    xAxis.Set(1, 0, 0);
                    zAxis.Set(0, Math.Sin(myPort.Rotx) / (Math.Cos(myPort.Rotx) * Math.Cos(myPort.Rotx) + Math.Sin(myPort.Rotx) * Math.Sin(myPort.Rotx)), Math.Cos(myPort.Rotx) / (Math.Cos(myPort.Rotx) * Math.Cos(myPort.Rotx) + Math.Sin(myPort.Rotx) * Math.Sin(myPort.Rotx)));
                }
                else if ((HgrCompareDoubleService.cmpdbl(myPort.Roty, 0) == false) && (HgrCompareDoubleService.cmpdbl(myPort.Rotx, 0) == true))
                {
                    xAxis.Set(Math.Cos(myPort.Roty) / (Math.Cos(myPort.Roty) * Math.Cos(myPort.Roty) + Math.Sin(myPort.Roty) * Math.Sin(myPort.Roty)), 0, Math.Sin(myPort.Roty) / (Math.Cos(myPort.Roty) * Math.Cos(myPort.Roty) + Math.Sin(myPort.Roty) * Math.Sin(myPort.Roty)));
                    zAxis.Set(Math.Cos((90 / 180.0) * Math.PI + myPort.Roty) / (Math.Cos((90 / 180.0) * Math.PI + myPort.Roty) * Math.Cos((90 / 180.0) * Math.PI + myPort.Roty) + Math.Sin((90 / 180.0) * Math.PI + myPort.Roty) * Math.Sin((90 / 180.0) * Math.PI + myPort.Roty)), 0, Math.Sin((90 / 180.0) * Math.PI + myPort.Roty) / (Math.Cos((90 / 180.0) * Math.PI + myPort.Roty) * Math.Cos((90 / 180.0) * Math.PI + myPort.Roty) + Math.Sin((90 / 180.0) * Math.PI + myPort.Roty) * Math.Sin((90 / 180.0) * Math.PI + myPort.Roty)));
                }
                else if ((HgrCompareDoubleService.cmpdbl(myPort.Rotz, 0) == false) && (HgrCompareDoubleService.cmpdbl(myPort.Rotx, 0) == true) && (HgrCompareDoubleService.cmpdbl(myPort.Roty, 0) == true))
                {
                    xAxis.Set(Math.Cos(myPort.Rotz) / (Math.Cos(myPort.Rotz) * Math.Cos(myPort.Rotz) + Math.Sin(myPort.Rotz) * Math.Sin(myPort.Rotz)), Math.Sin(myPort.Rotz) / (Math.Cos(myPort.Rotz) * Math.Cos(myPort.Rotz) + Math.Sin(myPort.Rotz) * Math.Sin(myPort.Rotz)), 0);
                    zAxis.Set(0, 0, 1);
                }
                else
                {
                    xAxis.Set(1, 0, 0);
                    zAxis.Set(0, 0, 1);
                }
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrhsPartsHoleRotatePort, "Error in HoleRotatePort");
            }
        }
        /// <summary>
        /// For rotating eport
        /// </summary>
        /// <param name="myPort">PortInputs</param>
        /// <param name="xAxis">Axis1</param>
        /// <param name="zAxis">Axis2</param>
        /// <Code>RotatePort(standardports[i], xaxis, zaxis);</Code>
        public void RotatePort(StandardPortInputs myPort, Vector xAxis, Vector zAxis)
        {
            try
            {
                if (HgrCompareDoubleService.cmpdbl(myPort.Rotx, 0) == false)
                {
                    xAxis.Set(1, 0, 0);
                    zAxis.Set(0, Math.Sin(myPort.Rotx) / (Math.Cos(myPort.Rotx) * Math.Cos(myPort.Rotx) + Math.Sin(myPort.Rotx) * Math.Sin(myPort.Rotx)), Math.Cos(myPort.Rotx) / (Math.Cos(myPort.Rotx) * Math.Cos(myPort.Rotx) + Math.Sin(myPort.Rotx) * Math.Sin(myPort.Rotx)));
                }
                else if ((HgrCompareDoubleService.cmpdbl(myPort.Roty, 0) == false) && (HgrCompareDoubleService.cmpdbl(myPort.Rotx, 0) == true))
                {
                    xAxis.Set(Math.Cos(myPort.Roty) / (Math.Cos(myPort.Roty) * Math.Cos(myPort.Roty) + Math.Sin(myPort.Roty) * Math.Sin(myPort.Roty)), 0, Math.Sin(myPort.Roty) / (Math.Cos(myPort.Roty) * Math.Cos(myPort.Roty) + Math.Sin(myPort.Roty) * Math.Sin(myPort.Roty)));
                    zAxis.Set(Math.Cos((90 / 180.0) * Math.PI + myPort.Roty) / (Math.Cos((90 / 180.0) * Math.PI + myPort.Roty) * Math.Cos((90 / 180.0) * Math.PI + myPort.Roty) + Math.Sin((90 / 180.0) * Math.PI + myPort.Roty) * Math.Sin((90 / 180.0) * Math.PI + myPort.Roty)), 0, Math.Sin((90 / 180.0) * Math.PI + myPort.Roty) / (Math.Cos((90 / 180.0) * Math.PI + myPort.Roty) * Math.Cos((90 / 180.0) * Math.PI + myPort.Roty) + Math.Sin((90 / 180.0) * Math.PI + myPort.Roty) * Math.Sin((90 / 180.0) * Math.PI + myPort.Roty)));
                }
                else if ((HgrCompareDoubleService.cmpdbl(myPort.Rotz, 0) == false) && (HgrCompareDoubleService.cmpdbl(myPort.Rotx, 0) == true) && (HgrCompareDoubleService.cmpdbl(myPort.Roty, 0) == true))
                {
                    // ' Rotate the XY Plane on the Z Axis
                    xAxis.Set(Math.Cos(myPort.Rotz) / (Math.Cos(myPort.Rotz) * Math.Cos(myPort.Rotz) + Math.Sin(myPort.Rotz) * Math.Sin(myPort.Rotz)), Math.Sin(myPort.Rotz) / (Math.Cos(myPort.Rotz) * Math.Cos(myPort.Rotz) + Math.Sin(myPort.Rotz) * Math.Sin(myPort.Rotz)), 0);
                    zAxis.Set(0, 0, 1);
                }
                else
                {
                    xAxis.Set(1, 0, 0);
                    zAxis.Set(0, 0, 1);
                }
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrhsPartsRotatePort, "Error in RotatePort");
            }
        }
        /// <summary>
        /// Loads the route port data.
        /// </summary>
        /// <param name="startIndex">The start index.</param>
        /// <code>RoutePortInputs routePort = LoadRoutePortData(24);</code>
        public RoutePortInputs LoadRoutePortData(int startIndex)
        {
            RoutePortInputs routePort = new RoutePortInputs();
            try
            {
                routePort.RPDiameter = GetDoubleInputValue(startIndex);
                routePort.RPOffsetfromPipeCL = GetDoubleInputValue(++startIndex);
                routePort.RPOffsetAlongPipeCL = GetDoubleInputValue(++startIndex);
                routePort.RPRotationAroundPipe = GetDoubleInputValue(++startIndex);
                routePort.RPAdjustPlateLength = (long)GetDoubleInputValue(++startIndex);
                routePort.XOffset = 0;
                routePort.YOffset = 0;
                routePort.ZOffset = 0;
                ++startIndex;
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadRoutePortData, "Error in LoadRoutePortData");
            }
            return routePort;
        }
        /// <summary>
        /// Adds the route port inputs.
        /// </summary>
        /// <param name="startIndex">The start index.</param>
        /// <param name="endIndex">The end index.</param>
        /// <param name="additionalInputs">The additional inputs.</param>
        /// <code>AddRoutePortInputs(endIndex, out endIndex, additionalInputs);</code>
        public void AddRoutePortInputs(int startIndex, out int endIndex, List<Input> additionalInputs)
        {
            try
            {
                additionalInputs.Add(new InputDouble(startIndex, "RPDiameter", "RPDiameter", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "RPOffsetfromPipeCL", "RPOffsetfromPipeCL", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "RPOffsetalongPipe", "RPOffsetalongPipe", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "RPRotationAroundPipe", "RPRotationAroundPipe", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "RPAdjustPlateLength", "RPAdjustPlateLength", 0, false));
                ++startIndex;

            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddRoutePortInputs, "Error in adding RoutePort inputs");
            }
            endIndex = startIndex;
        }

        /// <summary>
        /// Adds the route port outputs.
        /// </summary>
        /// <param name="aspectName">Name of the aspect.</param>
        /// <param name="additionalOutputs">The additional outputs.</param>
        /// <code> AddRoutePortOutputs(aspectName, additionalOutputs);</code>
        public void AddRoutePortOutputs(string aspectName, List<OutputDefinition> additionalOutputs)
        {
            try
            {
                additionalOutputs.Add(new OutputDefinition("Route", "Route"));
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddRoutePortoutputs, "Error in adding RoutePort outputs");
            }
        }
        /// <summary>
        /// Loads the hole port data.
        /// </summary>
        /// <param name="startIndex">The start index.</param>
        /// <param name="numberOfHolePorts">The number of hole ports.</param>
        /// <code>HolePortInputs[] holePorts = LoadHolePortData(35, numberOfHolePorts);</code>
        public HolePortInputs[] LoadHolePortData(int startIndex, int numberOfHolePorts)
        {
            HolePortInputs[] holePort = new HolePortInputs[numberOfHolePorts];
            try
            {
                for (int i = 0; i < numberOfHolePorts; i++)
                {
                    holePort[i].Rotx = GetDoubleInputValue(startIndex);
                    holePort[i].Roty = GetDoubleInputValue(++startIndex);
                    holePort[i].Rotz = GetDoubleInputValue(++startIndex);
                    holePort[i].PosX = GetDoubleInputValue(++startIndex);
                    holePort[i].PosY = GetDoubleInputValue(++startIndex);
                    ++startIndex;
                    holePort[i].Size = 0;
                    ++startIndex;
                }
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadHolePortData, "Error in LoadHolePortData");
            }
            return holePort;
        }
        /// <summary>
        /// This property adds inputs for Pin.User symbol calls this property AdditionalInputs
        /// to define additional inputs. The list of inputs returned by this method will be the inputs for the user symbol in addition
        /// to the inputs that are already defined as member variables.
        /// </summary>
        ///<code>
        /// public override IEnumerable<Input> AdditionalInputs
        /// {
        ///     get
        ///     {
        ///         int endIndex;
        ///         additionalInputs = new List(Input)();
        ///         //Example , I have added the pin with staring index 3.
        ///         AddPinInputs(3, out endIndex, additionalInputs);
        ///         return additionalInputs; 
        ///    }
        /// }
        ///</code>
        public void AddPinInputs(int startIndex, out int endIndex, List<Input> additionalInputs)
        {
            try
            {
                additionalInputs.Add((Input)new InputDouble(startIndex, "Pin1Diameter", "Pin1Diameter", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Pin1Length", "Pin1Length", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "CotterDia", "CotterDia", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "CotterLength", "CotterLength", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "CotterOffset", "CotterOffset", 0, false));

            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrPinAdditionalInputs, "Error in adding Pin inputs");
            }
            endIndex = startIndex;
        }
        /// <summary>
        /// Adds the Pin outputs.User symbol calls this method during AdditionalOutputs
        /// to define additional outputs for an aspect. The list of outputs returned by this method will be the outputs for the aspect
        /// in addition to the outputs that are already defined as attributes on the aspect.
        /// </summary>
        /// <param name="additionalOutputs">The additional outputs.</param>
        ///<code>
        ///public override IEnumerable<OutputDefinition> AdditionalOutputs(string aspectName)
        ///{
        ///    List<OutputDefinition> additionalOutputs = new List<OutputDefinition>();
        ///    if (aspectName == "Symbolic")
        ///    {
        ///        AddPinOutputs(additionalOutputs);
        ///    }
        ///    return additionalOutputs;
        ///}
        ///</code> 
        public void AddPinOutputs(List<OutputDefinition> additionalOutputs)
        {
            try
            {
                additionalOutputs.Add(new OutputDefinition("Pin" + "Pin", "Pin" + "Pin"));
                additionalOutputs.Add(new OutputDefinition("Pin" + "CotterPin1", "Pin" + "CotterPin1"));
                additionalOutputs.Add(new OutputDefinition("Pin" + "CotterPin2", "Pin" + "CotterPin2"));
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrPinAdditionalOutputs, "Error in adding Pin outputs");
            }
        }
        /// <summary>
        /// This method will be called by user symbol to get value of an input(in this case, Pin input structure)during construction of outputs. 
        /// Given the start index, this method will return the value of the PinInputs struct object.
        /// </summary>
        /// <param name="startIndex">The start index.</param>
        /// <returns></returns>
        ///<code>
        ///PinInputs pin = LoadPinData(2);
        ///</code>
        public PinInputs LoadPinData(int startIndex)
        {
            PinInputs pin = new PinInputs();
            try
            {
                pin.PinDiameter = GetDoubleInputValue(startIndex);
                if (pin.PinDiameter <= 0)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidPinDiameterValue, "Pin Diameter value should not be less than or equal to zero");
                }
                pin.PinLength = GetDoubleInputValue(++startIndex);
                if (pin.PinLength <= 0)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidLengthValue, "Pin Length value should not be less than or equal to zero");
                }
                pin.CotterDiameter = GetDoubleInputValue(++startIndex);
                if (pin.CotterDiameter <= 0)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrPinCotterDiameterValue, "Cotter Diameter value should not be less than or equal to zero");
                }
                pin.CotterLength = GetDoubleInputValue(++startIndex);
                if (pin.CotterLength <= 0)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrPinCotterLengthValue, "Cotter Length value should not be less than or equal to zero");
                }
                pin.CotterOffset = GetDoubleInputValue(++startIndex);
            }
            catch (SmartPartSymbolException hgrEx)
            {
                throw hgrEx;
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadPinData, "Error in Loading Pin Data");
            }
            return pin;

        }
        /// <summary>
        /// This property adds inputs for Nut.User symbol calls this property AdditionalInputs
        /// to define additional inputs. The list of inputs returned by this method will be the inputs for the user symbol in addition
        /// to the inputs that are already defined as member variables.
        /// </summary>
        ///<code>
        /// public override IEnumerable<Input> AdditionalInputs
        /// {
        ///     get
        ///     {
        ///         int endIndex;
        ///         additionalInputs = new List(Input)();
        ///         //Example , I have added the nut with staring index 3.
        ///         AddNutInputs(3, out endIndex, additionalInputs);
        ///         return additionalInputs; 
        ///    }
        /// }
        ///</code>
        public void AddNutInputs(int startIndex, out int endIndex, List<Input> additionalInputs)
        {
            try
            {
                additionalInputs.Add((Input)new InputDouble(startIndex, "Shape1Type", "Shape1Type", 1, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Shape1Width1", "Shape1Width1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Shape1Width2", "Shape1Width2", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Shape1Length", "Shape1Length", 0, false));
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrNutAdditionalInputs, "Error in adding Nut inputs");
            }
            endIndex = startIndex;
        }
        /// <summary>
        /// Adds the nut outputs.User symbol calls this method during AdditionalOutputs
        /// to define additional outputs for an aspect. The list of outputs returned by this method will be the outputs for the aspect
        /// in addition to the outputs that are already defined as attributes on the aspect.
        /// </summary>
        /// <param name="additionalOutputs">The additional outputs.</param>
        ///<code>
        ///public override IEnumerable<OutputDefinition> AdditionalOutputs(string aspectName)
        ///{
        ///    List<OutputDefinition> additionalOutputs = new List<OutputDefinition>();
        ///    if (aspectName == "Symbolic")
        ///    {
        ///        AddNutOutputs(additionalOutputs);
        ///    }
        ///    return additionalOutputs;
        ///}
        ///</code> 
        public void AddNutOutputs(List<OutputDefinition> additionalOutputs)
        {
            try
            {
                additionalOutputs.Add(new OutputDefinition("Nut", "Nut"));
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrNutAdditionalOutputs, "Error in AddNutOutputs.");
            }
        }
        /// <summary>
        /// This method will be called by user symbol to get value of an input(in this case, Nut input structure)during construction of outputs. 
        /// Given the start index, this method will return the value of the NutInputs struct object.
        /// </summary>
        /// <param name="startIndex">The start index.</param>
        /// <returns></returns>
        ///<code>
        ///NutInputs nut = LoadNutData(3);
        ///</code>
        public NutInputs LoadNutData(int startIndex)
        {
            NutInputs nut = new NutInputs();
            try
            {

                nut.ShapeType = (int)GetDoubleInputValue(startIndex);
                if (nut.ShapeType == -1)
                    nut.ShapeType = 0;
                if (nut.ShapeType < 0 || nut.ShapeType > 3)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrShapeTypeCodeListValue, "ShapeType code list value should be between 0 and 3");
                }
                nut.ShapeWidth1 = GetDoubleInputValue(++startIndex);
                nut.ShapeWidth2 = GetDoubleInputValue(++startIndex);
                nut.ShapeLength = GetDoubleInputValue(++startIndex);
            }
            catch (SmartPartSymbolException hgrEx)
            {
                throw hgrEx;
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadNutData, "Error in loading Nut data");
            }
            return nut;
        }
        /// <summary>
        /// This method adds inputs for Turnbuckle.User symbol calls this method during calls this method during DefineAdditionalInputs
        /// to define additional inputs. The list of inputs returned by this method will be the inputs for the user symbol in addition
        /// to the inputs that are already defined as member variables.
        /// </summary>
        /// <param name="startIndex">start Index.</param>
        /// <param name="endIndex">Out - end Index.</param>
        /// <param name="additionalInputs">The list of additional Inputs for the symbol in addition
        /// to the inputs that are already defined as member variables.</param>
        ///<code>
        ///public override IEnumerable<Input> AdditionalInputs
        ///{
        ///    get
        ///    {
        ///        int endIndex;
        ///        List<Input> additionalInputs = new List<Input>();
        ///        AddTurnbuckleInputs(4, out endIndex, additionalInputs);
        ///        return additionalInputs;
        ///    }
        ///}
        ///</code>
        public void AddTurnbuckleInputs(int startIndex, out int endIndex, List<Input> additionalInputs)
        {
            try
            {
                additionalInputs.Add((Input)new InputDouble(startIndex, "Opening1", "Opening1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Length2", "Length2", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Width2", "Width2", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Thickness2", "Thickness2", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Opening2", "Opening2", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Diameter1", "Diameter1", 0, false));
                AddNutInputs(++startIndex, out endIndex, additionalInputs);
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrTurnbuckleAdditionalInputs, "Error in adding Turnbuckle inputs");
                endIndex = startIndex;
            }

        }
        /// <summary>
        /// Adds the Turnbuckle outputs.User symbol calls this method during AdditionalOutputs
        /// to define additional outputs for an aspect. The list of outputs returned by this method will be the outputs for the aspect
        /// in addition to the outputs that are already defined as attributes on the aspect.
        /// </summary>
        /// <param name="additionalOutputs">The additional outputs.</param>
        ///<code>
        ///public override IEnumerable<OutputDefinition> AdditionalOutputs(string aspectName)
        ///{
        ///    List<OutputDefinition> additionalOutputs = new List<OutputDefinition>();
        ///    if (aspectName == "Symbolic")
        ///    {
        ///       AddTurnbuckleOutputs(additionalOutputs);
        ///    }
        ///    return additionalOutputs;
        ///}
        ///</code> 
        public void AddTurnbuckleOutputs(List<OutputDefinition> additionalOutputs)
        {
            try
            {
                additionalOutputs.Add(new OutputDefinition("TurnbuckleSideBlock1", "TurnbuckleSideBlock1"));
                additionalOutputs.Add(new OutputDefinition("TurnbuckleSideBlock2", "TurnbuckleSideBlock2"));
                additionalOutputs.Add(new OutputDefinition("TurnbuckleCenterTube", "TurnbuckleCenterTube"));
                additionalOutputs.Add(new OutputDefinition("TurnbuckleNut1", "TurnbuckleNut1"));
                additionalOutputs.Add(new OutputDefinition("TurnbuckleNut2", "TurnbuckleNut2"));
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrTurnbuckleAdditionalOutputs, "Error in AddTurnbuckleOutputs");
            }
        }
        /// <summary>
        /// This method will be called by user symbol to get value of an input(in this case, Nut input structure)during construction of outputs. 
        /// Given the start index, this method will return the value of the NutInputs struct object.
        /// </summary>
        /// <param name="startIndex">The start index.</param>
        /// <returns></returns>
        ///<code>
        ///TurnbuckleInputs turnbuckle = LoadTurnbuckleData(3);
        ///</code>
        public TurnbuckleInputs LoadTurnbuckleData(int startIndex)
        {
            TurnbuckleInputs turnbuckle = new TurnbuckleInputs();
            try
            {
                turnbuckle.Opening1 = GetDoubleInputValue(startIndex);
                turnbuckle.Length2 = GetDoubleInputValue(++startIndex);
                turnbuckle.Width2 = GetDoubleInputValue(++startIndex);
                turnbuckle.Thickness2 = GetDoubleInputValue(++startIndex);
                turnbuckle.Opening2 = GetDoubleInputValue(++startIndex);
                turnbuckle.Diameter1 = GetDoubleInputValue(++startIndex);
                turnbuckle.Nut = LoadNutData(++startIndex);
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadTurnbuckleData, "Error in loading Turnbuckle data");
            }
            return turnbuckle;
        }
        /// <summary>
        /// Adds the plate inputs.
        /// </summary>        
        /// <param name="startIndex">The start index.</param>
        /// <param name="endIndex">The end index.</param>
        /// <param name="additionalInputs">The additional inputs.</param>
        /// <code>
        /// int endIndex;
        /// List<Input> additionalInputs = new List<Input>();
        /// AddPlateInputs(2, out endIndex, additionalInputs);
        /// </code>
        public void AddPlateInputs(int startIndex, out int endIndex, List<Input> additionalInputs)
        {
            try
            {
                additionalInputs.Add(new InputDouble(startIndex, "Width1", "Width1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Length1", "Length1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Thickness1", "Thickness1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "TLCornerType", "TLCornerType", 1, false));
                additionalInputs.Add(new InputDouble(++startIndex, "TLCornerX", "TLCornerX", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "TLCornerY", "TLCornerY", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "TLCornerRadius", "TLCornerRadius", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "TRCornerType", "TRCornerType", 1, false));
                additionalInputs.Add(new InputDouble(++startIndex, "TRCornerX", "TRCornerX", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "TRCornerY", "TRCornerY", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "TRCornerRadius", "TRCornerRadius", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "BLCornerType", "BLCornerType", 1, false));
                additionalInputs.Add(new InputDouble(++startIndex, "BLCornerX", "BLCornerX", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "BLCornerY", "BLCornerY", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "BLCornerRadius", "BLCornerRadius", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "BRCornerType", "BRCornerType", 1, false));
                additionalInputs.Add(new InputDouble(++startIndex, "BRCornerX", "BRCornerX", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "BRCornerY", "BRCornerY", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "BRCornerRadius", "BRCornerRadius", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "CurvedEndRad", "CurvedEndRad", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "CurvedEndX", "CurvedEndX", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "CurvedEndY", "CurvedEndY", 0, false));
                ++startIndex;
                endIndex = startIndex;
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrPlateAdditionalInputs, "Error in adding Plate inputs");
                endIndex = startIndex;
            }
        }
        /// <summary>
        /// Adds the plate outputs.
        /// </summary>       
        /// <param name="aspectName">Name of the aspect.</param>
        /// <param name="additionalOutputs">The additional outputs.</param>
        /// <code>
        ///  List<OutputDefinition> additionalOutputs = new List<OutputDefinition>();
        ///  AddPlateOutputs(aspectName, additionalOutputs);
        /// </code>
        public void AddPlateOutputs(string aspectName, List<OutputDefinition> additionalOutputs)
        {
            try
            {
                additionalOutputs.Add(new OutputDefinition("Plate", "Plate"));
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrPlateAdditionalOutputs, "Error in AddPlateOutputs.");
            }
        }
        /// <summary>
        /// Loads the standard port data.
        /// </summary>
        /// <param name="startIndex">The start index.</param>
        /// <param name="numberOfStandardPorts">The number of standard ports.</param>
        /// <returns></returns>
        public StandardPortInputs[] LoadStandardPortData(int startIndex, int numberOfStandardPorts)
        {
            StandardPortInputs[] standardPort = new StandardPortInputs[numberOfStandardPorts];
            try
            {
                for (int i = 0; i < numberOfStandardPorts; i++)
                {
                    standardPort[i].XOffset = GetDoubleInputValue(startIndex);
                    standardPort[i].YOffset = GetDoubleInputValue(++startIndex);
                    standardPort[i].ZOffset = GetDoubleInputValue(++startIndex);
                    standardPort[i].Rotx = GetDoubleInputValue(++startIndex);
                    standardPort[i].Roty = GetDoubleInputValue(++startIndex);
                    standardPort[i].Rotz = GetDoubleInputValue(++startIndex);
                    ++startIndex;
                }
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrStandardPortInputs, "Error in LoadStandardPortData");
            }
            return standardPort;
        }
        /// <summary>
        /// Adds the standard port inputs.
        /// </summary>
        /// <param name="startIndex">The start index.</param>
        /// <param name="numberOfStandardPorts">The number of standard ports.</param>
        /// <param name="endIndex">The end index.</param>
        /// <param name="additionalInputs">The additional inputs.</param>
        public void AddStandardPortInputs(int startIndex, int numberOfStandardPorts, out int endIndex, List<Input> additionalInputs)
        {
            try
            {
                for (int i = 1; i <= numberOfStandardPorts; i++)
                {
                    additionalInputs.Add(new InputDouble(startIndex, "P" + i + "xOffset", "P" + i + "xOffset", 0, false));
                    additionalInputs.Add(new InputDouble(++startIndex, "P" + i + "yOffset", "P" + i + "yOffset", 0, false));
                    additionalInputs.Add(new InputDouble(++startIndex, "P" + i + "zOffset", "P" + i + "zOffset", 0, false));
                    additionalInputs.Add(new InputDouble(++startIndex, "P" + i + "Rotx", "P" + i + "Rotx", 0, false));
                    additionalInputs.Add(new InputDouble(++startIndex, "P" + i + "Roty", "P" + i + "Roty", 0, false));
                    additionalInputs.Add(new InputDouble(++startIndex, "P" + i + "Rotz", "P" + i + "Rotz", 0, false));
                    ++startIndex;
                }
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddStandardPortInputs, "Error in adding StandardPort inputs");
            }
            endIndex = startIndex;
        }
        /// <summary>
        /// Adds the standard port outputs.
        /// </summary>
        /// <param name="aspectName">Name of the aspect.</param>
        /// <param name="numberOfStandardPorts">The number of standard ports.</param>
        /// <param name="additionalOutputs">The additional outputs.</param>
        public void AddStandardPortOutputs(string aspectName, int numberOfStandardPorts, List<OutputDefinition> additionalOutputs)
        {
            try
            {
                for (int i = 1; i <= numberOfStandardPorts; i++)
                    additionalOutputs.Add(new OutputDefinition("Port" + i, "Port" + i));
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddStandardPortoutputs, "Error in adding StandardPort outputs");
            }
        }
        /// <summary>
        /// Adds the hole port inputs.
        /// </summary>
        /// <param name="startIndex">The start index.</param>
        /// <param name="numberOfHolePorts">The number of hole ports.</param>
        /// <param name="endIndex">The end index.</param>
        /// <param name="additionalInputs">The additional inputs.</param>
        public void AddHolePortInputs(int startIndex, int numberOfHolePorts, out int endIndex, List<Input> additionalInputs)
        {
            try
            {
                for (int i = 1; i <= numberOfHolePorts; i++)
                {
                    additionalInputs.Add(new InputDouble(startIndex, "HP" + i + "Rotx", "HP" + i + "Rotx", 0, false));
                    additionalInputs.Add(new InputDouble(++startIndex, "HP" + i + "Roty", "HP" + i + "Roty", 0, false));
                    additionalInputs.Add(new InputDouble(++startIndex, "HP" + i + "Rotz", "HP" + i + "Rotz", 0, false));
                    additionalInputs.Add(new InputDouble(++startIndex, "HP" + i + "PosX", "HP" + i + "PosX", 0, false));
                    additionalInputs.Add(new InputDouble(++startIndex, "HP" + i + "PosY", "HP" + i + "PosY", 0, false));
                    additionalInputs.Add(new InputDouble(++startIndex, "HP" + i + "Size", "HP" + i + "Size", 0, false));
                    ++startIndex;
                }
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddHolePortinputs, "Error in adding HolePort inputs");
            }
            endIndex = startIndex;
        }
        /// <summary>
        /// Adds the hole port outputs.
        /// </summary>
        /// <param name="aspectName">Name of the aspect.</param>
        /// <param name="numberOfHolePorts">The number of hole ports.</param>
        /// <param name="additionalOutputs">The additional outputs.</param>
        public void AddHolePortOutputs(string aspectName, int numberOfHolePorts, List<OutputDefinition> additionalOutputs)
        {
            try
            {
                for (int i = 1; i <= numberOfHolePorts; i++)
                    additionalOutputs.Add(new OutputDefinition("Hole" + i, "Hole" + i));
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddHolePortoutputs, "Error in adding HolePort outputs");
            }
        }
        /// <summary>
        /// Loads the plate data.
        /// </summary>        
        /// <param name="startIndex">The start index.</param>
        /// /// <code>
        ///  PlateInputs plate = LoadPlateData(2);
        /// </code>
        /// <returns></returns>
        public PlateInputs LoadPlateData(int startIndex)
        {
            PlateInputs plate = new PlateInputs();
            try
            {
                //Basic Plate Dimensions
                plate.width1 = GetDoubleInputValue(startIndex);
                if (plate.width1 <= 0)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidWidth1GTZero, "Width1 value should not be less than or equal to zero");
                }
                plate.length1 = GetDoubleInputValue(++startIndex);
                if (plate.length1 <= 0)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidLength1GTZero, "Length1 value should not be less than or equal to zero");
                }
                plate.thickness1 = GetDoubleInputValue(++startIndex);
                if (plate.thickness1 <= 0)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidThickness1GTZero, "Thickness1 value should not be less than or equal to zero");
                }
                //Top Left Corner
                plate.tlCornerType = (int)GetDoubleInputValue(++startIndex);
                if (plate.tlCornerType == -1)
                    plate.tlCornerType = 0;
                if (plate.tlCornerType < 0 || plate.tlCornerType > 7)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvTLCornerTypeCodeListValue, "TLCornerType code list value should be between 0 and 7");
                }
                plate.tlCornerX = GetDoubleInputValue(++startIndex);
                plate.tlCornerY = GetDoubleInputValue(++startIndex);
                plate.tlCornerRad = GetDoubleInputValue(++startIndex);

                //Top Right Corner
                plate.trCornerType = (int)GetDoubleInputValue(++startIndex);
                if (plate.trCornerType == -1)
                    plate.trCornerType = 0;
                if (plate.trCornerType < 0 || plate.trCornerType > 7)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvTRCornerTypeCodeListValue, "TRCornerType code list value should be between 0 and 7");
                }
                plate.trCornerX = GetDoubleInputValue(++startIndex);
                plate.trCornerY = GetDoubleInputValue(++startIndex);
                plate.trCornerRad = GetDoubleInputValue(++startIndex);

                //Bottom Left Corner
                plate.blCornerType = (int)GetDoubleInputValue(++startIndex);
                if (plate.blCornerType == -1)
                    plate.blCornerType = 0;
                if (plate.blCornerType < 0 || plate.blCornerType > 7)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvBLCornerTypeCodeListValue, "BLCornerType code list value should be between 0 and 7");
                }
                plate.blCornerX = GetDoubleInputValue(++startIndex);
                plate.blCornerY = GetDoubleInputValue(++startIndex);
                plate.blCornerRad = GetDoubleInputValue(++startIndex);

                //Bottom Right Corner
                plate.brCornerType = (int)GetDoubleInputValue(++startIndex);
                if (plate.brCornerType == -1)
                    plate.brCornerType = 0;
                if (plate.brCornerType < 0 || plate.brCornerType > 7)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvBRCornerTypeCodeListValue, "BRCornerType code list value should be between 0 and 7");
                }
                plate.brCornerX = GetDoubleInputValue(++startIndex);
                plate.brCornerY = GetDoubleInputValue(++startIndex);
                plate.brCornerRad = GetDoubleInputValue(++startIndex);

                //Curved End
                plate.curvedEndRad = GetDoubleInputValue(++startIndex);
                plate.curvedEndX = GetDoubleInputValue(++startIndex);
                plate.curvedEndY = GetDoubleInputValue(++startIndex);
            }
            catch (SmartPartSymbolException hgrEx)
            {
                throw hgrEx;
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadPlateData, "Error in loading Plate data");
            }
            return plate;
        }
        /// <summary>
        /// Adds the WBABolt inputs.
        /// </summary>
        /// <param name="startIndex">The start index.</param>
        /// <param name="endIndex">The end index.</param>
        /// <param name="additionalInputs">The additional inputs.</param>
        /// <code>AddWBABoltInputs(3, out endIndex, additionalInputs);</code>
        public void AddWBABoltInputs(int startIndex, out int endIndex, List<Input> additionalInputs)
        {
            try
            {
                additionalInputs.Add(new InputDouble(startIndex, "Gap1", "Gap1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Thickness1", "Thickness1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Height1", "Height1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Width1", "Width1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Offset1", "Offset1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Width2", "Width2", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Length2", "Length2", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Thickness2", "Thickness2", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Offset2", "Offset2", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Gap2", "Gap2", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Width3", "Width3", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Length3", "Length3", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Thickness3", "Thickness3", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Offset3", "Offset3", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Pin1Diameter", "Pin1Diameter", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Pin1Length", "Pin1Length", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Height2", "Height2", 0, false));
                //Top Left Corner
                additionalInputs.Add(new InputDouble(++startIndex, "TLCornerType", "TLCornerType", 1, false));
                additionalInputs.Add(new InputDouble(++startIndex, "TLCornerX", "TLCornerX", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "TLCornerY", "TLCornerY", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "TLCornerRadius", "TLCornerRadius", 0, false));
                //Top Right Corner
                additionalInputs.Add(new InputDouble(++startIndex, "TRCornerType", "TRCornerType", 1, false));
                additionalInputs.Add(new InputDouble(++startIndex, "TRCornerX", "TRCornerX", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "TRCornerY", "TRCornerY", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "TRCornerRadius", "TRCornerRadius", 0, false));
                ++startIndex;
                endIndex = startIndex;
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrWBABoltAdditionalInputs, "Error in adding WBABolt inputs");
                endIndex = startIndex;
            }
        }
        /// <summary>
        /// Adds the WBABolt outputs.
        /// </summary>
        /// <param name="aspectName">Name of the aspect.</param>
        /// <param name="additionalOutputs">The additional outputs.</param>
        /// <code> AddWBABoltOutputs(aspectName, additionalOutputs);</code>
        public void AddWBABoltOutputs(string aspectName, List<OutputDefinition> additionalOutputs)
        {
            try
            {
                additionalOutputs.Add(new OutputDefinition("WBABolt" + "TOP", "TOP"));
                additionalOutputs.Add(new OutputDefinition("WBABolt" + "SIDE1", "SIDE1"));
                additionalOutputs.Add(new OutputDefinition("WBABolt" + "SIDE2", "SIDE2"));
                additionalOutputs.Add(new OutputDefinition("WBABolt" + "PIN", "PIN"));
                additionalOutputs.Add(new OutputDefinition("WBABolt" + "TOP2", "TOP2"));

            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrWBABoltAdditionalOutputs, "Error in adding WBABolt outputs");
            }
        }
        /// <summary>
        /// Loads the WBABolt data.
        /// </summary>
        /// <param name="startIndex">The start index.</param>
        ///<code>WBABoltInputs wbaBolt = LoadWBABoltData(3);</code>
        public WBABoltInputs LoadWBABoltData(int startIndex)
        {
            WBABoltInputs wbaBolt = new WBABoltInputs();
            try
            {
                //Basic Plate Dimensions
                wbaBolt.Gap1 = GetDoubleInputValue(startIndex);
                if (wbaBolt.Gap1 < 0)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidGap1ValueNLTZero, "Gap1 value should not be less than zero");
                }
                wbaBolt.Thickness1 = GetDoubleInputValue(++startIndex);
                if (wbaBolt.Thickness1 < 0)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidThickness1NLTZero, "Thickness1 value should not be less than zero");
                }
                wbaBolt.Height1 = GetDoubleInputValue(++startIndex);
                if (wbaBolt.Height1 < 0)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidHeight1NLTZero, "Height1 value should not be less than zero");
                }
                wbaBolt.Width1 = GetDoubleInputValue(++startIndex);
                if (wbaBolt.Width1 < 0)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidWidth1NLTZero, "Width1 value should not be less than zero");
                }
                wbaBolt.Offset1 = GetDoubleInputValue(++startIndex);
                wbaBolt.Width2 = GetDoubleInputValue(++startIndex);
                if (wbaBolt.Width2 < 0)
                    ToDoListMessage = new ToDoListMessage(ToDoMessageTypes.ToDoMessageWarning, SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidWidth2NLTZero, "Width2 value should not be less than zero"));
                wbaBolt.Length2 = GetDoubleInputValue(++startIndex);
                if (wbaBolt.Length2 < 0)
                    ToDoListMessage = new ToDoListMessage(ToDoMessageTypes.ToDoMessageWarning, SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidLength2NLTZero, "Length2 value should not be less than zero"));
                wbaBolt.Thickness2 = GetDoubleInputValue(++startIndex);
                if (wbaBolt.Thickness2 < 0)
                    ToDoListMessage = new ToDoListMessage(ToDoMessageTypes.ToDoMessageWarning, SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidThickness2NLTZero, "Thickness2 value should not be less than zero"));

                wbaBolt.Offset2 = GetDoubleInputValue(++startIndex);
                wbaBolt.Gap2 = GetDoubleInputValue(++startIndex);
                wbaBolt.Width3 = GetDoubleInputValue(++startIndex);
                wbaBolt.Length3 = GetDoubleInputValue(++startIndex);
                wbaBolt.Thickness3 = GetDoubleInputValue(++startIndex);
                wbaBolt.Offset3 = GetDoubleInputValue(++startIndex);
                wbaBolt.Pin1Diameter = GetDoubleInputValue(++startIndex);
                wbaBolt.Pin1Length = GetDoubleInputValue(++startIndex);
                wbaBolt.Height2 = GetDoubleInputValue(++startIndex);

                //Top Left Corner
                wbaBolt.TLCornerType = (int)GetDoubleInputValue(++startIndex);
                if (wbaBolt.TLCornerType == -1)
                    wbaBolt.TLCornerType = 0;
                if (wbaBolt.TLCornerType < 0 || wbaBolt.TLCornerType > 7)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvTLCornerTypeCodeListValue, "TLCornerType code list value should be between 0 and 7");
                }
                wbaBolt.TLCornerX = GetDoubleInputValue(++startIndex);
                wbaBolt.TLCornerY = GetDoubleInputValue(++startIndex);
                wbaBolt.TLCornerRadius = GetDoubleInputValue(++startIndex);

                //Top Right Corner
                wbaBolt.TRCornerType = (int)GetDoubleInputValue(++startIndex);
                if (wbaBolt.TRCornerType == -1)
                    wbaBolt.TRCornerType = 0;
                if (wbaBolt.TRCornerType < 0 || wbaBolt.TRCornerType > 7)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvTRCornerTypeCodeListValue, "TRCornerType code list value should be between 0 and 7");
                }
                wbaBolt.TRCornerX = GetDoubleInputValue(++startIndex);
                wbaBolt.TRCornerY = GetDoubleInputValue(++startIndex);
                wbaBolt.TRCornerRadius = GetDoubleInputValue(++startIndex);
            }
            catch (SmartPartSymbolException hgrEx)
            {
                throw hgrEx;
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadWBABoltData, "Error in loading WBABolt data");
            }
            return wbaBolt;
        }
        /// <summary>
        /// Adds the WBAHole inputs.
        /// </summary>
        /// <param name="startIndex">The start index.</param>
        /// <param name="endIndex">The end index.</param>
        /// <param name="additionalInputs">The additional inputs.</param>
        /// <Code>AddWBAHoleInputs(3, out endIndex, additionalInputs);</Code>
        public void AddWBAHoleInputs(int startIndex, out int endIndex, List<Input> additionalInputs)
        {
            try
            {
                additionalInputs.Add(new InputDouble(startIndex, "WBAHoleConfig", "WBAHoleConfig", 1, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Offset1", "Offset1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Gap1", "Gap1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Thickness1", "Thickness1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Height1", "Height1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Width1", "Width1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Offset2", "Offset2", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Width2", "Width2", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Length1", "Length1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Thickness2", "Thickness2", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Width3", "Width3", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Length2", "Length2", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Thickness3", "Thickness3", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Width4", "Width4", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Length3", "Length3", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Thickness4", "Thickness4", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Offset3", "Offset3", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "SimpShapeType", "SimpShapeType", 1, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Width5", "Width5", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Thickness5", "Thickness5", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "ShapeType", "ShapeType", 1, false));
                ++startIndex;
                endIndex = startIndex;
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrWBAHoleAdditionalInputs, "Error in adding WBAHole inputs");
                endIndex = startIndex;
            }
        }
        /// <summary>
        /// Adds the WBAHole outputs.
        /// </summary>
        /// <param name="aspectName">Name of the aspect.</param>
        /// <param name="additionalOutputs">The additional outputs.</param>
        ///<code>AddWBAHoleOutputs(aspectName, additionalOutputs);</code>
        public void AddWBAHoleOutputs(string aspectName, List<OutputDefinition> additionalOutputs)
        {
            try
            {
                additionalOutputs.Add(new OutputDefinition("WBAHole" + "TOP", "TOP"));
                additionalOutputs.Add(new OutputDefinition("WBAHole" + "TOP2", "TOP2"));
                additionalOutputs.Add(new OutputDefinition("WBAHole" + "SIDE1", "SIDE1"));
                additionalOutputs.Add(new OutputDefinition("WBAHole" + "SIDE2", "SIDE2"));
                additionalOutputs.Add(new OutputDefinition("WBAHole" + "BOTTOM", "BOTTOM"));
                additionalOutputs.Add(new OutputDefinition("WBAHole" + "EXTRARODCONN", "EXTRARODCONN"));
                additionalOutputs.Add(new OutputDefinition("WBAHole" + "TOPCONCRETE", "TOPCONCRETE"));
                additionalOutputs.Add(new OutputDefinition("WBAHole" + "STRAP", "STRAP"));
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrWBAHoleAdditionalOutputs, "Error in adding WBAHole outputs");
            }
        }
        /// <summary>
        /// Loads the WBAHole data.
        /// </summary>
        /// <param name="startIndex">The start index.</param>
        /// <code>WBAHoleInputs wbaHole = LoadWBAHoleData(3);</code>
        public WBAHoleInputs LoadWBAHoleData(int startIndex)
        {
            WBAHoleInputs WBAHole = new WBAHoleInputs();
            try
            {
                //Basic Plate Dimensions
                WBAHole.WBAHoleConfig = (int)GetDoubleInputValue(startIndex);
                if (WBAHole.WBAHoleConfig < 1 || WBAHole.WBAHoleConfig > 2)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrWBAHoleConfigCodeListValue, "WBAHoleConfig code list value should be 1 and 2");
                }
                WBAHole.Offset1 = GetDoubleInputValue(++startIndex);
                WBAHole.Gap1 = GetDoubleInputValue(++startIndex);
                WBAHole.Thickness1 = GetDoubleInputValue(++startIndex);
                WBAHole.Height1 = GetDoubleInputValue(++startIndex);
                WBAHole.Width1 = GetDoubleInputValue(++startIndex);
                WBAHole.Offset2 = GetDoubleInputValue(++startIndex);
                WBAHole.Width2 = GetDoubleInputValue(++startIndex);
                WBAHole.Length1 = GetDoubleInputValue(++startIndex);
                WBAHole.Thickness2 = GetDoubleInputValue(++startIndex);
                WBAHole.Width3 = GetDoubleInputValue(++startIndex);
                WBAHole.Length2 = GetDoubleInputValue(++startIndex);
                WBAHole.Thickness3 = GetDoubleInputValue(++startIndex);
                WBAHole.Width4 = GetDoubleInputValue(++startIndex);
                WBAHole.Length3 = GetDoubleInputValue(++startIndex);
                WBAHole.Thickness4 = GetDoubleInputValue(++startIndex);
                if (WBAHole.Thickness4 < 0)
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidThickness4NLTZero, "Thickness4 value should not be less than zero");

                WBAHole.Offset3 = GetDoubleInputValue(++startIndex);
                WBAHole.SimpShapeType = (int)GetDoubleInputValue(++startIndex);
                WBAHole.Width5 = GetDoubleInputValue(++startIndex);
                WBAHole.Thickness5 = GetDoubleInputValue(++startIndex);
                WBAHole.ShapeType = (int)GetDoubleInputValue(++startIndex);
                if (WBAHole.ShapeType == -1)
                    WBAHole.ShapeType = 0;
                if (WBAHole.ShapeType < 0 || WBAHole.ShapeType > 3)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrShapeTypeCodeListValue, "ShapeType code list value should be between 0 and 3");
                }
            }
            catch (SmartPartSymbolException hgrEx)
            {
                throw hgrEx;
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadWBABoltData, "Error in loading WBAHole Data");
            }
            return WBAHole;

        }
        /// <summary>
        /// This property adds inputs for ElbowLug.User symbol calls this property AdditionalInputs
        /// to define additional inputs. The list of inputs returned by this method will be the inputs for the user symbol in addition
        /// to the inputs that are already defined as member variables.
        /// </summary>
        ///<code>
        /// public override IEnumerable<Input> AdditionalInputs
        /// {
        ///     get
        ///     {
        ///         int endIndex;
        ///         additionalInputs = new List(Input)();
        ///         //Example , I have added the ElbowLug with staring index 4.
        ///         AddElbowLugInputs(4, out endIndex, additionalInputs);
        ///         return additionalInputs; 
        ///    }
        /// }
        ///</code>
        public void AddElbowLugInputs(int startIndex, out int endIndex, List<Input> additionalInputs)
        {
            try
            {
                additionalInputs.Add((Input)new InputDouble(startIndex, "ElbowRadius", "ElbowRadius", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "FaceToCenter", "FaceToCenter", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "TopShape", "TopShape", 1, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Angle1", "Angle1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "RodTakeOut", "RodTakeOut", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Width1", "Width1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Width2", "Width2", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Thickness1", "Thickness1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Angle2", "Angle2", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Angle3", "Angle3", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Angle4", "Angle4", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Gap1", "Gap1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "StiffenerOffset", "StiffenerOffset", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "StiffenerHeight", "StiffenerHeight", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "StiffenerLength", "StiffenerLength", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Offset1", "Offset1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "ChamfLength", "ChamfLength", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "RadiusActual", "RadiusActual", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Pin1Diameter", "Pin1Diameter", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Pin1Length", "Pin1Length", 0, false));

            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddElbowLugInputs, "Error in adding ElbowLug inputs");
                }
            }
            endIndex = startIndex;
        }
        /// <summary>
        /// Adds the ElbowLug outputs.User symbol calls this method during AdditionalOutputs
        /// to define additional outputs for an aspect. The list of outputs returned by this method will be the outputs for the aspect
        /// in addition to the outputs that are already defined as attributes on the aspect.
        /// </summary>
        /// <param name="additionalOutputs">The additional outputs.</param>
        ///<code>
        ///public override IEnumerable<OutputDefinition> AdditionalOutputs(string aspectName)
        ///{
        ///    List<OutputDefinition> additionalOutputs = new List<OutputDefinition>();
        ///    if (aspectName == "Symbolic")
        ///    {
        ///        AddElbowLugOutputs(additionalOutputs);
        ///    }
        ///    return additionalOutputs;
        ///}
        ///</code> 
        public void AddElbowLugOutputs(List<OutputDefinition> additionalOutputs)
        {
            try
            {
                additionalOutputs.Add(new OutputDefinition("ElbowLug" + "Shape1", "ElbowLug" + "Shape1"));
                additionalOutputs.Add(new OutputDefinition("ElbowLug" + "Shape2", "ElbowLug" + "Shape2"));
                additionalOutputs.Add(new OutputDefinition("ElbowLug" + "Stiffener", "ElbowLug" + "Stiffener"));
                additionalOutputs.Add(new OutputDefinition("ElbowLug" + "Pin", "ElbowLug" + "Pin"));
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddElbowLugOutputs, "Error in adding ElbowLug outputs");
                }
            }
        }
        /// <summary>
        /// This method will be called by user symbol to get value of an input(in this case, ElbowLug input structure)during construction of outputs. 
        /// Given the start index, this method will return the value of the PinInputs struct object.
        /// </summary>
        /// <param name="startIndex">The start index.</param>
        /// <returns></returns>
        ///<code>
        ///ElbowLugInputs elbowLug = LoadElbowLugData(4);
        ///</code>
        public ElbowLugInputs LoadElbowLugData(int startIndex)
        {
            ElbowLugInputs elbowLug = new ElbowLugInputs();
            try
            {

                elbowLug.ElbowRadius = GetDoubleInputValue(startIndex);
                if (elbowLug.ElbowRadius < 0)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidElbowRadius, "Elbow Radius should be Positive Value");
                }
                elbowLug.FaceToCenter = GetDoubleInputValue(++startIndex);
                if (elbowLug.FaceToCenter < 0)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidFacetoCenter, "FaceToCenter should be Positive Value");
                }
                elbowLug.TopShape = (int)GetDoubleInputValue(++startIndex);
                elbowLug.Angle1 = GetDoubleInputValue(++startIndex);
                elbowLug.RodTakeOut = GetDoubleInputValue(++startIndex);
                elbowLug.Width1 = GetDoubleInputValue(++startIndex);
                elbowLug.Width2 = GetDoubleInputValue(++startIndex);
                elbowLug.Thickness1 = GetDoubleInputValue(++startIndex);
                elbowLug.Angle2 = GetDoubleInputValue(++startIndex);
                elbowLug.Angle3 = GetDoubleInputValue(++startIndex);
                elbowLug.Angle4 = GetDoubleInputValue(++startIndex);
                elbowLug.Gap1 = GetDoubleInputValue(++startIndex);
                if (elbowLug.Gap1 < 0.0)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidGap1ValueNLTZero, "Gap1 value should not be less than or equal to zero");
                }
                elbowLug.StiffenerOffset = GetDoubleInputValue(++startIndex);
                elbowLug.StiffenerHeight = GetDoubleInputValue(++startIndex);
                if (elbowLug.StiffenerHeight < 0.0)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidStiffenerHeightValue, "Height value should not be less than zero");
                }
                elbowLug.StiffenerLength = GetDoubleInputValue(++startIndex);
                if (elbowLug.StiffenerLength < 0.0)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidStiffenerLengthValue, "Length value should not be less than zero");
                }
                elbowLug.Offset1 = GetDoubleInputValue(++startIndex);
                elbowLug.ChamfLength = GetDoubleInputValue(++startIndex);
                elbowLug.ActualRadius = GetDoubleInputValue(++startIndex);
                elbowLug.Pin1Diameter = GetDoubleInputValue(++startIndex);
                if (elbowLug.Pin1Diameter < 0)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidPin1DiameterNLTZero, "Pin1Diameter value should not be less than zero");
                }
                elbowLug.Pin1Length = GetDoubleInputValue(++startIndex);
            }
            catch (SmartPartSymbolException hgrEx)
            {
                throw hgrEx;
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadElbowLugData, "Error in LoadElbowLugData");
                }
            }
            return elbowLug;
        }

        /// <summary>
        /// This property adds inputs for Guide.User symbol calls this property AdditionalInputs
        /// to define additional inputs. The list of inputs returned by this method will be the inputs for the user symbol in addition
        /// to the inputs that are already defined as member variables.
        /// </summary>
        ///<code>
        /// public override IEnumerable<Input> AdditionalInputs
        /// {
        ///     get
        ///     {
        ///         int endIndex;
        ///         additionalInputs = new List(Input)();
        ///         //Example , I have added the Guide with staring index 3.
        ///         AddGuideInputs(3, out endIndex, additionalInputs);
        ///         return additionalInputs; 
        ///    }
        /// }
        ///</code>
        public void AddGuideInputs(int startIndex, out int endIndex, List<Input> additionalInputs)
        {
            try
            {
                additionalInputs.Add((Input)new InputDouble(startIndex, "Width1", "Width1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Length1", "Length1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Thickness1", "Thickness1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Width2", "Width2", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Length2", "Length2", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Thickness2", "Thickness2", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Gap1", "Gap1", 0, false));
                additionalInputs.Add((Input)new InputString(++startIndex, "VerPlSecStand", "VerPlSecStand", "No Value", false));
                additionalInputs.Add((Input)new InputString(++startIndex, "VerPlSecSize", "VerPlSecSize", "No Value", false));
                additionalInputs.Add((Input)new InputString(++startIndex, "VerPlSecType", "VerPlSecType", "No Value", false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Angle1", "Angle1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Angle2", "Angle2", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Connection1", "Connection1", 1, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Connection2", "Connection2", 1, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Mirrored1", "Mirrored1", 1, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Mirrored2", "Mirrored2", 1, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "SecConfig", "SecConfig", 1, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Width3", "Width3", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Length3", "Length3", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Thickness3", "Thickness3", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Offset1", "Offset1", 1, false));
                additionalInputs.Add((Input)new InputString(++startIndex, "HorPlSecStand", "HorPlSecStand", "No Value", false));
                additionalInputs.Add((Input)new InputString(++startIndex, "HorPlSecSize", "HorPlSecSize", "No Value", false));
                additionalInputs.Add((Input)new InputString(++startIndex, "HorPlSecType", "HorPlSecType", "No Value", false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Angle3", "Angle3", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Angle4", "Angle4", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Connection3", "Connection3", 1, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Connection4", "Connection4", 1, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Offset2", "Offset2", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "SolidBaseVerPl", "SolidBaseVerPl", 1, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "SolidVerHorPl", "SolidVerHorPl", 1, false));
                endIndex = startIndex;
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrGuideAdditionalInputs, "Error in adding Guide inputs");
                endIndex = startIndex;
            }
        }

        /// <summary>
        /// Adds the guide outputs.User symbol calls this method during AdditionalOutputs
        /// to define additional outputs for an aspect. The list of outputs returned by this method will be the outputs for the aspect
        /// in addition to the outputs that are already defined as attributes on the aspect.
        /// </summary>
        /// <param name="additionalOutputs">The additional outputs.</param>
        ///<code>
        ///public override IEnumerable<OutputDefinition> AdditionalOutputs(string aspectName)
        ///{
        ///    List<OutputDefinition> additionalOutputs = new List<OutputDefinition>();
        ///    if (aspectName == "Symbolic")
        ///    {
        ///       AddGuideOutputs(additionalOutputs);
        ///    }
        ///    return additionalOutputs;
        ///}
        ///</code> 
        public void AddGuideOutputs(List<OutputDefinition> additionalOutputs)
        {
            try
            {
                additionalOutputs.Add(new OutputDefinition("Guide" + "Bplate", "Guide" + "Bplate"));
                additionalOutputs.Add(new OutputDefinition("Guide" + "VPlate1", "Guide" + "VPlate1"));
                additionalOutputs.Add(new OutputDefinition("Guide" + "VPlate2", "Guide" + "VPlate2"));
                additionalOutputs.Add(new OutputDefinition("Guide" + "HPlate1", "Guide" + "HPlate1"));
                additionalOutputs.Add(new OutputDefinition("Guide" + "HPlate2", "Guide" + "HPlate2"));
                additionalOutputs.Add(new OutputDefinition("Guide" + "Section1", "Guide" + "Section1"));
                additionalOutputs.Add(new OutputDefinition("Guide" + "Section2", "Guide" + "Section2"));
                additionalOutputs.Add(new OutputDefinition("Guide" + "Section1Hor", "Guide" + "Section1Hor"));
                additionalOutputs.Add(new OutputDefinition("Guide" + "Section2Hor", "Guide" + "Section2Hor"));
                additionalOutputs.Add(new OutputDefinition("Guide" + "guide", "Guide" + "guide"));
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrGuideAdditionalOutputs, "Error in adding Guide outputs");
            }
        }

        /// <summary>
        /// This method will be called by user symbol to get value of an input during construction of outputs. 
        /// Given the start index, this method will return the value of the GuideInputs struct object.
        /// </summary>
        /// <param name="startIndex">The start index.</param>
        /// <returns></returns>
        ///<code>
        ///GuideInputs Guide = LoadGuideData(3);
        ///</code>
        public GuideInputs LoadGuideData(int startIndex, Part part)
        {
            GuideInputs guide = new GuideInputs();
            try
            {
                guide.Width1 = GetDoubleInputValue(startIndex);
                guide.Length1 = GetDoubleInputValue(++startIndex);
                guide.Thickness1 = GetDoubleInputValue(++startIndex);
                guide.Width2 = GetDoubleInputValue(++startIndex);
                guide.Length2 = GetDoubleInputValue(++startIndex);
                guide.Thickness2 = GetDoubleInputValue(++startIndex);
                guide.Gap1 = GetDoubleInputValue(++startIndex);
                guide.VerPlSecStand = GetStringInputValue(++startIndex);
                guide.VerPlSecSize = GetStringInputValue(++startIndex);
                guide.VerPlSecType = GetStringInputValue(++startIndex);
                guide.Angle1 = GetDoubleInputValue(++startIndex);
                guide.Angle2 = GetDoubleInputValue(++startIndex);
                guide.Connection1 = (int)GetDoubleInputValue(++startIndex);
                if (guide.Connection1 < 1 || guide.Connection1 > 15)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidConnection, "Connection code list value should be between 1 and 15");
                }
                guide.Connection2 = (int)GetDoubleInputValue(++startIndex);
                if (guide.Connection2 < 1 || guide.Connection2 > 15)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidConnection, "Connection code list value should be between 1 and 15");
                }
                guide.Mirrored1 = (int)GetDoubleInputValue(++startIndex);
                if (guide.Mirrored1 == -1)
                    guide.Mirrored1 = 1;
                if (guide.Mirrored1 < 1 || guide.Mirrored1 > 2)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidMirrored, "Mirrored code list value should be between 1 and 2");
                }
                guide.Mirrored2 = (int)GetDoubleInputValue(++startIndex);
                if (guide.Mirrored2 < 1 || guide.Mirrored2 > 2)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidMirrored, "Mirrored code list value should be between 1 and 2");
                }
                guide.SecConfig = (int)GetDoubleInputValue(++startIndex);
                if (guide.SecConfig < 1 || guide.SecConfig > 2)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidSecConfigCodeListValue, "SecConfig code list value should be between 1 and 2");
                }
                guide.Width3 = GetDoubleInputValue(++startIndex);
                guide.Length3 = GetDoubleInputValue(++startIndex);
                guide.Thickness3 = GetDoubleInputValue(++startIndex);
                guide.Offset1 = GetDoubleInputValue(++startIndex);
                guide.HorPlSecStand = GetStringInputValue(++startIndex);
                guide.HorPlSecSize = GetStringInputValue(++startIndex);
                guide.HorPlSecType = GetStringInputValue(++startIndex);
                guide.Angle3 = GetDoubleInputValue(++startIndex);
                guide.Angle4 = GetDoubleInputValue(++startIndex);
                guide.Connection3 = (int)GetDoubleInputValue(++startIndex);
                if (guide.Connection3 < 1 || guide.Connection3 > 15)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidConnection, "Connection code list value should be between 1 and 15");
                }
                guide.Connection4 = (int)GetDoubleInputValue(++startIndex);
                if (guide.Connection4 < 1 || guide.Connection4 > 15)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidConnection, "Connection code list value should be between 1 and 15");
                }
                guide.Offset2 = (int)GetDoubleInputValue(++startIndex);
                guide.SolidBaseVerPl = (int)GetDoubleInputValue(++startIndex);
                if (guide.SolidBaseVerPl < 1 || guide.SolidBaseVerPl > 2)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidSolidBaseVerPl, "SolidBaseVerPl code list value should be between 1 and 2");
                }
                guide.SolidVerHorPl = (int)GetDoubleInputValue(++startIndex);
                if (guide.SolidVerHorPl < 1 || guide.SolidVerHorPl > 2)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidSolidVerHorPl, "SolidVerHorPl code list value should be between 1 and 2");
                }
                try
                {
                    if (part.SupportsInterface("IJUAhsCPXOffset"))
                        guide.CPXoffset = GetDoubleInputValue(++startIndex);
                    else
                        ++startIndex;
                }
                catch
                {
                    guide.CPXoffset = 0;
                }
                try
                {
                    if (part.SupportsInterface("IJUAhsCPYOffset"))
                        guide.CPYoffset = GetDoubleInputValue(++startIndex);
                    else
                        ++startIndex;
                }
                catch
                {
                    guide.CPYoffset = 0;
                }
                try
                {
                    if (part.SupportsInterface("IJUAhsGuideHeight"))
                        guide.GuideHeight = GetDoubleInputValue(++startIndex);
                    else
                        ++startIndex;
                }
                catch
                {
                    guide.GuideHeight = 0;
                }
            }
            catch (SmartPartSymbolException hgrEx)
            {
                throw hgrEx;
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadGuideData, "Error in loading Guide data");
            }
            return guide;
        }

        /// <summary>
        /// This property adds inputs for SlidePlate.User symbol calls this property AdditionalInputs
        /// to define additional inputs. The list of inputs returned by this method will be the inputs for the user symbol in addition
        /// to the inputs that are already defined as member variables.
        /// </summary>
        ///<code>
        /// public override IEnumerable<Input> AdditionalInputs
        /// {
        ///     get
        ///     {
        ///         int endIndex;
        ///         additionalInputs = new List(Input)();
        ///         //Example , I have added the Slideplate with staring index 3.
        ///         AddSlidePlateInputs(3, out endIndex, additionalInputs);
        ///         return additionalInputs; 
        ///    }
        /// }
        ///</code>
        public void AddSlidePlateInputs(int startIndex, out int endIndex, List<Input> additionalInputs)
        {
            try
            {
                additionalInputs.Add((Input)new InputDouble(startIndex, "Width1", "Width1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Height1", "Height1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Thickness1", "Thickness1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "XPl1", "XPl1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "YPl1", "YPl1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "ZPl1", "ZPl1", 0, false));

                additionalInputs.Add((Input)new InputDouble(++startIndex, "Width2", "Width2", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Height2", "Height2", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Thickness2", "Thickness2", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "XPl2", "XPl2", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "YPl2", "YPl2", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "ZPl2", "ZPl2", 0, false));

                additionalInputs.Add((Input)new InputDouble(++startIndex, "Width3", "Width3", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Height3", "Height3", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Thickness3", "Thickness3", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "XPl3", "XPl3", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "YPl3", "YPl3", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "ZPl3", "ZPl3", 0, false));

                additionalInputs.Add((Input)new InputDouble(++startIndex, "Width4", "Width4", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Height4", "Height4", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Thickness4", "Thickness4", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "XPl4", "XPl4", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "YPl4", "YPl4", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "ZPl4", "ZPl4", 0, false));

                additionalInputs.Add((Input)new InputDouble(++startIndex, "Width5", "Width5", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Height5", "Height5", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Thickness5", "Thickness5", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "XPl5", "XPl5", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "YPl5", "YPl5", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "ZPl5", "ZPl5", 0, false));

                additionalInputs.Add((Input)new InputDouble(++startIndex, "Width6", "Width6", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Height6", "Height6", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Thickness6", "Thickness6", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "XPl6", "XPl6", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "YPl6", "YPl6", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "ZPl6", "ZPl6", 0, false));

                additionalInputs.Add((Input)new InputDouble(++startIndex, "ShoeHeight", "ShoeHeight", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Diameter1", "Diameter1", 0, false));
                additionalInputs.Add((Input)new InputString(++startIndex, "GuideShape", "GuideShape", "No Value", false));

                endIndex = startIndex;
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrSlidePlateAdditionalInputs, "Error in adding SlidePlate inputs");
                endIndex = startIndex;
            }
        }

        /// <summary>
        /// Adds the SlidePlate outputs.User symbol calls this method during AdditionalOutputs
        /// to define additional outputs for an aspect. The list of outputs returned by this method will be the outputs for the aspect
        /// in addition to the outputs that are already defined as attributes on the aspect.
        /// </summary>
        /// <param name="additionalOutputs">The additional outputs.</param>
        ///<code>
        ///public override IEnumerable<OutputDefinition> AdditionalOutputs(string aspectName)
        ///{
        ///    List<OutputDefinition> additionalOutputs = new List<OutputDefinition>();
        ///    if (aspectName == "Symbolic")
        ///    {
        ///        AddSlidePlateOutputs(additionalOutputs);
        ///    }
        ///    return additionalOutputs;
        ///}
        ///</code> 
        public void AddSlidePlateOutputs(List<OutputDefinition> additionalOutputs)
        {
            try
            {
                additionalOutputs.Add(new OutputDefinition("SlidePlate" + "SlidePlate1", "SlidePlate" + "SlidePlate1"));
                additionalOutputs.Add(new OutputDefinition("SlidePlate" + "SlidePlate2", "SlidePlate" + "SlidePlate2"));
                additionalOutputs.Add(new OutputDefinition("SlidePlate" + "SlidePlate3", "SlidePlate" + "SlidePlate3"));
                additionalOutputs.Add(new OutputDefinition("SlidePlate" + "SlidePlate4", "SlidePlate" + "SlidePlate4"));
                additionalOutputs.Add(new OutputDefinition("SlidePlate" + "SlidePlate5", "SlidePlate" + "SlidePlate5"));
                additionalOutputs.Add(new OutputDefinition("SlidePlate" + "SlidePlate6", "SlidePlate" + "SlidePlate6"));
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrSlidePlateAdditionalOutputs, "Error in adding SlidePlate outputs");
            }
        }

        /// <summary>
        /// This method will be called by user symbol to get value of an input(in this case, SlidePlate input structure)during construction of outputs. 
        /// Given the start index, this method will return the value of the SlidePlateInputs struct object.
        /// </summary>
        /// <param name="startIndex">The start index.</param>
        /// <returns></returns>
        ///<code>
        ///SlidePlateInputs slidePlate = LoadSlidePlateData(2);
        ///</code>
        public SlidePlateInputs LoadSlidePlateData(int startIndex)
        {
            SlidePlateInputs slidePlate = new SlidePlateInputs();
            try
            {
                slidePlate.Width1 = GetDoubleInputValue(startIndex);
                if (slidePlate.Width1 <= 0)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidWidth1, "Width1 should be greater than zero");
                }
                slidePlate.Height1 = GetDoubleInputValue(++startIndex);
                if (slidePlate.Height1 <= 0)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidHeight1GTZero, "Height1 should be greater than zero");
                }
                slidePlate.Thickness1 = GetDoubleInputValue(++startIndex);
                if (slidePlate.Thickness1 <= 0)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidThickness1GTZero, "Thickness1 should be greater than zero");
                }
                slidePlate.XPl1 = GetDoubleInputValue(++startIndex);
                slidePlate.YPl1 = GetDoubleInputValue(++startIndex);
                slidePlate.ZPl1 = GetDoubleInputValue(++startIndex);

                slidePlate.Width2 = GetDoubleInputValue(++startIndex);
                slidePlate.Height2 = GetDoubleInputValue(++startIndex);
                slidePlate.Thickness2 = GetDoubleInputValue(++startIndex);
                slidePlate.XPl2 = GetDoubleInputValue(++startIndex);
                slidePlate.YPl2 = GetDoubleInputValue(++startIndex);
                slidePlate.ZPl2 = GetDoubleInputValue(++startIndex);

                slidePlate.Width3 = GetDoubleInputValue(++startIndex);
                slidePlate.Height3 = GetDoubleInputValue(++startIndex);
                slidePlate.Thickness3 = GetDoubleInputValue(++startIndex);
                slidePlate.XPl3 = GetDoubleInputValue(++startIndex);
                slidePlate.YPl3 = GetDoubleInputValue(++startIndex);
                slidePlate.ZPl3 = GetDoubleInputValue(++startIndex);

                slidePlate.Width4 = GetDoubleInputValue(++startIndex);
                slidePlate.Height4 = GetDoubleInputValue(++startIndex);
                slidePlate.Thickness4 = GetDoubleInputValue(++startIndex);
                slidePlate.XPl4 = GetDoubleInputValue(++startIndex);
                slidePlate.YPl4 = GetDoubleInputValue(++startIndex);
                slidePlate.ZPl4 = GetDoubleInputValue(++startIndex);

                slidePlate.Width5 = GetDoubleInputValue(++startIndex);
                slidePlate.Height5 = GetDoubleInputValue(++startIndex);
                slidePlate.Thickness5 = GetDoubleInputValue(++startIndex);
                slidePlate.XPl5 = GetDoubleInputValue(++startIndex);
                slidePlate.YPl5 = GetDoubleInputValue(++startIndex);
                slidePlate.ZPl5 = GetDoubleInputValue(++startIndex);

                slidePlate.Width6 = GetDoubleInputValue(++startIndex);
                slidePlate.Height6 = GetDoubleInputValue(++startIndex);
                slidePlate.Thickness6 = GetDoubleInputValue(++startIndex);
                slidePlate.XPl6 = GetDoubleInputValue(++startIndex);
                slidePlate.YPl6 = GetDoubleInputValue(++startIndex);
                slidePlate.ZPl6 = GetDoubleInputValue(++startIndex);

                slidePlate.ShoeHeight = GetDoubleInputValue(++startIndex);
                slidePlate.PipeDia = GetDoubleInputValue(++startIndex);
            }
            catch (SmartPartSymbolException hgrEx)
            {
                throw hgrEx;
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadSlidePlateData, "Error in loading SlidePlate data");
            }
            return slidePlate;
        }

        /// <summary>
        /// This property adds inputs for SwivelRing.User symbol calls this property AdditionalInputs
        /// to define additional inputs. The list of inputs returned by this method will be the inputs for the user symbol in addition
        /// to the inputs that are already defined as member variables.
        /// </summary>
        ///<code>
        /// public override IEnumerable<Input> AdditionalInputs
        /// {
        ///     get
        ///     {
        ///         int endIndex;
        ///         additionalInputs = new List(Input)();
        ///         //Example , I have added the Slideplate with staring index 3.
        ///         AddSwivelRingInputs(3, out endIndex, additionalInputs);
        ///         return additionalInputs; 
        ///    }
        /// }
        ///</code>
        public void AddSwivelRingInputs(int startIndex, out int endIndex, List<Input> additionalInputs)
        {
            try
            {
                additionalInputs.Add((Input)new InputDouble(startIndex, "RodDiameter", "RodDiameter", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "RodTakeOut", "RodTakeOut", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "PipeOD", "PipeOD", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Width1", "Width1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Width2", "Width2", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Width3", "Width3", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Thickness1", "Thickness1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Height1", "Height1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Diameter1", "Diameter1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Gap1", "Gap1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Width4", "Width4", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Height2", "Height2", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Diameter2", "Diameter2", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Thickness2", "Thickness2", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Pin1Diameter", "Pin1Diameter", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Pin1Length", "Pin1Length", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Height3", "Height3", 0, false));
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrSwivelRingAdditionalInputs, "Error in adding SwivelRing inputs");
                }
            }
            endIndex = startIndex;
        }

        /// <summary>
        /// Adds the SwivelRing outputs.User symbol calls this method during AdditionalOutputs
        /// to define additional outputs for an aspect. The list of outputs returned by this method will be the outputs for the aspect
        /// in addition to the outputs that are already defined as attributes on the aspect.
        /// </summary>
        /// <param name="additionalOutputs">The additional outputs.</param>
        ///<code>
        ///public override IEnumerable<OutputDefinition> AdditionalOutputs(string aspectName)
        ///{
        ///    List<OutputDefinition> additionalOutputs = new List<OutputDefinition>();
        ///    if (aspectName == "Symbolic")
        ///    {
        ///        AddSwivelRingOutputs(additionalOutputs);
        ///    }
        ///    return additionalOutputs;
        ///}
        ///</code> 
        public void AddSwivelRingOutputs(List<OutputDefinition> additionalOutputs)
        {
            try
            {
                additionalOutputs.Add(new OutputDefinition("SwivelRing" + "Swivel", "SwivelRing" + "Swivel"));
                additionalOutputs.Add(new OutputDefinition("SwivelRing" + "TopShape", "SwivelRing" + "TopShape"));
                additionalOutputs.Add(new OutputDefinition("SwivelRing" + "Rod", "SwivelRing" + "Rod"));
                additionalOutputs.Add(new OutputDefinition("SwivelRing" + "Liner", "SwivelRing" + "Liner"));
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrSwivelRingAdditionalOutputs, "Error in adding SwivelRing outputs");
                }
            }
        }

        /// <summary>
        /// This method will be called by user symbol to get value of an input(in this case, SwivelRing input structure)during construction of outputs. 
        /// Given the start index, this method will return the value of the SwivelInputs struct object.
        /// </summary>
        /// <param name="startIndex">The start index.</param>
        /// <returns></returns>
        ///<code>
        ///SwivelInputs swivelRing = LoadSwivelData(2);
        ///</code>
        public SwivelInputs LoadSwivelData(int startIndex)
        {
            SwivelInputs swivelRing = new SwivelInputs();
            try
            {
                swivelRing.RodDiameter = GetDoubleInputValue(startIndex);
                swivelRing.RodTakeOut = GetDoubleInputValue(++startIndex);
                swivelRing.PipeOD = GetDoubleInputValue(++startIndex);
                swivelRing.Width1 = GetDoubleInputValue(++startIndex);
                swivelRing.Width2 = GetDoubleInputValue(++startIndex);
                swivelRing.Width3 = GetDoubleInputValue(++startIndex);
                swivelRing.Thickness1 = GetDoubleInputValue(++startIndex);
                swivelRing.Height1 = GetDoubleInputValue(++startIndex);
                swivelRing.Diameter1 = GetDoubleInputValue(++startIndex);
                swivelRing.Gap1 = GetDoubleInputValue(++startIndex);
                swivelRing.Width4 = GetDoubleInputValue(++startIndex);
                swivelRing.Height2 = GetDoubleInputValue(++startIndex);
                swivelRing.Diameter2 = GetDoubleInputValue(++startIndex);
                swivelRing.Thickness2 = GetDoubleInputValue(++startIndex);
                swivelRing.Pin1Diameter = GetDoubleInputValue(++startIndex);
                swivelRing.Pin1Length = GetDoubleInputValue(++startIndex);
                swivelRing.Height3 = GetDoubleInputValue(++startIndex);
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadSwivelRingData, "Error in loading SwivelRing data");
            }
            return swivelRing;
        }
        /// <summary>
        /// Adds the Shoe inputs.
        /// </summary>
        /// <param name="startIndex">The start index.</param>
        /// <param name="endIndex">The end index.</param>
        /// <param name="additionalInputs">The additional inputs.</param>
        /// <code>AddShoeInputs (2, out endIndex, additionalInputs);</code>
        public void AddShoeInputs(int startIndex, out int endIndex, List<Input> additionalInputs)
        {
            try
            {
                // Add Dimension Inputs for the Basic Shoe Attributes
                additionalInputs.Add(new InputString(startIndex, "ShoeShape", "ShoeShape", "", false));
                additionalInputs.Add(new InputDouble(++startIndex, "ShoeHeight", "ShoeHeight", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "ShoeWidth", "ShoeWidth", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "ShoeLength", "ShoeLength", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "ShoeGap", "ShoeGap", 0, false));

                additionalInputs.Add(new InputDouble(++startIndex, "Diameter1", "Diameter1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "SlopeAngle", "SlopeAngle", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "ShoeQty", "ShoeQty", 0, false));
                // Add End Plate Inputs
                additionalInputs.Add(new InputDouble(++startIndex, "EndPlateNum", "EndPlateNum", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "EndPlateHeight", "EndPlateHeight", 0, false));
                additionalInputs.Add(new InputString(++startIndex, "EndPlateShape", "EndPlateShape", "", false));
                additionalInputs.Add(new InputDouble(++startIndex, "EndPlateOffset", "EndPlateOffset", 0, false));
                // Add Reinforced Pad Inputs
                additionalInputs.Add(new InputString(++startIndex, "RepadShape", "RepadShape", "", false));
                additionalInputs.Add(new InputDouble(++startIndex, "Multi1Qty", "Multi1Qty", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Multi1LocateBy", "Multi1LocateBy", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Multi1Location", "Multi1Location", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "RepadOffset1", "RepadOffset1", 0, false));
                // Add Clamp Inputs
                additionalInputs.Add(new InputString(++startIndex, "ClampShape", "ClampShape", "", false));
                additionalInputs.Add(new InputDouble(++startIndex, "Multi2Qty", "Multi2Qty", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Multi2LocateBy", "Multi2LocateBy", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Multi2Location", "Multi2Location", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "ClampOffset1", "ClampOffset1", 0, false));
                // Add U-bolt Inputs
                additionalInputs.Add(new InputString(++startIndex, "UboltShape", "UboltShape", "", false));
                additionalInputs.Add(new InputDouble(++startIndex, "Multi3Qty", "Multi3Qty", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Multi3LocateBy", "Multi3LocateBy", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Multi3Location", "Multi3Location", 0, false));
                // Add Strap Inputs
                additionalInputs.Add(new InputString(++startIndex, "StrapShape", "StrapShape", "", false));
                additionalInputs.Add(new InputDouble(++startIndex, "Multi4Qty", "Multi4Qty", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Multi4LocateBy", "Multi4LocateBy", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Multi4Location", "Multi4Location", 0, false));
                // Add Gusset Inputs
                additionalInputs.Add(new InputString(++startIndex, "GussetShape", "GussetShape", "", false));
                additionalInputs.Add(new InputDouble(++startIndex, "Multi5Qty", "Multi5Qty", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Multi5LocateBy", "Multi5LocateBy", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Multi5Location", "Multi5Location", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "GussetGap", "GussetGap", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "GussetHeight", "GussetHeight", 0, false));
                // Add Guide Inputs
                additionalInputs.Add(new InputString(++startIndex, "GuideShape", "GuideShape", "", false));
                additionalInputs.Add(new InputDouble(++startIndex, "Multi6Qty", "Multi6Qty", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Multi6LocateBy", "Multi6LocateBy", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Multi6Location", "Multi6Location", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "GuideVerticalOffset", "GuideVerticalOffset", 0, false));
                // Add Shield Plate Inputs
                additionalInputs.Add(new InputString(++startIndex, "ShieldShape", "ShieldShape", "", false));
                additionalInputs.Add(new InputDouble(++startIndex, "Multi7Qty", "Multi7Qty", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Multi7LocateBy", "Multi7LocateBy", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Multi7Location", "Multi7Location", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "ShieldOffset1", "ShieldOffset1", 0, false));
                // Add Stiffener Inputs
                additionalInputs.Add(new InputString(++startIndex, "StiffenerShape", "StiffenerShape", "", false));
                additionalInputs.Add(new InputDouble(++startIndex, "Multi8Qty", "Multi8Qty", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Multi8LocateBy", "Multi8LocateBy", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Multi8Location", "Multi8Location", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "StiffVerticalOffset", "StiffVerticalOffset", 0, false));
                // Add Slide Plate Inputs
                additionalInputs.Add(new InputString(++startIndex, "SlidePlateShape", "SlidePlateShape", "", false));
                additionalInputs.Add(new InputDouble(++startIndex, "Multi9Qty", "Multi9Qty", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Multi9LocateBy", "Multi9LocateBy", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Multi9Location", "Multi9Location", 0, false));
                // Add Shield2 Plate Inputs
                additionalInputs.Add(new InputString(++startIndex, "Shield2Shape", "Shield2Shape", "", false));
                additionalInputs.Add(new InputDouble(++startIndex, "Multi10Qty", "Multi10Qty", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Multi10LocateBy", "Multi10LocateBy", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Multi10Location", "Multi10Location", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Shield2Offset1", "Shield2Offset1", 0, false));
                // Additional Plates
                additionalInputs.Add(new InputString(++startIndex, "AdditionalPlateShape", "AdditionalPlateShape", "", false));
                additionalInputs.Add(new InputDouble(++startIndex, "PlateNumber", "PlateNumber", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "CenterDiameter", "CenterDiameter", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "PlateRotAngle", "PlateRotAngle", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "PlateAngle", "PlateAngle", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "AddPlateOffset1", "AddPlateOffset1", 0, false));
                // Clamp2
                additionalInputs.Add(new InputString(++startIndex, "Clamp2Shape", "Clamp2Shape", "", false));
                additionalInputs.Add(new InputDouble(++startIndex, "Multi11Qty", "Multi11Qty", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Multi11LocateBy", "Multi11LocateBy", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Multi11Location", "Multi11Location", 0, false));
                // Rib
                additionalInputs.Add(new InputString(++startIndex, "RibShape", "RibShape", "", false));
                additionalInputs.Add(new InputDouble(++startIndex, "RibHeight", "RibHeight", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "RibQty", "RibQty", 0, false));
                //++startIndex;
                endIndex = ++startIndex;
            }
            catch
            {

                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddShoeInputs, "Error in adding Shoe Inputs");
                endIndex = startIndex;
            }
        }
        /// This property adds inputs for DummyLeg.User symbol calls this property AdditionalInputs
        /// to define additional inputs. The list of inputs returned by this method will be the inputs for the user symbol in addition
        /// to the inputs that are already defined as member variables.
        /// </summary>
        ///<code>
        /// public override IEnumerable<Input> AdditionalInputs
        /// {
        ///     get
        ///     {
        ///         int endIndex;
        ///         additionalInputs = new List(Input)();
        ///         //Example , I have added the DummyLeg with staring index 3.
        ///         AddDummyLegInputs(3, out endIndex, additionalInputs);
        ///         return additionalInputs; 
        ///    }
        /// }
        ///</code>
        public void AddDummyLegInputs(int startIndex, out int endIndex, List<Input> additionalInputs)
        {
            try
            {
                additionalInputs.Add((Input)new InputString(startIndex, "BotShape", "BotShape", "", false));
                additionalInputs.Add((Input)new InputString(++startIndex, "TopShape", "TopShape", "", false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Length", "Length", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "StanGap", "StanGap", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Diameter1", "Diameter1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Offset1", "Offset1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Offset2", "Offset2", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "ElbowRadius", "ElbowRadius", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "FaceToCenter", "FaceToCenter", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "IsStanchion", "IsStanchion", 0, false));
                additionalInputs.Add((Input)new InputString(++startIndex, "RepadShape", "RepadShape", "", false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "MinLen", "MinLen", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "MaxLen", "MaxLen", 0, false));
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddDummyLegInputs, "Error in AddDummyLegInputs");
            }
            endIndex = startIndex;
        }
        /// <summary>
        /// Adds the DummyLeg outputs.User symbol calls this method during AdditionalOutputs
        /// to define additional outputs for an aspect. The list of outputs returned by this method will be the outputs for the aspect
        /// in addition to the outputs that are already defined as attributes on the aspect.
        /// </summary>
        /// <param name="additionalOutputs">The additional outputs.</param>
        ///<code>
        ///public override IEnumerable<OutputDefinition> AdditionalOutputs(string aspectName)
        ///{
        ///    List<OutputDefinition> additionalOutputs = new List<OutputDefinition>();
        ///    if (aspectName == "Symbolic")
        ///    {
        ///       AddDummyLegOutpus(additionalOutputs);
        ///    }
        ///    return additionalOutputs;
        ///}
        ///</code> 
        public void AddDummyLegOutpus(List<OutputDefinition> additionalOutputs)
        {
            try
            {
                additionalOutputs.Add(new OutputDefinition("DummyLeg" + "BotShape", "DummyLeg" + "BotShape"));
                additionalOutputs.Add(new OutputDefinition("DummyLeg" + "TopShape", "DummyLeg" + "TopShape"));
                additionalOutputs.Add(new OutputDefinition("DummyLeg" + "BotPlate1Shape", "DummyLeg" + "BotPlate1Shape"));
                additionalOutputs.Add(new OutputDefinition("DummyLeg" + "TopPlate1Shape", "DummyLeg" + "TopPlate1Shape"));
                additionalOutputs.Add(new OutputDefinition("DummyLeg" + "BotPlate2Shape", "DummyLeg" + "BotPlate2Shape"));
                additionalOutputs.Add(new OutputDefinition("DummyLeg" + "TopPlate2Shape", "DummyLeg" + "TopPlate2Shape"));
                additionalOutputs.Add(new OutputDefinition("DummyLeg" + "BotBoltRow1", "DummyLeg" + "BotBoltRow1"));
                additionalOutputs.Add(new OutputDefinition("DummyLeg" + "TopBoltRow1", "DummyLeg" + "TopBoltRow1"));

            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddDummyLegoutputs, "Error in AddDummyLegOutputs");
            }
        }
        /// <summary>
        /// Create the graphical representation of a Elbow Lug.
        /// </summary>
        /// <param name="elbowLug">Structure for specifying the inputs for the elbowLug -ElbowLugInputs.</param>
        /// <param name="PipeOD">- Double -Outside diameter of the Pipe.</param>          
        /// <param name="outputs">The outputs</param>
        /// <param name="outputName">- string -The Name Of The Output</param> 
        /// <Code>
        /// AddElbowLug(elbowLug, pipeDiameter, matrix, m_PhysicalAspect.Outputs, "ElbowLugShape1");
        /// </Code>
        public void AddElbowLug(ElbowLugInputs elbowLugInputs, Double PipeOD, Matrix4X4 Matrix, OutputDictionary outputs, String outputName)
        {
            try
            {
                ElbowLugInputs elbowLug = elbowLugInputs;
                //string error = "";
                Double pipeDiameter = PipeOD;
                const int zeroAngle = 0;
                const int rightAngle = 90;
                const int straightAngle = 180;
                const int reflexAngle = 270;
                SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();
                Matrix4X4 matrix = new Matrix4X4();
                Line3d line;
                Collection<ICurve> collection = new Collection<ICurve>();

                //Check the Angles are correct' other wise Throw error
                if (HgrCompareDoubleService.cmpdbl(Math.Round((elbowLug.Angle1 * 180) / Math.PI, 5), 0) == false && elbowLug.TopShape == 1)    //For curved
                {
                    if (Math.Round((elbowLug.Angle1 * 180) / Math.PI, 5) < rightAngle || Math.Round((elbowLug.Angle1 * 180) / Math.PI, 5) > reflexAngle)
                    {
                        ToDoListMessage = new ToDoListMessage(ToDoMessageTypes.ToDoMessageWarning, SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrAngle1Range, "Angle 1 should be between 90 and 270 degrees. Resetting angle 1 to 180 degrees"));
                        elbowLug.Angle1 = (straightAngle * Math.PI) / 180;
                    }
                }
                else if (HgrCompareDoubleService.cmpdbl(elbowLug.Angle1, 0) == true && elbowLug.TopShape == 1)    //For curved Keep 180 degree as default
                {
                    elbowLug.Angle1 = (straightAngle * Math.PI) / straightAngle;
                }
                int acutAngle = 30;
                if (Math.Round((elbowLug.Angle2 * 180) / Math.PI, 5) < zeroAngle || Math.Round((elbowLug.Angle2 * 180) / Math.PI, 5) > acutAngle)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAngle2Range, "Angle 2 should be between 0 and 30 degrees");
                }
                if (Math.Round((elbowLug.Angle3 * 180) / Math.PI, 5) < zeroAngle || Math.Round((elbowLug.Angle3 * 180) / Math.PI, 5) > acutAngle)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAngle3Range, "Angle 3 should be between 0 and 30 degrees");
                }
                acutAngle = 45;
                if (Math.Round((elbowLug.Angle4 * 180) / Math.PI, 5) < zeroAngle || Math.Round((elbowLug.Angle4 * 180) / Math.PI, 5) > acutAngle)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAngle4Range, "Angle 4 should be between 0 and 45 degrees");
                }
                //Check Width1 and Width2 properties
                if ((HgrCompareDoubleService.cmpdbl(elbowLug.Width2, 0) == false) && (HgrCompareDoubleService.cmpdbl(elbowLug.Width1, 0) == true))//Check Width1 property 
                {
                    elbowLug.Width1 = elbowLug.Width2;
                }
                else if (HgrCompareDoubleService.cmpdbl(elbowLug.Width1, 0) == false)  //Check Width2 property
                {
                    if ((HgrCompareDoubleService.cmpdbl(elbowLug.Width2, 0) == true) && (HgrCompareDoubleService.cmpdbl(elbowLug.Angle3, 0) == true))
                        elbowLug.Width2 = elbowLug.Width1;
                }
                else if ((HgrCompareDoubleService.cmpdbl(elbowLug.Width2, 0) == true) && (HgrCompareDoubleService.cmpdbl(elbowLug.Width1, 0) == true) && (HgrCompareDoubleService.cmpdbl(elbowLug.Angle3, 0) == true))
                {
                    elbowLug.Width1 = pipeDiameter;
                    elbowLug.Width2 = pipeDiameter;
                }

                //Check the Actual Radius
                if (HgrCompareDoubleService.cmpdbl(elbowLug.ActualRadius, 0) == true)
                    elbowLug.ActualRadius = pipeDiameter / 2;

                //Check the Configuration
                Double horizontalLength1, horizontalLength2, outerRadius, verticalLength1, verticalLength2, angle1, angle2, X, Z, theta, leftNotchAngle, rightNotchAngle, bottomNotchAngle, topCurveAngle, topCurveStartAngle, topCurveEndAngle;
                horizontalLength1 = horizontalLength2 = outerRadius = verticalLength1 = verticalLength2 = angle1 = angle2 = X = Z = theta = leftNotchAngle = rightNotchAngle = bottomNotchAngle = topCurveAngle = topCurveStartAngle = topCurveEndAngle = 0.0;
                int componentsCount;
                Boolean isBottomChamfer;

                //New Code to get the Intersection Point
                Double topLeftLineX, topLeftLineY, topLeftLineZ, topRightLineX, topRightLineY, topRightLineZ, bottomLeftLineX, bottomLeftLineY, bottomLeftLineZ, bottomRightLineX, bottomRightLineY, bottomRightLineZ, bottomChamLineX, bottomChamLineY, bottomChamLineZ, tempX;//tempY
                topLeftLineX = topLeftLineY = topLeftLineZ = topRightLineX = topRightLineY = topRightLineZ = bottomLeftLineX = bottomLeftLineY = bottomLeftLineZ = bottomRightLineX = bottomRightLineY = bottomRightLineZ = bottomChamLineX = bottomChamLineY = bottomChamLineZ = tempX = 0.0;

                Surface3d surface;
                Collection<BusinessObject> iJElements = new Collection<BusinessObject>();
                GeometryIntersectionType intersection = new GeometryIntersectionType();
                IPoint point;

                //Get the Angles
                topCurveAngle = elbowLug.Angle1;
                leftNotchAngle = elbowLug.Angle2;
                rightNotchAngle = elbowLug.Angle3;
                bottomNotchAngle = elbowLug.Angle4;

                //Top Curve points
                if (elbowLug.TopShape == 1) //Curved
                {

                    if (HgrCompareDoubleService.cmpdbl(Math.Round((topCurveAngle * 180) / Math.PI, 5), straightAngle) == true) //Angle=180
                    {
                        theta = ((Math.PI) - topCurveAngle) / 2;
                        X = elbowLug.Offset1 * Math.Cos(theta);
                        Z = (elbowLug.Offset1 * Math.Sin(theta));
                        topCurveStartAngle = (Math.PI - topCurveAngle) * 180 / Math.PI;
                        topCurveEndAngle = (topCurveAngle * 180 / Math.PI);
                    }
                    else if (Math.Round((topCurveAngle * 180) / Math.PI) > straightAngle)
                    {
                        theta = -((Math.PI) - topCurveAngle) / 2;
                        X = elbowLug.Offset1 * Math.Cos(theta);
                        Z = (elbowLug.Offset1 * Math.Sin(theta));
                        topCurveStartAngle = ((topCurveAngle - (Math.PI)) / 2) * 180 / Math.PI;
                        topCurveEndAngle = ((Math.PI / 2) * 180 / Math.PI) + topCurveStartAngle;
                    }
                    else
                    {
                        theta = topCurveAngle / 2;
                        X = elbowLug.Offset1 * Math.Cos(theta);
                        Z = -(elbowLug.Offset1 * Math.Sin(theta));
                        topCurveStartAngle = (2 * (Math.PI) - topCurveAngle / 2) * 180 / Math.PI;
                        topCurveEndAngle = ((Math.PI) + topCurveAngle / 2) * 180 / Math.PI;
                    }

                    topLeftLineX = -X;
                    topLeftLineY = -elbowLug.Thickness1 / 2;
                    topLeftLineZ = elbowLug.FaceToCenter + elbowLug.RodTakeOut + Z;

                    topRightLineX = X;
                    topRightLineY = -elbowLug.Thickness1 / 2;
                    topRightLineZ = elbowLug.FaceToCenter + elbowLug.RodTakeOut + Z;
                }
                else
                {
                    topLeftLineX = -elbowLug.Width1 / 2;
                    topLeftLineY = -elbowLug.Thickness1 / 2;
                    topRightLineX = elbowLug.Width1 / 2;
                    topRightLineY = -elbowLug.Thickness1 / 2;
                    if (elbowLug.TopShape == 2)      //Squared
                    {
                        topLeftLineZ = elbowLug.FaceToCenter + elbowLug.RodTakeOut + elbowLug.Offset1;
                        topRightLineZ = elbowLug.FaceToCenter + elbowLug.RodTakeOut + elbowLug.Offset1;
                    }
                    else if (elbowLug.TopShape == 3) //Rounded
                    {
                        topLeftLineZ = elbowLug.FaceToCenter + elbowLug.RodTakeOut + elbowLug.Offset1 - elbowLug.Width1 / 4;
                        topRightLineZ = elbowLug.FaceToCenter + elbowLug.RodTakeOut + elbowLug.Offset1 - elbowLug.Width1 / 4;
                    }
                    else if (elbowLug.TopShape == 4)            //Chamfered
                    {
                        X = elbowLug.ChamfLength * Math.Cos((Math.PI) / 4);  //Chamfer angle is 45 degree
                        Z = elbowLug.ChamfLength * Math.Sin((Math.PI) / 4);
                        topLeftLineZ = elbowLug.FaceToCenter + elbowLug.RodTakeOut + elbowLug.Offset1 - Z;
                        topRightLineZ = elbowLug.FaceToCenter + elbowLug.RodTakeOut + elbowLug.Offset1 - Z;
                    }
                }

                //Left Side
                horizontalLength1 = elbowLug.ElbowRadius + elbowLug.Width1 / 2;
                outerRadius = elbowLug.ElbowRadius + elbowLug.ActualRadius;

                verticalLength1 = Math.Sqrt(Math.Abs(outerRadius * outerRadius - horizontalLength1 * horizontalLength1)) + elbowLug.FaceToCenter - elbowLug.ElbowRadius;
                isBottomChamfer = false; //Intialise

                //Check the Bottom Chamfered
                if (HgrCompareDoubleService.cmpdbl(bottomNotchAngle, 0) == false)
                    isBottomChamfer = true;

                Arc3d curve = new Arc3d(new Position(elbowLug.ElbowRadius, -elbowLug.Thickness1 / 2, elbowLug.FaceToCenter - elbowLug.ElbowRadius), new Vector(0, 1, 0), new Position(-elbowLug.ActualRadius, -elbowLug.Thickness1 / 2, elbowLug.FaceToCenter - elbowLug.ElbowRadius), new Position(elbowLug.ElbowRadius, -elbowLug.Thickness1 / 2, outerRadius + elbowLug.FaceToCenter - elbowLug.ElbowRadius));
                tempX = topLeftLineZ * Math.Tan(leftNotchAngle);
                line = new Line3d(new Position(topLeftLineX, topLeftLineY, topLeftLineZ), new Position(-elbowLug.Width1 / 2 - tempX, -elbowLug.Thickness1 / 2, 0));
                surface = new Projection3d(line, new Vector(0, 1, 0), 1, true);


                if (HgrCompareDoubleService.cmpdbl(leftNotchAngle, 0) == false)
                {
                    surface.Intersect(curve, out iJElements, out intersection);

                    if (iJElements == null)
                    {
                        //Get the Intersection points where the the Line from Elbow center intersect with an angle4
                        isBottomChamfer = true;
                        if (HgrCompareDoubleService.cmpdbl(bottomNotchAngle, 0) == true)
                            bottomNotchAngle = (45 * Math.PI) / 180;    //Set to 45 degree if the angle not given
                    }
                    else
                    {
                        point = (IPoint)iJElements.First();
                        Position chamferedIntersection = point.Position;
                        bottomLeftLineX = chamferedIntersection.X; bottomLeftLineY = chamferedIntersection.Y; bottomLeftLineZ = chamferedIntersection.Z;
                        horizontalLength1 = elbowLug.ElbowRadius - bottomLeftLineX;
                    }
                }
                else
                {
                    bottomLeftLineX = -elbowLug.Width1 / 2;
                    bottomLeftLineY = -elbowLug.Thickness1 / 2;
                    bottomLeftLineZ = verticalLength1;
                }
                //Check the Bottom tapered
                if (isBottomChamfer == true)
                {
                    line = new Line3d(new Position(elbowLug.ElbowRadius, -elbowLug.Thickness1 / 2, elbowLug.FaceToCenter - elbowLug.ElbowRadius), new Vector(-Math.Cos(bottomNotchAngle), 0, Math.Sin(bottomNotchAngle)), 5 * outerRadius);
                    surface.Intersect(line, out iJElements, out intersection);
                    if (iJElements.Count == 0)
                    {
                        isBottomChamfer = false;
                        bottomLeftLineX = -elbowLug.Width1 / 2;
                        bottomLeftLineY = -elbowLug.Thickness1 / 2;
                        bottomLeftLineZ = verticalLength1;
                    }
                    else
                    {
                        point = (IPoint)iJElements.First();
                        Position taperedIntersection = point.Position;
                        bottomLeftLineX = taperedIntersection.X; bottomLeftLineY = taperedIntersection.Y; bottomLeftLineZ = taperedIntersection.Z;

                        bottomChamLineX = -(outerRadius * Math.Cos(bottomNotchAngle) - elbowLug.ElbowRadius);
                        bottomChamLineY = -elbowLug.Thickness1 / 2;
                        bottomChamLineZ = outerRadius * Math.Sin(bottomNotchAngle) + elbowLug.FaceToCenter - elbowLug.ElbowRadius;
                        horizontalLength1 = elbowLug.ElbowRadius - bottomChamLineX;
                    }
                }

                //Get the Angle1
                angle1 = (Math.Acos(horizontalLength1 / outerRadius) * 180 / Math.PI);

                if (isBottomChamfer == true)      //For Bottom Taper add the Extra Taper Hor length
                    horizontalLength1 = horizontalLength1 - (bottomLeftLineX - bottomChamLineX);
                //Right Side
                if (HgrCompareDoubleService.cmpdbl(rightNotchAngle, 0) == false)           //Override width2 Property if the Right Notch angle is given
                {
                    tempX = topRightLineZ * Math.Tan(rightNotchAngle);    //5 degree
                    line = new Line3d(new Position(topRightLineX, topRightLineY, topRightLineZ), new Position(elbowLug.Width1 / 2 + tempX, -elbowLug.Thickness1 / 2, 0));
                    surface = new Projection3d(line, new Vector(0, 1, 0), 1, true);
                    surface.Intersect(curve, out iJElements, out intersection);

                    if (iJElements.Count == 0)
                    {
                        RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidAngle3, "Angle3 value is not given Properly");
                    }
                    else
                    {
                        point = (IPoint)iJElements.First();
                        Position intersectionPoint = point.Position;
                        bottomRightLineX = intersectionPoint.X; bottomRightLineY = intersectionPoint.Y; bottomRightLineZ = intersectionPoint.Z;
                    }
                    elbowLug.Width2 = horizontalLength1 - elbowLug.ElbowRadius + bottomRightLineX;
                    horizontalLength2 = horizontalLength1 - elbowLug.Width2;
                }
                else
                {
                    horizontalLength2 = horizontalLength1 - elbowLug.Width2;
                    verticalLength2 = Math.Sqrt(Math.Abs(outerRadius * outerRadius - horizontalLength2 * horizontalLength2));

                    bottomRightLineX = bottomLeftLineX + elbowLug.Width2;
                    bottomRightLineY = -elbowLug.Thickness1 / 2;
                    bottomRightLineZ = verticalLength2 + elbowLug.FaceToCenter - elbowLug.ElbowRadius;
                }
                //Get the Angle2
                angle2 = (Math.Acos(horizontalLength2 / outerRadius) * 180 / Math.PI);

                //Get the Composite count
                if (elbowLug.TopShape == 3 || elbowLug.TopShape == 4)   //Rounded or Chamfered
                    componentsCount = 6;
                else
                    componentsCount = 4;


                if (isBottomChamfer == true)
                    componentsCount = componentsCount + 1;
                //Draw the Graphics
                if (elbowLug.TopShape == 1)        //Rounded
                {
                    symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    matrix.SetIdentity();
                    matrix.Rotate(topCurveStartAngle * Math.PI / 180, new Vector(0, 0, 1));
                    Arc3d topArc = symbolGeometryHelper.CreateArc(null, elbowLug.Offset1, (topCurveEndAngle - topCurveStartAngle) * Math.PI / 180);
                    topArc.Transform(matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Rotate((Math.PI / 2), new Vector(1, 0, 0));
                    topArc.Transform(matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Translate(new Vector(0, -elbowLug.Thickness1 / 2, elbowLug.FaceToCenter + elbowLug.RodTakeOut));
                    topArc.Transform(matrix);
                    collection.Add(topArc);
                }
                else if (elbowLug.TopShape == 2)    //Squared
                    collection.Add(new Line3d(new Position(topLeftLineX, topLeftLineY, topLeftLineZ), new Position(topRightLineX, topRightLineY, topRightLineZ)));
                else if (elbowLug.TopShape == 3)    //Rounded
                {
                    collection.Add(new Line3d(new Position(-elbowLug.Width1 / 4, -elbowLug.Thickness1 / 2, elbowLug.FaceToCenter + elbowLug.RodTakeOut + elbowLug.Offset1), new Position(elbowLug.Width1 / 4, -elbowLug.Thickness1 / 2, elbowLug.FaceToCenter + elbowLug.RodTakeOut + elbowLug.Offset1)));
                    //LeftArc
                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    matrix.SetIdentity();
                    matrix.Rotate(Math.PI / 2, new Vector(0, 0, 1));
                    Arc3d leftArc = symbolGeometryHelper.CreateArc(null, elbowLug.Width1 / 4, Math.PI / 2);
                    leftArc.Transform(matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Rotate((Math.PI / 2), new Vector(1, 0, 0));
                    leftArc.Transform(matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Translate(new Vector(-elbowLug.Width1 / 4, -elbowLug.Thickness1 / 2, elbowLug.FaceToCenter + elbowLug.RodTakeOut + elbowLug.Offset1 - elbowLug.Width1 / 4));
                    leftArc.Transform(matrix);
                    collection.Add(leftArc);
                    //RightArc
                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    Arc3d rightArc = symbolGeometryHelper.CreateArc(null, elbowLug.Width1 / 4, Math.PI / 2);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Rotate((Math.PI / 2), new Vector(1, 0, 0));
                    rightArc.Transform(matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Translate(new Vector(elbowLug.Width1 / 4, -elbowLug.Thickness1 / 2, elbowLug.FaceToCenter + elbowLug.RodTakeOut + elbowLug.Offset1 - elbowLug.Width1 / 4));
                    rightArc.Transform(matrix);
                    collection.Add(rightArc);

                }
                else if (elbowLug.TopShape == 4)    //Chamfered
                {
                    //TopLine                    
                    collection.Add(new Line3d(new Position(-elbowLug.Width1 / 2 + X, -elbowLug.Thickness1 / 2, elbowLug.FaceToCenter + elbowLug.RodTakeOut + elbowLug.Offset1), new Position(elbowLug.Width1 / 2 - X, -elbowLug.Thickness1 / 2, elbowLug.FaceToCenter + elbowLug.RodTakeOut + elbowLug.Offset1)));

                    //LeftTaper                    
                    collection.Add(new Line3d(new Position(-elbowLug.Width1 / 2 + X, -elbowLug.Thickness1 / 2, elbowLug.FaceToCenter + elbowLug.RodTakeOut + elbowLug.Offset1), new Position(-elbowLug.Width1 / 2, -elbowLug.Thickness1 / 2, elbowLug.FaceToCenter + elbowLug.RodTakeOut + elbowLug.Offset1 - Z)));
                    //RightTaper                    
                    collection.Add(new Line3d(new Position(elbowLug.Width1 / 2 - X, -elbowLug.Thickness1 / 2, elbowLug.FaceToCenter + elbowLug.RodTakeOut + elbowLug.Offset1), new Position(elbowLug.Width1 / 2, -elbowLug.Thickness1 / 2, elbowLug.FaceToCenter + elbowLug.RodTakeOut + elbowLug.Offset1 - Z)));
                }

                //LeftLine                
                collection.Add(new Line3d(new Position(topLeftLineX, topLeftLineY, topLeftLineZ), new Position(bottomLeftLineX, bottomLeftLineY, bottomLeftLineZ)));

                //RightLine                
                collection.Add(new Line3d(new Position(topRightLineX, topRightLineY, topRightLineZ), new Position(bottomRightLineX, bottomRightLineY, bottomRightLineZ)));

                //BottomArc
                symbolGeometryHelper = new SymbolGeometryHelper();
                symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                matrix = new Matrix4X4();
                matrix.SetIdentity();
                matrix.Rotate(angle1 * Math.PI / 180, new Vector(0, 0, 1));
                Arc3d bottomArc = symbolGeometryHelper.CreateArc(null, outerRadius, (angle2 - angle1) * Math.PI / 180);
                bottomArc.Transform(matrix);

                matrix = new Matrix4X4();
                matrix.SetIdentity();
                matrix.Rotate((3 * Math.PI) / 2, new Vector(0, 1, 0));
                bottomArc.Transform(matrix);

                matrix = new Matrix4X4();
                matrix.SetIdentity();
                matrix.Rotate((3 * Math.PI) / 2, new Vector(0, 0, 1));
                bottomArc.Transform(matrix);

                matrix = new Matrix4X4();
                matrix.SetIdentity();
                matrix.Translate(new Vector((elbowLug.FaceToCenter - elbowLug.ElbowRadius), -elbowLug.Thickness1 / 2, -elbowLug.ElbowRadius));
                bottomArc.Transform(matrix);

                matrix = new Matrix4X4();
                matrix.SetIdentity();
                matrix.Rotate((3 * Math.PI) / 2, new Vector(0, 1, 0));
                bottomArc.Transform(matrix);
                collection.Add(bottomArc);

                if (isBottomChamfer == true)
                    //BottomChamfer                    
                    collection.Add(new Line3d(new Position(bottomLeftLineX, bottomLeftLineY, bottomLeftLineZ), new Position(bottomChamLineX, bottomChamLineY, bottomChamLineZ)));

                Projection3d elbowLugShape = new Projection3d(new ComplexString3d(collection), new Vector(0, 1, 0), elbowLug.Thickness1, true);
                elbowLugShape.Transform(Matrix);
                outputs.Add(outputName, elbowLugShape);

            }
            catch (SmartPartSymbolException hgrEx)
            {
                throw hgrEx;
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddElbowLug, "Error in AddElbowLug");
                }
            }
        }
        /// <summary>
        ///Create the graphical representation of a Pin.  Specify the inputs.
        /// </summary>
        ///<param name="pin">Structure for specifying the inputs for the Pin -tPinInputs </param>
        ///<param name="matrix">string to specify the position and oreintation the graphics - String.</param>
        /// <param name="outputcoll">Collection of declared outputs, which is indexed by the name of the outputs declared as defining SymbolOutputs on the AspectDefinition field- OutputDictionary</param>
        /// <param name="output">Output that this graphic is being placed on-String</param>
        ///<code>
        ///AddPin(pinInputs, new Matrix4X4(), m_PhysicalAspect.Outputs, "Pin");
        ///</code>
        public void AddPin(PinInputs pin, Matrix4X4 matrix, OutputDictionary outputcoll, string output)
        {
            try
            {
                SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();
                symbolGeometryHelper.ActivePosition = new Position(0, -pin.PinLength / 2, 0);
                symbolGeometryHelper.SetOrientation(new Vector(0, 1, 0), new Vector(0, 0, 1));
                Projection3d pinProjection = symbolGeometryHelper.CreateCylinder(null, pin.PinDiameter / 2, pin.PinLength);
                pinProjection.Transform(matrix);
                outputcoll.Add(output + "Pin", pinProjection);
                if ((HgrCompareDoubleService.cmpdbl(pin.CotterDiameter, 0) == false) || (HgrCompareDoubleService.cmpdbl(pin.CotterLength, 0) == false) || (HgrCompareDoubleService.cmpdbl(pin.CotterOffset, 0) == false))
                {
                    symbolGeometryHelper.ActivePosition = new Position(0, pin.PinLength / 2 - pin.CotterOffset, -pin.CotterLength / 2);
                    symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(1, 0, 0));
                    Projection3d cotterPin1 = symbolGeometryHelper.CreateCylinder(null, pin.CotterDiameter / 2, pin.CotterLength);
                    cotterPin1.Transform(matrix);
                    outputcoll.Add(output + "CotterPin1", cotterPin1);
                    symbolGeometryHelper.ActivePosition = new Position(0, -(pin.PinLength / 2 - pin.CotterOffset), -pin.CotterLength / 2);
                    Projection3d cotterPin2 = symbolGeometryHelper.CreateCylinder(null, pin.CotterDiameter / 2, pin.CotterLength);
                    cotterPin2.Transform(matrix);
                    outputcoll.Add(output + "CotterPin2", cotterPin2);
                }
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddPinMethod, "Error in AddPin");
                }

            }
        }
        /// <summary>
        /// Create the graphical representation of a turnbuckle.
        /// </summary>
        /// <param name="turnbuckle">Structure for specifying the inputs for the Turnbuckle -TurnbuckleProperties.</param>
        /// <param name="rodTakeOut">Specifies the distance between the structure port and the RodEnd port-Double.</param>
        /// <param name="matrix">Matrix to specify the position and oreintation the graphics - Matrix4X4.</param>
        /// <param name="outputs">Collection of declared outputs, which is indexed by the name of the outputs declared as defining SymbolOutputs on the AspectDefinition field- OutputDictionary.</param>
        /// <param name="outputName">OutputName that this graphic is being placed on-String.</param>
        ///<code>
        ///Matrix4X4 matrix = new Matrix4X4();
        ///matrix.Origin = new Position(0,0,0);
        ///AddTurnbuckle(turnbuckle, rodTakeOut,matrix, m_PhysicalAspect.Outputs, "Turnbuckle");
        ///</code>
        public void AddTurnbuckle(TurnbuckleInputs turnbuckle, Double rodTakeOut, Matrix4X4 matrix, OutputDictionary outputs, String outputName)
        {
            try
            {
                String[] objectColl = new String[10];
                int objectCount = 0;
                Boolean noCenterTube = true;
                Boolean noSideBlock = true;
                SymbolGeometryHelper symbolGeomHlpr = new SymbolGeometryHelper();

                //Center Tube
                symbolGeomHlpr.ActivePosition = new Position(0, 0, -rodTakeOut - (turnbuckle.Opening1 - rodTakeOut) / 2);
                symbolGeomHlpr.SetOrientation(new Vector(0, 0, 1), new Vector(1, 0, 0));
                if (turnbuckle.Diameter1 > 0 && turnbuckle.Opening1 > 0)
                {
                    BusinessObject centerTube = symbolGeomHlpr.CreateCylinder(null, turnbuckle.Diameter1 / 2, turnbuckle.Opening1);
                    outputs.Add(outputName + "CenterTube", centerTube);
                    ++objectCount;
                    objectColl[objectCount] = outputName + "CenterTube";
                    noCenterTube = false;
                }
                //Nuts-Nut1     
                Matrix4X4 nutMatrix = new Matrix4X4();
                nutMatrix.Origin = new Position(0, 0, (turnbuckle.Opening1 - rodTakeOut) / 2);
                //nutMatrix.SetOrientation(new Vector(0, 0, 1), new Vector(1, 0, 0));
                AddNut(turnbuckle.Nut, nutMatrix, outputs, outputName + "Nut1");
                ++objectCount;
                objectColl[objectCount] = outputName + "Nut1";
                //Nut2
                nutMatrix.Origin = new Position(0, 0, -rodTakeOut - (turnbuckle.Opening1 - rodTakeOut) / 2 - turnbuckle.Nut.ShapeLength);
                //nutMatrix.SetOrientation(new Vector(0, 0, 1), new Vector(1, 0, 0));
                AddNut(turnbuckle.Nut, nutMatrix, outputs, outputName + "Nut2");
                ++objectCount;
                objectColl[objectCount] = outputName + "Nut2";

                //Side Blocks
                if (turnbuckle.Length2 > 0 && turnbuckle.Width2 > 0 && turnbuckle.Thickness2 > 0)
                {
                    //SideBlock1
                    symbolGeomHlpr.ActivePosition = new Position(-turnbuckle.Opening2 / 2 - turnbuckle.Thickness2 / 2, 0, -rodTakeOut / 2 - turnbuckle.Length2 / 2);
                    symbolGeomHlpr.SetOrientation(new Vector(0, 0, 1), new Vector(1, 0, 0));
                    BusinessObject sideBlock1 = symbolGeomHlpr.CreateBox(null, turnbuckle.Length2, turnbuckle.Thickness2, turnbuckle.Width2);
                    outputs.Add(outputName + "SideBlock1", sideBlock1);
                    ++objectCount;
                    objectColl[objectCount] = outputName + "SideBlock1";
                    //SideBlock2
                    symbolGeomHlpr.ActivePosition = new Position(turnbuckle.Opening2 / 2 + turnbuckle.Thickness2 / 2, 0, -rodTakeOut / 2 - turnbuckle.Length2 / 2);
                    symbolGeomHlpr.SetOrientation(new Vector(0, 0, 1), new Vector(1, 0, 0));
                    BusinessObject sideBlock2 = symbolGeomHlpr.CreateBox(null, turnbuckle.Length2, turnbuckle.Thickness2, turnbuckle.Width2);
                    outputs.Add(outputName + "SideBlock2", sideBlock2);
                    ++objectCount;
                    objectColl[objectCount] = outputName + "SideBlock2";
                    noSideBlock = false;
                }
                //If no side blocks or center tube has been drawn then output warning.
                if (noCenterTube && noSideBlock)
                    ToDoListMessage = new ToDoListMessage(ToDoMessageTypes.ToDoMessageWarning, SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrNoCenterTubeOrSideBlocks, "Turnbuckle has no Center Tube or Side Blocks"));
                //Try to rotate and translate the Graphic to a new location wrt local origin
                Geometry3d obj;
                for (int i = 1; i <= objectCount; i++)
                {
                    obj = (Geometry3d)outputs[objectColl[i]];
                    obj.Transform(matrix);
                }

            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddAddTurnbuckle, "Error in AddTurnbuckle");
                }

            }
        }
        /// <summary>
        /// Create the graphical representation of a nut based on Codelist hsShapeType.1 – Round,2 - Square, 3 - Hex.
        /// </summary>        
        /// <param name="nut">Structure for specifying the inputs for the Nut -NutInputs.</param>
        /// <param name="matrix">Matrix to specify the position and oreintation the graphics - Matrix4X4.</param>
        /// <param name="outputs">Collection of declared outputs, which is indexed by the name of the outputs declared as defining SymbolOutputs on the AspectDefinition field- OutputDictionary.</param>
        /// <param name="outputName">OutputName that this graphic is being placed on-String.</param>
        ///<code>
        /// Matrix4X4 nutMatrix = new Matrix4X4();
        /// nutMatrix.Origin = new Position(0, 0, (myTurnbuckle.Opening1 - rodTakeOut) / 2);
        /// nutMatrix.SetOrientation(new Vector(0, 0, 1), new Vector(1, 0, 0));            
        /// AddNut(myTurnbuckle.Nut, nutMatrix, Outputs, "TurnBuckleNut1");
        ///</code>
        public void AddNut(NutInputs nut, Matrix4X4 matrix, OutputDictionary outputs, String outputName)
        {
            try
            {
                SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();
                symbolGeometryHelper.SetActiveMatrix(matrix);


                if (nut.ShapeWidth1 > 0 && nut.ShapeLength != 0)
                {
                    switch (nut.ShapeType)
                    {
                        case 1: //Round Nut
                            if (nut.ShapeWidth2 <= 0 || nut.ShapeWidth2.Equals(nut.ShapeWidth1))
                            {
                                symbolGeometryHelper = new SymbolGeometryHelper();
                                symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                                symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(0, 1, 0));
                                Projection3d roundNut = symbolGeometryHelper.CreateCylinder(null, nut.ShapeWidth1 / 2, nut.ShapeLength);
                                roundNut.Transform(matrix);
                                outputs.Add(outputName, roundNut);
                            }
                            else//Elliptical Nut
                            {
                                symbolGeometryHelper = new SymbolGeometryHelper();
                                symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                                symbolGeometryHelper.SetOrientation(new Vector(0, 1, 0), new Vector(1, 0, 0));
                                Ellipse3d curve = (Ellipse3d)symbolGeometryHelper.CreateEllipse(null, nut.ShapeWidth2 / 2, nut.ShapeWidth1 / 2, 2 * Math.PI);
                                Projection3d ellipticalNut = new Projection3d(curve, new Vector(0, 0, 1), nut.ShapeLength, true);
                                ellipticalNut.Transform(matrix);
                                outputs.Add(outputName, ellipticalNut);
                            }
                            break;
                        case 2://Rectangular Nut
                            if (nut.ShapeWidth2 <= 0)
                                nut.ShapeWidth2 = nut.ShapeWidth1;
                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                            symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(0, 1, 0));
                            Projection3d squareNut = (Projection3d)symbolGeometryHelper.CreateBox(null, nut.ShapeLength, nut.ShapeWidth2, nut.ShapeWidth1);
                            squareNut.Transform(matrix);
                            outputs.Add(outputName, squareNut);
                            break;
                        case 3://Hex Nut
                            double x, y;
                            y = Math.Sin(60 * Math.PI / 180) * nut.ShapeWidth1 / 2;
                            x = Math.Cos(60 * Math.PI / 180) * nut.ShapeWidth1 / 2;
                            List<Position> points = new List<Position>();
                            points.Add(new Position(-nut.ShapeWidth1 / 2, 0, 0));
                            points.Add((new Position(-x, y, 0)));
                            points.Add((new Position(x, y, 0)));
                            points.Add((new Position(nut.ShapeWidth1 / 2, 0, 0)));
                            points.Add((new Position(x, -y, 0)));
                            points.Add((new Position(-x, -y, 0)));
                            points.Add((new Position(-nut.ShapeWidth1 / 2, 0, 0)));
                            symbolGeometryHelper = new SymbolGeometryHelper();
                            LineString3d linestring = symbolGeometryHelper.CreateLineString(null, points, true);
                            Projection3d extrusion = new Projection3d(linestring, new Vector(0, 0, 1), nut.ShapeLength, true);
                            extrusion.Transform(matrix);
                            outputs.Add(outputName, extrusion);
                            break;
                    }

                }
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddNutMethod, "Error in AddNut");
                }
            }
        }
        /// <summary>
        /// Adds the WBABolt.
        /// </summary>
        /// <param name="connection">The connection.</param>
        /// <param name="myPlateShape">My WBABolt.</param>
        /// <param name="matrix">The matrix.</param>
        /// <param name="outputs">The outputs.</param>
        /// <param name="outputName">Name of the output.</param>
        /// <code>AddWBABolt(wbaBolt, matrix, m_PhysicalAspect.Outputs, "WBABolt");</code>
        public void AddWBABolt(WBABoltInputs wbaBolt, Matrix4X4 matrix, OutputDictionary outputs, String outputName)
        {
            try
            {

                SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();
                String[] objectCollection = new String[15];
                int objectCount = 0;

                //Initialisations 
                StringBuilder error = new StringBuilder();

                if (HgrCompareDoubleService.cmpdbl(wbaBolt.Offset1, 0) == true)
                    wbaBolt.Offset1 = wbaBolt.Width1 / 2;

                if (HgrCompareDoubleService.cmpdbl(wbaBolt.Width2, 0) == true)
                    wbaBolt.Width2 = wbaBolt.Width1;

                if (HgrCompareDoubleService.cmpdbl(wbaBolt.Length2, 0) == true)
                    wbaBolt.Length2 = wbaBolt.Gap1 + (2 * wbaBolt.Thickness1);

                if (HgrCompareDoubleService.cmpdbl(wbaBolt.Thickness2, 0) == true)
                    wbaBolt.Thickness2 = wbaBolt.Thickness1;

                if (wbaBolt.Thickness3 < 0)
                    wbaBolt.Thickness3 = 0;

                if (HgrCompareDoubleService.cmpdbl(wbaBolt.Offset3, 0) == true)
                    wbaBolt.Offset3 = wbaBolt.Width3 / 2;

                if (HgrCompareDoubleService.cmpdbl(wbaBolt.Offset2, 0) == true)
                    wbaBolt.Offset2 = -wbaBolt.Offset1 - ((wbaBolt.Width2 - wbaBolt.Width1) / 2);
                //Make graphics
                //base
                if (HgrCompareDoubleService.cmpdbl(wbaBolt.Gap2, 0) == true)
                {
                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(0, 0, -wbaBolt.Thickness3);
                    symbolGeometryHelper.SetOrientation(new Vector(0, 0, -1), new Vector(1, 0, 0));
                    Projection3d topBox = (Projection3d)symbolGeometryHelper.CreateBox(null, wbaBolt.Thickness2, wbaBolt.Width2, wbaBolt.Length2);
                    outputs.Add(outputName + "TOP", topBox);
                    ++objectCount;
                    objectCollection[objectCount] = outputName + "TOP";
                }
                else
                {
                    symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                    symbolGeometryHelper.SetOrientation(new Vector(0, 0, -1), new Vector(1, 0, 0));
                    Projection3d topBox = (Projection3d)symbolGeometryHelper.CreateBox(null, wbaBolt.Thickness2, wbaBolt.Width2, wbaBolt.Length2);
                    outputs.Add(outputName + "TOP", topBox);
                    ++objectCount;
                    objectCollection[objectCount] = outputName + "TOP";

                    symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                    symbolGeometryHelper.SetOrientation(new Vector(0, 0, -1), new Vector(1, 0, 0));
                    Projection3d topBox1 = (Projection3d)symbolGeometryHelper.CreateBox(null, wbaBolt.Thickness2, wbaBolt.Width2, wbaBolt.Length2);
                    outputs.Add(outputName + "TOP2", topBox1);
                    ++objectCount;
                    objectCollection[objectCount] = outputName + "TOP2";
                }
                //Concrete Attachment

                if (wbaBolt.Width3 > 0 && wbaBolt.Length3 > 0 && wbaBolt.Thickness3 > 0)
                {
                    symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                    symbolGeometryHelper.SetOrientation(new Vector(0, 0, -1), new Vector(1, 0, 0));
                    Projection3d topBox2 = (Projection3d)symbolGeometryHelper.CreateBox(null, wbaBolt.Thickness3, wbaBolt.Width3, wbaBolt.Length3);
                    outputs.Add(outputName + "TOP2", topBox2);
                    ++objectCount;
                    objectCollection[objectCount] = outputName + "TOP2";
                }

                //Sides
                PlateInputs plate = new PlateInputs();
                plate.width1 = wbaBolt.Width1;
                plate.length1 = wbaBolt.Height1 - wbaBolt.Thickness2;
                plate.thickness1 = wbaBolt.Thickness1;
                plate.tlCornerType = wbaBolt.TLCornerType;
                plate.tlCornerX = wbaBolt.TLCornerX;
                plate.tlCornerY = wbaBolt.TLCornerY;
                plate.tlCornerRad = wbaBolt.TLCornerRadius;
                plate.trCornerType = wbaBolt.TRCornerType;
                plate.trCornerX = wbaBolt.TRCornerX;
                plate.trCornerY = wbaBolt.TRCornerY;
                plate.trCornerRad = wbaBolt.TRCornerRadius;

                Matrix4X4 platematrix = new Matrix4X4();
                platematrix.SetIdentity();
                platematrix.Rotate(3 * (Math.PI / 2), new Vector(1, 0, 0));

                platematrix.Translate(new Vector(-wbaBolt.Width1 / 2, wbaBolt.Gap1 / 2, -wbaBolt.Thickness2 - wbaBolt.Thickness3));
                AddPlate(plate, platematrix, outputs, outputName + "SIDE1");
                ++objectCount;
                objectCollection[objectCount] = outputName + "SIDE1";

                platematrix = new Matrix4X4();
                platematrix.SetIdentity();
                platematrix.Rotate(3 * (Math.PI / 2), new Vector(1, 0, 0));

                platematrix.Translate(new Vector(-wbaBolt.Width1 / 2, -wbaBolt.Gap1 / 2 - wbaBolt.Thickness1, -wbaBolt.Thickness2 - wbaBolt.Thickness3));
                AddPlate(plate, platematrix, outputs, outputName + "SIDE2");
                ++objectCount;
                objectCollection[objectCount] = outputName + "SIDE2";

                //pin
                if (wbaBolt.Pin1Diameter > 0 && wbaBolt.Pin1Length > 0)
                {
                    Vector normal = new Position(0, wbaBolt.Pin1Length / 2, -wbaBolt.Height2 - wbaBolt.Thickness3).Subtract(new Position(0, -wbaBolt.Pin1Length / 2, -wbaBolt.Height2 - wbaBolt.Thickness3));
                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(0, -wbaBolt.Pin1Length / 2, -wbaBolt.Height2 - wbaBolt.Thickness3);
                    symbolGeometryHelper.SetOrientation(normal, new Vector(1, 0, 0));
                    Projection3d pin = symbolGeometryHelper.CreateCylinder(null, wbaBolt.Pin1Diameter / 2, normal.Length);
                    outputs.Add(outputName + "PIN", pin);
                    ++objectCount;
                    objectCollection[objectCount] = outputName + "PIN";

                }
                //Try to rotate and translate the Graphic to a new location wrt local origin             
                for (int i = 1; i <= objectCount; i++)
                {
                    Geometry3d geom3dObj = (Geometry3d)outputs[objectCollection[i]];
                    geom3dObj.Transform(matrix);
                }
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddAddWBABolt, "Error in AddWBABolt");
                }
            }
        }

        /// <summary>
        /// Adds the WBAHole.
        /// </summary>
        /// <param name="wbaHole">Structure for specifying the inputs for the WBAHole -WBAHoleInputs.</param>
        /// <param name="matrix">Matrix to specify the position and oreintation the graphics - Matrix4X4.</param>
        /// <param name="outputs">Collection of declared outputs, which is indexed by the name of the outputs declared as defining SymbolOutputs on the AspectDefinition field- OutputDictionary.</param>
        /// <param name="outputName">OutputName that this graphic is being placed on-String.</param>
        ///<code>
        /// matrix = new Matrix4X4();
        /// matrix.Origin = new Position(0, 0, -vertOffset2);
        /// AddWBAHole(wbaHole, matrix, m_PhysicalAspect.Outputs, "BeamClampBottom");
        ///</code>
        public void AddWBAHole(WBAHoleInputs wbaHole, Matrix4X4 matrix, OutputDictionary outputs, String outputName)
        {
            try
            {

                SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();
                //Initialisations
                StringBuilder error = new StringBuilder();
                Matrix4X4 boxMatrix = new Matrix4X4();

                if (wbaHole.Gap1 <= Math3d.DistanceTolerance)
                {
                    wbaHole.Offset1 = wbaHole.Thickness5 / 2;
                    if (wbaHole.Width4 <= Math3d.DistanceTolerance)
                        wbaHole.Width4 = wbaHole.Length3;
                }

                if ((wbaHole.WBAHoleConfig == 1) && (wbaHole.Gap1 - Math3d.DistanceTolerance <= 0))
                    wbaHole.Gap1 = wbaHole.Width1;

                if ((wbaHole.WBAHoleConfig == 1) && (wbaHole.Gap1 - Math3d.DistanceTolerance <= 0))
                    wbaHole.Gap1 = wbaHole.Width1;

                if (wbaHole.Offset1 < -Math3d.DistanceTolerance)
                    error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidOffset1NLTZero, "Enter positive value for Offset1"));

                if (wbaHole.Gap1 < -Math3d.DistanceTolerance)
                    error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidGap1ValueNLTZero, "Enter positive value for Gap1"));

                if (wbaHole.Thickness1 < -Math3d.DistanceTolerance)
                    error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidThickness1NLTZero, "Enter positive value for Thickness1"));

                if (wbaHole.Height1 < -Math3d.DistanceTolerance)
                    error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidHeight1NLTZero, "Enter positive value for Height1"));

                if (wbaHole.Width1 < -Math3d.DistanceTolerance)
                    error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidWidth1NLTZero, "Enter positive value for Width1"));

                if (wbaHole.Offset2 < -Math3d.DistanceTolerance)
                    error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidOffset2NLTZero, "Enter positive value for Offset2"));

                if (wbaHole.Offset2 - Math3d.DistanceTolerance <= 0)
                    wbaHole.Offset2 = wbaHole.Width1 / 2;

                if ((wbaHole.Length1 < wbaHole.Gap1) && (wbaHole.Length1 - Math3d.DistanceTolerance <= 0))
                    wbaHole.Length1 = wbaHole.Gap1;

                if ((wbaHole.Width2 < wbaHole.Width1) && (wbaHole.Width2 - Math3d.DistanceTolerance <= 0))
                    wbaHole.Width2 = wbaHole.Width1;

                if ((wbaHole.Thickness2 < -Math3d.DistanceTolerance))
                    error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidThickness2NLTZero, "Enter positive value for Thickness2"));

                if (wbaHole.Thickness2 - Math3d.DistanceTolerance <= 0)
                    wbaHole.Thickness2 = wbaHole.Thickness1;

                if (wbaHole.Width3 - Math3d.DistanceTolerance <= 0)
                    wbaHole.Width3 = wbaHole.Width1;

                if (wbaHole.Thickness3 < -Math3d.DistanceTolerance)
                    error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidThickness3NLTZero, "Enter positive value for Thickness3"));

                if (wbaHole.Thickness3 - Math3d.DistanceTolerance <= 0)
                    wbaHole.Thickness3 = wbaHole.Thickness1;

                if (wbaHole.Offset3 - Math3d.DistanceTolerance <= 0)
                    wbaHole.Offset3 = wbaHole.Width4 / 2;

                //Strap Shape for Continuous
                if (wbaHole.WBAHoleConfig == 1)
                {
                    StrapInputs myStrapShape;
                    myStrapShape.StrapWidthInside = wbaHole.Gap1;
                    myStrapShape.StrapThickness = wbaHole.Thickness1;
                    myStrapShape.StrapHeightInside = wbaHole.Height1 - wbaHole.Thickness1;
                    myStrapShape.StrapStockWidth = wbaHole.Width1;
                    myStrapShape.StrapFlatSpot = 0.9 * wbaHole.Gap1;       //90%of dgap1
                    myStrapShape.StrapTopGap = 0;
                    myStrapShape.StrapWidthWings = wbaHole.Length2;
                    myStrapShape.StrapOneSided = 2;
                    myStrapShape.StrapSplitGap = 0;
                    myStrapShape.StrapSplitExtension = 0;

                    //AddStrap
                    Matrix4X4 strapMatrix = new Matrix4X4();
                    strapMatrix.SetIdentity();
                    strapMatrix.Rotate(Math.PI, new Vector(1, 0, 0));

                    strapMatrix.Translate(strapMatrix.Transform(new Vector(0, 0, myStrapShape.StrapHeightInside - wbaHole.Gap1 / 2)));
                    AddStrap(myStrapShape, wbaHole.Gap1, strapMatrix, outputs, outputName + "STRAP");
                    Projection3d strapOutput = (Projection3d)outputs[outputName + "STRAP"];
                    strapOutput.Transform(matrix);
                }
                if (wbaHole.Gap1 != Math3d.DistanceTolerance)     //Plates
                {
                    if (wbaHole.WBAHoleConfig == 2)
                    {
                        //Base
                        symbolGeometryHelper = new SymbolGeometryHelper();
                        symbolGeometryHelper.ActivePosition = new Position(-(wbaHole.Length1 / 2), -wbaHole.Width2 / 2, -wbaHole.Height1);
                        boxMatrix = new Matrix4X4();
                        boxMatrix.Rotate(3 * (Math.PI / 2), new Vector(0, 0, 1));
                        Projection3d baseBox = symbolGeometryHelper.CreateBox(null, wbaHole.Length1, wbaHole.Width2, wbaHole.Thickness2, 9);
                        baseBox.Transform(boxMatrix);
                        baseBox.Transform(matrix);
                        outputs.Add(outputName + "BOTTOM", baseBox);

                        //Sides
                        if (wbaHole.Thickness1 != Math3d.DistanceTolerance)
                        {
                            if (wbaHole.Length1 <= wbaHole.Gap1)
                            {
                                //SIDE1
                                symbolGeometryHelper = new SymbolGeometryHelper();
                                symbolGeometryHelper.ActivePosition = new Position(-(wbaHole.Gap1 / 2 + wbaHole.Thickness1), -wbaHole.Offset2, -wbaHole.Height1);
                                boxMatrix = new Matrix4X4();
                                boxMatrix.Rotate(3 * (Math.PI / 2), new Vector(0, 0, 1));
                                Projection3d side1Box = symbolGeometryHelper.CreateBox(null, wbaHole.Thickness1, wbaHole.Width1, wbaHole.Height1 - wbaHole.Thickness3 - wbaHole.Thickness4, 9);
                                side1Box.Transform(boxMatrix);
                                side1Box.Transform(matrix);
                                outputs.Add(outputName + "SIDE1", side1Box);

                                //SIDE2
                                symbolGeometryHelper = new SymbolGeometryHelper();
                                symbolGeometryHelper.ActivePosition = new Position(wbaHole.Gap1 / 2, -wbaHole.Offset2, -wbaHole.Height1);
                                boxMatrix = new Matrix4X4();
                                boxMatrix.Rotate(3 * (Math.PI / 2), new Vector(0, 0, 1));
                                Projection3d side2Box = symbolGeometryHelper.CreateBox(null, wbaHole.Thickness1, wbaHole.Width1, wbaHole.Height1 - wbaHole.Thickness3 - wbaHole.Thickness4, 9);
                                side2Box.Transform(boxMatrix);
                                side2Box.Transform(matrix);
                                outputs.Add(outputName + "SIDE2", side2Box);
                            }
                            else
                            {
                                //SIDE1
                                symbolGeometryHelper = new SymbolGeometryHelper();
                                symbolGeometryHelper.ActivePosition = new Position(-(wbaHole.Gap1 / 2 + wbaHole.Thickness1), -wbaHole.Offset2, -wbaHole.Height1);
                                boxMatrix = new Matrix4X4();
                                boxMatrix.Rotate(3 * (Math.PI / 2), new Vector(0, 0, 1));
                                Projection3d side1Box = symbolGeometryHelper.CreateBox(null, wbaHole.Thickness1, wbaHole.Width1, wbaHole.Height1 - wbaHole.Thickness2 - wbaHole.Thickness3 - wbaHole.Thickness4, 9);
                                side1Box.Transform(boxMatrix);
                                side1Box.Transform(matrix);
                                outputs.Add(outputName + "SIDE1", side1Box);

                                //SIDE2
                                symbolGeometryHelper = new SymbolGeometryHelper();
                                symbolGeometryHelper.ActivePosition = new Position(wbaHole.Gap1 / 2, -wbaHole.Offset2, -wbaHole.Height1);
                                boxMatrix = new Matrix4X4();
                                boxMatrix.Rotate(3 * (Math.PI / 2), new Vector(0, 0, 1));
                                Projection3d side2Box = symbolGeometryHelper.CreateBox(null, wbaHole.Thickness1, wbaHole.Width1, wbaHole.Height1 - wbaHole.Thickness2 - wbaHole.Thickness3 - wbaHole.Thickness4, 9);
                                side2Box.Transform(boxMatrix);
                                side2Box.Transform(matrix);
                                outputs.Add(outputName + "SIDE2", side2Box);
                            }
                        }
                    }
                    //Top
                    if (wbaHole.Length2 > Math3d.DistanceTolerance)
                    {
                        if ((wbaHole.Length2 > (wbaHole.Gap1 + 2 * wbaHole.Thickness1)) && (wbaHole.WBAHoleConfig != 1))   // Draw the ears outside
                        {
                            //Top1
                            wbaHole.Length2 = (wbaHole.Length2 - wbaHole.Gap1) / 2;
                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(wbaHole.Gap1 / 2, -wbaHole.Offset2, -wbaHole.Thickness3);
                            boxMatrix = new Matrix4X4();
                            boxMatrix.Rotate(Math.PI / 2, new Vector(0, 0, 1));
                            Projection3d topBox = symbolGeometryHelper.CreateBox(null, wbaHole.Length2, wbaHole.Width3, wbaHole.Thickness3, 9);
                            topBox.Transform(boxMatrix);
                            topBox.Transform(matrix);
                            outputs.Add(outputName + "TOP", topBox);

                            //TOP2
                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(wbaHole.Gap1 / 2, -wbaHole.Offset2, -wbaHole.Thickness3);
                            boxMatrix = new Matrix4X4();
                            boxMatrix.Rotate(3 * (Math.PI / 2), new Vector(0, 0, 1));
                            Projection3d top2Box = symbolGeometryHelper.CreateBox(null, wbaHole.Length2, wbaHole.Width2, wbaHole.Thickness2, 9);
                            top2Box.Transform(boxMatrix);
                            top2Box.Transform(matrix);
                            outputs.Add(outputName + "TOP2", top2Box);
                        }
                        else if (wbaHole.Length2 <= wbaHole.Gap1)     //Draw the ears indside
                        {
                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(-(wbaHole.Length2 / 2 + wbaHole.Thickness1), -wbaHole.Offset2, -wbaHole.Thickness3 - wbaHole.Thickness4);
                            boxMatrix = new Matrix4X4();
                            boxMatrix.Rotate(3 * (Math.PI / 2), new Vector(0, 0, 1));
                            Projection3d topBox = symbolGeometryHelper.CreateBox(null, wbaHole.Length2 + 2 * wbaHole.Thickness1, wbaHole.Width3, wbaHole.Thickness3, 9);
                            topBox.Transform(boxMatrix);
                            topBox.Transform(matrix);
                            outputs.Add(outputName + "TOP", topBox);
                        }
                    }
                }

                //Concrete Attachement
                if (wbaHole.Length3 > 0 && wbaHole.Width4 > 0 && (wbaHole.Thickness4 > Math3d.DistanceTolerance || wbaHole.Thickness4 < Math3d.DistanceTolerance))
                {
                    if (wbaHole.SimpShapeType == 2)     //For Rectangle plate
                    {
                        symbolGeometryHelper = new SymbolGeometryHelper();
                        symbolGeometryHelper.ActivePosition = new Position(-(wbaHole.Length3 / 2), -wbaHole.Offset3, -wbaHole.Thickness4);
                        boxMatrix = new Matrix4X4();
                        boxMatrix.Rotate(3 * (Math.PI / 2), new Vector(0, 0, 1));
                        Projection3d topBox1 = symbolGeometryHelper.CreateBox(null, wbaHole.Length3, wbaHole.Width4, wbaHole.Thickness4, 9);
                        topBox1.Transform(boxMatrix);
                        topBox1.Transform(matrix);
                        outputs.Add(outputName + "TOPCONCRETE", topBox1);
                    }
                    else if (wbaHole.SimpShapeType == 1)     //For Round plate
                    {
                        symbolGeometryHelper = new SymbolGeometryHelper();
                        symbolGeometryHelper.ActivePosition = new Position(0, 0, -wbaHole.Thickness4);
                        symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(1, 0, 0));
                        Projection3d topConcrete = symbolGeometryHelper.CreateCylinder(null, wbaHole.Length3 / 2, wbaHole.Thickness4);
                        topConcrete.Transform(matrix);
                        outputs.Add(outputName + "TOPCONCRETE", topConcrete);
                    }
                }

                //Extra Rod connection
                if (wbaHole.Thickness5 != 0)
                {
                    NutInputs NutShape;
                    NutShape.ShapeType = wbaHole.ShapeType;
                    NutShape.ShapeWidth1 = wbaHole.Width5;
                    NutShape.ShapeWidth2 = wbaHole.Width5;
                    NutShape.ShapeLength = wbaHole.Thickness5;
                    Matrix4X4 nutmatrix = new Matrix4X4();
                    if (wbaHole.Gap1 <= Math3d.DistanceTolerance)
                    {
                        nutmatrix.SetIdentity();
                        nutmatrix.Translate(new Vector(0, 0, -wbaHole.Height1));
                        AddNut(NutShape, nutmatrix, outputs, outputName + "EXTRARODCONN");
                        Projection3d nutOutput = (Projection3d)outputs[outputName + "EXTRARODCONN"];
                        nutOutput.Transform(matrix);
                    }
                    else
                    {
                        nutmatrix.SetIdentity();
                        nutmatrix.Translate(new Vector(0, 0, -wbaHole.Height1));
                        nutmatrix.Rotate(Math.PI, new Vector(0, 1, 0));
                        AddNut(NutShape, nutmatrix, outputs, outputName + "EXTRARODCONN");
                        Projection3d nutOutput = (Projection3d)outputs[outputName + "EXTRARODCONN"];
                        nutOutput.Transform(matrix);
                    }
                }

                if (error.Length != 0)
                {
                    ToDoListMessage = new ToDoListMessage(ToDoMessageTypes.ToDoMessageWarning, error.ToString());
                }
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddAddWBAHole, "Error in AddWBAHole");
                }
            }
        }


        /// <summary>
        /// Adds the Strap.
        /// </summary>
        /// <param name="connection">The connection.</param>
        /// <param name="myPlateShape">My plate shape.</param>
        /// <param name="Matrix">The matrix.</param>
        /// <param name="Outputs">The outputs.</param>
        /// <param name="outputName">Name of the output.</param>
        /// <code>AddStrap(rectStrap, pipeOD, matrix, m_PhysicalAspect.Outputs, "StrapWrap");</code>
        public void AddStrap(StrapInputs myStrapShape, Double pipeOD, Matrix4X4 Matrix, OutputDictionary Outputs, String outputName)
        {
            try
            {

                //Boolean Values used to determine general shape of strap
                Boolean hasWings = false;
                Boolean hasFlatSpot = false;
                Boolean isOneSided = false;
                Boolean hasSplitGap = false;
                Boolean isSquare = false;

                //This If checks to see if ANY strap graphic should be drawn at all
                if (myStrapShape.StrapHeightInside > 0 && myStrapShape.StrapStockWidth > 0 && myStrapShape.StrapThickness > 0 && myStrapShape.StrapWidthInside > 0)
                {

                    // If statements that check to see what general shape is going to be
                    if (myStrapShape.StrapFlatSpot == myStrapShape.StrapWidthInside)
                        isSquare = true;
                    else
                        isSquare = false;

                    if (myStrapShape.StrapWidthWings != 0 || myStrapShape.StrapWidthWings > (myStrapShape.StrapWidthInside + (2 * myStrapShape.StrapThickness)))
                        hasWings = true;

                    // If statement that checks whether the Flatspot exists
                    if (myStrapShape.StrapFlatSpot != 0)
                    {
                        //Check to see if the Flatspot length is invalid.. that is larger than the StrapWidthInside
                        if (myStrapShape.StrapFlatSpot > myStrapShape.StrapWidthInside)
                        {
                            RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrStrapFlatSpot, "Width of Flat Spot exceeds entire width of strap");
                        }
                        else
                            hasFlatSpot = true;
                    }
                    //Checks to see if Strap is to be one sided
                    if (myStrapShape.StrapOneSided == 1)
                        isOneSided = true;


                    //Checks to see of there should be a split gap with extension.
                    //The reason extension is used in the check instead of dSplitGap is because a zero gap with extension is still 2 extrusions
                    if (hasFlatSpot == false && myStrapShape.StrapSplitExtension != 0)
                        hasSplitGap = true;

                    if (myStrapShape.StrapWidthWings < (myStrapShape.StrapWidthInside + (2 * myStrapShape.StrapThickness)) && myStrapShape.StrapWidthWings > 0)
                    {
                        RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrStrapWidthWings, "Width of wings is less than the straps width");
                    }

                    if (pipeOD > myStrapShape.StrapWidthInside)
                    {
                        ToDoListMessage = new ToDoListMessage(ToDoMessageTypes.ToDoMessageWarning, SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrPipeODNGTStrapWidthInside, "PipeOD should not be greater than StrapWidthInside"));
                    }

                    //Some variables that make drawing a little easier
                    Double HeightToWidthDiff;
                    Double PipeToHeightDiff;
                    Double TopGap = myStrapShape.StrapTopGap;
                    Double HalfWidth = myStrapShape.StrapWidthInside / 2;
                    Double HalfHeight = (myStrapShape.StrapHeightInside) / 2;
                    Double Length = myStrapShape.StrapStockWidth;
                    Double HalfLength = myStrapShape.StrapStockWidth / 2;
                    Double Thickness = myStrapShape.StrapThickness;
                    Double WingWidth = myStrapShape.StrapWidthWings;
                    Double FlatSpot = myStrapShape.StrapFlatSpot;
                    Double SplitGap = myStrapShape.StrapSplitGap;
                    Double SplitExtension = myStrapShape.StrapSplitExtension;
                    Double angle;

                    ArcInputs OuterArc;
                    OuterArc.StartAngle = 0;
                    OuterArc.EndAngle = 0;
                    OuterArc.Radius = 0;


                    ArcInputs InnerArc;
                    InnerArc.StartAngle = 0;
                    InnerArc.EndAngle = 0;
                    InnerArc.Radius = 0;

                    ArcInputs RightArcTop;
                    RightArcTop.StartAngle = 0;
                    RightArcTop.EndAngle = 0;
                    RightArcTop.Radius = 0;

                    ArcInputs RightArcBottom;
                    RightArcBottom.StartAngle = 0;
                    RightArcBottom.EndAngle = 0;
                    RightArcBottom.Radius = 0;

                    ArcInputs LeftArcTop;
                    LeftArcTop.StartAngle = 0;
                    LeftArcTop.EndAngle = 0;
                    LeftArcTop.Radius = 0;

                    ArcInputs LeftArcBottom;
                    LeftArcBottom.StartAngle = 0;
                    LeftArcBottom.EndAngle = 0;
                    LeftArcBottom.Radius = 0;

                    LineInputs OuterRight;
                    OuterRight.StartX = 0;
                    OuterRight.StartY = 0;
                    OuterRight.StartZ = 0;
                    OuterRight.EndX = 0;
                    OuterRight.EndY = 0;
                    OuterRight.EndZ = 0;

                    LineInputs InnerRight;
                    InnerRight.StartX = 0;
                    InnerRight.StartY = 0;
                    InnerRight.StartZ = 0;
                    InnerRight.EndX = 0;
                    InnerRight.EndY = 0;
                    InnerRight.EndZ = 0;


                    LineInputs OuterLeft;
                    OuterLeft.StartX = 0;
                    OuterLeft.StartY = 0;
                    OuterLeft.StartZ = 0;
                    OuterLeft.EndX = 0;
                    OuterLeft.EndY = 0;
                    OuterLeft.EndZ = 0;

                    LineInputs InnerLeft;
                    InnerLeft.StartX = 0;
                    InnerLeft.StartY = 0;
                    InnerLeft.StartZ = 0;
                    InnerLeft.EndX = 0;
                    InnerLeft.EndY = 0;
                    InnerLeft.EndZ = 0;

                    LineInputs BottomRight;
                    BottomRight.StartX = 0;
                    BottomRight.StartY = 0;
                    BottomRight.StartZ = 0;
                    BottomRight.EndX = 0;
                    BottomRight.EndY = 0;
                    BottomRight.EndZ = 0;

                    LineInputs BottomLeft;
                    BottomLeft.StartX = 0;
                    BottomLeft.StartY = 0;
                    BottomLeft.StartZ = 0;
                    BottomLeft.EndX = 0;
                    BottomLeft.EndY = 0;
                    BottomLeft.EndZ = 0;

                    LineInputs RightWingSide;
                    RightWingSide.StartX = 0;
                    RightWingSide.StartY = 0;
                    RightWingSide.StartZ = 0;
                    RightWingSide.EndX = 0;
                    RightWingSide.EndY = 0;
                    RightWingSide.EndZ = 0;

                    LineInputs RightWingTop;
                    RightWingTop.StartX = 0;
                    RightWingTop.StartY = 0;
                    RightWingTop.StartZ = 0;
                    RightWingTop.EndX = 0;
                    RightWingTop.EndY = 0;
                    RightWingTop.EndZ = 0;

                    LineInputs LeftWingSide;
                    LeftWingSide.StartX = 0;
                    LeftWingSide.StartY = 0;
                    LeftWingSide.StartZ = 0;
                    LeftWingSide.EndX = 0;
                    LeftWingSide.EndY = 0;
                    LeftWingSide.EndZ = 0;

                    LineInputs LeftWingTop;
                    LeftWingTop.StartX = 0;
                    LeftWingTop.StartY = 0;
                    LeftWingTop.StartZ = 0;
                    LeftWingTop.EndX = 0;
                    LeftWingTop.EndY = 0;
                    LeftWingTop.EndZ = 0;

                    LineInputs FlatSpotTop;
                    FlatSpotTop.StartX = 0;
                    FlatSpotTop.StartY = 0;
                    FlatSpotTop.StartZ = 0;
                    FlatSpotTop.EndX = 0;
                    FlatSpotTop.EndY = 0;
                    FlatSpotTop.EndZ = 0;

                    LineInputs FlatSpotBottom;
                    FlatSpotBottom.StartX = 0;
                    FlatSpotBottom.StartY = 0;
                    FlatSpotBottom.StartZ = 0;
                    FlatSpotBottom.EndX = 0;
                    FlatSpotBottom.EndY = 0;
                    FlatSpotBottom.EndZ = 0;

                    LineInputs OuterRightExtension;
                    OuterRightExtension.StartX = 0;
                    OuterRightExtension.StartY = 0;
                    OuterRightExtension.StartZ = 0;
                    OuterRightExtension.EndX = 0;
                    OuterRightExtension.EndY = 0;
                    OuterRightExtension.EndZ = 0;

                    LineInputs TopRightExtension;
                    TopRightExtension.StartX = 0;
                    TopRightExtension.StartY = 0;
                    TopRightExtension.StartZ = 0;
                    TopRightExtension.EndX = 0;
                    TopRightExtension.EndY = 0;
                    TopRightExtension.EndZ = 0;

                    LineInputs InnerRightExtension;
                    InnerRightExtension.StartX = 0;
                    InnerRightExtension.StartY = 0;
                    InnerRightExtension.StartZ = 0;
                    InnerRightExtension.EndX = 0;
                    InnerRightExtension.EndY = 0;
                    InnerRightExtension.EndZ = 0;

                    LineInputs OuterLeftExtension;
                    OuterLeftExtension.StartX = 0;
                    OuterLeftExtension.StartY = 0;
                    OuterLeftExtension.StartZ = 0;
                    OuterLeftExtension.EndX = 0;
                    OuterLeftExtension.EndY = 0;
                    OuterLeftExtension.EndZ = 0;

                    LineInputs TopLeftExtension;
                    TopLeftExtension.StartX = 0;
                    TopLeftExtension.StartY = 0;
                    TopLeftExtension.StartZ = 0;
                    TopLeftExtension.EndX = 0;
                    TopLeftExtension.EndY = 0;
                    TopLeftExtension.EndZ = 0;

                    LineInputs InnerLeftExtension;
                    InnerLeftExtension.StartX = 0;
                    InnerLeftExtension.StartY = 0;
                    InnerLeftExtension.StartZ = 0;
                    InnerLeftExtension.EndX = 0;
                    InnerLeftExtension.EndY = 0;
                    InnerLeftExtension.EndZ = 0;
                    //Height or z-axis offsets are set here

                    //HeightToWidthDiff represents the difference that exists between a straps height and width..
                    //Used to draw a strap that has a wider width than strap inside height
                    HeightToWidthDiff = -((myStrapShape.StrapWidthInside - myStrapShape.StrapHeightInside) / 2);

                    //PipeToHeightDiff represents the difference between pipe diameter and strap inside height
                    PipeToHeightDiff = (-(myStrapShape.StrapHeightInside - pipeOD) / 2) + TopGap;

                    //If the strap has wings..
                    if (hasWings)
                    {
                        //RIGHT SIDE OF STRAP

                        //Bottom Left of Strap With Wings
                        BottomLeft.StartX = -HalfLength;
                        BottomLeft.StartY = -(WingWidth / 2);
                        BottomLeft.StartZ = -HalfHeight + PipeToHeightDiff;
                        BottomLeft.EndX = -HalfLength;
                        BottomLeft.EndY = -HalfWidth;
                        BottomLeft.EndZ = -HalfHeight + PipeToHeightDiff;

                        //  Side of left wing of Winged Strap
                        LeftWingSide.StartX = -HalfLength;
                        LeftWingSide.StartY = -(WingWidth / 2);
                        LeftWingSide.StartZ = -HalfHeight + PipeToHeightDiff;
                        LeftWingSide.EndX = -HalfLength;
                        LeftWingSide.EndY = -(WingWidth / 2);
                        LeftWingSide.EndZ = -HalfHeight + Thickness + PipeToHeightDiff;


                        //Top of Left Wing of Winged Strap
                        LeftWingTop.StartX = -HalfLength;
                        LeftWingTop.StartY = -(WingWidth / 2);
                        LeftWingTop.StartZ = -HalfHeight + Thickness + PipeToHeightDiff;
                        LeftWingTop.EndX = -HalfLength;
                        LeftWingTop.EndY = -HalfWidth - Thickness;
                        LeftWingTop.EndZ = -HalfHeight + Thickness + PipeToHeightDiff;



                        //If the strap has a flatspot
                        if (hasFlatSpot)
                        {
                            //Outer left line with dFlatSpot and wings
                            OuterLeft.StartX = -HalfLength;
                            OuterLeft.StartY = -HalfWidth - Thickness;
                            OuterLeft.StartZ = -HalfHeight + Thickness + PipeToHeightDiff;
                            OuterLeft.EndX = -HalfLength;
                            OuterLeft.EndY = -HalfWidth - Thickness;
                            if (isSquare)
                                //This if handles the square strap with wings outer left side
                                OuterLeft.EndZ = HalfHeight - (HalfWidth - FlatSpot / 2) + PipeToHeightDiff + Thickness;
                            else
                                OuterLeft.EndZ = HalfHeight - (HalfWidth - FlatSpot / 2) + PipeToHeightDiff;


                        }
                        else
                        {
                            //Outer Left Line of Strap With Wings
                            OuterLeft.StartX = -HalfLength;
                            OuterLeft.StartY = -HalfWidth - Thickness;
                            OuterLeft.StartZ = -HalfHeight + Thickness + PipeToHeightDiff;
                            OuterLeft.EndX = -HalfLength;
                            OuterLeft.EndY = -HalfWidth - Thickness;
                            OuterLeft.EndZ = HeightToWidthDiff + PipeToHeightDiff;

                        }

                    }
                    else //Else handles left input presets for Strap that has NO WINGS
                    {
                        //Bottom Left of Strap With Out Wings
                        BottomLeft.StartX = -HalfLength;
                        BottomLeft.StartY = -HalfWidth - Thickness;
                        BottomLeft.StartZ = -HalfHeight + PipeToHeightDiff;
                        BottomLeft.EndX = -HalfLength;
                        BottomLeft.EndY = -HalfWidth;
                        BottomLeft.EndZ = -HalfHeight + PipeToHeightDiff;


                        //If the strap has a flatspot And NO WINGS
                        if (hasFlatSpot)
                        {
                            //Outer left line with dFlatSpot and NO wings
                            OuterLeft.StartX = -HalfLength;
                            OuterLeft.StartY = -HalfWidth - Thickness;
                            OuterLeft.StartZ = -HalfHeight + PipeToHeightDiff;
                            OuterLeft.EndX = -HalfLength;
                            OuterLeft.EndY = -HalfWidth - Thickness;
                            if (isSquare)
                                //If that handles square strap with NO Wings
                                OuterLeft.EndZ = HalfHeight - (HalfWidth - FlatSpot / 2) + PipeToHeightDiff + Thickness;
                            else
                                OuterLeft.EndZ = HalfHeight - (HalfWidth - FlatSpot / 2) + PipeToHeightDiff;


                        }
                        else
                        {
                            //Outer Left Line of Strap With Out Wings NO dFlatSpot
                            OuterLeft.StartX = -HalfLength;
                            OuterLeft.StartY = -HalfWidth - Thickness;
                            OuterLeft.StartZ = -HalfHeight + PipeToHeightDiff;
                            OuterLeft.EndX = -HalfLength;
                            OuterLeft.EndY = -HalfWidth - Thickness;
                            OuterLeft.EndZ = HeightToWidthDiff + PipeToHeightDiff;

                        }
                    }

                    if (hasFlatSpot)
                    {

                        //Inner Left Line of Strap With dFlatSpot With Or Without Wings
                        InnerLeft.StartX = -HalfLength;
                        InnerLeft.StartY = -HalfWidth;
                        InnerLeft.StartZ = -HalfHeight + PipeToHeightDiff;
                        InnerLeft.EndX = -HalfLength;
                        InnerLeft.EndY = -HalfWidth;
                        InnerLeft.EndZ = HalfHeight - (HalfWidth - FlatSpot / 2) + PipeToHeightDiff;

                    }

                    else
                    {
                        //Inner Left Line of Strap With Or With Out Wings;
                        InnerLeft.StartX = -HalfLength;
                        InnerLeft.StartY = -HalfWidth;
                        InnerLeft.StartZ = -HalfHeight + PipeToHeightDiff;
                        InnerLeft.EndX = -HalfLength;
                        InnerLeft.EndY = -HalfWidth;
                        InnerLeft.EndZ = HeightToWidthDiff + PipeToHeightDiff;


                    }

                    //ARC PRESETS

                    if (hasFlatSpot)
                    {
                        //Presets for Top of Left Arc for strap with dFlatSpot
                        LeftArcTop.StartAngle = Math.PI / 2;
                        LeftArcTop.EndAngle = Math.PI;
                        LeftArcTop.Radius = (HalfWidth + Thickness) - FlatSpot / 2;


                        //Presets for Bottom of left arc for strap with dFlatSpot
                        LeftArcBottom.StartAngle = Math.PI / 2;
                        LeftArcBottom.EndAngle = Math.PI;
                        LeftArcBottom.Radius = HalfWidth - FlatSpot / 2;

                        //FlatSpotTop   
                        FlatSpotTop.StartX = -HalfLength;
                        FlatSpotTop.StartZ = HalfHeight + Thickness + PipeToHeightDiff;
                        FlatSpotTop.EndX = -HalfLength;
                        FlatSpotTop.EndZ = HalfHeight + Thickness + PipeToHeightDiff;


                        if (isSquare)
                        {
                            FlatSpotTop.StartY = (-FlatSpot / 2) - Thickness;
                            if (isOneSided)
                                FlatSpotTop.EndY = (FlatSpot / 2);
                            else
                                FlatSpotTop.EndY = (FlatSpot / 2) + Thickness;
                        }
                        else
                        {
                            FlatSpotTop.StartY = -FlatSpot / 2;
                            FlatSpotTop.EndY = FlatSpot / 2;
                        }
                        //FlatSpotBottom
                        FlatSpotBottom.StartX = -HalfLength;
                        FlatSpotBottom.StartY = -FlatSpot / 2;
                        FlatSpotBottom.StartZ = HalfHeight + PipeToHeightDiff;
                        FlatSpotBottom.EndX = -HalfLength;
                        FlatSpotBottom.EndY = FlatSpot / 2;
                        FlatSpotBottom.EndZ = HalfHeight + PipeToHeightDiff;


                        //Presets for Top of Right Arc for strap with dFlatSpot
                        RightArcTop.StartAngle = 0;
                        RightArcTop.EndAngle = Math.PI / 2;
                        RightArcTop.Radius = (HalfWidth + Thickness) - FlatSpot / 2;



                        //Presets for Bottom of Right arc for strap with dFlatSpot
                        RightArcBottom.StartAngle = 0;
                        RightArcBottom.EndAngle = Math.PI / 2;
                        RightArcBottom.Radius = HalfWidth - FlatSpot / 2;


                    }
                    else if (hasSplitGap)
                    {

                        //LEFT SIDE OF SPLIT GAP STRAP
                        //Presets for Top of Left Arc for strap with Split Gap                    
                        angle = (Thickness + (SplitGap / 2)) / (HalfWidth + Thickness);
                        LeftArcTop.StartAngle = Math.PI / 2 + (Math.Asin(angle));
                        LeftArcTop.EndAngle = Math.PI;
                        LeftArcTop.Radius = (HalfWidth + Thickness);


                        //Presets for Bottom of left arc for strap with Split Gap                    
                        angle = (SplitGap / 2) / HalfWidth;
                        LeftArcBottom.StartAngle = Math.PI / 2 + (Math.Asin(angle));
                        LeftArcBottom.EndAngle = Math.PI;
                        LeftArcBottom.Radius = HalfWidth;


                        //Code for setting LEFT side Split Gap extensions
                        //InnerLeftExtension
                        InnerLeftExtension.StartX = -HalfLength;
                        InnerLeftExtension.StartY = -(SplitGap / 2);
                        InnerLeftExtension.StartZ = Math.Sqrt(-((SplitGap / 2) * (SplitGap / 2)) + (HalfWidth * HalfWidth)) + HeightToWidthDiff + PipeToHeightDiff;
                        InnerLeftExtension.EndX = -HalfLength;
                        InnerLeftExtension.EndY = -(SplitGap / 2);
                        InnerLeftExtension.EndZ = HalfHeight + SplitExtension + HeightToWidthDiff + PipeToHeightDiff;

                        //OuterLeftExtension
                        OuterLeftExtension.StartX = -HalfLength;
                        OuterLeftExtension.StartY = -(SplitGap / 2) - Thickness;
                        OuterLeftExtension.StartZ = Math.Sqrt(-((SplitGap / 2 + Thickness) * (SplitGap / 2 + Thickness)) + ((HalfWidth + Thickness) * (HalfWidth + Thickness))) + HeightToWidthDiff + PipeToHeightDiff;
                        OuterLeftExtension.EndX = -HalfLength;
                        OuterLeftExtension.EndY = -(SplitGap / 2) - Thickness;
                        OuterLeftExtension.EndZ = HalfHeight + SplitExtension + HeightToWidthDiff + PipeToHeightDiff;

                        //TopLeftExtension
                        TopLeftExtension.StartX = -HalfLength;
                        TopLeftExtension.StartY = -(SplitGap / 2) - Thickness;
                        TopLeftExtension.StartZ = HalfHeight + SplitExtension + HeightToWidthDiff + PipeToHeightDiff;
                        TopLeftExtension.EndX = -HalfLength;
                        TopLeftExtension.EndY = -(SplitGap / 2);
                        TopLeftExtension.EndZ = HalfHeight + SplitExtension + HeightToWidthDiff + PipeToHeightDiff;


                        //RIGHT SIDE OF SPLIT GAP STRAP
                        //Presets for Top of Right Arc for strap with dSplitGap
                        RightArcTop.StartAngle = 0;
                        angle = (Thickness + (SplitGap / 2)) / (HalfWidth + Thickness);
                        RightArcTop.EndAngle = Math.PI / 2 - (Math.Asin(angle));
                        RightArcTop.Radius = (HalfWidth + Thickness);


                        //Presets for Bottom of Right arc for strap with dSplitGap
                        RightArcBottom.StartAngle = 0;
                        angle = (SplitGap / 2) / (HalfWidth);
                        RightArcBottom.EndAngle = Math.PI / 2 - (Math.Asin(angle));
                        RightArcBottom.Radius = HalfWidth;


                        //Code for setting RIGHT side Split Gap extensions
                        //InnerRightExtension
                        InnerRightExtension.StartX = -HalfLength;
                        InnerRightExtension.StartY = (SplitGap / 2);
                        InnerRightExtension.StartZ = Math.Sqrt(-((SplitGap / 2) * (SplitGap / 2)) + (HalfWidth * HalfWidth)) + HeightToWidthDiff + PipeToHeightDiff;
                        InnerRightExtension.EndX = -HalfLength;
                        InnerRightExtension.EndY = (SplitGap / 2);
                        InnerRightExtension.EndZ = HalfHeight + SplitExtension + HeightToWidthDiff + PipeToHeightDiff;

                        //OuterRightExtension
                        OuterRightExtension.StartX = -HalfLength;
                        OuterRightExtension.StartY = (SplitGap / 2) + Thickness;
                        OuterRightExtension.StartZ = Math.Sqrt(-((SplitGap / 2 + Thickness) * (SplitGap / 2 + Thickness)) + ((HalfWidth + Thickness) * (HalfWidth + Thickness))) + HeightToWidthDiff + PipeToHeightDiff;
                        OuterRightExtension.EndX = -HalfLength;
                        OuterRightExtension.EndY = (SplitGap / 2) + Thickness;
                        OuterRightExtension.EndZ = HalfHeight + SplitExtension + HeightToWidthDiff + PipeToHeightDiff;

                        //TopRightExtension
                        TopRightExtension.StartX = -HalfLength;
                        TopRightExtension.StartY = (SplitGap / 2) + Thickness;
                        TopRightExtension.StartZ = HalfHeight + SplitExtension + HeightToWidthDiff + PipeToHeightDiff;
                        TopRightExtension.EndX = -HalfLength;
                        TopRightExtension.EndY = (SplitGap / 2);
                        TopRightExtension.EndZ = HalfHeight + SplitExtension + HeightToWidthDiff + PipeToHeightDiff;

                    }
                    else
                    {
                        //Inputs for Outer Arc of strap With or With Out Wings
                        OuterArc.StartAngle = 0;
                        OuterArc.EndAngle = Math.PI;
                        OuterArc.Radius = HalfWidth + Thickness;



                        //Inputs for Inner Arc of strap With or With Out Wings
                        InnerArc.StartAngle = 0;
                        InnerArc.EndAngle = Math.PI;
                        InnerArc.Radius = HalfWidth;


                    }
                    //''''RIGHT SIDE OF STRAP''''''''''''''''''''''''''''''''''''''''''''''''''''


                    if (isOneSided && isSquare == false)
                    {
                        //Bottom right of one sided winged strap
                        BottomRight.StartX = -HalfLength;
                        BottomRight.StartY = HalfWidth + Thickness;
                        BottomRight.StartZ = (HalfHeight - (HalfWidth - FlatSpot / 2)) + PipeToHeightDiff;
                        BottomRight.EndX = -HalfLength;
                        BottomRight.EndY = HalfWidth;
                        BottomRight.EndZ = (HalfHeight - (HalfWidth - FlatSpot / 2)) + PipeToHeightDiff;

                        //OuterRight
                        OuterRight.StartX = -HalfLength;
                        OuterRight.StartY = HalfWidth + Thickness;
                        OuterRight.StartZ = -HalfHeight + Thickness + PipeToHeightDiff;
                        OuterRight.EndX = -HalfLength;
                        OuterRight.EndY = HalfWidth + Thickness;
                        OuterRight.EndZ = HalfHeight - (HalfWidth - FlatSpot / 2) + PipeToHeightDiff;

                    }
                    else
                    {
                        if (hasWings)
                        {

                            if (isOneSided == false)
                            {
                                //Bottom Right of Strap With Wings
                                BottomRight.StartX = -HalfLength;
                                BottomRight.StartY = (WingWidth / 2);
                                BottomRight.StartZ = -HalfHeight + PipeToHeightDiff;
                                BottomRight.EndX = -HalfLength;
                                BottomRight.EndY = HalfWidth;
                                BottomRight.EndZ = -HalfHeight + PipeToHeightDiff;

                            }


                            //Side of right wing of Winged Strap
                            RightWingSide.StartX = -HalfLength;
                            RightWingSide.StartY = (WingWidth / 2);
                            RightWingSide.StartZ = -HalfHeight + PipeToHeightDiff;
                            RightWingSide.EndX = -HalfLength;
                            RightWingSide.EndY = (WingWidth / 2);
                            RightWingSide.EndZ = -HalfHeight + Thickness + PipeToHeightDiff;


                            //Top of Right Wing of Winged Strap
                            RightWingTop.StartX = -HalfLength;
                            RightWingTop.StartY = (WingWidth / 2);
                            RightWingTop.StartZ = -HalfHeight + Thickness + PipeToHeightDiff;
                            RightWingTop.EndX = -HalfLength;
                            RightWingTop.EndY = HalfWidth + Thickness;
                            RightWingTop.EndZ = -HalfHeight + Thickness + PipeToHeightDiff;

                            if (hasFlatSpot)
                            {

                                //Outer right with FlatSpot and wings
                                OuterRight.StartX = -HalfLength;
                                OuterRight.EndX = -HalfLength;
                                if (isSquare && isOneSided == false)
                                {
                                    //If that handles square strap with wings
                                    OuterRight.StartY = HalfWidth + Thickness;
                                    OuterRight.EndY = HalfWidth + Thickness;
                                    OuterRight.StartZ = -HalfHeight + Thickness + PipeToHeightDiff;
                                    OuterRight.EndZ = HalfHeight - (HalfWidth - FlatSpot / 2) + PipeToHeightDiff + Thickness;
                                }
                                else if (isSquare && isOneSided)
                                {
                                    OuterRight.StartY = HalfWidth;
                                    OuterRight.EndY = HalfWidth;
                                    OuterRight.StartZ = HalfHeight + Thickness + PipeToHeightDiff;
                                    OuterRight.EndZ = HalfHeight - (HalfWidth - FlatSpot / 2) + PipeToHeightDiff;
                                }
                                else
                                {
                                    OuterRight.StartY = HalfWidth + Thickness;
                                    OuterRight.EndY = HalfWidth + Thickness;
                                    OuterRight.StartZ = -HalfHeight + Thickness + PipeToHeightDiff;
                                    OuterRight.EndZ = HalfHeight - (HalfWidth - FlatSpot / 2) + PipeToHeightDiff;
                                }

                            }
                            else
                            {
                                //Outer Right Line of Strap With Wings
                                OuterRight.StartX = -HalfLength;
                                OuterRight.StartY = HalfWidth + Thickness;
                                OuterRight.StartZ = (-HalfHeight + Thickness) + PipeToHeightDiff;
                                OuterRight.EndX = -HalfLength;
                                OuterRight.EndY = HalfWidth + Thickness;
                                OuterRight.EndZ = HeightToWidthDiff + PipeToHeightDiff;

                            }
                        }
                        else if (isSquare == false)
                        {
                            //Bottom Right of Double sided Strap With Out Wings
                            BottomRight.StartX = -HalfLength;
                            BottomRight.StartY = HalfWidth + Thickness;
                            BottomRight.StartZ = -HalfHeight + PipeToHeightDiff;
                            BottomRight.EndX = -HalfLength;
                            BottomRight.EndY = HalfWidth;
                            BottomRight.EndZ = -HalfHeight + PipeToHeightDiff;

                            if (hasFlatSpot)
                            {
                                //Outer right line for strap with no wings and FlatSpot

                                OuterRight.StartX = -HalfLength;
                                OuterRight.StartY = HalfWidth + Thickness;
                                OuterRight.StartZ = -HalfHeight + PipeToHeightDiff;
                                OuterRight.EndX = -HalfLength;
                                OuterRight.EndY = HalfWidth + Thickness;

                                if (isSquare)

                                    //If that handles square strap that has no wings
                                    OuterRight.EndZ = HalfHeight - (HalfWidth - FlatSpot / 2) + PipeToHeightDiff + Thickness;
                                else
                                    OuterRight.EndZ = HalfHeight - (HalfWidth - FlatSpot / 2) + PipeToHeightDiff;


                            }
                            else
                            {
                                //Outer right of strap without wings
                                OuterRight.StartX = -HalfLength;
                                OuterRight.StartY = HalfWidth + Thickness;
                                OuterRight.StartZ = -HalfHeight + PipeToHeightDiff;
                                OuterRight.EndX = -HalfLength;
                                OuterRight.EndY = HalfWidth + Thickness;
                                OuterRight.EndZ = HeightToWidthDiff + PipeToHeightDiff;

                            }
                        }
                    }

                    if (isSquare && hasWings == false)
                    {
                        OuterRight.StartX = -HalfLength;
                        OuterRight.EndX = -HalfLength;
                        if (isOneSided)
                        {
                            OuterRight.StartY = HalfWidth;
                            OuterRight.EndY = HalfWidth;
                            OuterRight.StartZ = HalfHeight + PipeToHeightDiff;
                            OuterRight.EndZ = HalfHeight - (HalfWidth - FlatSpot / 2) + PipeToHeightDiff + Thickness;
                        }
                        else
                        {
                            OuterRight.StartY = HalfWidth + Thickness;
                            OuterRight.EndY = HalfWidth + Thickness;
                            OuterRight.StartZ = -HalfHeight + PipeToHeightDiff;
                            OuterRight.EndZ = HalfHeight - (HalfWidth - FlatSpot / 2) + PipeToHeightDiff + Thickness;
                        }

                        if (isOneSided == false)
                        {
                            BottomRight.StartX = -HalfLength;
                            BottomRight.StartY = HalfWidth;
                            BottomRight.StartZ = -HalfHeight + PipeToHeightDiff;
                            BottomRight.EndX = -HalfLength;
                            BottomRight.EndY = HalfWidth + Thickness;
                            BottomRight.EndZ = -HalfHeight + PipeToHeightDiff;

                        }
                    }

                    if (hasFlatSpot)
                    {
                        //Inner right of strap with FlatSpot With or without wings
                        InnerRight.StartX = -HalfLength;
                        InnerRight.StartY = HalfWidth;
                        InnerRight.StartZ = -HalfHeight + PipeToHeightDiff;
                        InnerRight.EndX = -HalfLength;
                        InnerRight.EndY = HalfWidth;
                        InnerRight.EndZ = HalfHeight - (HalfWidth - FlatSpot / 2) + PipeToHeightDiff;


                    }
                    else
                    {

                        InnerRight.StartX = -HalfLength;
                        InnerRight.StartY = HalfWidth;
                        InnerRight.StartZ = -HalfHeight + PipeToHeightDiff;
                        InnerRight.EndX = -HalfLength;
                        InnerRight.EndY = HalfWidth;
                        InnerRight.EndZ = HeightToWidthDiff + PipeToHeightDiff;

                    }

                    //Here is where the strap actually gets drawn using preset inputs
                    Matrix4X4 matrix = new Matrix4X4();
                    SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();

                    Collection<ICurve> curveCollection = new Collection<ICurve>();


                    //Draws bottom left line of strap
                    Line3d botomLeftLine = new Line3d(new Position(BottomLeft.StartX, BottomLeft.StartY, BottomLeft.StartZ), new Position(BottomLeft.EndX, BottomLeft.EndY, BottomLeft.EndZ));
                    curveCollection.Add(botomLeftLine);



                    if (hasWings)
                    {
                        //Draws line that makes left side of left wing
                        Line3d leftWingSideLine = new Line3d(new Position(LeftWingSide.StartX, LeftWingSide.StartY, LeftWingSide.StartZ), new Position(LeftWingSide.EndX, LeftWingSide.EndY, LeftWingSide.EndZ));
                        curveCollection.Add(leftWingSideLine);

                        //Draws line that makes top of left wing
                        Line3d leftWingTopLine = new Line3d(new Position(LeftWingTop.StartX, LeftWingTop.StartY, LeftWingTop.StartZ), new Position(LeftWingTop.EndX, LeftWingTop.EndY, LeftWingTop.EndZ));
                        curveCollection.Add(leftWingTopLine);
                    }


                    //Draws outer left line of strap
                    Line3d outerLeftLine = new Line3d(new Position(OuterLeft.StartX, OuterLeft.StartY, OuterLeft.StartZ), new Position(OuterLeft.EndX, OuterLeft.EndY, OuterLeft.EndZ));
                    curveCollection.Add(outerLeftLine);

                    //Draws inner left line of strap
                    Line3d innerLeftLine = new Line3d(new Position(InnerLeft.StartX, InnerLeft.StartY, InnerLeft.StartZ), new Position(InnerLeft.EndX, InnerLeft.EndY, InnerLeft.EndZ));
                    curveCollection.Add(innerLeftLine);

                    if (hasFlatSpot)
                    {
                        Line3d flatSpotTopLine = new Line3d(new Position(FlatSpotTop.StartX, FlatSpotTop.StartY, FlatSpotTop.StartZ), new Position(FlatSpotTop.EndX, FlatSpotTop.EndY, FlatSpotTop.EndZ));
                        curveCollection.Add(flatSpotTopLine);


                        Line3d flatSpotBottomLine = new Line3d(new Position(FlatSpotBottom.StartX, FlatSpotBottom.StartY, FlatSpotBottom.StartZ), new Position(FlatSpotBottom.EndX, FlatSpotBottom.EndY, FlatSpotBottom.EndZ));
                        curveCollection.Add(flatSpotBottomLine);


                        if (hasFlatSpot && isSquare == false)
                        {

                            //LeftArcTop
                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                            symbolGeometryHelper.SetOrientation(new Vector(0, 1, 0), new Vector(1, 0, 0));
                            matrix.SetIdentity();
                            matrix.Rotate(LeftArcTop.StartAngle, new Vector(0, 0, 1));

                            Arc3d leftArcTop = symbolGeometryHelper.CreateArc(null, LeftArcTop.Radius, (LeftArcTop.EndAngle - LeftArcTop.StartAngle));
                            leftArcTop.Transform(matrix);

                            matrix = new Matrix4X4();
                            matrix.SetIdentity();
                            matrix.Rotate(Math.PI / 2, new Vector(1, 0, 0));
                            leftArcTop.Transform(matrix);


                            matrix = new Matrix4X4();
                            matrix.SetIdentity();
                            matrix.Translate(new Vector(-FlatSpot / 2, HalfLength, (HalfHeight - (HalfWidth - FlatSpot / 2)) + PipeToHeightDiff));
                            leftArcTop.Transform(matrix);

                            matrix = new Matrix4X4();
                            matrix.SetIdentity();
                            matrix.Rotate(Math.PI / 2, new Vector(0, 0, 1));
                            leftArcTop.Transform(matrix);
                            curveCollection.Add(leftArcTop);

                            //LeftArcBottom
                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                            symbolGeometryHelper.SetOrientation(new Vector(0, 1, 0), new Vector(1, 0, 0));
                            matrix.SetIdentity();
                            matrix.Rotate(LeftArcBottom.StartAngle, new Vector(0, 0, 1));

                            Arc3d leftArcBottom = symbolGeometryHelper.CreateArc(null, LeftArcBottom.Radius, (LeftArcBottom.EndAngle - LeftArcBottom.StartAngle));
                            leftArcBottom.Transform(matrix);

                            matrix = new Matrix4X4();
                            matrix.SetIdentity();
                            matrix.Rotate(Math.PI / 2, new Vector(1, 0, 0));
                            leftArcBottom.Transform(matrix);


                            matrix = new Matrix4X4();
                            matrix.SetIdentity();
                            matrix.Translate(new Vector(-FlatSpot / 2, HalfLength, (HalfHeight - (HalfWidth - FlatSpot / 2)) + PipeToHeightDiff));
                            leftArcBottom.Transform(matrix);

                            matrix = new Matrix4X4();
                            matrix.SetIdentity();
                            matrix.Rotate(Math.PI / 2, new Vector(0, 0, 1));
                            leftArcBottom.Transform(matrix);
                            curveCollection.Add(leftArcBottom);

                            //RightArcTop
                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                            symbolGeometryHelper.SetOrientation(new Vector(0, 1, 0), new Vector(1, 0, 0));
                            matrix.SetIdentity();
                            matrix.Rotate(RightArcTop.StartAngle, new Vector(0, 0, 1));

                            Arc3d rightArcTop = symbolGeometryHelper.CreateArc(null, RightArcTop.Radius, (RightArcTop.EndAngle - RightArcTop.StartAngle));
                            rightArcTop.Transform(matrix);

                            matrix = new Matrix4X4();
                            matrix.SetIdentity();
                            matrix.Rotate(Math.PI / 2, new Vector(1, 0, 0));
                            rightArcTop.Transform(matrix);


                            matrix = new Matrix4X4();
                            matrix.SetIdentity();
                            matrix.Translate(new Vector(FlatSpot / 2, HalfLength, (HalfHeight - (HalfWidth - FlatSpot / 2)) + PipeToHeightDiff));
                            rightArcTop.Transform(matrix);

                            matrix = new Matrix4X4();
                            matrix.SetIdentity();
                            matrix.Rotate(Math.PI / 2, new Vector(0, 0, 1));
                            rightArcTop.Transform(matrix);
                            curveCollection.Add(rightArcTop);

                            //RightArcBottom
                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                            symbolGeometryHelper.SetOrientation(new Vector(0, 1, 0), new Vector(1, 0, 0));
                            matrix.SetIdentity();
                            matrix.Rotate(RightArcBottom.StartAngle, new Vector(0, 0, 1));

                            Arc3d rightArcBottom = symbolGeometryHelper.CreateArc(null, RightArcBottom.Radius, (RightArcBottom.EndAngle - RightArcBottom.StartAngle));
                            rightArcBottom.Transform(matrix);

                            matrix = new Matrix4X4();
                            matrix.SetIdentity();
                            matrix.Rotate(Math.PI / 2, new Vector(1, 0, 0));
                            rightArcBottom.Transform(matrix);


                            matrix = new Matrix4X4();
                            matrix.SetIdentity();
                            matrix.Translate(new Vector(FlatSpot / 2, HalfLength, (HalfHeight - (HalfWidth - FlatSpot / 2)) + PipeToHeightDiff));
                            rightArcBottom.Transform(matrix);

                            matrix = new Matrix4X4();
                            matrix.SetIdentity();
                            matrix.Rotate(Math.PI / 2, new Vector(0, 0, 1));
                            rightArcBottom.Transform(matrix);
                            curveCollection.Add(rightArcBottom);

                        }
                    }

                    else if (hasSplitGap)
                    {

                        //Left Arcs of dSplitGap strap drawn here

                        //LeftArcTop
                        symbolGeometryHelper = new SymbolGeometryHelper();
                        symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                        symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        matrix.SetIdentity();
                        matrix.Rotate(LeftArcTop.StartAngle, new Vector(0, 0, 1));

                        Arc3d leftArcTop = symbolGeometryHelper.CreateArc(null, LeftArcTop.Radius, (LeftArcTop.EndAngle - LeftArcTop.StartAngle));
                        leftArcTop.Transform(matrix);

                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Rotate(Math.PI / 2, new Vector(1, 0, 0));
                        leftArcTop.Transform(matrix);


                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Translate(new Vector(0, HalfLength, HeightToWidthDiff + PipeToHeightDiff));
                        leftArcTop.Transform(matrix);

                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Rotate(Math.PI / 2, new Vector(0, 0, 1));
                        leftArcTop.Transform(matrix);
                        curveCollection.Add(leftArcTop);

                        //LeftArcBottom
                        symbolGeometryHelper = new SymbolGeometryHelper();
                        symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                        symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        matrix.SetIdentity();
                        matrix.Rotate(LeftArcBottom.StartAngle, new Vector(0, 0, 1));

                        Arc3d leftArcBottom = symbolGeometryHelper.CreateArc(null, LeftArcBottom.Radius, (LeftArcBottom.EndAngle - LeftArcBottom.StartAngle));
                        leftArcBottom.Transform(matrix);

                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Rotate(Math.PI / 2, new Vector(1, 0, 0));
                        leftArcBottom.Transform(matrix);


                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Translate(new Vector(0, HalfLength, HeightToWidthDiff + PipeToHeightDiff));
                        leftArcBottom.Transform(matrix);

                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Rotate(Math.PI / 2, new Vector(0, 0, 1));
                        leftArcBottom.Transform(matrix);
                        curveCollection.Add(leftArcBottom);


                        //Code for drawing extension on left side of strap                

                        Line3d innerLeftExtension = new Line3d(new Position(InnerLeftExtension.StartX, InnerLeftExtension.StartY, InnerLeftExtension.StartZ), new Position(InnerLeftExtension.EndX, InnerLeftExtension.EndY, InnerLeftExtension.EndZ));
                        curveCollection.Add(innerLeftExtension);


                        Line3d outerLeftExtension = new Line3d(new Position(OuterLeftExtension.StartX, OuterLeftExtension.StartY, OuterLeftExtension.StartZ), new Position(OuterLeftExtension.EndX, OuterLeftExtension.EndY, OuterLeftExtension.EndZ));
                        curveCollection.Add(outerLeftExtension);

                        Line3d topLeftExtension = new Line3d(new Position(TopLeftExtension.StartX, TopLeftExtension.StartY, TopLeftExtension.StartZ), new Position(TopLeftExtension.EndX, TopLeftExtension.EndY, TopLeftExtension.EndZ));
                        curveCollection.Add(topLeftExtension);


                        //Extrusion done for left side of strap
                        ComplexString3d leftStrapLineString = new ComplexString3d(curveCollection);
                        Vector leftStrapLineVector = new Vector(1, 0, 0);
                        Projection3d leftSideStrap = new Projection3d(leftStrapLineString, leftStrapLineVector, Length, true);
                        Outputs.Add(outputName + "Left", leftSideStrap);


                        curveCollection = new Collection<ICurve>();
                        //Right Arcs for dSplitGap strap drawn here                  
                        //RightArcTop
                        symbolGeometryHelper = new SymbolGeometryHelper();
                        symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                        symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        matrix.SetIdentity();
                        matrix.Rotate(RightArcTop.StartAngle, new Vector(0, 0, 1));


                        Arc3d rightArcTop = symbolGeometryHelper.CreateArc(null, RightArcTop.Radius, (RightArcTop.EndAngle - RightArcTop.StartAngle));
                        rightArcTop.Transform(matrix);

                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Rotate(Math.PI / 2, new Vector(1, 0, 0));
                        rightArcTop.Transform(matrix);


                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Translate(new Vector(0, HalfLength, HeightToWidthDiff + PipeToHeightDiff));
                        rightArcTop.Transform(matrix);

                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Rotate(Math.PI / 2, new Vector(0, 0, 1));
                        rightArcTop.Transform(matrix);
                        curveCollection.Add(rightArcTop);



                        //RightArcBottom
                        symbolGeometryHelper = new SymbolGeometryHelper();
                        symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                        symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        matrix.SetIdentity();
                        matrix.Rotate(RightArcBottom.StartAngle, new Vector(0, 0, 1));


                        Arc3d rightArcBottom = symbolGeometryHelper.CreateArc(null, RightArcBottom.Radius, (RightArcBottom.EndAngle - RightArcBottom.StartAngle));
                        rightArcBottom.Transform(matrix);

                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Rotate(Math.PI / 2, new Vector(1, 0, 0));
                        rightArcBottom.Transform(matrix);


                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Translate(new Vector(0, HalfLength, HeightToWidthDiff + PipeToHeightDiff));
                        rightArcBottom.Transform(matrix);

                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Rotate(Math.PI / 2, new Vector(0, 0, 1));
                        rightArcBottom.Transform(matrix);
                        curveCollection.Add(rightArcBottom);



                        //Code for drawing extension for right side of strap  

                        Line3d innerRightExtension = new Line3d(new Position(InnerRightExtension.StartX, InnerRightExtension.StartY, InnerRightExtension.StartZ), new Position(InnerRightExtension.EndX, InnerRightExtension.EndY, InnerRightExtension.EndZ));
                        curveCollection.Add(innerRightExtension);

                        Line3d outerRightExtension = new Line3d(new Position(OuterRightExtension.StartX, OuterRightExtension.StartY, OuterRightExtension.StartZ), new Position(OuterRightExtension.EndX, OuterRightExtension.EndY, OuterRightExtension.EndZ));
                        curveCollection.Add(outerRightExtension);

                        Line3d topRightExtension = new Line3d(new Position(TopRightExtension.StartX, TopRightExtension.StartY, TopRightExtension.StartZ), new Position(TopRightExtension.EndX, TopRightExtension.EndY, TopRightExtension.EndZ));
                        curveCollection.Add(topRightExtension);

                    }
                    else if (hasFlatSpot == false && hasSplitGap == false)
                    {
                        //Draws Outer Arc of Strap
                        symbolGeometryHelper = new SymbolGeometryHelper();
                        symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                        symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        matrix.SetIdentity();
                        matrix.Rotate(OuterArc.StartAngle, new Vector(0, 0, 1));

                        Arc3d outerArc = symbolGeometryHelper.CreateArc(null, OuterArc.Radius, (OuterArc.EndAngle - OuterArc.StartAngle));
                        outerArc.Transform(matrix);

                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Rotate(Math.PI / 2, new Vector(1, 0, 0));
                        outerArc.Transform(matrix);


                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Translate(new Vector(0, HalfLength, HeightToWidthDiff + PipeToHeightDiff));
                        outerArc.Transform(matrix);

                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Rotate(Math.PI / 2, new Vector(0, 0, 1));
                        outerArc.Transform(matrix);
                        curveCollection.Add(outerArc);

                        //Draws Inner Arc of Strap 
                        symbolGeometryHelper = new SymbolGeometryHelper();
                        symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                        symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        matrix.SetIdentity();
                        matrix.Rotate(InnerArc.StartAngle, new Vector(0, 0, 1));

                        Arc3d innerArc = symbolGeometryHelper.CreateArc(null, InnerArc.Radius, (InnerArc.EndAngle - InnerArc.StartAngle));
                        innerArc.Transform(matrix);

                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Rotate(Math.PI / 2, new Vector(1, 0, 0));
                        innerArc.Transform(matrix);

                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Translate(new Vector(0, HalfLength, HeightToWidthDiff + PipeToHeightDiff));
                        innerArc.Transform(matrix);

                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Rotate(Math.PI / 2, new Vector(0, 0, 1));
                        innerArc.Transform(matrix);

                        curveCollection.Add(innerArc);
                    }

                    if ((isOneSided == false && isSquare == false) || (isOneSided && isSquare == false) || (isOneSided == false && isSquare))
                    {

                        //Draws bottom right line of strap

                        Line3d bottomRighLine = new Line3d(new Position(BottomRight.StartX, BottomRight.StartY, BottomRight.StartZ), new Position(BottomRight.EndX, BottomRight.EndY, BottomRight.EndZ));

                        curveCollection.Add(bottomRighLine);
                    }

                    if (hasWings && isOneSided == false)
                    {

                        //Draws line that makes right side of right wing  
                        Line3d rightWingSide = new Line3d(new Position(RightWingSide.StartX, RightWingSide.StartY, RightWingSide.StartZ), new Position(RightWingSide.EndX, RightWingSide.EndY, RightWingSide.EndZ));
                        curveCollection.Add(rightWingSide);

                        //Draws line that makes top of right wing                   
                        Line3d rightWingTop = new Line3d(new Position(RightWingTop.StartX, RightWingTop.StartY, RightWingTop.StartZ), new Position(RightWingTop.EndX, RightWingTop.EndY, RightWingTop.EndZ));
                        curveCollection.Add(rightWingTop);
                    }

                    if ((isOneSided == false) || (isOneSided && isSquare))
                    {
                        //Draws outer right line of strap
                        Line3d outerRightLine = new Line3d(new Position(OuterRight.StartX, OuterRight.StartY, OuterRight.StartZ), new Position(OuterRight.EndX, OuterRight.EndY, OuterRight.EndZ));

                        curveCollection.Add(outerRightLine);
                    }

                    if (isOneSided == false)
                    {
                        //Draws inner right line of strap

                        Line3d innerRightLine = new Line3d(new Position(InnerRight.StartX, InnerRight.StartY, InnerRight.StartZ), new Position(InnerRight.EndX, InnerRight.EndY, InnerRight.EndZ));
                        curveCollection.Add(innerRightLine);
                    }
                    //Final Extrusion
                    ComplexString3d rightStrapLineString = new ComplexString3d(curveCollection);
                    Vector rightStrapLineVector = new Vector(1, 0, 0);
                    Projection3d rightSideStrap = new Projection3d(rightStrapLineString, rightStrapLineVector, Length, true);
                    rightSideStrap.Transform(Matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Rotate(Math.PI, new Vector(1, 0, 0));

                    Outputs.Add(outputName, rightSideStrap);

                    if (hasFlatSpot == false && hasSplitGap == true)
                    {
                        Geometry3d geom3dObj = (Geometry3d)Outputs[outputName + "Left"];
                        geom3dObj.Transform(Matrix);
                    }

                } // End If that checks that dStrapHeightInside And myStrapShape And dStrapThickness And dStrapWidthInside are not zero
            }
            catch (SmartPartSymbolException hgrEx)
            {
                throw hgrEx;
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddStrap, "Error in AddStrap");
                }
            }
        }

        /// <summary>
        /// Adds the plate.
        /// </summary>
        /// <param name="connection">The connection.</param>
        /// <param name="plate">My plate shape.</param>
        /// <param name="matrix">The matrix.</param>
        /// <param name="outputs">The outputs.</param>
        /// <param name="outputName">Name of the output.</param>
        /// <code>
        ///  matrix = new Matrix4X4();
        ///  matrix.Origin = new Position(0, 0, 0);
        ///  AddPlate(plate, matrix, m_PhysicalAspect.Outputs, "Plate");
        /// </code>
        public void AddPlate(PlateInputs plate, Matrix4X4 matrix, OutputDictionary outputs, String outputName)
        {
            try
            {
                Double dCurvedEndAlpha = 0;    // for curved top edge
                int iCount;  // point counter
                int nPts;    // number of points to use in the extrusion
                StringBuilder sError = new StringBuilder();
                if (plate.width1 <= 0 || plate.length1 <= 0 || plate.thickness1 == 0)
                {
                    sError.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidRectangularNotchsizes, "Either Width, Length or Thickness wasn't valid. Can't create a plate graphic shape"));
                    return;
                }


                // Figure out the number of vertices and the eight tangent points based on the input parameters for the four corners.
                //
                // +-------TL----TR--------+
                // |                       |
                // |                      RT
                // |                       |
                // LT                      |
                // |                       |
                // |                       |
                // LB                      |
                // |                       |
                // |                      RB
                // |                       |
                // |                       |
                // +-------BL-------BR-----+
                //
                Double TopLeftX;
                Double TopLeftY;
                Double TopRightX;
                Double TopRightY;
                Double LeftTopX;
                Double LeftTopY;
                Double RightTopX;
                Double RightTopY;
                Double LeftBottomX;
                Double LeftBottomY;
                Double RightBottomX;
                Double RightBottomY;
                Double BottomLeftX;
                Double BottomLeftY;
                Double BottomRightX;
                Double BottomRightY;

                Double CurvedEndLeftX;
                Double CurvedEndRightX;
                int CurvedEndpts;

                Double dAngleNotchStartPtX;
                Double dAngleNotchStartPtY;
                Double dAngleNotchEndPtX;
                Double dAngleNotchEndPtY;

                // Initialize them to the four corners defined by Width1 and Length
                // These won't change
                TopLeftY = plate.length1;
                TopRightY = plate.length1;
                BottomLeftY = 0;
                BottomRightY = 0;
                LeftTopX = 0;
                LeftBottomX = 0;
                RightTopX = plate.width1;
                RightBottomX = plate.width1;

                // These will change based on the corner specifications - this is redundant as they all get set later.
                TopLeftX = 0;
                TopRightX = plate.width1;
                BottomLeftX = 0;
                BottomRightX = plate.width1;
                LeftTopY = plate.length1;
                LeftBottomY = 0;
                RightTopY = plate.length1;
                RightBottomY = 0;

                CurvedEndLeftX = 0;
                CurvedEndRightX = 0;

                //Initialize point count to 1 for each corner
                CurvedEndpts = 0;
                // Clockwise starting with the Top Right
                // 1 = Top Right
                // 2 = Bottom Right
                // 3 = Bottom Left
                // 4 = Top Left
                // This is the order in which we will draw the corner graphics later
                // so let's start thinking in this order right now!
                PlateCorner[] corner = new PlateCorner[4];
                int ID;
                Collection<ICurve> curveColl = new Collection<ICurve>();
                SymbolGeometryHelper symbolGeomHlpr = new SymbolGeometryHelper();
                Matrix4X4 matrix1 = new Matrix4X4();
                for (ID = 0; ID < 4; ID++)
                {
                    corner[ID].Points = 1;
                    switch (ID)
                    {
                        case 0:
                            corner[ID].name = "Top Right";
                            corner[ID].startX = plate.width1;
                            corner[ID].startY = plate.length1;
                            corner[ID].dirX = -1;
                            corner[ID].dirY = -1;
                            corner[ID].CornerType = plate.trCornerType;
                            corner[ID].CornerX = plate.trCornerX;
                            corner[ID].CornerY = plate.trCornerY;
                            corner[ID].CornerRad = plate.trCornerRad;
                            corner[ID].pointX = plate.width1;
                            corner[ID].pointY = plate.length1;
                            break;
                        case 1:
                            corner[ID].name = "Bottom Right";
                            corner[ID].startX = plate.width1;
                            corner[ID].startY = 0;
                            corner[ID].dirX = -1;
                            corner[ID].dirY = 1;
                            corner[ID].CornerType = plate.brCornerType;
                            corner[ID].CornerX = plate.brCornerX;
                            corner[ID].CornerY = plate.brCornerY;
                            corner[ID].CornerRad = plate.brCornerRad;
                            corner[ID].pointX = plate.width1;
                            corner[ID].pointY = 0;
                            break;
                        case 2:
                            corner[ID].name = "Bottom Left";
                            corner[ID].startX = 0;
                            corner[ID].startY = 0;
                            corner[ID].dirX = 1;
                            corner[ID].dirY = 1;
                            corner[ID].CornerType = plate.blCornerType;
                            corner[ID].CornerX = plate.blCornerX;
                            corner[ID].CornerY = plate.blCornerY;
                            corner[ID].CornerRad = plate.blCornerRad;
                            corner[ID].pointX = 0;
                            corner[ID].pointY = 0;
                            break;
                        case 3:
                            corner[ID].name = "Top Left";
                            corner[ID].startX = 0;
                            corner[ID].startY = plate.length1;
                            corner[ID].dirX = 1;
                            corner[ID].dirY = -1;
                            corner[ID].CornerType = plate.tlCornerType;
                            corner[ID].CornerX = plate.tlCornerX;
                            corner[ID].CornerY = plate.tlCornerY;
                            corner[ID].CornerRad = plate.tlCornerRad;
                            corner[ID].pointX = 0;
                            corner[ID].pointY = plate.length1;
                            break;
                    }


                    // Figure out how many vertices are needed in this corner
                    // Figure out what tangent points are used for this corner type

                    switch (corner[ID].CornerType)
                    {
                        case 0:
                            // None - do nothing
                            break;

                        case 1:
                            // Rectangular Notch - specify size of notch as X and Y distances from corner, radius is ignored                
                            // Valid notch?
                            if (corner[ID].CornerX <= 0 || corner[ID].CornerX >= plate.width1 || corner[ID].CornerY <= 0 || corner[ID].CornerY >= plate.length1)
                            {
                                // Not valid. Treat as no shape
                                corner[ID].CornerX = 0;
                                corner[ID].CornerY = 0;
                                corner[ID].CornerRad = 0;
                                corner[ID].CornerType = 0; // None
                                sError.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidRectangularNotchsizes, "Rectangular Notch sizes invalid - ignoring corner type -" + corner[ID].name));
                                goto label1;
                            }

                            // Now have valid notch - set the corner points
                            corner[ID].pointX = corner[ID].startX + corner[ID].dirX * corner[ID].CornerX;
                            corner[ID].pointY = corner[ID].startY + corner[ID].dirY * corner[ID].CornerY;
                            corner[ID].Points = 3;
                            break;
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            //2 - AngleXYChamfer  Angled Notch - X and Y chamfer sizes
                            //3 - AngleXYEdges    Angled Notch - X and Y edge sizes
                            //4 - AngleXwithAngle Angled Notch - X notch size and angle
                            //5 - AngleYwithAngle Angled Notch - Y notch size and angle
                            // Convert all to the same as 2, XY Chamfer

                            if (corner[ID].CornerType == 3)  //3 - AngleXYEdges - convert from edges to chamfer sizes
                            {
                                corner[ID].CornerX = plate.width1 - corner[ID].CornerX;
                                corner[ID].CornerY = plate.length1 - corner[ID].CornerY;
                            }

                            if (corner[ID].CornerType == 4)  //4 - AngleXwithAngle
                            {
                                // The Y should contain an angle, in degrees. Calculate Y from X and this angle
                                // First, massage the angle value if necessary - here's why:
                                // 1. angles are entered in XLS in the X, Y attributes
                                // 2. these attributes have distance units of mm in the CustomInterfaces sheet
                                // 3. these attributes are then stored in the database in the standard db length units of meters.
                                // 4. an angle of 30 is stored in the db as 0.030m, which makes for bloody small angles in this function
                                // 5. so, if the angle is tiny, multiply it by 1000 to get back to the original number from the XLS
                                // 6. if the angle is NOT tiny, leave it alone as it is already valid.
                                if (corner[ID].CornerY > Common.Middle.Math3d.DistanceTolerance && corner[ID].CornerY <= 0.361)
                                    corner[ID].CornerY = corner[ID].CornerY * 1000;

                                corner[ID].Beta = corner[ID].CornerY;
                                corner[ID].CornerY = corner[ID].CornerX * Common.Middle.Math3d.TanDeg(corner[ID].Beta);
                            }

                            if (corner[ID].CornerType == 5)  //5 - AngleYwithAngle
                            {
                                // The X should contain an angle, in degrees. Calculate X from Y and this angle
                                // First, massage the angle value if necessary - see comment above for corner type 4
                                if (corner[ID].CornerX > Common.Middle.Math3d.DistanceTolerance && corner[ID].CornerX <= 0.361)
                                    corner[ID].CornerX = corner[ID].CornerX * 1000;

                                corner[ID].Alpha = corner[ID].CornerX;
                                corner[ID].CornerX = corner[ID].CornerY * Common.Middle.Math3d.TanDeg(corner[ID].Alpha);
                            }

                            // Valid notch?
                            if (corner[ID].CornerX <= 0 || corner[ID].CornerY <= 0)
                            {
                                // Not valid, notch must have positive sizes to be visible. Treat as None for top corner
                                corner[ID].CornerX = 0;
                                corner[ID].CornerY = 0;
                                corner[ID].CornerRad = 0;
                                corner[ID].CornerType = 0; // None
                                sError.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidAngledNotchsizes, "Angled Notch sizes invalid - ignoring corner type-" + corner[ID].name));
                                goto label1;
                            }

                            // Since the angle notch can be radiused, we need to consider the rounding radius and check the dimensions
                            if (corner[ID].CornerRad > 0)
                            {
                                corner[ID].Alpha = Math.Atan(corner[ID].CornerX / corner[ID].CornerY); // checked earlier so we know CornerY is not zero
                                corner[ID].Beta = Math.Atan(corner[ID].CornerY / corner[ID].CornerX); // checked earlier so we know CornerX is not zero
                                iCount = 4; // each corner will require 4 points but don't set it yet as we have more validity checking to do

                                corner[ID].RoundedX = true;
                                corner[ID].RoundedY = true;

                                // If the notch starts exactly on a corner, don't round it.
                                if (Math.Abs(corner[ID].CornerX - plate.width1) < Common.Middle.Math3d.DistanceTolerance)
                                {
                                    iCount = iCount - 1;
                                    corner[ID].RoundedX = false;
                                }
                                if (Math.Abs(corner[ID].CornerY - plate.length1) < Common.Middle.Math3d.DistanceTolerance)
                                {
                                    iCount = iCount - 1;
                                    corner[ID].RoundedY = false;
                                }

                                // If the notch starts exactly in BOTH corners, we can ignore the specified radius since neither end
                                // of the notch will be rounded.
                                if (iCount == 2)
                                {
                                    corner[ID].CornerRad = 0;
                                }
                            }
                            else
                            {
                                corner[ID].Alpha = 0;
                                corner[ID].Beta = 0;
                                iCount = 2; // each corner will require 2 points but don't set it yet as we have more validity checking to do
                            }

                            if (corner[ID].RoundedX == true)
                            {
                                // We ARE rounding this end of the notch so check to make sure the rounded corner fits within the plate
                                if (corner[ID].CornerX + corner[ID].CornerRad * Math.Tan(corner[ID].Beta / 2) > plate.width1)
                                {
                                    corner[ID].CornerX = 0;
                                    corner[ID].CornerY = 0;
                                    corner[ID].CornerRad = 0;
                                    corner[ID].CornerType = 0; // None
                                    sError.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidAngledNotchX, "Angled Notch X size with specified radius is larger than plate width - ignoring corner type " + corner[ID].name));
                                    goto label1;
                                }
                            }

                            if (corner[ID].RoundedY == true)
                            {
                                // We ARE rounding this end of the notch so check to make sure the rounded corner fits within the plate
                                if (corner[ID].CornerY + corner[ID].CornerRad * Math.Tan(corner[ID].Alpha / 2) > plate.length1)
                                {
                                    corner[ID].CornerX = 0;
                                    corner[ID].CornerY = 0;
                                    corner[ID].CornerRad = 0;
                                    corner[ID].CornerType = 0; // None
                                    sError.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidAngledNotchY, "Angled Notch Y size with specified radius is larger than plate width - ignoring corner type " + corner[ID].name));
                                    goto label1;
                                }
                            }

                            // Now have valid notch - set the corner points
                            if (corner[ID].RoundedX == true)
                                // Rounded
                                corner[ID].pointX = corner[ID].startX + corner[ID].dirX * (corner[ID].CornerX + corner[ID].CornerRad * Math.Tan(corner[ID].Beta / 2));
                            else
                                // Sharp
                                corner[ID].pointX = corner[ID].startX + corner[ID].dirX * corner[ID].CornerX;

                            if (corner[ID].RoundedY == true)
                                // Rounded
                                corner[ID].pointY = corner[ID].startY + corner[ID].dirY * (corner[ID].CornerY + corner[ID].CornerRad * Math.Tan(corner[ID].Alpha / 2));
                            else
                                // Sharp
                                corner[ID].pointY = corner[ID].startY + corner[ID].dirY * corner[ID].CornerY;

                            corner[ID].Points = iCount;
                            break;
                        case 6:
                            // Round Notch - specify radius of notch, and X and Y offsets from corner

                            // Check if round notch is offset too far off the plate. if (so, ignore it.
                            if (corner[ID].CornerX < 0 && corner[ID].CornerY < 0)
                            {
                                if (Math.Pow((corner[ID].CornerX * corner[ID].CornerX + corner[ID].CornerY * corner[ID].CornerY), 2) >= corner[ID].CornerRad)
                                {
                                    corner[ID].CornerX = 0;
                                    corner[ID].CornerY = 0;
                                    corner[ID].CornerRad = 0;
                                    corner[ID].CornerType = 0; // None
                                    sError.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidRoundNotch, "Round Notch is offset too far off plate, not visible - ignoring corner type " + corner[ID].name));
                                    goto label1;
                                }
                            }

                            if ((corner[ID].CornerX < 0 && Math.Abs(corner[ID].CornerX) >= corner[ID].CornerRad) || (corner[ID].CornerY < 0 && Math.Abs(corner[ID].CornerY) >= corner[ID].CornerRad))
                            {
                                corner[ID].CornerX = 0;
                                corner[ID].CornerY = 0;
                                corner[ID].CornerRad = 0;
                                corner[ID].CornerType = 0; // None
                                sError.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidRoundNotchXorY, "Round Notch X or Y is offset too far off plate, not visible - ignoring corner type " + corner[ID].name));
                                goto label1;
                            }

                            if (corner[ID].CornerRad <= 0)
                            {
                                corner[ID].CornerX = 0;
                                corner[ID].CornerY = 0;
                                corner[ID].CornerRad = 0;
                                corner[ID].CornerType = 0; // None
                                sError.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidRoundNotchRadius, "Round Notch has invalid radius - ignoring corner type " + corner[ID].name));
                                goto label1;
                            }

                            // Calculate the angles for negative offsets, zero for no offset or positive offset
                            if (corner[ID].CornerX < 0)

                                corner[ID].Beta = Math.Asin(Math.Abs(corner[ID].CornerX) / corner[ID].CornerRad); // checked earlier so we know corner[ID].dCornerRad is not zero;
                            else
                                corner[ID].Beta = 0;


                            if (corner[ID].CornerY < 0)
                                corner[ID].Alpha = Math.Asin(Math.Abs(corner[ID].CornerY) / corner[ID].CornerRad); // checked earlier so we know corner[ID].dCornerRad is not zero
                            else
                                corner[ID].Alpha = 0;


                            if (corner[ID].CornerX + corner[ID].CornerRad * Math.Cos(corner[ID].Alpha) > plate.width1)
                            {
                                corner[ID].CornerX = 0;
                                corner[ID].CornerY = 0;
                                corner[ID].CornerType = 0; // None
                                sError.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidRoundCornerRadius, "Round Notch radius with specified offsets is larger than plate width - ignoring corner type " + corner[ID].name));
                                goto label1;
                            }

                            if (corner[ID].CornerY + corner[ID].CornerRad * Math.Cos(corner[ID].Beta) > plate.length1)
                            {
                                corner[ID].CornerX = 0;
                                corner[ID].CornerY = 0;
                                corner[ID].CornerType = 0; // None
                                sError.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidRoundCornerRadius, "Round Notch radius with specified offsets is larger than plate width - ignoring corner type " + corner[ID].name));
                                goto label1;
                            }

                            // How many points in the corners
                            iCount = 2;
                            if (corner[ID].CornerX > 0) iCount = iCount + 1;
                            if (corner[ID].CornerY > 0) iCount = iCount + 1;

                            // Now have valid notch - set the corner points
                            corner[ID].pointX = corner[ID].startX + corner[ID].dirX * (corner[ID].CornerX + corner[ID].CornerRad * Math.Cos(corner[ID].Alpha));
                            corner[ID].pointY = corner[ID].startY + corner[ID].dirY * (corner[ID].CornerY + corner[ID].CornerRad * Math.Cos(corner[ID].Beta));
                            corner[ID].Points = iCount;
                            break;
                        case 7:
                            // Rounded Corner - specify radius of rounding, and X and Y offsets from corner.

                            // Make sure the radius is specified
                            if (corner[ID].CornerRad <= 0)
                            {
                                corner[ID].CornerX = 0;
                                corner[ID].CornerY = 0;
                                corner[ID].CornerRad = 0;
                                corner[ID].CornerType = 0; // None
                                sError.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidRoundCornerRadius, "Rounded Corner has invalid radius - ignoring corner type " + corner[ID].name));
                                goto label1;
                            }

                            // Check if offsets are validly negative
                            if (corner[ID].CornerX > 0)
                            {
                                corner[ID].CornerX = -corner[ID].CornerX;
                                sError.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidRoundTopCornerX, "Rounded Top Corner has positive X offset, not allowed - using negative of value"));
                            }
                            if (corner[ID].CornerY > 0)
                            {
                                corner[ID].CornerY = -corner[ID].CornerY;
                                sError.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidRoundTopCornerY, "Rounded Top Corner has positive Y offset, not allowed - using negative of value"));
                            }

                            // Calculate the angles
                            if (corner[ID].CornerY < 0)

                                corner[ID].Beta = Math.Acos((corner[ID].CornerRad + corner[ID].CornerY) / corner[ID].CornerRad); // checked earlier so we know corner[ID].dCornerRad is not zero
                            else
                                corner[ID].Beta = 0;


                            if (corner[ID].CornerX < 0)

                                corner[ID].Alpha = Math.Acos((corner[ID].CornerRad + corner[ID].CornerX) / corner[ID].CornerRad); // checked earlier so we know corner[ID].dCornerRad is not zero
                            else
                                corner[ID].Alpha = 0;


                            // Check if the offset rounding will still be visible on the plate
                            if (corner[ID].CornerRad * Math.Sin(corner[ID].Beta) > corner[ID].CornerRad + corner[ID].CornerX || corner[ID].CornerRad * Math.Sin(corner[ID].Alpha) > corner[ID].CornerRad + corner[ID].CornerY)
                            {
                                corner[ID].CornerX = 0;
                                corner[ID].CornerY = 0;
                                corner[ID].CornerRad = 0;
                                corner[ID].CornerType = 0; // None
                                sError.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidRoundCornerOffset, "Rounded Corner with offsets would be off the plate - ignoring " + corner[ID].name));
                                goto label1;
                            }

                            if (corner[ID].CornerRad + corner[ID].CornerX - corner[ID].CornerRad * Math.Sin(corner[ID].Beta) > plate.width1)
                            {
                                corner[ID].CornerX = 0;
                                corner[ID].CornerY = 0;
                                corner[ID].CornerType = 0; // None
                                sError.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidRoundCornerOffset, "Round Corner with offsets larger than plate width - ignoring " + corner[ID].name));
                                goto label1;
                            }

                            if (corner[ID].CornerRad + corner[ID].CornerY - corner[ID].CornerRad * Math.Sin(corner[ID].Alpha) > plate.length1)
                            {
                                corner[ID].CornerX = 0;
                                corner[ID].CornerY = 0;
                                corner[ID].CornerType = 0; // None
                                sError.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidRCOffsettGTPlateWidth, "Round Corner with offsets larger than plate width - ignoring " + corner[ID].name));
                                goto label1;
                            }

                            // Now have valid notch - set the corner points
                            corner[ID].pointX = corner[ID].startX + corner[ID].dirX * (corner[ID].CornerRad + corner[ID].CornerX - corner[ID].CornerRad * Math.Sin(corner[ID].Beta));
                            corner[ID].pointY = corner[ID].startY + corner[ID].dirY * (corner[ID].CornerRad + corner[ID].CornerY - corner[ID].CornerRad * Math.Sin(corner[ID].Alpha));
                            corner[ID].Points = 2;
                            break;
                    }
                label1:
                    switch (ID)
                    {
                        case 0:  // Top Right
                            TopRightX = corner[ID].pointX;
                            RightTopY = corner[ID].pointY;
                            break;
                        case 1:  // Bottom Right
                            BottomRightX = corner[ID].pointX;
                            RightBottomY = corner[ID].pointY;
                            break;
                        case 2:  // Bottom Left
                            BottomLeftX = corner[ID].pointX;
                            LeftBottomY = corner[ID].pointY;
                            break;
                        case 3:  // Top Left
                            TopLeftX = corner[ID].pointX;
                            LeftTopY = corner[ID].pointY;
                            break;
                    }
                }
                // Check if there's a request for a curved notch in the top edge, and if there's room for it
                if (plate.curvedEndRad > 0)
                {
                    // Requested a curved notch in the top edge. Make sure Y offset is not too far off or on to the plate
                    if (Math.Abs(plate.curvedEndY) >= plate.curvedEndRad)
                    {
                        plate.curvedEndRad = 0;
                        plate.curvedEndX = 0;
                        plate.curvedEndY = 0; // None
                        sError.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidCurveEndY, "Curved End Y offset is greater than specified Curved End radius - ignoring Curved End."));
                        goto label2;
                    }

                    dCurvedEndAlpha = Math.Acos(plate.curvedEndY / plate.curvedEndRad);
                    CurvedEndLeftX = plate.width1 / 2 + plate.curvedEndX - plate.curvedEndRad * Math.Sin(dCurvedEndAlpha);
                    CurvedEndRightX = plate.width1 / 2 + plate.curvedEndX + plate.curvedEndRad * Math.Sin(dCurvedEndAlpha);

                    double tempCurvedEndLeftX = Math.Round(CurvedEndLeftX, 10);
                    double tempCurvedEndRightX = Math.Round(CurvedEndRightX, 10);

                    if (Math.Round(tempCurvedEndLeftX, 4) < Math.Round(TopLeftX, 4) || Math.Round(tempCurvedEndRightX, 4) > Math.Round(TopRightX, 4))
                    {
                        plate.curvedEndRad = 0;
                        plate.curvedEndX = 0;
                        plate.curvedEndY = 0; // None
                        CurvedEndRightX = 0;
                        CurvedEndLeftX = 0;
                        sError.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidCurveEnd, "Curved End doesn't fit on remaining top edge - ignoring Curved End."));
                        goto label2;
                    }

                    // We know there will be a curved notch in the top edge. If the end points of the curve
                    // won't exactly match the existing TopLeft and TopRight tangent points, we'll need
                    // extra lines, and thus extra points.
                    if (CurvedEndLeftX > TopLeftX && Math.Abs(CurvedEndLeftX - TopLeftX) > Common.Middle.Math3d.DistanceTolerance)
                        CurvedEndpts = CurvedEndpts + 1;
                    if (CurvedEndRightX < TopRightX && Math.Abs(CurvedEndRightX - TopRightX) > Common.Middle.Math3d.DistanceTolerance)
                        CurvedEndpts = CurvedEndpts + 1;

                }
            label2:
                // ************************************************************************************************************************************    
                // Now, we know how many points to use so we can do our extrusion
                nPts = corner[0].Points + corner[1].Points + corner[2].Points + corner[3].Points + CurvedEndpts;
                // If there are coincident points, we need less pieces in the extrusion
                if (Math.Abs(TopLeftX - TopRightX) < Common.Middle.Math3d.DistanceTolerance)
                    nPts = nPts - 1;
                if (Math.Abs(RightTopY - RightBottomY) < Common.Middle.Math3d.DistanceTolerance)
                    nPts = nPts - 1;
                if (Math.Abs(BottomLeftX - BottomRightX) < Common.Middle.Math3d.DistanceTolerance)
                    nPts = nPts - 1;
                if (Math.Abs(LeftTopY - LeftBottomY) < Common.Middle.Math3d.DistanceTolerance)
                    nPts = nPts - 1;

                iCount = 1;


                // Draw top right corner
                ID = 0;
                switch (corner[ID].CornerType)
                {
                    case 0:
                        // None - do nothing
                        break;
                    case 1:
                        // Rectangular Notch
                        // Draw from TR to inside corner to RT
                        Line3d line = new Line3d(new Position(TopRightX, TopRightY, 0), new Position(TopRightX, RightTopY, 0));
                        curveColl.Add(line);
                        iCount = iCount + 1;
                        line = new Line3d(new Position(TopRightX, RightTopY, 0), new Position(RightTopX, RightTopY, 0));
                        curveColl.Add(line);
                        iCount = iCount + 1;
                        break;
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        if (corner[ID].CornerRad > 0)
                        {
                            // Rounded
                            if (corner[ID].RoundedX == true)
                            {
                                symbolGeomHlpr.ActivePosition = new Position(0, 0, 0);
                                symbolGeomHlpr.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                                Arc3d arc = symbolGeomHlpr.CreateArc(null, corner[ID].CornerRad, (90 - Math3d.Deg(corner[ID].Alpha)) * Math.PI / 180);
                                matrix1 = new Matrix4X4();
                                matrix1.SetIdentity();
                                matrix1.Rotate(Math3d.Deg(corner[ID].Alpha) * Math.PI / 180, new Vector(0, 0, 1));
                                arc.Transform(matrix1);

                                matrix1 = new Matrix4X4();
                                matrix1.SetIdentity();
                                matrix1.Translate(new Vector(TopRightX, TopRightY - corner[ID].CornerRad, 0));
                                arc.Transform(matrix1);

                                curveColl.Add(arc);
                                iCount = iCount + 1;
                                dAngleNotchStartPtX = TopRightX + corner[ID].CornerRad * Math.Sin(corner[ID].Beta);
                                dAngleNotchStartPtY = TopRightY - corner[ID].CornerRad + corner[ID].CornerRad * Math.Cos(corner[ID].Beta);
                            }
                            else
                            {
                                dAngleNotchStartPtX = TopRightX;
                                dAngleNotchStartPtY = TopRightY;
                            }

                            if (corner[ID].RoundedY == true)
                            {
                                dAngleNotchEndPtX = RightTopX - corner[ID].CornerRad + corner[ID].CornerRad * Math.Cos(corner[ID].Alpha);
                                dAngleNotchEndPtY = RightTopY + corner[ID].CornerRad * Math.Sin(corner[ID].Alpha);
                            }
                            else
                            {
                                dAngleNotchEndPtX = RightTopX;
                                dAngleNotchEndPtY = RightTopY;
                            }
                            line = new Line3d(new Position(dAngleNotchStartPtX, dAngleNotchStartPtY, 0), new Position(dAngleNotchEndPtX, dAngleNotchEndPtY, 0));
                            curveColl.Add(line);

                            iCount = iCount + 1;

                            if (corner[ID].RoundedY == true)
                            {
                                symbolGeomHlpr = new SymbolGeometryHelper();
                                symbolGeomHlpr.ActivePosition = new Position(0, 0, 0);
                                symbolGeomHlpr.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                                Arc3d arc = symbolGeomHlpr.CreateArc(null, corner[ID].CornerRad, Math3d.Deg(corner[ID].Alpha) * Math.PI / 180);

                                matrix1 = new Matrix4X4();
                                matrix1.SetIdentity();
                                matrix1.Translate(new Vector(RightTopX - corner[ID].CornerRad, RightTopY, 0));
                                arc.Transform(matrix1);

                                curveColl.Add(arc);
                                iCount = iCount + 1;
                            }

                        }
                        else
                        {
                            // No rounding, just draw one line
                            line = new Line3d(new Position(TopRightX, TopRightY, 0), new Position(RightTopX, RightTopY, 0));
                            curveColl.Add(line);
                            iCount = iCount + 1;
                        }

                        break;
                    case 6:
                        // Round Notch
                        if (corner[ID].CornerY > 0)
                        {
                            line = new Line3d(new Position(TopRightX, TopRightY, 0), new Position(TopRightX, TopRightY - corner[ID].CornerY, 0));
                            curveColl.Add(line);
                            iCount = iCount + 1;
                        }
                        symbolGeomHlpr = new SymbolGeometryHelper();
                        symbolGeomHlpr.ActivePosition = new Position(0, 0, 0);
                        symbolGeomHlpr.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        Arc3d arc1 = symbolGeomHlpr.CreateArc(null, corner[ID].CornerRad, (90 - Math3d.Deg(corner[ID].Alpha) - Math3d.Deg(corner[ID].Beta)) * Math.PI / 180);
                        matrix1 = new Matrix4X4();
                        matrix1.SetIdentity();
                        matrix1.Rotate((180 + Math3d.Deg(corner[ID].Alpha)) * Math.PI / 180, new Vector(0, 0, 1));
                        arc1.Transform(matrix1);

                        matrix1 = new Matrix4X4();
                        matrix1.SetIdentity();
                        matrix1.Translate(new Vector(plate.width1 - corner[ID].CornerX, plate.length1 - corner[ID].CornerY, 0));
                        arc1.Transform(matrix1);
                        curveColl.Add(arc1);
                        iCount = iCount + 1;
                        if (corner[ID].CornerX > 0)
                        {
                            line = new Line3d(new Position(RightTopX - corner[ID].CornerX, RightTopY, 0), new Position(RightTopX, RightTopY, 0));
                            curveColl.Add(line);
                            iCount = iCount + 1;
                        }
                        break;
                    case 7:

                        // Rounded Corner
                        symbolGeomHlpr = new SymbolGeometryHelper();
                        symbolGeomHlpr.ActivePosition = new Position(0, 0, 0);
                        symbolGeomHlpr.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        arc1 = symbolGeomHlpr.CreateArc(null, corner[ID].CornerRad, (90 - Math3d.Deg(corner[ID].Alpha) - Math3d.Deg(corner[ID].Beta)) * Math.PI / 180);
                        matrix1 = new Matrix4X4();
                        matrix1.SetIdentity();
                        matrix1.Rotate((Math3d.Deg(corner[ID].Alpha)) * Math.PI / 180, new Vector(0, 0, 1));
                        arc1.Transform(matrix1);

                        matrix1 = new Matrix4X4();
                        matrix1.SetIdentity();
                        matrix1.Translate(new Vector(plate.width1 - (corner[ID].CornerRad + corner[ID].CornerX), plate.length1 - (corner[ID].CornerRad + corner[ID].CornerY), 0));
                        arc1.Transform(matrix1);
                        curveColl.Add(arc1);
                        iCount = iCount + 1;
                        break;
                }
                // Draw optional line from Top Right corner to Bottom Right corner
                if (Math.Abs(RightTopY - RightBottomY) >= Math3d.DistanceTolerance)
                {
                    Line3d line = new Line3d(new Position(RightTopX, RightTopY, 0), new Position(RightBottomX, RightBottomY, 0));
                    curveColl.Add(line);
                    iCount = iCount + 1;
                }

                // Draw bottom right corner
                ID = 1;
                switch (corner[ID].CornerType)
                {
                    case 0:
                        // None - do nothing
                        break;
                    case 1:
                        // Rectangular Notch
                        // Draw from TR to inside corner to RT
                        Line3d line = new Line3d(new Position(RightBottomX, RightBottomY, 0), new Position(BottomRightX, RightBottomY, 0));
                        curveColl.Add(line);
                        iCount = iCount + 1;
                        line = new Line3d(new Position(BottomRightX, RightBottomY, 0), new Position(BottomRightX, BottomRightY, 0));
                        curveColl.Add(line);
                        iCount = iCount + 1;
                        break;
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        // Angle Notch
                        if (corner[ID].CornerRad > 0)
                        {
                            // Rounded
                            if (corner[ID].RoundedY == true)
                            {
                                symbolGeomHlpr = new SymbolGeometryHelper();
                                symbolGeomHlpr.ActivePosition = new Position(0, 0, 0);
                                symbolGeomHlpr.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                                Arc3d arc1 = symbolGeomHlpr.CreateArc(null, corner[ID].CornerRad, Math3d.Deg(corner[ID].Alpha) * Math.PI / 180);
                                matrix1 = new Matrix4X4();
                                matrix1.SetIdentity();
                                matrix1.Rotate((360 - Math3d.Deg(corner[ID].Alpha)) * Math.PI / 180, new Vector(0, 0, 1));
                                arc1.Transform(matrix1);

                                matrix1 = new Matrix4X4();
                                matrix1.SetIdentity();
                                matrix1.Translate(new Vector(RightBottomX - corner[ID].CornerRad, RightBottomY, 0));
                                arc1.Transform(matrix1);
                                curveColl.Add(arc1);

                                iCount = iCount + 1;

                                dAngleNotchStartPtX = RightBottomX - corner[ID].CornerRad + corner[ID].CornerRad * Math.Cos(corner[ID].Alpha);
                                dAngleNotchStartPtY = RightBottomY - corner[ID].CornerRad * Math.Sin(corner[ID].Alpha);
                            }
                            else
                            {
                                dAngleNotchStartPtX = RightBottomX;
                                dAngleNotchStartPtY = RightBottomY;
                            }

                            if (corner[ID].RoundedX == true)
                            {
                                dAngleNotchEndPtX = BottomRightX + corner[ID].CornerRad * Math.Sin(corner[ID].Beta);
                                dAngleNotchEndPtY = BottomRightY + corner[ID].CornerRad - corner[ID].CornerRad * Math.Cos(corner[ID].Beta);
                            }
                            else
                            {
                                dAngleNotchEndPtX = BottomRightX;
                                dAngleNotchEndPtY = BottomRightY;
                            }
                            line = new Line3d(new Position(dAngleNotchStartPtX, dAngleNotchStartPtY, 0), new Position(dAngleNotchEndPtX, dAngleNotchEndPtY, 0));
                            curveColl.Add(line);
                            iCount = iCount + 1;

                            if (corner[ID].RoundedX == true)
                            {
                                symbolGeomHlpr = new SymbolGeometryHelper();
                                symbolGeomHlpr.ActivePosition = new Position(0, 0, 0);
                                symbolGeomHlpr.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                                Arc3d arc1 = symbolGeomHlpr.CreateArc(null, corner[ID].CornerRad, (90 - Math3d.Deg(corner[ID].Alpha)) * Math.PI / 180);
                                matrix1 = new Matrix4X4();
                                matrix1.SetIdentity();
                                matrix1.Rotate((270) * Math.PI / 180, new Vector(0, 0, 1));
                                arc1.Transform(matrix1);

                                matrix1 = new Matrix4X4();
                                matrix1.SetIdentity();
                                matrix1.Translate(new Vector(BottomRightX, BottomRightY + corner[ID].CornerRad, 0));
                                arc1.Transform(matrix1);

                                curveColl.Add(arc1);
                                iCount = iCount + 1;
                            }
                        }
                        else
                        {
                            line = new Line3d(new Position(RightBottomX, RightBottomY, 0), new Position(BottomRightX, BottomRightY, 0));
                            curveColl.Add(line);
                            iCount = iCount + 1;
                        }
                        break;
                    case 6:
                        // Round Notch
                        if (corner[ID].CornerX > 0)
                        {
                            line = new Line3d(new Position(RightBottomX, RightBottomY, 0), new Position(RightBottomX - corner[ID].CornerX, RightBottomY, 0));
                            curveColl.Add(line);
                            iCount = iCount + 1;
                        }
                        symbolGeomHlpr = new SymbolGeometryHelper();
                        symbolGeomHlpr.ActivePosition = new Position(0, 0, 0);
                        symbolGeomHlpr.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        Arc3d arc = symbolGeomHlpr.CreateArc(null, corner[ID].CornerRad, (90 - Math3d.Deg(corner[ID].Alpha) - Math3d.Deg(corner[ID].Beta)) * Math.PI / 180);
                        matrix1 = new Matrix4X4();
                        matrix1.SetIdentity();
                        matrix1.Rotate((90 + Math3d.Deg(corner[ID].Beta)) * Math.PI / 180, new Vector(0, 0, 1));
                        arc.Transform(matrix1);

                        matrix1 = new Matrix4X4();
                        matrix1.SetIdentity();
                        matrix1.Translate(new Vector(plate.width1 - corner[ID].CornerX, corner[ID].CornerY, 0));
                        arc.Transform(matrix1);

                        curveColl.Add(arc);
                        iCount = iCount + 1;

                        if (corner[ID].CornerY > 0)
                        {
                            line = new Line3d(new Position(BottomRightX, BottomRightY + corner[ID].CornerY, 0), new Position(BottomRightX, BottomRightY, 0));
                            curveColl.Add(line);
                            iCount = iCount + 1;
                        }
                        break;
                    case 7:
                        // Rounded Corner
                        symbolGeomHlpr = new SymbolGeometryHelper();
                        symbolGeomHlpr.ActivePosition = new Position(0, 0, 0);
                        symbolGeomHlpr.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        arc = symbolGeomHlpr.CreateArc(null, corner[ID].CornerRad, (90 - Math3d.Deg(corner[ID].Alpha) - Math3d.Deg(corner[ID].Beta)) * Math.PI / 180);
                        matrix1 = new Matrix4X4();
                        matrix1.SetIdentity();
                        matrix1.Rotate((270 + Math3d.Deg(corner[ID].Beta)) * Math.PI / 180, new Vector(0, 0, 1));
                        arc.Transform(matrix1);

                        matrix1 = new Matrix4X4();
                        matrix1.SetIdentity();
                        matrix1.Translate(new Vector(plate.width1 - (corner[ID].CornerRad + corner[ID].CornerX), corner[ID].CornerRad + corner[ID].CornerY, 0));
                        arc.Transform(matrix1);
                        curveColl.Add(arc);
                        iCount = iCount + 1;
                        break;
                }

                // Draw optional line from Bottom Right corner to Bottom Left corner
                if (Math.Abs(BottomRightX - BottomLeftX) >= Math3d.DistanceTolerance)
                {
                    Line3d line = new Line3d(new Position(BottomRightX, BottomRightY, 0), new Position(BottomLeftX, BottomLeftY, 0));
                    curveColl.Add(line);
                    iCount = iCount + 1;
                }

                // Draw bottom left corner
                ID = 2;
                switch (corner[ID].CornerType)
                {
                    case 0:
                        // None - do nothing
                        break;
                    case 1:
                        // Rectangular Notch
                        // Draw from TR to inside corner to RT
                        Line3d line = new Line3d(new Position(BottomLeftX, BottomLeftY, 0), new Position(BottomLeftX, LeftBottomY, 0));
                        curveColl.Add(line);
                        iCount = iCount + 1;
                        line = new Line3d(new Position(BottomLeftX, LeftBottomY, 0), new Position(LeftBottomX, LeftBottomY, 0));
                        curveColl.Add(line);
                        iCount = iCount + 1;
                        break;
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        // Angle Notch
                        if (corner[ID].CornerRad > 0)
                        {
                            // Rounded
                            if (corner[ID].RoundedX == true)
                            {
                                symbolGeomHlpr = new SymbolGeometryHelper();
                                symbolGeomHlpr.ActivePosition = new Position(0, 0, 0);
                                symbolGeomHlpr.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                                Arc3d arc = symbolGeomHlpr.CreateArc(null, corner[ID].CornerRad, (90 - Common.Middle.Math3d.Deg(corner[ID].Alpha)) * Math.PI / 180);
                                matrix1 = new Matrix4X4();
                                matrix1.SetIdentity();
                                matrix1.Rotate((180 + Math3d.Deg(corner[ID].Alpha)) * Math.PI / 180, new Vector(0, 0, 1));
                                arc.Transform(matrix1);

                                matrix1 = new Matrix4X4();
                                matrix1.SetIdentity();
                                matrix1.Translate(new Vector(BottomLeftX, BottomLeftY + corner[ID].CornerRad, 0));
                                arc.Transform(matrix1);
                                curveColl.Add(arc);
                                iCount = iCount + 1;

                                dAngleNotchStartPtX = BottomLeftX - corner[ID].CornerRad * Math.Sin(corner[ID].Beta);
                                dAngleNotchStartPtY = BottomLeftY + corner[ID].CornerRad - corner[ID].CornerRad * Math.Cos(corner[ID].Beta);
                            }
                            else
                            {
                                dAngleNotchStartPtX = BottomLeftX;
                                dAngleNotchStartPtY = BottomLeftY;
                            }

                            if (corner[ID].RoundedY == true)
                            {
                                dAngleNotchEndPtX = LeftBottomX + corner[ID].CornerRad - corner[ID].CornerRad * Math.Cos(corner[ID].Alpha);
                                dAngleNotchEndPtY = LeftBottomY - corner[ID].CornerRad * Math.Sin(corner[ID].Alpha);
                            }
                            else
                            {
                                dAngleNotchEndPtX = LeftBottomX;
                                dAngleNotchEndPtY = LeftBottomY;
                            }
                            line = new Line3d(new Position(dAngleNotchStartPtX, dAngleNotchStartPtY, 0), new Position(dAngleNotchEndPtX, dAngleNotchEndPtY, 0));
                            curveColl.Add(line);
                            iCount = iCount + 1;

                            if (corner[ID].RoundedY == true)
                            {
                                symbolGeomHlpr = new SymbolGeometryHelper();
                                symbolGeomHlpr.ActivePosition = new Position(0, 0, 0);
                                symbolGeomHlpr.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                                Arc3d arc = symbolGeomHlpr.CreateArc(null, corner[ID].CornerRad, (Common.Middle.Math3d.Deg(corner[ID].Alpha)) * Math.PI / 180);
                                matrix1 = new Matrix4X4();
                                matrix1.SetIdentity();
                                matrix1.Rotate((180) * Math.PI / 180, new Vector(0, 0, 1));
                                arc.Transform(matrix1);

                                matrix1 = new Matrix4X4();
                                matrix1.SetIdentity();
                                matrix1.Translate(new Vector(LeftBottomX + corner[ID].CornerRad, LeftBottomY, 0));
                                arc.Transform(matrix1);
                                curveColl.Add(arc);
                                iCount = iCount + 1;
                            }
                        }
                        else
                        {
                            line = new Line3d(new Position(BottomLeftX, BottomLeftY, 0), new Position(LeftBottomX, LeftBottomY, 0));
                            curveColl.Add(line);
                            iCount = iCount + 1;
                        }
                        break;
                    case 6:
                        // Round Notch
                        if (corner[ID].CornerY > 0)
                        {
                            line = new Line3d(new Position(BottomLeftX, BottomLeftY, 0), new Position(BottomLeftX, BottomLeftY + corner[ID].CornerY, 0));
                            curveColl.Add(line);
                            iCount = iCount + 1;
                        }
                        symbolGeomHlpr = new SymbolGeometryHelper();
                        symbolGeomHlpr.ActivePosition = new Position(0, 0, 0);
                        symbolGeomHlpr.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        Arc3d arc1 = symbolGeomHlpr.CreateArc(null, corner[ID].CornerRad, (90 - Common.Middle.Math3d.Deg(corner[ID].Alpha) - Common.Middle.Math3d.Deg(corner[ID].Beta)) * Math.PI / 180);
                        matrix1 = new Matrix4X4();
                        matrix1.SetIdentity();
                        matrix1.Rotate((Math3d.Deg(corner[ID].Alpha)) * Math.PI / 180, new Vector(0, 0, 1));
                        arc1.Transform(matrix1);

                        matrix1 = new Matrix4X4();
                        matrix1.SetIdentity();
                        matrix1.Translate(new Vector(corner[ID].CornerX, corner[ID].CornerY, 0));
                        arc1.Transform(matrix1);

                        curveColl.Add(arc1);
                        iCount = iCount + 1;

                        if (corner[ID].CornerX > 0)
                        {
                            line = new Line3d(new Position(LeftBottomX + corner[ID].CornerX, LeftBottomY, 0), new Position(LeftBottomX, LeftBottomY, 0));
                            curveColl.Add(line);
                            iCount = iCount + 1;
                        }
                        break;
                    case 7:
                        // Rounded Corner
                        symbolGeomHlpr = new SymbolGeometryHelper();
                        symbolGeomHlpr.ActivePosition = new Position(0, 0, 0);
                        symbolGeomHlpr.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        arc1 = symbolGeomHlpr.CreateArc(null, corner[ID].CornerRad, (90 - Common.Middle.Math3d.Deg(corner[ID].Alpha) - Common.Middle.Math3d.Deg(corner[ID].Beta)) * Math.PI / 180);
                        matrix1 = new Matrix4X4();
                        matrix1.SetIdentity();
                        matrix1.Rotate((180 + Math3d.Deg(corner[ID].Alpha)) * Math.PI / 180, new Vector(0, 0, 1));
                        arc1.Transform(matrix1);

                        matrix1 = new Matrix4X4();
                        matrix1.SetIdentity();
                        matrix1.Translate(new Vector(corner[ID].CornerRad + corner[ID].CornerX, corner[ID].CornerRad + corner[ID].CornerY, 0));
                        arc1.Transform(matrix1);
                        curveColl.Add(arc1);
                        iCount = iCount + 1;
                        break;

                }

                // Draw optional line from Bottom Left corner to Top Left corner
                if (Math.Abs(LeftBottomY - LeftTopY) >= Math3d.DistanceTolerance)
                {
                    Line3d line = new Line3d(new Position(LeftBottomX, LeftBottomY, 0), new Position(LeftTopX, LeftTopY, 0));
                    curveColl.Add(line);
                    iCount = iCount + 1;
                }

                // Draw top left corner

                ID = 3;
                switch (corner[ID].CornerType)
                {
                    case 0:
                        // None - do nothing
                        break;
                    case 1:
                        // Rectangular Notch
                        // Draw from TR to inside corner to RT
                        Line3d line = new Line3d(new Position(LeftTopX, LeftTopY, 0), new Position(TopLeftX, LeftTopY, 0));
                        curveColl.Add(line);
                        iCount = iCount + 1;
                        line = new Line3d(new Position(TopLeftX, LeftTopY, 0), new Position(TopLeftX, TopLeftY, 0));
                        curveColl.Add(line);
                        iCount = iCount + 1;
                        break;
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        // Angle Notch
                        if (corner[ID].CornerRad > 0)
                        {
                            // Rounded
                            if (corner[ID].RoundedY == true)
                            {
                                symbolGeomHlpr = new SymbolGeometryHelper();
                                symbolGeomHlpr.ActivePosition = new Position(0, 0, 0);
                                symbolGeomHlpr.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                                Arc3d arc1 = symbolGeomHlpr.CreateArc(null, corner[ID].CornerRad, (Math3d.Deg(corner[ID].Alpha)) * Math.PI / 180);
                                matrix1 = new Matrix4X4();
                                matrix1.SetIdentity();
                                matrix1.Rotate((180 - Math3d.Deg(corner[ID].Alpha)) * Math.PI / 180, new Vector(0, 0, 1));
                                arc1.Transform(matrix1);

                                matrix1 = new Matrix4X4();
                                matrix1.SetIdentity();
                                matrix1.Translate(new Vector(LeftTopX + corner[ID].CornerRad, LeftTopY, 0));
                                arc1.Transform(matrix1);
                                curveColl.Add(arc1);
                                iCount = iCount + 1;
                                dAngleNotchStartPtX = LeftTopX + corner[ID].CornerRad - corner[ID].CornerRad * Math.Cos(corner[ID].Alpha);
                                dAngleNotchStartPtY = LeftTopY + corner[ID].CornerRad * Math.Sin(corner[ID].Alpha);
                            }
                            else
                            {
                                dAngleNotchStartPtX = LeftTopX;
                                dAngleNotchStartPtY = LeftTopY;
                            }

                            if (corner[ID].RoundedX == true)
                            {
                                dAngleNotchEndPtX = TopLeftX - corner[ID].CornerRad * Math.Sin(corner[ID].Beta);
                                dAngleNotchEndPtY = TopLeftY - corner[ID].CornerRad + corner[ID].CornerRad * Math.Cos(corner[ID].Beta);
                            }
                            else
                            {
                                dAngleNotchEndPtX = TopLeftX;
                                dAngleNotchEndPtY = TopLeftY;
                            }
                            line = new Line3d(new Position(dAngleNotchStartPtX, dAngleNotchStartPtY, 0), new Position(dAngleNotchEndPtX, dAngleNotchEndPtY, 0));
                            curveColl.Add(line);
                            iCount = iCount + 1;

                            if (corner[ID].RoundedX == true)
                            {
                                symbolGeomHlpr = new SymbolGeometryHelper();
                                symbolGeomHlpr.ActivePosition = new Position(0, 0, 0);
                                symbolGeomHlpr.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                                Arc3d arc1 = symbolGeomHlpr.CreateArc(null, corner[ID].CornerRad, (90 - Math3d.Deg(corner[ID].Alpha)) * Math.PI / 180);
                                matrix1 = new Matrix4X4();
                                matrix1.SetIdentity();
                                matrix1.Rotate((90) * Math.PI / 180, new Vector(0, 0, 1));
                                arc1.Transform(matrix1);

                                matrix1 = new Matrix4X4();
                                matrix1.SetIdentity();
                                matrix1.Translate(new Vector(TopLeftX, TopLeftY - corner[ID].CornerRad, 0));
                                arc1.Transform(matrix1);
                                curveColl.Add(arc1);
                                iCount = iCount + 1;
                            }
                        }
                        else
                        {
                            line = new Line3d(new Position(LeftTopX, LeftTopY, 0), new Position(TopLeftX, TopLeftY, 0));
                            curveColl.Add(line);
                            iCount = iCount + 1;
                        }
                        break;
                    case 6:
                        // Round Notch
                        if (corner[ID].CornerX > 0)
                        {
                            line = new Line3d(new Position(LeftTopX, LeftTopY, 0), new Position(LeftTopX + corner[ID].CornerX, LeftTopY, 0));
                            curveColl.Add(line);
                            iCount = iCount + 1;
                        }
                        symbolGeomHlpr = new SymbolGeometryHelper();
                        symbolGeomHlpr.ActivePosition = new Position(0, 0, 0);
                        symbolGeomHlpr.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        Arc3d arc = symbolGeomHlpr.CreateArc(null, corner[ID].CornerRad, (90 - Math3d.Deg(corner[ID].Alpha) - Math3d.Deg(corner[ID].Beta)) * Math.PI / 180);
                        matrix1 = new Matrix4X4();
                        matrix1.SetIdentity();
                        matrix1.Rotate((Math3d.Deg(corner[ID].Beta) + 270) * Math.PI / 180, new Vector(0, 0, 1));
                        arc.Transform(matrix1);

                        matrix1 = new Matrix4X4();
                        matrix1.SetIdentity();
                        matrix1.Translate(new Vector(corner[ID].CornerX, plate.length1 - corner[ID].CornerY, 0));
                        arc.Transform(matrix1);


                        curveColl.Add(arc);
                        iCount = iCount + 1;

                        if (corner[ID].CornerY > 0)
                        {
                            line = new Line3d(new Position(TopLeftX, TopLeftY - corner[ID].CornerY, 0), new Position(TopLeftX, TopLeftY, 0));
                            curveColl.Add(line);
                            iCount = iCount + 1;
                        }
                        break;
                    case 7:
                        // Rounded Corner
                        symbolGeomHlpr = new SymbolGeometryHelper();
                        symbolGeomHlpr.ActivePosition = new Position(0, 0, 0);
                        symbolGeomHlpr.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        arc = symbolGeomHlpr.CreateArc(null, corner[ID].CornerRad, (90 - Math3d.Deg(corner[ID].Alpha) - Math3d.Deg(corner[ID].Beta)) * Math.PI / 180);
                        matrix1 = new Matrix4X4();
                        matrix1.SetIdentity();
                        matrix1.Rotate((90 + Math3d.Deg(corner[ID].Beta)) * Math.PI / 180, new Vector(0, 0, 1));
                        arc.Transform(matrix1);

                        matrix1 = new Matrix4X4();
                        matrix1.SetIdentity();
                        matrix1.Translate(new Vector(corner[ID].CornerRad + corner[ID].CornerX, plate.length1 - (corner[ID].CornerRad + corner[ID].CornerY), 0));
                        arc.Transform(matrix1);
                        curveColl.Add(arc);
                        iCount = iCount + 1;
                        break;
                }
                // Do we need a curved notch on the end?
                if (plate.curvedEndRad > 0)
                {
                    if (Math.Abs(CurvedEndLeftX - TopLeftX) >= Math3d.DistanceTolerance)
                    {
                        Line3d line = new Line3d(new Position(TopLeftX, TopLeftY, 0), new Position(CurvedEndLeftX, TopLeftY, 0));
                        curveColl.Add(line);
                        iCount = iCount + 1;
                    }
                    symbolGeomHlpr = new SymbolGeometryHelper();
                    symbolGeomHlpr.ActivePosition = new Position(0, 0, 0);
                    if (plate.curvedEndType == 2)
                        symbolGeomHlpr.SetOrientation(new Vector(1, 0, 0), new Vector(0, -1, 0));
                    else if (plate.curvedEndType == 1)
                        symbolGeomHlpr.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    Arc3d arc = symbolGeomHlpr.CreateArc(null, plate.curvedEndRad, (2 * Math3d.Deg(dCurvedEndAlpha)) * Math.PI / 180);
                    matrix1 = new Matrix4X4();
                    matrix1.SetIdentity();
                    matrix1.Rotate((270 - Math3d.Deg(dCurvedEndAlpha)) * Math.PI / 180, new Vector(0, 0, 1));
                    arc.Transform(matrix1);

                    matrix1 = new Matrix4X4();
                    matrix1.SetIdentity();
                    matrix1.Translate(new Vector(plate.width1 / 2.0 + plate.curvedEndX, plate.length1 + plate.curvedEndY, 0));
                    arc.Transform(matrix1);

                    curveColl.Add(arc);
                    iCount = iCount + 1;

                    if (Math.Abs(CurvedEndRightX - TopRightX) >= Math3d.DistanceTolerance)
                    {
                        Line3d line = new Line3d(new Position(CurvedEndRightX, TopRightY, 0), new Position(TopRightX, TopRightY, 0));
                        curveColl.Add(line);
                        iCount = iCount + 1;
                    }
                }
                else
                {
                    // No curved notch.
                    // Draw optional line from Top Left corner to Top Right corner
                    if (Math.Abs(TopLeftX - TopRightX) >= Math3d.DistanceTolerance)
                    {
                        Line3d line = new Line3d(new Position(TopLeftX, TopLeftY, 0), new Position(TopRightX, TopRightY, 0));
                        curveColl.Add(line);
                        iCount = iCount + 1;
                    }
                }

                // Done with iCount, remove the last increment as it was for the "next" object to be added
                iCount = iCount - 1;

                // Make sure outputs match what we expected.
                if (iCount != nPts)
                    sError.Append("iCount of " + iCount + " doesn't match nPts of " + nPts);
                if (sError.Length > 0)
                    ToDoListMessage = new ToDoListMessage(ToDoMessageTypes.ToDoMessageWarning, sError.ToString());
                ComplexString3d complexString = new ComplexString3d(curveColl);
                Projection3d proj = new Projection3d(complexString, new Vector(0, 0, 1), plate.thickness1, true);
                proj.Transform(matrix);
                outputs.Add(outputName, proj);

            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddPlateMethod, "Error in AddPlate");
                }
            }
        }
        /// <summary>
        /// Defines the inputs for the PipeClamp.
        /// </summary>
        public struct PipeClampInputs
        {
            /// <summary>
            /// Inside diameter of pipe clamp body.
            /// </summary>
            public double Diameter1;
            /// <summary>
            /// Thickness of stock used to make clamp body.Diameter1 plus twice Thickness1 is the outside diameter of the clamp body.Also defines thickness of the top and bottom tabs.
            /// </summary>
            public double Thickness1;
            /// <summary>
            /// Width of clamp body.Both the left and right halves of the clamp are the same width, unless Width2 is also specified.
            /// If Width 1 is negative, the left half of the clamp is not displayed.Width1 can not be zero or undefined.
            /// </summary>
            public double Width1;
            /// <summary>
            /// Optional second width of clamp body.If specified, sets the width of right half of the clamp body to be different from the left half. Example application shown.
            /// If zero or undefined, Width1 is used for both halves of the clamp.If negative, the right half of the clamp is not shown. 
            /// If Angle1 is set to 360, right half of clamp is not drawn, so Width 2 is ignored.
            /// </summary>
            public double Width2;
            /// <summary>
            /// Height from pipe center to top of clamp. If 0, or less than outside diameter of clamp body, top tabs are not included.
            /// </summary>
            public double Height1;
            /// <summary>
            /// Height from pipe center to bottom of clamp. If 0, or less than outside diameter of clamp body, bottom tabs are not included. If Angle1 is set to 360, Height2 is ignored.
            /// </summary>
            public double Height2;
            /// <summary>
            /// The gap between the two top tabs.Can be zero but not negative.
            /// </summary>
            public double Gap1;
            /// <summary>
            /// The gap between the two bottom tabs.Can be zero but not negative. If Angle1 is set to 360, Gap2 is ignored.
            /// </summary>
            public double Gap2;
            /// <summary>
            /// The sweep angle between the top and bottom tabs. If zero (default), 180 degrees is assumed.
            /// If 360, only the left half of the clamp is drawn; the right half is not displayed. In this case, Gap1 is used for the tab spacing, and Gap2 is ignored. 
            /// Also, if 360, you should set only bolt rows 1, 3, and 5 should  be used; don’t use bolt rows 2, 4, and 6 as they will be rotated to the top and will overlap rows 1, 3, and 5.
            /// If you do include them, they will be drawn.
            /// If Angle1 is negative then a warning is appear and we will use the absolute value of Angle1.
            /// </summary>
            public double Angle1;
            /// <summary>
            /// Diameter of bolts / pins.All bolts are drawn the same diameter.
            /// This diameter is also used as the connection diameter. 
            /// AIR’s that join an PipeClamp to an EyeNut, for example, read the Pin1Diameter property from the PipeClamp and pass it into the PinDiameter prompt of the EyeNut.
            /// </summary>
            public double Pin1Diameter;
            /// <summary>
            ///Length of bolts / pins.All bolts are drawn the same length, centered.
            ///Pin1Length should be greater than the larger of Gap1 or Gap2 plus 2 Thickness1’s  in order to be visible.
            /// </summary>
            public double Pin1Length;
            /// <summary>
            /// 1 – Rod Hanger,2 – Side Mounted ,3 – Side Mounted ,4 – Direct Bolted,5 – Riser Rod Hanger,6 – Riser on Structure,7 – Offset Pipe Clamp
            /// </summary>
            public int ClampCfg;
            /// <summary>
            /// For ClampCfg 1 and 5, Angle3 rotates the clamp Route port about its x axis. For ClampCfg 2 and 3 Angle3 rotates the clamp from horizontal.
            /// By default, if zero or undefined, the pipe port is oriented so that the clamp body is horizontal (as opposed to vertical for ClampCfg 1).
            /// A positive Angle3 rotates the clamp body counter-clockwise when looking along the positive X direction of the Pipe port. Negative Angle3 rotates the clamp body clockwise.
            /// The rotation is actually achieved by rotating the Pipe port’s orientation in the opposite direction by Angle3.
            /// </summary>
            public double Angle3;
            /// <summary>
            /// For ClampCfg 2, Width3 specifies the outside width of the post or shoe that the clamp will rest on.
            /// For ClampCfg 3, if Width3 is specified, the ports will be located on the side of the clamp, separated by the specified width, with orthogonal ports orientated as shown. 
            /// Width3 must be less than the outside diameter of the clamp body (ie. Less than Diameter1 + 2 x Thickness1) Practically, it should be less than that or the ports will be inside the end tabs of the clamp.
            /// If BOTH Width3 and Angle2 are specified, Width3 will be used.
            /// For ClampCfg 4, the ports will be separated by Width3, and centered in the clamp body
            /// For ClampCfg 6, the bottom ports will be separated by Width3. 
            /// For ClampCfg 8, Width3 sets the overall width of the wings.
            /// </summary>
            public double Width3;
            /// <summary>
            /// For ClampCfg 2, Height3 sets the distance from the side of the clamp to the ClampSide port. If both Height3 and Width3 are set, Height3 is used.
            /// For ClampCfg 4, Height3 sets the amount to offset the ports from the pipe centerline. 
            /// </summary>
            public double Height3;
            /// <summary>
            /// Only used for ClampCfg 8, Offset Pipe Clamps.If variable length, use IJOAHgrOccLength.If fixed length, use JUAhsLength.ONLY USED FOR OFFSET PIPE CLAMPS!
            /// </summary>
            public double Length;
            /// <summary>
            /// Width of gusset at the end of the clamp. Same value is used at both ends of the clamp, on both sides. Can be positive, zero, or negative.
            /// </summary>
            public double Dim1;
            /// <summary>
            /// Distance the gusset extends past the clamp body at the center of the clamp. Can be positive, zero, or negative.
            /// </summary>
            public double Dim2;
            /// <summary>
            /// If zero, the gussets are NOT drawn. If positive, the gussets are drawn inside the clamp body. If negative, the gussets are drawn outside the clamp body.
            /// </summary>
            public double Thickness2;
            /// <summary>
            /// Outside diameter of cylinder used to represent clamp liner.If zero or undefined, liner is not drawn.
            /// </summary>
            public double Diameter4;
            /// <summary>
            /// Width of cylinder used to represent clamp liner.If zero or undefined, liner is not drawn.
            /// </summary>
            public double Width4;
            /// <summary>
            /// The graphic shape to use for the side connection graphic.
            /// </summary>
            public int ShapeType;
            /// <summary>
            /// The thickness of the side connection shape, from the outside face of the clamp, to the outside face of the side connection. The graphic is drawn over-length so it fully embeds in the clamp body.
            /// </summary>
            public double Thickness3;
            /// <summary>
            /// The outside dimension of the side connection shape.
            /// </summary>
            public double Width5;
            /// <summary>
            /// For NutShape 2 (square), use Width6 to create a rectangle shape instead of a square. If zero or not specified, NutShape 2 will be drawn square shape
            /// </summary>
            public double Width6;
            /// <summary>
            /// For ClampCfg 2, Angle2 rotates the ClampSide port around its Z axis.
            /// For ClampCfg 3, Angle2 determines the angle between the two ports on the side of the clamp. The port orientations will also be angled to simplify joints in assemblies.
            /// Angle2 must be less than 180. Practically, it should be less than that or the ports will be inside the end tabs of the clamp.
            /// </summary>
            public double Angle2;
            /// <summary>
            ///The BoltRow input parameter type.
            /// </summary>
            public BoltRowInputs BoltRow1;
            public BoltRowInputs BoltRow2;
            public BoltRowInputs BoltRow3;
            public BoltRowInputs BoltRow4;
            public BoltRowInputs BoltRow5;
            public BoltRowInputs BoltRow6;
        }
        /// <summary>
        /// Defines the inputs for the BoltRows.
        /// </summary>
        public struct BoltRowInputs
        {
            /// <summary>
            /// Offset of each bolt row from the pipe centerline.
            /// </summary>
            public double Offset;
            /// <summary>
            /// If the Qty is zero for any row, there will be no bolt graphics in that row.
            /// </summary>
            public double MultiQty;
            /// <summary>
            /// Locates the bolts by edge
            /// </summary>
            public double MultiLocateBy;
            /// <summary>
            ///  Locates the bolts by center
            /// </summary>
            public double MultiLocation;
        }
        /// <summary>
        /// Adds the BoltRow inputs.
        /// </summary>        
        /// <param name="startIndex">The start index.</param>
        /// <param name="endIndex">The end index.</param>
        /// <param name="additionalInputs">The additional inputs.</param>
        /// <param name="iNutNumber">The inutnumber.</param>
        /// <code>
        /// int endIndex;
        /// List<Input> additionalInputs = new List<Input>();
        /// AddBoltRowInputs(startIndex, out endIndex, additionalInputs);
        /// </code>
        public void AddBoltRowInputs(int startIndex, out int endIndex, List<Input> addtionalInputs, int iNutNumber)
        {
            try
            {
                addtionalInputs.Add(new InputDouble(startIndex, "Offset" + iNutNumber, "Offset", 0, false));
                addtionalInputs.Add(new InputDouble(++startIndex, "Multi" + iNutNumber + "Qty", "Multi" + iNutNumber + "Qty", 0, false));
                addtionalInputs.Add(new InputDouble(++startIndex, "Multi" + iNutNumber + "LocateBy", "Multi" + iNutNumber + "LocateBy", 0, false));
                addtionalInputs.Add(new InputDouble(++startIndex, "Multi" + iNutNumber + "Location", "Multi" + iNutNumber + "Location", 0, false));

            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddBoltRowInputs, "Error in adding BoltRow inputs");
                }
            }
            endIndex = ++startIndex;
        }
        /// <summary>
        /// Loads the BoltRow data.
        /// </summary>        
        /// <param name="startIndex">The start index.</param>
        /// /// <code>
        /// PipeClamp.BoltRow1 = LoadBoltRowData(startIndex);
        /// </code>
        /// <returns></returns>
        public BoltRowInputs LoadBoltRowData(int startIndex, out int endIndex)
        {
            BoltRowInputs boltRow = new BoltRowInputs();
            endIndex = startIndex;
            try
            {
                boltRow.Offset = GetDoubleInputValue(startIndex);
                boltRow.MultiQty = GetDoubleInputValue(++startIndex);
                ++startIndex;
                if (startIndex == -1)
                    boltRow.MultiLocateBy = 0;
                else
                    boltRow.MultiLocateBy = GetDoubleInputValue(startIndex);

                boltRow.MultiLocation = GetDoubleInputValue(++startIndex);
                ++startIndex;

                endIndex = startIndex;
                return boltRow;

            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadBoltRowData, "Error in LoadBoltRowData");
                }
                return boltRow;
            }
        }
        /// <summary>
        ///Create the graphical representation of a full beam clamp.
        /// </summary>
        /// <param name="diameter1">- Double -Inside diameter of clamp body</param>
        /// <param name="thickness1">- Double - Thickness of stock used to make clamp body.Also defines thickness of the top and bottom tabs.</param>
        /// <param name="width1">- Double - Width of clamp body.  If Width 1 is negative, the left half of the clamp is not displayed.</param>
        /// <param name="width2">- Double - Optional second width of clamp body.  if set to zero then dWidth1 will be used.  If set to less then zero then the right half of the clamp is not displayed.</param>
        /// <param name="height1">- Double - Height from pipe center to top of the clamp.  IF 0 or less than outside diameter of clamp body, top tabs are not included.</param>
        /// <param name="height2">- Double - Height from pipe center to bottom of the clamp.  IF 0 or less than outside diameter of clamp body, top tabs are not included.</param>
        /// <param name="gap1">- Double - The gap between the two top tabs.  Can be zero but not negative.</param>
        /// <param name="gap2">- Double - The gap between the two bottom tabs.  Can be zero but not negative.</param>
        /// <param name="angle1">- Double - The Sweep angle between the top and bottom tabs.  If Angle is set to 0 then 180 is assumed.  If angle is set to 360 then only left half of clamp is drawn</param>
        /// <param name="length">- Double - For offset pipe Clamps.  This is the height brom the pipe centerline to the base of the clamp.</param>
        /// <param name="width3">- Double - Clamp Config 7 - the overall width of the wings on the base of the clamp.</param>
        /// <param name="outputs">The outputs</param>
        /// <param name="outputName">- string -The Name Of The Output</param>
        /// <param name="name">- string - optional - Optional name of the graphic being placed.</param>
        /// <param name="rotAngle">- Double - Optional - Angle that the whole clamp graphic will rotate by (on x axis).</param>
        /// <param name="isRaiser">- Boolean - Optional - To state wether or not this is a riser clamp or not.</param>
        /// <Code>AddClamp(pipeClamp.Diameter1, pipeClamp.Thickness1, pipeClamp.Width1, pipeClamp.Width2, pipeClamp.Height1, pipeClamp.Height2, pipeClamp.Gap1, pipeClamp.Gap2, angle1, 0, 0, outputs, outputName, "Clamp");</Code>
        public void AddClamp(Double diameter1, Double thickness1, Double width1, Double width2, Double height1, Double height2, Double gap1, Double gap2, Double angle1, Double length, Double width3, OutputDictionary outputs, String outputName, string name = "None", Double rotAngle = 0, Boolean isRaiser = false)
        {
            try
            {

                if (diameter1 > 0 && (HgrCompareDoubleService.cmpdbl(width1, 0) == false) && thickness1 > 0)
                {
                    if (length > 0)
                        AddClampWithWings(diameter1, thickness1, width1, width2, height1, height2, gap1, gap2, angle1, length, width3, outputs, outputName, name, rotAngle);
                    else
                        AddClampShape(diameter1, thickness1, width1, width2, height1, height2, gap1, gap2, angle1, outputs, outputName, name, rotAngle, isRaiser);
                }
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddClampMethod, "Error in AddClamp");
                }
            }
        }
        /// <summary>
        /// Create the graphical representation of a full beam clamp with wings
        /// </summary>
        /// <param name="diameter1">- Double -Inside diameter of clamp body</param>
        /// <param name="thickness1">- Double - Thickness of stock used to make clamp body.Also defines thickness of the top and bottom tabs.</param>
        /// <param name="width1">- Double - Width of clamp body.  If Width 1 is negative, the left half of the clamp is not displayed.</param>
        /// <param name="width2">- Double - Optional second width of clamp body.  if set to zero then dWidth1 will be used.  If set to less then zero then the right half of the clamp is not displayed.</param>
        /// <param name="height1">- Double - Height from pipe center to top of the clamp.  IF 0 or less than outside diameter of clamp body, top tabs are not included.</param>
        /// <param name="height2">- Double - Height from pipe center to bottom of the clamp.  IF 0 or less than outside diameter of clamp body, top tabs are not included.</param>
        /// <param name="gap1">- Double - The gap between the two top tabs.  Can be zero but not negative.</param>
        /// <param name="gap2">- Double - The gap between the two bottom tabs.  Can be zero but not negative.</param>
        /// <param name="angle1">- Double - The Sweep angle between the top and bottom tabs.  If Angle is set to 0 then 180 is assumed.  If angle is set to 360 then only left half of clamp is drawn</param>
        /// <param name="length">- Double - For offset pipe Clamps.  This is the height brom the pipe centerline to the base of the clamp.</param>
        /// <param name="width3">- Double - Clamp Config 7 - the overall width of the wings on the base of the clamp.</param>
        /// <param name="outputs">The outputs</param>
        /// <param name="outputName">- string -The Name Of The Output</param>
        /// <param name="name">- string - optional - Optional name of the graphic being placed.</param>
        /// <param name="rotAngle">- Double - Optional - Angle that the whole clamp graphic will rotate by (on x axis).</param>
        /// <Code>AddClampWithWings(diameter1, thickness1, width1, width2, height1, height2, gap1, gap2, angle1, length, width3, outputs, outputName, name, rotAngle);</Code>
        public void AddClampWithWings(Double diameter1, Double thickness1, Double width1, Double width2, Double height1, Double height2, Double gap1, Double gap2, Double angle1, Double length, Double width3, OutputDictionary outputs, String outputName, string name = "None", Double rotAngle = 0)
        {
            try
            {
                if (HgrCompareDoubleService.cmpdbl(width2, 0) == true)
                    width2 = width1;

                Double calc1, calc2, alpha1, alpha2, alpha3, alpha4;
                string[] objectCollection = new string[1];

                calc1 = Math.Sqrt(((diameter1 / 2) * (diameter1 / 2)) - ((gap1 / 2) * (gap1 / 2)));
                calc2 = Math.Sqrt((((diameter1 / 2) + thickness1) * ((diameter1 / 2) + thickness1)) - (((gap1 / 2) + thickness1) * ((gap1 / 2) + thickness1)));
                alpha1 = Math.Asin(((gap1 / 2) + thickness1) / ((diameter1 / 2) + thickness1)) * 180 / Math.PI;
                alpha2 = Math.Asin((gap1 / 2) / (diameter1 / 2)) * 180 / Math.PI;
                alpha3 = Math.Asin(((gap1 / 2) + thickness1) / ((diameter1 / 2) + thickness1)) * 180 / Math.PI;
                alpha4 = Math.Asin((gap1 / 2) / (diameter1 / 2)) * 180 / Math.PI;

                Collection<ICurve> collection = new Collection<ICurve>();
                SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();
                Matrix4X4 matrix = new Matrix4X4();


                if (width3 > (height1 + height2))
                {
                    collection.Add(new Line3d(new Position(-width1 / 2, gap1 / 2, calc1), new Position(-width1 / 2, gap1 / 2, height1 + thickness1)));
                    collection.Add(new Line3d(new Position(-width1 / 2, gap1 / 2, height1 + thickness1), new Position(-width1 / 2, length - thickness1, height1 + thickness1)));
                    collection.Add(new Line3d(new Position(-width1 / 2, length - thickness1, height1 + thickness1), new Position(-width1 / 2, length - thickness1, width3 / 2)));
                    collection.Add(new Line3d(new Position(-width1 / 2, length - thickness1, width3 / 2), new Position(-width1 / 2, length, width3 / 2)));
                    collection.Add(new Line3d(new Position(-width1 / 2, length, width3 / 2), new Position(-width1 / 2, length, height1)));
                    collection.Add(new Line3d(new Position(-width1 / 2, length, height1), new Position(-width1 / 2, gap1 / 2 + thickness1, height1)));
                    collection.Add(new Line3d(new Position(-width1 / 2, gap1 / 2 + thickness1, height1), new Position(-width1 / 2, gap1 / 2 + thickness1, calc2)));

                    symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    matrix.SetIdentity();
                    matrix.Rotate((Math.PI + alpha1 * Math.PI / 180), new Vector(0, 0, 1));
                    Arc3d arc1 = symbolGeometryHelper.CreateArc(null, diameter1 / 2 + thickness1, (Math.PI - alpha3 * Math.PI / 180 - alpha1 * Math.PI / 180));
                    arc1.Transform(matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                    arc1.Transform(matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                    arc1.Transform(matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Translate(new Vector(-width1 / 2, 0, 0));
                    arc1.Transform(matrix);
                    collection.Add(arc1);

                    collection.Add(new Line3d(new Position(-width1 / 2, gap1 / 2 + thickness1, -calc2), new Position(-width1 / 2, gap2 / 2 + thickness1, -height2)));
                    collection.Add(new Line3d(new Position(-width1 / 2, gap2 / 2 + thickness1, -height2), new Position(-width1 / 2, length, -height2)));
                    collection.Add(new Line3d(new Position(-width1 / 2, length, -height2), new Position(-width1 / 2, length, -width3 / 2)));
                    collection.Add(new Line3d(new Position(-width1 / 2, length, -width3 / 2), new Position(-width1 / 2, length - thickness1, -width3 / 2)));
                    collection.Add(new Line3d(new Position(-width1 / 2, length - thickness1, -width3 / 2), new Position(-width1 / 2, length - thickness1, -height2 - thickness1)));
                    collection.Add(new Line3d(new Position(-width1 / 2, length - thickness1, -height2 - thickness1), new Position(-width1 / 2, gap2 / 2, -height2 - thickness1)));
                    collection.Add(new Line3d(new Position(-width1 / 2, gap2 / 2, -height2 - thickness1), new Position(-width1 / 2, gap2 / 2, -calc1)));

                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Rotate((Math.PI + alpha2 * Math.PI / 180), new Vector(0, 0, 1));
                    Arc3d arc2 = symbolGeometryHelper.CreateArc(null, diameter1 / 2, (Math.PI - alpha4 * Math.PI / 180 - alpha2 * Math.PI / 180));
                    arc2.Transform(matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                    arc2.Transform(matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                    arc2.Transform(matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Translate(new Vector(-width1 / 2, 0, 0));
                    arc2.Transform(matrix);
                    collection.Add(arc2);

                    Vector side1Vector = new Vector(1, 0, 0);
                    Projection3d side1 = new Projection3d(new ComplexString3d(collection), side1Vector, width1, true);
                    outputs.Add(outputName + "side1", side1);

                }
                else
                {
                    collection.Add(new Line3d(new Position(-width1 / 2, gap1 / 2, calc1), new Position(-width1 / 2, gap1 / 2, height1 + thickness1)));
                    collection.Add(new Line3d(new Position(-width1 / 2, gap1 / 2, height1 + thickness1), new Position(-width1 / 2, length, height1 + thickness1)));
                    collection.Add(new Line3d(new Position(-width1 / 2, length, height1 + thickness1), new Position(-width1 / 2, length, height1)));
                    collection.Add(new Line3d(new Position(-width1 / 2, length, height1), new Position(-width1 / 2, gap1 / 2 + thickness1, height1)));
                    collection.Add(new Line3d(new Position(-width1 / 2, gap1 / 2 + thickness1, height1), new Position(-width1 / 2, gap1 / 2 + thickness1, calc2)));

                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    matrix.SetIdentity();
                    matrix.Rotate((Math.PI + alpha1 * Math.PI / 180), new Vector(0, 0, 1));
                    Arc3d arc1 = symbolGeometryHelper.CreateArc(null, diameter1 / 2 + thickness1, (Math.PI - alpha3 * Math.PI / 180 - alpha1 * Math.PI / 180));
                    arc1.Transform(matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                    arc1.Transform(matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                    arc1.Transform(matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Translate(new Vector(-width1 / 2, 0, 0));
                    arc1.Transform(matrix);
                    collection.Add(arc1);

                    collection.Add(new Line3d(new Position(-width1 / 2, gap1 / 2 + thickness1, -calc2), new Position(-width1 / 2, gap2 / 2 + thickness1, -height2)));
                    collection.Add(new Line3d(new Position(-width1 / 2, gap2 / 2 + thickness1, -height2), new Position(-width1 / 2, length, -height2)));
                    collection.Add(new Line3d(new Position(-width1 / 2, length, -height2), new Position(-width1 / 2, length, -height2 - thickness1)));
                    collection.Add(new Line3d(new Position(-width1 / 2, length, -height2 - thickness1), new Position(-width1 / 2, gap2 / 2, -height2 - thickness1)));
                    collection.Add(new Line3d(new Position(-width1 / 2, gap2 / 2, -height2 - thickness1), new Position(-width1 / 2, gap2 / 2, -calc1)));

                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Rotate((Math.PI + alpha2 * Math.PI / 180), new Vector(0, 0, 1));
                    Arc3d arc2 = symbolGeometryHelper.CreateArc(null, diameter1 / 2, (Math.PI - alpha4 * Math.PI / 180 - alpha2 * Math.PI / 180));
                    arc2.Transform(matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                    arc2.Transform(matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                    arc2.Transform(matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Translate(new Vector(-width1 / 2, 0, 0));
                    arc2.Transform(matrix);
                    collection.Add(arc2);

                    Vector side1Vector = new Vector(1, 0, 0);
                    Projection3d side1 = new Projection3d(new ComplexString3d(collection), side1Vector, width1, true);
                    outputs.Add(outputName + "side1", side1);
                }
                if (width2 >= 0)
                {
                    collection = new Collection<ICurve>();
                    collection.Add(new Line3d(new Position(-width2 / 2, -gap1 / 2, calc1), new Position(-width2 / 2, -gap1 / 2, height1)));
                    collection.Add(new Line3d(new Position(-width2 / 2, -gap1 / 2, height1), new Position(-width2 / 2, -gap1 / 2 - thickness1, height1)));
                    collection.Add(new Line3d(new Position(-width2 / 2, -gap1 / 2 - thickness1, height1), new Position(-width2 / 2, -gap1 / 2 - thickness1, calc2)));

                    symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    matrix.SetIdentity();
                    matrix.Rotate(2 * Math.PI + alpha3 * Math.PI / 180, new Vector(0, 0, 1));
                    Arc3d arc1 = symbolGeometryHelper.CreateArc(null, diameter1 / 2 + thickness1, -(Math.PI + alpha1 * Math.PI / 180 + alpha3 * Math.PI / 180));
                    arc1.Transform(matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                    arc1.Transform(matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                    arc1.Transform(matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Translate(new Vector(-width2 / 2, 0, 0));
                    arc1.Transform(matrix);
                    collection.Add(arc1);

                    collection.Add(new Line3d(new Position(-width2 / 2, -gap2 / 2 - thickness1, -calc2), new Position(-width2 / 2, -gap2 / 2 - thickness1, -height2)));
                    collection.Add(new Line3d(new Position(-width2 / 2, -gap2 / 2 - thickness1, -height2), new Position(-width2 / 2, -gap2 / 2, -height2)));
                    collection.Add(new Line3d(new Position(-width2 / 2, -gap2 / 2, -height2), new Position(-width2 / 2, -gap2 / 2, -calc1)));

                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Rotate(2 * Math.PI + alpha4 * Math.PI / 180, new Vector(0, 0, 1));
                    Arc3d arc2 = symbolGeometryHelper.CreateArc(null, diameter1 / 2, -(Math.PI + alpha2 * Math.PI / 180 + alpha4 * Math.PI / 180));
                    arc2.Transform(matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                    arc2.Transform(matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                    arc2.Transform(matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Translate(new Vector(-width2 / 2, 0, 0));
                    arc2.Transform(matrix);
                    collection.Add(arc2);

                    Vector side2Vector = new Vector(1, 0, 0);
                    Projection3d side2 = new Projection3d(new ComplexString3d(collection), side2Vector, width2, true);
                    outputs.Add(outputName + "side2", side2);
                }

                if (HgrCompareDoubleService.cmpdbl(rotAngle, 0) == false)
                {
                    objectCollection[0] = outputName + "side1";
                    if (width2 >= 0)
                        Array.Resize(ref objectCollection, 2);
                    objectCollection[1] = outputName + "side2";
                    matrix = new Matrix4X4();
                    matrix.SetIdentity();

                    matrix.Rotate(rotAngle, new Vector(1, 0, 0));

                    for (int i = 0; i < objectCollection.Length; i++)
                        if (objectCollection[i] != null)
                        {
                            Geometry3d transformObject = (Geometry3d)outputs[objectCollection[i]];
                            transformObject.Transform(matrix);
                        }
                }
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddClampWithwingsMethod, "Error in AddClampWithWings");
                }
            }
        }
        /// <summary>
        /// Create the graphical representation of the clamp shape
        /// </summary>
        /// <param name="diameter1">- Double -Inside diameter of clamp body</param>
        /// <param name="thickness1">- Double - Thickness of stock used to make clamp body.Also defines thickness of the top and bottom tabs.</param>
        /// <param name="width1">- Double - Width of clamp body.  If Width 1 is negative, the left half of the clamp is not displayed.</param>
        /// <param name="width2">- Double - Optional second width of clamp body.  if set to zero then dWidth1 will be used.  If set to less then zero then the right half of the clamp is not displayed.</param>
        /// <param name="height1">- Double - Height from pipe center to top of the clamp.  IF 0 or less than outside diameter of clamp body, top tabs are not included.</param>
        /// <param name="height2">- Double - Height from pipe center to bottom of the clamp.  IF 0 or less than outside diameter of clamp body, top tabs are not included.</param>
        /// <param name="gap1">- Double - The gap between the two top tabs.  Can be zero but not negative.</param>
        /// <param name="gap2">- Double - The gap between the two bottom tabs.  Can be zero but not negative.</param>
        /// <param name="angle1">- Double - The Sweep angle between the top and bottom tabs.  If Angle is set to 0 then 180 is assumed.  If angle is set to 360 then only left half of clamp is drawn</param>
        /// <param name="outputs">The outputs</param>
        /// <param name="outputName">- string -The Name Of The Output</param>
        /// <param name="name">- string - optional - Optional name of the graphic being placed.</param>
        /// <param name="rotAngle">- Double - Optional - Angle that the whole clamp graphic will rotate by (on x axis).</param>
        /// <param name="isRaiser">- Boolean - Optional - To state wether or not this is a riser clamp or not.</param>
        /// <code>AddClampShape(diameter1, thickness1, width1, width2, height1, height2, gap1, gap2, angle1, outputs, outputName, name, rotAngle, isRaiser);</code>
        public void AddClampShape(Double diameter1, Double thickness1, Double width1, Double width2, Double height1, Double height2, Double gap1, Double gap2, Double angle1, OutputDictionary outputs, String outputName, string name = "None", Double rotAngle = 0, Boolean isRaiser = false)
        {
            try
            {
                if (HgrCompareDoubleService.cmpdbl(width2, 0) == true)
                    width2 = width1;
                Double alpha1 = 0, alpha2 = 0, beta1 = 0, beta2 = 0, beta3 = 0, beta4 = 0, beta5 = 0, beta6 = 0, beta7 = 0, beta8 = 0;
                Double topZ = 0, topThickZ = 0;
                Double Y1 = 0, Y2 = 0, Y3 = 0, Y4 = 0, Y5 = 0, Y6 = 0, Y7 = 0, Y8 = 0, Z1 = 0, Z2 = 0, Z3 = 0, Z4 = 0, Z5 = 0, Z6 = 0, Z7 = 0, Z8 = 0;
                Double topDimension = 0, topDimension2 = 0, smallOffsetY = 0, smallOffsetZ = 0, angleNoGapTop = 0, angleNoGapBot = 0, angleNoGapTop2 = 0, anglenogapBot2 = 0, topZDimension = 0;
                string[] objectCollection = new string[2];
                Double tempHeight1 = 0, tempHeight2 = 0;
                const Double tempValue = 0.000001;
                const Double angleValue1 = 359.999999;
                const Double angleValue2 = 360.000001;

                SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();
                Matrix4X4 matrix = new Matrix4X4();
                Collection<ICurve> collection = new Collection<ICurve>();

                if (HgrCompareDoubleService.cmpdbl(angle1, 2 * Math.PI) == true)
                {
                    height2 = height1;
                    gap2 = gap1;
                }
                if (height1 < diameter1 / 2 + thickness1)
                    height1 = 0;
                else if (height2 < diameter1 / 2 + thickness1)
                    height2 = 0;

                alpha1 = Math.Asin(((gap1 / 2) + thickness1) / ((diameter1 / 2) + thickness1)) * 180 / Math.PI;
                alpha2 = Math.Asin((gap1 / 2) / (diameter1 / 2)) * 180 / Math.PI;

                topZ = Math.Cos(alpha2 * (Math.PI / 180)) * (diameter1 / 2);
                topThickZ = Math.Cos(alpha1 * (Math.PI / 180)) * ((diameter1 / 2) + thickness1);

                if (height2 > 0 && height2 <= 0)
                {
                    beta1 = (Math.Asin((gap1 / 2) / (diameter1 / 2)) * 180 / Math.PI);
                    beta2 = (Math.Asin((gap1 / 2) / (diameter1 / 2)) * 180 / Math.PI);
                    beta3 = (Math.Asin(((gap1 / 2) + thickness1) / ((diameter1 / 2) + thickness1)) * 180 / Math.PI);
                    beta4 = (Math.Asin(((gap1 / 2) + thickness1) / ((diameter1 / 2) + thickness1)) * 180 / Math.PI);
                }
                if (height2 > 0)
                {
                    beta1 = (angle1) - (Math.Asin((gap2 / 2) / (diameter1 / 2)) * 180 / Math.PI);
                    beta2 = (angle1) + (Math.Asin((gap2 / 2) / (diameter1 / 2)) * 180 / Math.PI);
                    beta3 = (angle1) - (Math.Asin(((gap2 / 2) + thickness1) / ((diameter1 / 2) + thickness1)) * 180 / Math.PI);
                    beta4 = (angle1) + (Math.Asin(((gap2 / 2) + thickness1) / ((diameter1 / 2) + thickness1)) * 180 / Math.PI);

                    beta5 = (angle1) - (Math.Atan((gap2 / 2) / (height2)) * 180 / Math.PI);
                    beta6 = (angle1) + (Math.Atan((gap2 / 2) / (height2)) * 180 / Math.PI);
                    beta7 = (angle1) - (Math.Atan(((gap2 / 2) + thickness1) / (height2)) * 180 / Math.PI);
                    beta8 = (angle1) + (Math.Atan(((gap2 / 2) + thickness1) / (height2)) * 180 / Math.PI);

                    tempHeight1 = Math.Sqrt(((height2) * (height2)) + (((gap2 / 2) + thickness1) * ((gap2 / 2) + thickness1)));
                    tempHeight2 = Math.Sqrt(((height2) * (height2)) + ((gap2 / 2) * (gap2 / 2)));

                    Y1 = Math.Sin(beta1 * (Math.PI / 180)) * (diameter1 / 2);
                    Z1 = Math.Cos(beta1 * (Math.PI / 180)) * (diameter1 / 2);

                    Y2 = Math.Sin(beta5 * (Math.PI / 180)) * (tempHeight2);
                    Z2 = Math.Cos(beta5 * (Math.PI / 180)) * (tempHeight2);

                    Y3 = Math.Sin(beta2 * (Math.PI / 180)) * (diameter1 / 2);
                    Z3 = Math.Cos(beta2 * (Math.PI / 180)) * (diameter1 / 2);

                    Y4 = Math.Sin(beta6 * (Math.PI / 180)) * (tempHeight2);
                    Z4 = Math.Cos(beta6 * (Math.PI / 180)) * (tempHeight2);

                    Y5 = Math.Sin(beta3 * (Math.PI / 180)) * ((diameter1 / 2) + thickness1);
                    Z5 = Math.Cos(beta3 * (Math.PI / 180)) * ((diameter1 / 2) + thickness1);

                    Y6 = Math.Sin(beta7 * (Math.PI / 180)) * (tempHeight1);
                    Z6 = Math.Cos(beta7 * (Math.PI / 180)) * (tempHeight1);

                    Y7 = Math.Sin(beta4 * (Math.PI / 180)) * ((diameter1 / 2) + thickness1);
                    Z7 = Math.Cos(beta4 * (Math.PI / 180)) * ((diameter1 / 2) + thickness1);

                    Y8 = Math.Sin(beta8 * (Math.PI / 180)) * (tempHeight1);
                    Z8 = Math.Cos(beta8 * (Math.PI / 180)) * (tempHeight1);
                }
                if ((gap1 > -tempValue && gap1 < tempValue) && (gap2 > -tempValue && gap2 < tempValue))
                {
                    smallOffsetY = Math.Sin(0.1 * (Math.PI / 180)) * diameter1 / 2;
                    smallOffsetZ = Math.Cos(0.1 * (Math.PI / 180)) * diameter1 / 2;

                    topZDimension = diameter1 / 2;

                    topDimension2 = Math.Sqrt((((diameter1 / 2) + thickness1) * ((diameter1 / 2) + thickness1)) - ((thickness1 + smallOffsetY) * (thickness1 + smallOffsetY)));
                    if (HgrCompareDoubleService.cmpdbl(height1, 0) == false)
                    {
                        angleNoGapTop2 = 179.9;
                        anglenogapBot2 = Math.PI;

                        angleNoGapTop = Math.Asin((smallOffsetY + thickness1) / (diameter1 / 2 + thickness1)) * 180 / Math.PI;
                        angleNoGapBot = Math.Asin(thickness1 / (diameter1 / 2 + thickness1)) * 180 / Math.PI;
                    }
                    else
                    {
                        angleNoGapTop2 = 0;
                        anglenogapBot2 = 0 - 0.1;

                        angleNoGapTop = Math.Asin(thickness1 / (diameter1 / 2 + thickness1)) * 180 / Math.PI;
                        angleNoGapBot = Math.Asin((smallOffsetY + thickness1) / (diameter1 / 2 + thickness1)) * 180 / Math.PI;
                    }
                }
                else
                {
                    if ((gap1 < -tempValue && gap1 > tempValue) && (gap2 > -tempValue && gap2 < -tempValue))
                    {
                        smallOffsetY = gap1 / 2;
                        smallOffsetZ = Math.Sqrt(((diameter1 / 2) * (diameter1 / 2)) - ((gap1 / 2) * (gap1 / 2)));

                        topZDimension = Math.Sqrt(((diameter1 / 2) * (diameter1 / 2)) - ((gap1 / 2) * (gap1 / 2)));

                        topDimension2 = Math.Sqrt((((diameter1 / 2) + thickness1) * ((diameter1 / 2) + thickness1)) - ((thickness1 + (gap1 / 2)) * (thickness1 + (gap1 / 2))));

                        angleNoGapTop2 = Math.PI - (Math.Asin((gap1 / 2) / (diameter1 / 2))) * 180 / Math.PI;
                        anglenogapBot2 = Math.PI + (Math.Asin((gap1 / 2) / (diameter1 / 2))) * 180 / Math.PI;

                        angleNoGapTop = (Math.Asin((thickness1 + (gap1 / 2)) / (diameter1 / 2 + thickness1)) * 180 / Math.PI);
                        angleNoGapBot = (Math.Asin((thickness1 + (gap1 / 2)) / (diameter1 / 2 + thickness1)) * 180 / Math.PI);
                    }
                    else if (gap2 < -tempValue && gap2 > tempValue)
                    {
                        smallOffsetY = gap2 / 2;
                        smallOffsetZ = Math.Sqrt(((diameter1 / 2) * (diameter1 / 2)) - ((gap2 / 2) * (gap2 / 2)));

                        topZDimension = Math.Sqrt(((diameter1 / 2) * (diameter1 / 2)) - ((gap2 / 2) * (gap2 / 2)));

                        topDimension2 = Math.Sqrt((((diameter1 / 2) + thickness1) * ((diameter1 / 2) + thickness1)) - ((thickness1 + (gap2 / 2)) * (thickness1 + (gap2 / 2))));
                        if (HgrCompareDoubleService.cmpdbl(height2, 0) == false)
                        {
                            angleNoGapTop2 = Math.PI - (Math.Asin((gap2 / 2) / (diameter1 / 2))) * 180 / Math.PI;
                            anglenogapBot2 = Math.PI + (Math.Asin((gap2 / 2) / (diameter1 / 2))) * 180 / Math.PI;
                        }
                        else
                        {
                            angleNoGapTop2 = 2 * (Math.PI) - (Math.Asin((gap2 / 2) / (diameter1 / 2)) * 180 / Math.PI);
                            anglenogapBot2 = (Math.Asin((gap2 / 2) / (diameter1 / 2)) * 180 / Math.PI);
                        }
                        angleNoGapTop = (Math.Asin((thickness1 + (gap2 / 2)) / (diameter1 / 2 + thickness1)) * 180 / Math.PI);
                        angleNoGapBot = (Math.Asin((thickness1 + (gap2 / 2)) / (diameter1 / 2 + thickness1)) * 180 / Math.PI);
                    }

                }
                if (height1 > 0 && height2 > 0)
                {
                    if (width1 >= 0)
                    {
                        collection.Add(new Line3d(new Position(-width1 / 2, -gap1 / 2, topZ), new Position(-width1 / 2, -gap1 / 2, height1)));
                        collection.Add(new Line3d(new Position(-width1 / 2, -gap1 / 2, height1), new Position(-width1 / 2, -gap1 / 2 - thickness1, height1)));
                        collection.Add(new Line3d(new Position(-width1 / 2, -gap1 / 2 - thickness1, height1), new Position(-width1 / 2, -gap1 / 2 - thickness1, topThickZ)));

                        symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                        symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        matrix.SetIdentity();
                        matrix.Rotate(((Math.PI) - beta3 * Math.PI / 180), new Vector(0, 0, 1));
                        Arc3d arc1 = symbolGeometryHelper.CreateArc(null, diameter1 / 2 + thickness1, (-alpha1 + beta3) * Math.PI / 180);
                        arc1.Transform(matrix);

                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                        arc1.Transform(matrix);

                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                        arc1.Transform(matrix);

                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Translate(new Vector(-width1 / 2, 0, 0));
                        arc1.Transform(matrix);
                        collection.Add(arc1);

                        collection.Add(new Line3d(new Position(-width1 / 2, -Y1, Z1), new Position(-width1 / 2, -Y2, Z2)));
                        collection.Add(new Line3d(new Position(-width1 / 2, -Y2, Z2), new Position(-width1 / 2, -Y6, Z6)));
                        collection.Add(new Line3d(new Position(-width1 / 2, -Y6, Z6), new Position(-width1 / 2, -Y5, Z5)));

                        symbolGeometryHelper = new SymbolGeometryHelper();
                        symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                        symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Rotate((Math.PI - beta1 * Math.PI / 180), new Vector(0, 0, 1));
                        Arc3d arc2 = symbolGeometryHelper.CreateArc(null, diameter1 / 2, (-alpha2 + beta1) * Math.PI / 180);
                        arc2.Transform(matrix);

                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                        arc2.Transform(matrix);

                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                        arc2.Transform(matrix);

                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Translate(new Vector(-width1 / 2, 0, 0));
                        arc2.Transform(matrix);
                        collection.Add(arc2);

                        Vector side1Vector = new Vector(1, 0, 0);
                        Projection3d side1 = new Projection3d(new ComplexString3d(collection), side1Vector, width1, true);
                        outputs.Add(outputName + "side1", side1);
                    }
                    if (width2 >= 0)
                    {
                        if (angle1 < angleValue1 && angle1 < angleValue2)
                        {

                            collection = new Collection<ICurve>();
                            collection.Add(new Line3d(new Position(-width2 / 2, gap1 / 2, topZ), new Position(-width2 / 2, gap1 / 2, height1)));
                            collection.Add(new Line3d(new Position(-width2 / 2, gap1 / 2, height1), new Position(-width2 / 2, gap1 / 2 + thickness1, height1)));
                            collection.Add(new Line3d(new Position(-width2 / 2, gap1 / 2 + thickness1, height1), new Position(-width2 / 2, gap1 / 2 + thickness1, topThickZ)));

                            symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                            symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                            matrix.SetIdentity();
                            matrix.Rotate((Math.PI + alpha1 * Math.PI / 180), new Vector(0, 0, 1));
                            Arc3d arc1 = symbolGeometryHelper.CreateArc(null, diameter1 / 2 + thickness1, (-beta4 - alpha1) * Math.PI / 180);
                            arc1.Transform(matrix);

                            matrix = new Matrix4X4();
                            matrix.SetIdentity();
                            matrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                            arc1.Transform(matrix);

                            matrix = new Matrix4X4();
                            matrix.SetIdentity();
                            matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                            arc1.Transform(matrix);

                            matrix = new Matrix4X4();
                            matrix.SetIdentity();
                            matrix.Translate(new Vector(-width2 / 2, 0, 0));
                            arc1.Transform(matrix);
                            collection.Add(arc1);

                            collection.Add(new Line3d(new Position(-width2 / 2, -Y3, Z3), new Position(-width2 / 2, -Y4, Z4)));
                            collection.Add(new Line3d(new Position(-width2 / 2, -Y4, Z4), new Position(-width2 / 2, -Y8, Z8)));
                            collection.Add(new Line3d(new Position(-width2 / 2, -Y8, Z8), new Position(-width2 / 2, -Y7, Z7)));

                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                            symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                            matrix = new Matrix4X4();
                            matrix.SetIdentity();
                            matrix.Rotate((Math.PI) + alpha2 * Math.PI / 180, new Vector(0, 0, 1));
                            Arc3d arc2 = symbolGeometryHelper.CreateArc(null, diameter1 / 2, (-beta2 - alpha2) * Math.PI / 180);
                            arc2.Transform(matrix);

                            matrix = new Matrix4X4();
                            matrix.SetIdentity();
                            matrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                            arc2.Transform(matrix);

                            matrix = new Matrix4X4();
                            matrix.SetIdentity();
                            matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                            arc2.Transform(matrix);

                            matrix = new Matrix4X4();
                            matrix.SetIdentity();
                            matrix.Translate(new Vector(-width2 / 2, 0, 0));
                            arc2.Transform(matrix);
                            collection.Add(arc2);

                            Vector side2Vector = new Vector(1, 0, 0);
                            Projection3d side2 = new Projection3d(new ComplexString3d(collection), side2Vector, width2, true);
                            outputs.Add(outputName + "side2", side2);
                        }
                    }
                    if (width1 < 0)
                    {
                        if (HgrCompareDoubleService.cmpdbl(angle1, 360) == false)
                        {
                            collection.Add(new Line3d(new Position(-width2 / 2, gap1 / 2, topZ), new Position(-width2 / 2, gap1 / 2, height1)));
                            collection.Add(new Line3d(new Position(-width2 / 2, gap1 / 2, height1), new Position(-width2 / 2, gap1 / 2 + thickness1, height1)));
                            collection.Add(new Line3d(new Position(-width2 / 2, gap1 / 2 + thickness1, height1), new Position(-width2 / 2, gap1 / 2 + thickness1, topThickZ)));

                            symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                            symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                            matrix.SetIdentity();
                            matrix.Rotate(((Math.PI) + alpha1 * Math.PI / 180), new Vector(1, 0, 0));
                            Arc3d arc1 = symbolGeometryHelper.CreateArc(null, diameter1 / 2 + thickness1, (-beta4 - alpha1) * Math.PI / 180);
                            arc1.Transform(matrix);

                            matrix = new Matrix4X4();
                            matrix.SetIdentity();
                            matrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                            arc1.Transform(matrix);

                            matrix = new Matrix4X4();
                            matrix.SetIdentity();
                            matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                            arc1.Transform(matrix);

                            matrix = new Matrix4X4();
                            matrix.SetIdentity();
                            matrix.Translate(new Vector(-width2 / 2, 0, 0));
                            arc1.Transform(matrix);
                            collection.Add(arc1);

                            collection.Add(new Line3d(new Position(-width2 / 2, -Y3, Z3), new Position(-width2 / 2, -Y4, Z4)));
                            collection.Add(new Line3d(new Position(-width2 / 2, -Y4, Z4), new Position(-width2 / 2, -Y8, Z8)));
                            collection.Add(new Line3d(new Position(-width2 / 2, -Y8, Z8), new Position(-width2 / 2, -Y7, Z7)));

                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                            symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                            matrix = new Matrix4X4();
                            matrix.SetIdentity();
                            matrix.Rotate((Math.PI + alpha2 * Math.PI / 180), new Vector(1, 0, 0));
                            Arc3d arc2 = symbolGeometryHelper.CreateArc(null, diameter1 / 2, (-beta2 - alpha2) * Math.PI / 180);
                            arc2.Transform(matrix);

                            matrix = new Matrix4X4();
                            matrix.SetIdentity();
                            matrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                            arc2.Transform(matrix);

                            matrix = new Matrix4X4();
                            matrix.SetIdentity();
                            matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                            arc2.Transform(matrix);

                            matrix = new Matrix4X4();
                            matrix.SetIdentity();
                            matrix.Translate(new Vector(-width2 / 2, 0, 0));
                            arc2.Transform(matrix);
                            collection.Add(arc2);

                            Vector side1Vector = new Vector(1, 0, 0);
                            Projection3d side1 = new Projection3d(new ComplexString3d(collection), side1Vector, width2, true);
                            outputs.Add(outputName + "side1", side1);

                        }
                    }
                }
                else if (height1 > 0 && height2 <= 0 && (HgrCompareDoubleService.cmpdbl(angle1, 180) == false))
                {
                    collection = new Collection<ICurve>();
                    collection.Add(new Line3d(new Position(-width1 / 2, -gap1 / 2, topZ), new Position(-width1 / 2, -gap1 / 2, height1)));
                    collection.Add(new Line3d(new Position(-width1 / 2, -gap1 / 2, height1), new Position(-width1 / 2, -gap1 / 2 - thickness1, height1)));
                    collection.Add(new Line3d(new Position(-width1 / 2, -gap1 / 2 - thickness1, height1), new Position(-width1 / 2, -gap1 / 2 - thickness1, topThickZ)));

                    symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    matrix.SetIdentity();
                    matrix.Rotate((alpha1 * Math.PI / 180), new Vector(0, 0, 1));
                    Arc3d arc1 = symbolGeometryHelper.CreateArc(null, diameter1 / 2 + thickness1, (2 * Math.PI - 2 * alpha1 * Math.PI / 180));
                    arc1.Transform(matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Rotate(3 * Math.PI / 2, new Vector(0, 1, 0));
                    arc1.Transform(matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                    arc1.Transform(matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Translate(new Vector(-width1 / 2, 0, 0));
                    arc1.Transform(matrix);
                    collection.Add(arc1);

                    collection.Add(new Line3d(new Position(-width1 / 2, gap1 / 2, topZ), new Position(-width1 / 2, gap1 / 2, height1)));
                    collection.Add(new Line3d(new Position(-width1 / 2, gap1 / 2, height1), new Position(-width1 / 2, gap1 / 2 + thickness1, height1)));
                    collection.Add(new Line3d(new Position(-width1 / 2, gap1 / 2 + thickness1, height1), new Position(-width1 / 2, gap1 / 2 + thickness1, topThickZ)));

                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Rotate((alpha2 * Math.PI / 180), new Vector(0, 0, 1));
                    Arc3d arc2 = symbolGeometryHelper.CreateArc(null, diameter1 / 2, (2 * Math.PI - 2 * alpha2 * Math.PI / 180));
                    arc2.Transform(matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Rotate(3 * Math.PI / 2, new Vector(0, 1, 0));
                    arc2.Transform(matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                    arc2.Transform(matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Translate(new Vector(-width1 / 2, 0, 0));
                    arc2.Transform(matrix);
                    collection.Add(arc2);

                    Vector side1Vector = new Vector(1, 0, 0);
                    Projection3d side1 = new Projection3d(new ComplexString3d(collection), side1Vector, width1, true);
                    outputs.Add(outputName + "side1", side1);
                }

                else if (height1 <= 0 && height2 > 0 && (HgrCompareDoubleService.cmpdbl(angle1, 180) == false))
                {
                    collection.Add(new Line3d(new Position(-width1 / 2, -Y1, Z1), new Position(-width1 / 2, -Y2, Z2)));
                    collection.Add(new Line3d(new Position(-width1 / 2, -Y2, Z2), new Position(-width1 / 2, -Y6, Z6)));
                    collection.Add(new Line3d(new Position(-width1 / 2, -Y6, Z6), new Position(-width1 / 2, -Y5, Z5)));

                    symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    matrix.SetIdentity();
                    matrix.Rotate(((Math.PI) - beta3 * Math.PI / 180), new Vector(0, 0, 1));
                    Arc3d arc1 = symbolGeometryHelper.CreateArc(null, diameter1 / 2 + thickness1, (-beta4 + beta3) * Math.PI / 180);
                    arc1.Transform(matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                    arc1.Transform(matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                    arc1.Transform(matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Translate(new Vector(-width1 / 2, 0, 0));
                    arc1.Transform(matrix);
                    collection.Add(arc1);

                    collection.Add(new Line3d(new Position(-width1 / 2, -Y3, Z3), new Position(-width1 / 2, -Y4, Z4)));
                    collection.Add(new Line3d(new Position(-width1 / 2, -Y4, Z4), new Position(-width1 / 2, -Y8, Z8)));
                    collection.Add(new Line3d(new Position(-width1 / 2, -Y8, Z8), new Position(-width1 / 2, -Y7, Z7)));

                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Rotate((Math.PI - beta1 * Math.PI / 180), new Vector(0, 0, 1));
                    Arc3d arc2 = symbolGeometryHelper.CreateArc(null, diameter1 / 2, (-beta2 + beta1) * Math.PI / 180);
                    arc2.Transform(matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                    arc2.Transform(matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                    arc2.Transform(matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Translate(new Vector(-width1 / 2, 0, 0));
                    arc2.Transform(matrix);
                    collection.Add(arc2);

                    Vector side1Vector = new Vector(1, 0, 0);
                    Projection3d side1 = new Projection3d(new ComplexString3d(collection), side1Vector, width1, true);
                    outputs.Add(outputName + "side1", side1);
                }
                else if (height1 > 0 && height2 <= 0 && (HgrCompareDoubleService.cmpdbl(angle1, 180) == true))
                {
                    topDimension = Math.Sqrt((((diameter1 / 2) + thickness1) * ((diameter1 / 2) + thickness1)) - ((thickness1 + (gap1 / 2)) * (thickness1 + (gap1 / 2))));

                    if ((HgrCompareDoubleService.cmpdbl(smallOffsetY, 0) == false) && (HgrCompareDoubleService.cmpdbl(smallOffsetZ, 0) == false))
                    {
                        collection.Add(new Line3d(new Position(-width1 / 2, -smallOffsetY, smallOffsetZ), new Position(-width1 / 2, -smallOffsetY, height1)));
                        collection.Add(new Line3d(new Position(-width1 / 2, -smallOffsetY, height1), new Position(-width1 / 2, -thickness1 - smallOffsetY, height1)));
                        collection.Add(new Line3d(new Position(-width1 / 2, -thickness1 - smallOffsetY, height1), new Position(-width1 / 2, -thickness1 - smallOffsetY, topDimension2)));

                        symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                        symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        matrix.SetIdentity();
                        matrix.Rotate(anglenogapBot2 * Math.PI / 180, new Vector(0, 0, 1));
                        Arc3d arc1 = symbolGeometryHelper.CreateArc(null, diameter1 / 2, (angleNoGapTop2 - anglenogapBot2) * Math.PI / 180);
                        arc1.Transform(matrix);

                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                        arc1.Transform(matrix);

                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                        arc1.Transform(matrix);

                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Translate(new Vector(-width1 / 2, 0, 0));
                        arc1.Transform(matrix);
                        collection.Add(arc1);

                        collection.Add(new Line3d(new Position(-width1 / 2, gap1 / 2, topZDimension), new Position(-width1 / 2, gap1 / 2, height1)));
                        collection.Add(new Line3d(new Position(-width1 / 2, gap1 / 2, height1), new Position(-width1 / 2, thickness1 + gap1 / 2, height1)));
                        collection.Add(new Line3d(new Position(-width1 / 2, thickness1 + gap1 / 2, height1), new Position(-width1 / 2, thickness1 + gap1 / 2, topDimension)));

                        symbolGeometryHelper = new SymbolGeometryHelper();
                        symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                        symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Rotate((Math.PI + angleNoGapBot * Math.PI / 180), new Vector(0, 0, 1));
                        Arc3d arc2 = symbolGeometryHelper.CreateArc(null, diameter1 / 2 + thickness1, (-angleNoGapTop - angleNoGapBot) * Math.PI / 180);
                        arc2.Transform(matrix);

                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                        arc2.Transform(matrix);

                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                        arc2.Transform(matrix);

                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Translate(new Vector(-width1 / 2, 0, 0));
                        arc2.Transform(matrix);
                        collection.Add(arc2);

                        Vector side1Vector = new Vector(1, 0, 0);
                        Projection3d side1 = new Projection3d(new ComplexString3d(collection), side1Vector, width1, true);
                        outputs.Add(outputName + "side1", side1);
                    }
                    else
                    {
                        collection.Add(new Line3d(new Position(-width1 / 2, -gap1 / 2, topZ), new Position(-width1 / 2, -gap1 / 2, height1)));
                        collection.Add(new Line3d(new Position(-width1 / 2, -gap1 / 2, height1), new Position(-width1 / 2, -gap1 / 2 - thickness1, height1)));
                        collection.Add(new Line3d(new Position(-width1 / 2, -gap1 / 2 - thickness1, height1), new Position(-width1 / 2, -gap1 / 2 - thickness1, topThickZ)));

                        symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                        symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        matrix.SetIdentity();
                        matrix.Rotate(Math.PI + alpha1 * Math.PI / 180, new Vector(0, 0, 1));
                        Arc3d arc1 = symbolGeometryHelper.CreateArc(null, diameter1 / 2 + thickness1, (-2 * alpha1) * Math.PI / 180);
                        arc1.Transform(matrix);

                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                        arc1.Transform(matrix);

                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                        arc1.Transform(matrix);

                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Translate(new Vector(-width1 / 2, 0, 0));
                        arc1.Transform(matrix);
                        collection.Add(arc1);

                        collection.Add(new Line3d(new Position(-width1 / 2, gap1 / 2, topZ), new Position(-width1 / 2, gap1 / 2, height1)));
                        collection.Add(new Line3d(new Position(-width1 / 2, gap1 / 2, height1), new Position(-width1 / 2, gap1 / 2 + thickness1, height1)));
                        collection.Add(new Line3d(new Position(-width1 / 2, gap1 / 2 + thickness1, height1), new Position(-width1 / 2, gap1 / 2 + thickness1, topThickZ)));

                        symbolGeometryHelper = new SymbolGeometryHelper();
                        symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                        symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Rotate((Math.PI + alpha2 * Math.PI / 180), new Vector(0, 0, 1));
                        Arc3d arc2 = symbolGeometryHelper.CreateArc(null, diameter1 / 2, (-2 * alpha2) * Math.PI / 180);
                        arc2.Transform(matrix);

                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                        arc2.Transform(matrix);

                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                        arc2.Transform(matrix);

                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Translate(new Vector(-width1 / 2, 0, 0));
                        arc2.Transform(matrix);
                        collection.Add(arc2);

                        Vector side1Vector = new Vector(1, 0, 0);
                        Projection3d side1 = new Projection3d(new ComplexString3d(collection), side1Vector, width1, true);
                        outputs.Add(outputName + "side1", side1);
                    }

                }
                else if (height1 <= 0 && height2 > 0 && (HgrCompareDoubleService.cmpdbl(angle1, 180) == true))
                {
                    topDimension = Math.Sqrt((((diameter1 / 2) + thickness1) * ((diameter1 / 2) + thickness1)) - ((thickness1 + (gap1 / 2)) * (thickness1 + (gap1 / 2))));

                    if ((HgrCompareDoubleService.cmpdbl(smallOffsetY, 0) == false) && (HgrCompareDoubleService.cmpdbl(smallOffsetZ, 0) == false))
                    {
                        collection.Add(new Line3d(new Position(-width1 / 2, -smallOffsetY, -smallOffsetZ), new Position(-width1 / 2, -smallOffsetY, -height2)));
                        collection.Add(new Line3d(new Position(-width1 / 2, -smallOffsetY, -height2), new Position(-width1 / 2, -thickness1 - smallOffsetY, -height2)));
                        collection.Add(new Line3d(new Position(-width1 / 2, -thickness1 - smallOffsetY, -height2), new Position(-width1 / 2, -thickness1 - smallOffsetY, -topDimension2)));

                        symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                        symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        matrix.SetIdentity();
                        matrix.Rotate(anglenogapBot2 * Math.PI / 180, new Vector(0, 0, 1));
                        Arc3d arc1 = symbolGeometryHelper.CreateArc(null, diameter1 / 2, (angleNoGapTop2 - anglenogapBot2) * Math.PI / 180);
                        arc1.Transform(matrix);

                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                        arc1.Transform(matrix);

                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                        arc1.Transform(matrix);

                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Translate(new Vector(-width1 / 2, 0, 0));
                        arc1.Transform(matrix);
                        collection.Add(arc1);

                        collection.Add(new Line3d(new Position(-width1 / 2, gap1 / 2, -topZDimension), new Position(-width1 / 2, gap2 / 2, -height2)));
                        collection.Add(new Line3d(new Position(-width1 / 2, gap2 / 2, -height2), new Position(-width1 / 2, thickness1 + gap2 / 2, -height2)));
                        collection.Add(new Line3d(new Position(-width1 / 2, thickness1 + gap2 / 2, -height2), new Position(-width1 / 2, thickness1 + gap2 / 2, -topDimension)));

                        symbolGeometryHelper = new SymbolGeometryHelper();
                        symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                        symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Rotate(angleNoGapBot * Math.PI / 180, new Vector(0, 0, 1));
                        Arc3d arc2 = symbolGeometryHelper.CreateArc(null, diameter1 / 2 + thickness1, (-2 * angleNoGapTop) * Math.PI / 180);
                        arc2.Transform(matrix);

                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                        arc2.Transform(matrix);

                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                        arc2.Transform(matrix);

                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Translate(new Vector(-width1 / 2, 0, 0));
                        arc2.Transform(matrix);
                        collection.Add(arc2);

                        Vector side1Vector = new Vector(1, 0, 0);
                        Projection3d side1 = new Projection3d(new ComplexString3d(collection), side1Vector, width1, true);
                        outputs.Add(outputName + "side1", side1);
                    }

                    else
                    {
                        collection.Add(new Line3d(new Position(-width2 / 2, -Y3, Z3), new Position(-width2 / 2, -Y4, Z4)));
                        collection.Add(new Line3d(new Position(-width2 / 2, -Y4, Z4), new Position(-width2 / 2, -Y8, Z8)));
                        collection.Add(new Line3d(new Position(-width2 / 2, -Y8, Z8), new Position(-width2 / 2, -Y7, Z7)));

                        symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                        symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        matrix.SetIdentity();
                        matrix.Rotate(Math.PI + beta4 * Math.PI / 180, new Vector(0, 0, 1));
                        Arc3d arc1 = symbolGeometryHelper.CreateArc(null, diameter1 / 2 + thickness1, (-2 * beta4) * Math.PI / 180);
                        arc1.Transform(matrix);

                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                        arc1.Transform(matrix);

                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                        arc1.Transform(matrix);

                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Translate(new Vector(-width2 / 2, 0, 0));
                        arc1.Transform(matrix);
                        collection.Add(arc1);

                        collection.Add(new Line3d(new Position(-width2 / 2, Y3, Z3), new Position(-width2 / 2, Y4, Z4)));
                        collection.Add(new Line3d(new Position(-width2 / 2, Y4, Z4), new Position(-width2 / 2, Y8, Z8)));
                        collection.Add(new Line3d(new Position(-width2 / 2, Y8, Z8), new Position(-width2 / 2, Y7, Z7)));

                        symbolGeometryHelper = new SymbolGeometryHelper();
                        symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                        symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Rotate((Math.PI + beta2 * Math.PI / 180), new Vector(0, 0, 1));
                        Arc3d arc2 = symbolGeometryHelper.CreateArc(null, diameter1 / 2, (-2 * beta2) * Math.PI / 180);
                        arc2.Transform(matrix);

                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                        arc2.Transform(matrix);

                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                        arc2.Transform(matrix);

                        matrix = new Matrix4X4();
                        matrix.SetIdentity();
                        matrix.Translate(new Vector(-width2 / 2, 0, 0));
                        arc2.Transform(matrix);
                        collection.Add(arc2);

                        Vector side1Vector = new Vector(1, 0, 0);
                        Projection3d side1 = new Projection3d(new ComplexString3d(collection), side1Vector, width1, true);
                        outputs.Add(outputName + "side1", side1);
                    }
                }
                Geometry3d transformObject;
                Matrix4X4 rotatematrix = new Matrix4X4();
                if ((HgrCompareDoubleService.cmpdbl(rotAngle, 0) == false))
                {


                    rotatematrix.Rotate(rotAngle, new Vector(1, 0, 0));

                    if (angle1 < angleValue2 && angle1 > angleValue1 || width2 < 0)
                    {
                        transformObject = (Geometry3d)outputs[outputName + "side1"];
                        transformObject.Transform(rotatematrix);
                    }
                    else if (height1 > 0 && height2 <= 0)
                    {
                        transformObject = (Geometry3d)outputs[outputName + "side1"];
                        transformObject.Transform(rotatematrix);
                    }
                    else if (height1 <= 0 && height2 > 0)
                    {
                        transformObject = (Geometry3d)outputs[outputName + "side1"];
                        transformObject.Transform(rotatematrix);
                    }
                    else if ((HgrCompareDoubleService.cmpdbl(angle1, 360) == false) && width2 >= 0)
                    {
                        transformObject = (Geometry3d)outputs[outputName + "side1"];
                        transformObject.Transform(rotatematrix);
                        transformObject = (Geometry3d)outputs[outputName + "side2"];
                        transformObject.Transform(rotatematrix);
                    }

                }
                if (isRaiser)
                {
                    rotatematrix = new Matrix4X4();
                    rotatematrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));

                    if (angle1 < angleValue2 && angle1 > angleValue1 || width2 < 0)
                    {
                        transformObject = (Geometry3d)outputs[outputName + "side1"];
                        transformObject.Transform(rotatematrix);
                    }
                    else if (height1 > 0 && height2 <= 0)
                    {
                        transformObject = (Geometry3d)outputs[outputName + "side1"];
                        transformObject.Transform(rotatematrix);
                    }
                    else if (height1 <= 0 && height2 > 0)
                    {
                        transformObject = (Geometry3d)outputs[outputName + "side1"];
                        transformObject.Transform(rotatematrix);
                    }
                    else if ((HgrCompareDoubleService.cmpdbl(angle1, 360) == false) && width2 >= 0)
                    {
                        transformObject = (Geometry3d)outputs[outputName + "side1"];
                        transformObject.Transform(rotatematrix);
                        transformObject = (Geometry3d)outputs[outputName + "side2"];
                        transformObject.Transform(rotatematrix);
                    }

                }
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddClampShapeMethod, "Error in AddClampShape");
                }
            }
        }
        /// <summary>
        /// Adds BoltRows
        /// </summary>
        /// <param name="angle1">- Double</param>
        /// <param name="boltRows">String Array</param>
        /// <param name="pindiameter">- Double</param>
        /// <param name="pinLength">- Double</param>
        /// <param name="width">- Double</param>
        /// <param name="rotAngle">- Double</param>
        /// <param name="outputs">the outputs</param>
        /// <param name="outputName">The Name Of The Output</param>
        /// <param name="isRaiser">- Boolean</param>
        /// <code>AddBoltRows(pipeClamp.Width1, boltrows, pipeClamp.Pin1Diameter, pipeClamp.Pin1Length, angle1, outputs, outputName);</code>
        public void AddBoltRows(Double width, string[] boltRows, Double pindiameter, Double pinLength, Double angle1, OutputDictionary outputs, String outputName, Double rotAngle = 0, Boolean isRaiser = false)
        {
            try
            {
                Double numTopRows = 0, numBottomRows = 0;
                int i = 0;

                numTopRows = GetNumRows(Convert.ToDouble(boltRows[1]), Convert.ToDouble(boltRows[9]), Convert.ToDouble(boltRows[17]));
                numBottomRows = GetNumRows(Convert.ToDouble(boltRows[5]), Convert.ToDouble(boltRows[13]), Convert.ToDouble(boltRows[21]));

                for (i = 0; i < numTopRows; i++)
                {
                    if (i == 0 && Convert.ToDouble(boltRows[1]) > 0)
                        AddBoltsByRow(width, Convert.ToDouble(boltRows[1]), Convert.ToDouble(boltRows[2]), Convert.ToDouble(boltRows[3]), pindiameter, pinLength, Convert.ToDouble(boltRows[0]), 0, 1, outputs, outputName + "bolt", "Bolts", rotAngle, isRaiser);
                    if (i == 1 && Convert.ToDouble(boltRows[9]) > 0)
                        AddBoltsByRow(width, Convert.ToDouble(boltRows[9]), Convert.ToDouble(boltRows[10]), Convert.ToDouble(boltRows[11]), pindiameter, pinLength, Convert.ToDouble(boltRows[8]), 0, 3, outputs, outputName + "bolt", "Bolts", rotAngle, isRaiser);
                    if (i == 2 && Convert.ToDouble(boltRows[17]) > 0)
                        AddBoltsByRow(width, Convert.ToDouble(boltRows[17]), Convert.ToDouble(boltRows[18]), Convert.ToDouble(boltRows[19]), pindiameter, pinLength, Convert.ToDouble(boltRows[16]), 0, 5, outputs, outputName + "bolt", "Bolts", rotAngle, isRaiser);
                }

                for (i = 0; i < numBottomRows; i++)
                {
                    if (i == 0 && Convert.ToDouble(boltRows[5]) > 0)
                        AddBoltsByRow(width, Convert.ToDouble(boltRows[5]), Convert.ToDouble(boltRows[6]), Convert.ToDouble(boltRows[7]), pindiameter, pinLength, Convert.ToDouble(boltRows[4]), angle1, 2, outputs, outputName + "bolt", "Bolts", rotAngle, isRaiser);
                    if (i == 1 && Convert.ToDouble(boltRows[13]) > 0)
                        AddBoltsByRow(width, Convert.ToDouble(boltRows[13]), Convert.ToDouble(boltRows[14]), Convert.ToDouble(boltRows[15]), pindiameter, pinLength, Convert.ToDouble(boltRows[12]), angle1, 4, outputs, outputName + "bolt", "Bolts", rotAngle, isRaiser);
                    if (i == 2 && Convert.ToDouble(boltRows[21]) > 0)
                        AddBoltsByRow(width, Convert.ToDouble(boltRows[21]), Convert.ToDouble(boltRows[22]), Convert.ToDouble(boltRows[23]), pindiameter, pinLength, Convert.ToDouble(boltRows[20]), angle1, 6, outputs, outputName + "bolt", "Bolts", rotAngle, isRaiser);
                }
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddBoltRowsMethod, "Error in AddBoltRows");
                }
            }
        }
        /// <summary>
        /// Returns the Number of Rows
        /// </summary>
        /// <param name="row1">- Double</param>
        /// <param name="row2">- Double</param>
        /// <param name="row3">- Double</param>
        /// <code>numTopRows = GetNumRows(Convert.ToDouble(boltRows[1]), Convert.ToDouble(boltRows[9]), Convert.ToDouble(boltRows[17]));</code>
        public Double GetNumRows(Double row1, Double row2, Double row3)
        {
            double numrows = 0;
            if (row1 > 0)
                numrows = numrows + 1;
            if (row2 > 0)
                numrows = numrows + 1;
            if (row3 > 0)
                numrows = numrows + 1;
            return numrows;
        }
        /// <summary>
        /// Create the graphical representation of the bolts
        /// </summary>
        /// <param name="width">- Double - Width of item that we want position on</param>
        /// <param name="qty">- Double  - Quantity of bolts to be placed</param>
        /// <param name="locateBy">- Double - Can be 0 - Nothing, 1 - Center or 2 - Edge</param>
        /// <param name="distance">- Double - Distance from the locateBy that we want the botls placed</param>
        /// <param name="pinDiameter">- Double - Diameter of the bolts</param>
        /// <param name="pinLength">- Double - Length of the bolts</param>
        /// <param name="offset">- Double - Distance from the clamp center we want the bolts placed</param>
        /// <param name="angle1">- Double - The Sweep angle between the top and bottom tabs.</param>
        /// <param name="row">- Double - Row number of the bolts that we are placing</param>
        /// <param name="outputs">The Outputs</param>
        /// <param name="outputName">The Output name</param>
        /// <param name="name">- string - optional - Optional name of the graphic being placed.</param>
        /// <param name="rotAngle">- Double - Optional - Angle that the whole clamp graphic will rotate by (on x axis).</param>
        /// <param name="isRaiser">- Boolean - Optional - To state wether or not this is a riser clamp or not.</param>
        /// <code>AddBoltsByRow(blockClamp.Length1 + blockClamp.Offset3, blockClamp.Multi1Qty, blockClamp.Multi1LocateBy, blockClamp.Multi1Location, blockClamp.Pin1Diameter, blockClamp.Pin1Length, -blockClamp.Offset4, 90, 1, outputs, outputName + "Bolt", outputName + "Bolt", 0, false, 0);</code>
        public void AddBoltsByRow(Double width, Double qty, Double locateBy, Double distance, Double pinDiameter, Double pinLength, Double offset, Double angle1, Double row, OutputDictionary outputs, String outputName, String name = "None", Double rotAngle = 0, Boolean isRaiser = false, Double zOffset = 0)
        {
            try
            {
                Double angle2 = 0, angle3 = 0, angle4 = 0;
                Double calc1 = 0, calc2 = 0, calc3 = 0, calc4 = 0, calc5 = 0;
                const Double angleValue1 = 179.9999;
                const Double angleValue2 = 180.0001;
                const Double angleValue3 = 89.9999;
                const Double angleValue4 = 90.0001;
                const Double angleValue5 = 269.9999;
                const Double angleValue6 = 270.0001;
                const Double angleValue7 = 359.9999;
                const Double angleValue8 = 360.0001;
                const Double angleValue10 = 90;
                const Double angleValue11 = 180;
                const Double angleValue12 = 270;
                const Double angleValue13 = 360;

                SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();

                angle2 = Math.Atan((pinLength / 2) / offset) * 180 / Math.PI;
                if (angle1 > 0 && angle1 < angleValue10)
                    angle3 = angleValue10 - (angle1 + angle2);
                else if (angle1 > angleValue10 && angle1 < angleValue11)
                    angle3 = angle1 - angleValue10 - angle2;
                else if (angle1 > angleValue11 && angle1 < angleValue12)
                    angle3 = angleValue12 - (angle1 + angle2);
                else if (angle1 > angleValue12 && angle1 < angleValue13)
                    angle3 = angle1 - angleValue12 - angle2;

                angle4 = (angle2 * 2) + angle3;

                calc1 = Math.Sqrt(((offset) * (offset)) + ((pinLength / 2) * (pinLength / 2)));
                calc2 = Math.Cos(angle3 * (Math.PI / 180)) * calc1;
                calc3 = Math.Sin(angle3 * (Math.PI / 180)) * calc1;
                calc4 = Math.Cos(angle4 * (Math.PI / 180)) * calc1;
                calc5 = Math.Sin(angle4 * (Math.PI / 180)) * calc1;

                Double[] boltXLocation = new double[Convert.ToInt64(qty)]; ;
                int i = 0;
                for (i = 0; i <= qty - 1; i++)
                {
                    boltXLocation[i] = MultiPosition(width, qty, locateBy, distance, pinDiameter)[i];
                }
                if ((HgrCompareDoubleService.cmpdbl(angle1, 0) == true))
                {
                    for (i = 0; i <= qty - 1; i++)
                    {
                        Vector normal = new Position(-width / 2 + boltXLocation[i], (pinLength / 2) + zOffset, offset).Subtract(new Position(-width / 2 + boltXLocation[i], (-pinLength / 2) + zOffset, offset));
                        Vector orthogonal = normal.GetOrthogonalVector();
                        symbolGeometryHelper.ActivePosition = new Position(-width / 2 + boltXLocation[i], (-pinLength / 2) + zOffset, offset);
                        symbolGeometryHelper.SetOrientation(normal, orthogonal);
                        Projection3d cylinder1 = symbolGeometryHelper.CreateCylinder(null, pinDiameter / 2, normal.Length);
                        outputs.Add(outputName + row + i, cylinder1);

                    }
                }
                else if (angle1 > angleValue1 && angle1 < angleValue2)
                {
                    for (i = 0; i <= qty - 1; i++)
                    {
                        Vector normal = new Position(-width / 2 + boltXLocation[i], (pinLength / 2) + zOffset, -offset).Subtract(new Position(-width / 2 + boltXLocation[i], (-pinLength / 2) + zOffset, -offset));
                        Vector orthogonal = normal.GetOrthogonalVector();
                        symbolGeometryHelper.ActivePosition = new Position(-width / 2 + boltXLocation[i], (-pinLength / 2) + zOffset, -offset);
                        symbolGeometryHelper.SetOrientation(normal, orthogonal);
                        Projection3d cylinder1 = symbolGeometryHelper.CreateCylinder(null, pinDiameter / 2, normal.Length);
                        outputs.Add(outputName + row + i, cylinder1);
                    }
                }
                else if (angle1 > angleValue3 && angle1 < angleValue4)
                {
                    for (i = 0; i <= qty - 1; i++)
                    {
                        Vector normal = new Position(-width / 2 + boltXLocation[i], -offset, (pinLength / 2) + zOffset).Subtract(new Position(-width / 2 + boltXLocation[i], -offset, (-pinLength / 2) + zOffset));
                        Vector orthogonal = normal.GetOrthogonalVector();
                        symbolGeometryHelper.ActivePosition = new Position(-width / 2 + boltXLocation[i], -offset, (-pinLength / 2) + zOffset);
                        symbolGeometryHelper.SetOrientation(normal, orthogonal);
                        Projection3d cylinder1 = symbolGeometryHelper.CreateCylinder(null, pinDiameter / 2, normal.Length);
                        outputs.Add(outputName + row + i, cylinder1);
                    }
                }
                else if (angle1 > angleValue5 && angle1 < angleValue6)
                {
                    for (i = 0; i <= qty - 1; i++)
                    {
                        Vector normal = new Position(-width / 2 + boltXLocation[i], offset, (pinLength / 2) + zOffset).Subtract(new Position(-width / 2 + boltXLocation[i], offset, (-pinLength / 2) + zOffset));
                        Vector orthogonal = normal.GetOrthogonalVector();
                        symbolGeometryHelper.ActivePosition = new Position(-width / 2 + boltXLocation[i], offset, (-pinLength / 2) + zOffset);
                        symbolGeometryHelper.SetOrientation(normal, orthogonal);
                        Projection3d cylinder1 = symbolGeometryHelper.CreateCylinder(null, pinDiameter / 2, normal.Length);
                        outputs.Add(outputName + row + i, cylinder1);
                    }
                }
                else if (angle1 > angleValue7 && angle1 < angleValue8)
                {
                    for (i = 0; i <= qty - 1; i++)
                    {
                        Vector normal = new Position(-width / 2 + boltXLocation[i], (pinLength / 2) + zOffset, offset).Subtract(new Position(-width / 2 + boltXLocation[i], (-pinLength / 2) + zOffset, offset));
                        Vector orthogonal = normal.GetOrthogonalVector();
                        symbolGeometryHelper.ActivePosition = new Position(-width / 2 + boltXLocation[i], (-pinLength / 2) + zOffset, offset);
                        symbolGeometryHelper.SetOrientation(normal, orthogonal);
                        Projection3d cylinder1 = symbolGeometryHelper.CreateCylinder(null, pinDiameter / 2, normal.Length);
                        outputs.Add(outputName + row + i, cylinder1);
                    }
                }
                else
                {
                    for (i = 0; i <= qty - 1; i++)
                    {
                        if (angle1 > 0 && angle1 < 90)
                        {
                            Vector normal = new Position(-width / 2 + boltXLocation[i], -calc4, calc5).Subtract(new Position(-width / 2 + boltXLocation[i], -calc2, calc3));
                            Vector orthogonal = normal.GetOrthogonalVector();
                            symbolGeometryHelper.ActivePosition = new Position(-width / 2 + boltXLocation[i], -calc2, calc3);
                            symbolGeometryHelper.SetOrientation(normal, orthogonal);
                            Projection3d cylinder1 = symbolGeometryHelper.CreateCylinder(null, pinDiameter / 2, normal.Length);
                            outputs.Add(outputName + row + i, cylinder1);
                        }
                        else if (angle1 > 90 && angle1 < 180)
                        {
                            Vector normal = new Position(-width / 2 + boltXLocation[i], -calc4, -calc5).Subtract(new Position(-width / 2 + boltXLocation[i], -calc2, -calc3));
                            Vector orthogonal = normal.GetOrthogonalVector();
                            symbolGeometryHelper.ActivePosition = new Position(-width / 2 + boltXLocation[i], -calc2, -calc3);
                            symbolGeometryHelper.SetOrientation(normal, orthogonal);
                            Projection3d cylinder1 = symbolGeometryHelper.CreateCylinder(null, pinDiameter / 2, normal.Length);
                            outputs.Add(outputName + row + i, cylinder1);
                        }
                        else if (angle1 > 180 && angle1 < 270)
                        {
                            Vector normal = new Position(-width / 2 + boltXLocation[i], calc4, -calc5).Subtract(new Position(-width / 2 + boltXLocation[i], calc2, -calc3));
                            Vector orthogonal = normal.GetOrthogonalVector();
                            symbolGeometryHelper.ActivePosition = new Position(-width / 2 + boltXLocation[i], calc2, -calc3);
                            symbolGeometryHelper.SetOrientation(normal, orthogonal);
                            Projection3d cylinder1 = symbolGeometryHelper.CreateCylinder(null, pinDiameter / 2, normal.Length);
                            outputs.Add(outputName + row + i, cylinder1);
                        }
                        else if (angle1 > 270 && angle1 < 360)
                        {
                            Vector normal = new Position(-width / 2 + boltXLocation[i], calc4, calc5).Subtract(new Position(-width / 2 + boltXLocation[i], calc2, calc3));
                            Vector orthogonal = normal.GetOrthogonalVector();
                            symbolGeometryHelper.ActivePosition = new Position(-width / 2 + boltXLocation[i], calc2, calc3);
                            symbolGeometryHelper.SetOrientation(normal, orthogonal);
                            Projection3d cylinder1 = symbolGeometryHelper.CreateCylinder(null, pinDiameter / 2, normal.Length);
                            outputs.Add(outputName + row + i, cylinder1);
                        }
                    }

                }

                String[] objectCollection = new String[(int)qty + 1];
                for (i = 0; i <= (int)qty - 1; i++)
                    objectCollection[i + 1] = outputName + row + i;

                Geometry3d transformObject;
                Matrix4X4 matrix = new Matrix4X4();

                if (HgrCompareDoubleService.cmpdbl(rotAngle, 0) == false)
                {
                    matrix.Rotate(rotAngle, new Vector(1, 0, 0));
                    for (int k = 1; k < objectCollection.Length; k++)
                    {
                        if (objectCollection[k] != null)
                        {
                            transformObject = (Geometry3d)outputs[objectCollection[k]];
                            transformObject.Transform(matrix);
                        }
                    }
                }
                if (isRaiser)
                {
                    matrix = new Matrix4X4();
                    matrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                    for (int k = 1; k < objectCollection.Length; k++)
                    {
                        if (objectCollection[k] != null)
                        {
                            transformObject = (Geometry3d)outputs[objectCollection[k]];
                            transformObject.Transform(matrix);
                        }
                    }
                }
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddBoltByRowMethod, "Error in AddBoltByRow");
                }
            }
        }
        /// <summary>
        /// Returns array of Positions
        /// </summary>
        /// <param name="width">- Double - Width of item that we want position on</param>
        /// <param name="qty">- Double  - Quantity of bolts to be placed</param>
        /// <param name="locateBy">- Double - Can be 0 - Nothing, 1 - Center or 2 - Edge</param>
        /// <param name="distance">- Double - Distance from the locateBy that we want the location of</param>
        /// <param name="multiWidth">- Double - Width of the graphics that will be place at the returned location</param>
        /// <code>uboltXLocation[i] = MultiPosition(yokeClamp.Width3, yokeClamp.Multi1Qty, yokeClamp.Multi1LocateBy, yokeClamp.Multi1Location, yokeClamp.UBolt.UBoltRodDia)[i];</code>
        public Double[] MultiPosition(Double width, Double qty, Double locateBy, Double distance, Double multiWidth)
        {
            Double[] tempArray = new Double[Convert.ToInt64(qty)];
            try
            {
                StringBuilder error = new StringBuilder();

                if ((int)qty == 1)
                {
                    if ((int)locateBy == 1 && HgrCompareDoubleService.cmpdbl(distance, 0) == true)
                        tempArray[0] = width / 2;
                    else if ((int)locateBy == 1 && HgrCompareDoubleService.cmpdbl(distance, 0) == false)
                        tempArray[0] = (width / 2) - distance;
                    else if ((int)locateBy == 2 && HgrCompareDoubleService.cmpdbl(distance, 0) == true)
                        tempArray[0] = 0;
                    else if ((int)locateBy == 2 && HgrCompareDoubleService.cmpdbl(distance, 0) == false)
                        tempArray[0] = (multiWidth / 2) + distance;
                }

                if ((int)qty == 2)
                {
                    if ((int)locateBy == 1 && HgrCompareDoubleService.cmpdbl(distance, 0) == false)
                    {
                        tempArray[0] = (width / 2) - distance / 2;
                        tempArray[1] = (width / 2) + distance / 2;
                    }
                    else if ((int)locateBy == 2 && HgrCompareDoubleService.cmpdbl(distance, 0) == true)
                    {
                        tempArray[0] = 0;
                        tempArray[1] = width;
                    }
                    else if ((int)locateBy == 2 && HgrCompareDoubleService.cmpdbl(distance, 0) == false)
                    {
                        tempArray[0] = (multiWidth / 2) + distance;
                        tempArray[1] = width - ((multiWidth / 2) + distance);
                    }
                    else
                    {
                        tempArray[0] = width / 2;
                        tempArray[1] = width / 2;
                        error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidQty2, "You should not pass a Qty of 2 located by center with a distance of zero"));
                    }
                }

                if ((int)qty == 3)
                {
                    if ((int)locateBy == 1 && HgrCompareDoubleService.cmpdbl(distance, 0) == false)
                    {
                        tempArray[0] = (width / 2) - distance;
                        tempArray[1] = (width / 2);
                        tempArray[2] = width / 2 + distance;
                    }
                    else if ((int)locateBy == 2 && HgrCompareDoubleService.cmpdbl(distance, 0) == true)
                    {
                        tempArray[0] = 0;
                        tempArray[1] = width / 2;
                        tempArray[2] = width;
                    }
                    else if ((int)locateBy == 2 && HgrCompareDoubleService.cmpdbl(distance, 0) == false)
                    {
                        tempArray[0] = (multiWidth / 2) + distance;
                        tempArray[1] = width / 2;
                        tempArray[2] = width - ((multiWidth / 2) + distance); ;
                    }
                    else
                    {
                        tempArray[0] = width / 2;
                        tempArray[1] = width / 2;
                        tempArray[2] = width / 2;
                        error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidQty3, "You should not have a Quantity of 3 located by center with a distance of zero"));
                    }
                }

                if (qty > 3)
                {
                    if (distance > 0)
                    {
                        int i = 1;
                        Double tempDistance = 0, startDistance = 0;

                        if ((int)qty % 2 == 0)
                            startDistance = ((width / 2) - (distance / 2)) - (((qty / 2) - 1) * distance);
                        else
                            startDistance = (width / 2) - (((qty - 1) / 2) * distance);
                        tempArray[0] = startDistance;
                        tempDistance = startDistance;

                        for (i = 1; i <= qty - 1; i++)
                        {
                            tempArray[i] = tempDistance + distance;
                            tempDistance = tempDistance + distance;
                        }
                        if ((((qty - 1) * distance) + multiWidth) > width)
                            error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidWidthQty, "The Width is too small for the distance and Quantity"));
                    }
                    else
                    {
                        error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidDistance, "There should be a distance greater than zero"));
                    }
                }
                if (error.Length != 0)
                {
                    ToDoListMessage = new ToDoListMessage(ToDoMessageTypes.ToDoMessageWarning, error.ToString());
                }
                return tempArray;
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrMutiPositionMethod, "Error in MultiPosition");
                }
                return tempArray;
            }
        }
        /// <summary>
        /// Create side connection
        /// </summary>
        /// <param name="diameter1">- Double-Inside diameter of pipe clamp body.</param>
        /// <param name="thickness1">- Double-- Thickness of stock used to make clamp body.Also defines thickness of the top and bottom tabs.</param>
        /// <param name="thickness3">- Double-The thickness of the side connection shape, from the outside face of the clamp, to the outside face of the side connection.</param>
        /// <param name="width5">- Double-The outside dimension of the side connection shape.</param>
        /// <param name="width6">- Double-For NutShape 2 (square), use Width6 to create a rectangle shape instead of a square.</param>
        /// <param name="x">- Double</param>
        /// <param name="y">- Double</param>
        /// <param name="z">- Double</param>
        /// <param name="shapeType">- Long-The graphic shape to use for the side connection graphic.</param>
        /// <param name="outputs">The Outputs</param>
        /// <param name="outputName">The Output Name</param>
        /// <param name="rotAngle">- Double-- Optional - Angle that the whole clamp graphic will rotate by (on x axis).</param>
        /// <param name="isRaiser">- Boolean-Optional - To state wether or not this is a riser clamp or not.</param>
        /// <code>CreateSideConnection(pipeClamp.Diameter1, pipeClamp.Thickness1, pipeClamp.Thickness3, pipeClamp.Width5, pipeClamp.Width6, 0, pipeClamp.Diameter1 / 2, pipeClamp.Thickness1, Convert.ToInt64(pipeClamp.ShapeType), 0, outputs, outputName);</code>
        public void CreateSideConnection(Double diameter1, Double thickness1, Double thickness3, Double width5, Double width6, Double x, Double y, Double z, long shapeType, Double rotAngle, OutputDictionary outputs, String outputName, Boolean isRaiser = false)
        {
            try
            {
                Double nutCalc = 0, extraThickness = 0;

                if (HgrCompareDoubleService.cmpdbl(diameter1, 0) == false)
                {
                    nutCalc = Math.Sqrt((((diameter1 / 2) + thickness1) * ((diameter1 / 2) + thickness1)) - ((width5 / 2) * (width5 / 2)));
                    extraThickness = ((diameter1 / 2) + thickness1) - nutCalc;
                }
                else
                {
                    nutCalc = 0;
                    extraThickness = 0;
                }

                NutInputs nutShape;
                nutShape.ShapeType = Convert.ToInt32(shapeType);
                nutShape.ShapeWidth1 = width5;
                nutShape.ShapeWidth2 = width6;
                nutShape.ShapeLength = thickness3 + extraThickness;

                Matrix4X4 nutMatrix = new Matrix4X4();
                switch (shapeType)
                {

                    case 1:
                        if (isRaiser)
                        {
                            nutMatrix = new Matrix4X4();
                            nutMatrix.Rotate(Math.PI / 2, new Vector(1, 0, 0));
                            nutMatrix.Rotate(Math.PI / 2, new Vector(0, 0, 1));
                            nutMatrix.Origin = new Position(nutCalc, 0, 0);
                            AddNut(nutShape, nutMatrix, outputs, outputName + "Nut");
                        }
                        else
                        {
                            nutMatrix = new Matrix4X4();
                            nutMatrix.Rotate(Math.PI / 2, new Vector(1, 0, 0));
                            nutMatrix.Rotate(Math.PI, new Vector(0, 0, 1));
                            nutMatrix.Origin = new Position(0, nutCalc, 0);
                            AddNut(nutShape, nutMatrix, outputs, outputName + "Nut");
                        }
                        break;
                    case 2:
                        if (HgrCompareDoubleService.cmpdbl(width6, 0) == true)
                            width6 = width5;
                        if (isRaiser)
                        {
                            nutMatrix = new Matrix4X4();
                            nutMatrix.Rotate(3 * (Math.PI) / 2, new Vector(0, 1, 0));
                            nutMatrix.Origin = new Position(nutCalc, 0, 0);
                            AddNut(nutShape, nutMatrix, outputs, outputName + "Nut");
                        }
                        else
                        {
                            nutMatrix = new Matrix4X4();
                            nutMatrix.Rotate(3 * (Math.PI) / 2, new Vector(1, 0, 0));
                            nutMatrix.Origin = new Position(0, nutCalc, 0);
                            AddNut(nutShape, nutMatrix, outputs, outputName + "Nut");
                        }
                        break;
                    case 3:
                        if (isRaiser)
                        {
                            nutMatrix = new Matrix4X4();
                            nutMatrix.Rotate(Math.PI, new Vector(0, 0, 1));
                            nutMatrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                            nutMatrix.Origin = new Position(nutCalc, 0, 0);
                            nutMatrix.Origin = new Position(nutCalc, 0, 0);
                            AddNut(nutShape, nutMatrix, outputs, outputName + "Nut");
                        }
                        else
                        {
                            nutMatrix = new Matrix4X4();
                            nutMatrix.Rotate(Math.PI / 2, new Vector(1, 0, 0));
                            nutMatrix.Rotate(Math.PI, new Vector(0, 0, 1));
                            nutMatrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                            nutMatrix.Origin = new Position(0, nutCalc, 0);
                            AddNut(nutShape, nutMatrix, outputs, outputName + "Nut");
                        }
                        break;
                }
                if (HgrCompareDoubleService.cmpdbl(rotAngle, 0) == false)
                {
                    Matrix4X4 matrix = new Matrix4X4();
                    matrix.Rotate(rotAngle, new Vector(1, 0, 0));
                    Geometry3d transformObject = (Geometry3d)outputs[outputName + "Nut"];
                    transformObject.Transform(matrix);
                }
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrCreateSideConnection, "Error in CreateSideConnection");
                }
            }
        }
        /// <summary>
        /// Adds Gussets
        /// </summary>
        /// <param name="diameter1">- Double-Inside diameter of clamp body</param>
        /// <param name="width1">- Double-Width of clamp body.  If Width 1 is negative, the left half of the clamp is not displayed.</param>
        /// <param name="thickness1">- Double- Thickness of stock used to make clamp body.Also defines thickness of the top and bottom tabs.</param>
        /// <param name="thickness2">- DoubleIf zero, the gussets are NOT drawn. If positive, the gussets are drawn inside the clamp body. If negative, the gussets are drawn outside the clamp body.</param>
        /// <param name="gap1">- Double- The gap between the two top tabs.  Can be zero but not negative.</param>
        /// <param name="gap2">- Double- The gap between the two bottom tabs.  Can be zero but not negative.</param>
        /// <param name="width2">- Double- Optional second width of clamp body.  if set to zero then dWidth1 will be used.  If set to less then zero then the right half of the clamp is not displayed.</param>
        /// <param name="height1">- Double- Height from pipe center to top of the clamp.  IF 0 or less than outside diameter of clamp body, top tabs are not included.</param>
        /// <param name="height2">- Double- Height from pipe center to bottom of the clamp.  IF 0 or less than outside diameter of clamp body, top tabs are not included.</param>
        /// <param name="dim1">- Double Width of gusset at the end of the clamp. Same value is used at both ends of the clamp, on both sides. Can be positive, zero, or negative.</param>
        /// <param name="dim2">- DoubleDistance the gusset extends past the clamp body at the center of the clamp. Can be positive, zero, or negative.</param>
        /// <param name="rotAngle">- Double- Optional - Angle that the whole clamp graphic will rotate by (on x axis).</param>
        /// <param name="bottomSide">- Boolean</param>
        /// <param name="topSide">- Boolean</param>
        /// <param name="outputs">The Outputs</param>
        /// <param name="outputName">The Output Name</param>
        /// <param name="isRaiser">- Boolean - Optional - To state wether or not this is a riser clamp or not.</param>
        /// <code> AddGussets(pipeClamp.Diameter1, pipeClamp.Width2, pipeClamp.Thickness1, pipeClamp.Thickness2, pipeClamp.Gap1, pipeClamp.Gap2, pipeClamp.Width1, pipeClamp.Height1, pipeClamp.Height2, pipeClamp.Dim1, pipeClamp.Dim2, outputs, outputName, 0, false, true, true);</code>
        public void AddGussets(Double diameter1, Double width2, Double thickness1, Double thickness2, Double gap1, Double gap2, Double width1, Double height1, Double height2, Double dim1, Double dim2, OutputDictionary outputs, String outputName, Double rotAngle = 0, Boolean isRaiser = true, Boolean topSide = true, Boolean bottomSide = true)
        {
            try
            {
                Double gussetCalc1 = 0, gussetCalc2 = 0, gussetAngle1 = 0, gussetAngle2 = 0;
                String[] objectCollection = new String[4];

                SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();
                Matrix4X4 matrix = new Matrix4X4();
                Line3d line;
                Collection<ICurve> curveCollection = new Collection<ICurve>();

                if (dim1 >= 0)
                {
                    gussetCalc1 = Math.Sqrt((((diameter1 / 2) + thickness1) * ((diameter1 / 2) + thickness1)) - (((gap1 / 2) + thickness1) * ((gap1 / 2) + thickness1)));
                    gussetCalc2 = Math.Sqrt((((diameter1 / 2) + thickness1) * ((diameter1 / 2) + thickness1)) - (((gap2 / 2) + thickness1) * ((gap2 / 2) + thickness1)));
                    gussetAngle1 = Math.Asin(((gap1 / 2) + thickness1) / ((diameter1 / 2) + thickness1)) * 180 / Math.PI;
                    gussetAngle2 = Math.Asin(((gap2 / 2) + thickness1) / ((diameter1 / 2) + thickness1)) * 180 / Math.PI;
                }
                else
                {
                    gussetCalc1 = Math.Sqrt((((diameter1 / 2) + thickness1) * ((diameter1 / 2) + thickness1)) - (((gap1 / 2) + thickness1 + dim1) * ((gap1 / 2) + thickness1 + dim1)));
                    gussetCalc2 = Math.Sqrt((((diameter1 / 2) + thickness1) * ((diameter1 / 2) + thickness1)) - (((gap2 / 2) + thickness1 + dim1) * ((gap2 / 2) + thickness1 + dim1)));
                    gussetAngle1 = Math.Asin(((gap1 / 2) + thickness1 + dim1) / ((diameter1 / 2) + thickness1)) * 180 / Math.PI;
                    gussetAngle2 = Math.Asin(((gap2 / 2) + thickness1 + dim1) / ((diameter1 / 2) + thickness1)) * 180 / Math.PI;
                }

                if (HgrCompareDoubleService.cmpdbl(thickness2, 0) == false)
                {
                    if (bottomSide == true)
                    {
                        if (HgrCompareDoubleService.cmpdbl(dim1, 0) == false)
                        {
                            if (dim1 > 0)
                            {
                                symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                                symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                                matrix.SetIdentity();
                                matrix.Rotate(2 * (Math.PI) + gussetAngle2 * Math.PI / 180, new Vector(0, 0, 1));
                                Arc3d arc1 = symbolGeometryHelper.CreateArc(null, (diameter1 / 2 + thickness1), (-Math.PI - gussetAngle1 * Math.PI / 180 - gussetAngle2 * Math.PI / 180));
                                arc1.Transform(matrix);

                                matrix = new Matrix4X4();
                                matrix.SetIdentity();
                                matrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                                arc1.Transform(matrix);

                                matrix = new Matrix4X4();
                                matrix.SetIdentity();
                                matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                                arc1.Transform(matrix);

                                matrix = new Matrix4X4();
                                matrix.SetIdentity();
                                matrix.Translate(new Vector(-width1 / 2, 0, 0));
                                arc1.Transform(matrix);
                                curveCollection.Add(arc1);

                                line = new Line3d(new Position(-width1 / 2, -gap2 / 2 - thickness1, -gussetCalc2), new Position(-width1 / 2, -gap2 / 2 - thickness1, -height2));
                                curveCollection.Add(line);
                                line = new Line3d(new Position(-width1 / 2, -gap2 / 2 - thickness1, -height2), new Position(-width1 / 2, -gap2 / 2 - thickness1 - dim1, -height2));
                                curveCollection.Add(line);
                                line = new Line3d(new Position(-width1 / 2, -gap2 / 2 - thickness1 - dim1, -height2), new Position(-width1 / 2, -diameter1 / 2 - thickness1 - dim2, 0));
                                curveCollection.Add(line);
                                line = new Line3d(new Position(-width1 / 2, -diameter1 / 2 - thickness1 - dim2, 0), new Position(-width1 / 2, -gap2 / 2 - thickness1 - dim1, height1));
                                curveCollection.Add(line);
                                line = new Line3d(new Position(-width1 / 2, -gap2 / 2 - thickness1 - dim1, height1), new Position(-width1 / 2, -gap2 / 2 - thickness1, height1));
                                curveCollection.Add(line);
                                line = new Line3d(new Position(-width1 / 2, -gap2 / 2 - thickness1, height1), new Position(-width1 / 2, -gap2 / 2 - thickness1, gussetCalc1));
                                curveCollection.Add(line);

                                ComplexString3d gusstet1Collection = new ComplexString3d(curveCollection);
                                Vector gusset1Vector = new Vector(1, 0, 0);
                                Projection3d gusset1 = new Projection3d(gusstet1Collection, gusset1Vector, thickness2, true);
                                outputs.Add(outputName + "Gusset1", gusset1);
                                objectCollection[1] = outputName + "Gusset1";

                                curveCollection = new Collection<ICurve>();
                                matrix = new Matrix4X4();
                                symbolGeometryHelper = new SymbolGeometryHelper();
                                symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                                symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                                matrix.SetIdentity();
                                matrix.Rotate(2 * (Math.PI) + gussetAngle2 * Math.PI / 180, new Vector(0, 0, 1));
                                Arc3d arc2 = symbolGeometryHelper.CreateArc(null, (diameter1 / 2 + thickness1), (-Math.PI - gussetAngle1 * Math.PI / 180 - gussetAngle2 * Math.PI / 180));
                                arc2.Transform(matrix);

                                matrix = new Matrix4X4();
                                matrix.SetIdentity();
                                matrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                                arc2.Transform(matrix);

                                matrix = new Matrix4X4();
                                matrix.SetIdentity();
                                matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                                arc2.Transform(matrix);

                                matrix = new Matrix4X4();
                                matrix.SetIdentity();
                                matrix.Translate(new Vector(width1 / 2, 0, 0));
                                arc2.Transform(matrix);
                                curveCollection.Add(arc2);

                                line = new Line3d(new Position(width1 / 2, -gap2 / 2 - thickness1, -gussetCalc2), new Position(width1 / 2, -gap2 / 2 - thickness1, -height2));
                                curveCollection.Add(line);
                                line = new Line3d(new Position(width1 / 2, -gap2 / 2 - thickness1, -height2), new Position(width1 / 2, -gap2 / 2 - thickness1 - dim1, -height2));
                                curveCollection.Add(line);
                                line = new Line3d(new Position(width1 / 2, -gap2 / 2 - thickness1 - dim1, -height2), new Position(width1 / 2, -diameter1 / 2 - thickness1 - dim2, 0));
                                curveCollection.Add(line);
                                line = new Line3d(new Position(width1 / 2, -diameter1 / 2 - thickness1 - dim2, 0), new Position(width1 / 2, -gap2 / 2 - thickness1 - dim1, height1));
                                curveCollection.Add(line);
                                line = new Line3d(new Position(width1 / 2, -gap2 / 2 - thickness1 - dim1, height1), new Position(width1 / 2, -gap2 / 2 - thickness1, height1));
                                curveCollection.Add(line);
                                line = new Line3d(new Position(width1 / 2, -gap2 / 2 - thickness1, height1), new Position(width1 / 2, -gap2 / 2 - thickness1, gussetCalc1));
                                curveCollection.Add(line);

                                ComplexString3d gusstet3Collection = new ComplexString3d(curveCollection);
                                Vector gusset3Vector = new Vector(1, 0, 0);
                                Projection3d gusset3 = new Projection3d(gusstet3Collection, gusset3Vector, -thickness2, true);
                                outputs.Add(outputName + "Gusset3", gusset3);
                                objectCollection[3] = outputName + "Gusset3";
                            }
                            else
                            {
                                symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                                symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                                matrix.SetIdentity();
                                matrix.Rotate(2 * (Math.PI) + gussetAngle2 * Math.PI / 180, new Vector(0, 0, 1));
                                Arc3d arc1 = symbolGeometryHelper.CreateArc(null, (diameter1 / 2 + thickness1), (-Math.PI - gussetAngle1 * Math.PI / 180 - gussetAngle2 * Math.PI / 180));
                                arc1.Transform(matrix);

                                matrix = new Matrix4X4();
                                matrix.SetIdentity();
                                matrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                                arc1.Transform(matrix);

                                matrix = new Matrix4X4();
                                matrix.SetIdentity();
                                matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                                arc1.Transform(matrix);

                                matrix = new Matrix4X4();
                                matrix.SetIdentity();
                                matrix.Translate(new Vector(-width1 / 2, 0, 0));
                                arc1.Transform(matrix);
                                curveCollection.Add(arc1);

                                line = new Line3d(new Position(-width1 / 2, -gap2 / 2 - thickness1 - dim1, -gussetCalc2), new Position(-width1 / 2, -gap2 / 2 - thickness1 - dim1, -height2));
                                curveCollection.Add(line);
                                line = new Line3d(new Position(-width1 / 2, -gap2 / 2 - thickness1 - dim1, -height2), new Position(-width1 / 2, -diameter1 / 2 - thickness1 - dim2, 0));
                                curveCollection.Add(line);
                                line = new Line3d(new Position(-width1 / 2, -diameter1 / 2 - thickness1 - dim2, 0), new Position(-width1 / 2, -gap2 / 2 - thickness1 - dim1, height1));
                                curveCollection.Add(line);
                                line = new Line3d(new Position(-width1 / 2, -gap2 / 2 - thickness1 - dim1, height1), new Position(-width1 / 2, -gap2 / 2 - thickness1 - dim1, gussetCalc1));
                                curveCollection.Add(line);

                                ComplexString3d gusstet1Collection = new ComplexString3d(curveCollection);
                                Vector gusset1Vector = new Vector(1, 0, 0);
                                Projection3d gusset1 = new Projection3d(gusstet1Collection, gusset1Vector, thickness2, true);
                                outputs.Add(outputName + "Gusset1", gusset1);
                                objectCollection[1] = outputName + "Gusset1";

                                curveCollection = new Collection<ICurve>();
                                matrix = new Matrix4X4();
                                symbolGeometryHelper = new SymbolGeometryHelper();
                                symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                                symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                                matrix.SetIdentity();
                                matrix.Rotate(2 * (Math.PI) + gussetAngle2 * Math.PI / 180, new Vector(0, 0, 1));
                                Arc3d arc2 = symbolGeometryHelper.CreateArc(null, (diameter1 / 2 + thickness1), (-Math.PI - gussetAngle1 * Math.PI / 180 - gussetAngle2 * Math.PI / 180));
                                arc2.Transform(matrix);

                                matrix = new Matrix4X4();
                                matrix.SetIdentity();
                                matrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                                arc2.Transform(matrix);

                                matrix = new Matrix4X4();
                                matrix.SetIdentity();
                                matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                                arc2.Transform(matrix);

                                matrix = new Matrix4X4();
                                matrix.SetIdentity();
                                matrix.Translate(new Vector(width1 / 2, 0, 0));
                                arc2.Transform(matrix);
                                curveCollection.Add(arc2);

                                line = new Line3d(new Position(width1 / 2, -gap2 / 2 - thickness1 - dim1, -gussetCalc2), new Position(width1 / 2, -gap2 / 2 - thickness1 - dim1, -height2));
                                curveCollection.Add(line);
                                line = new Line3d(new Position(width1 / 2, -gap2 / 2 - thickness1 - dim1, -height2), new Position(width1 / 2, -diameter1 / 2 - thickness1 - dim2, 0));
                                curveCollection.Add(line);
                                line = new Line3d(new Position(width1 / 2, -diameter1 / 2 - thickness1 - dim2, 0), new Position(width1 / 2, -gap2 / 2 - thickness1 - dim1, height1));
                                curveCollection.Add(line);
                                line = new Line3d(new Position(width1 / 2, -gap2 / 2 - thickness1 - dim1, height1), new Position(width1 / 2, -gap2 / 2 - thickness1 - dim1, gussetCalc1));
                                curveCollection.Add(line);

                                ComplexString3d gusstet3Collection = new ComplexString3d(curveCollection);
                                Vector gusset3Vector = new Vector(1, 0, 0);
                                Projection3d gusset3 = new Projection3d(gusstet3Collection, gusset3Vector, -thickness2, true);
                                outputs.Add(outputName + "Gusset3", gusset3);
                                objectCollection[3] = outputName + "Gusset3";
                            }
                        }
                        else
                        {
                            symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                            symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                            matrix.SetIdentity();
                            matrix.Rotate(2 * Math.PI + gussetAngle2 * Math.PI / 180, new Vector(0, 0, 1));
                            Arc3d arc1 = symbolGeometryHelper.CreateArc(null, (diameter1 / 2 + thickness1), (-Math.PI - gussetAngle1 * Math.PI / 180 - gussetAngle2 * Math.PI / 180));
                            arc1.Transform(matrix);

                            matrix = new Matrix4X4();
                            matrix.SetIdentity();
                            matrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                            arc1.Transform(matrix);

                            matrix = new Matrix4X4();
                            matrix.SetIdentity();
                            matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                            arc1.Transform(matrix);

                            matrix = new Matrix4X4();
                            matrix.SetIdentity();
                            matrix.Translate(new Vector(-width1 / 2, 0, 0));
                            arc1.Transform(matrix);
                            curveCollection.Add(arc1);

                            line = new Line3d(new Position(-width1 / 2, -gap2 / 2 - thickness1, -gussetCalc2), new Position(-width1 / 2, -gap2 / 2 - thickness1, -height2));
                            curveCollection.Add(line);
                            line = new Line3d(new Position(-width1 / 2, -gap2 / 2 - thickness1, -height2), new Position(-width1 / 2, -diameter1 / 2 - thickness1 - dim2, 0));
                            curveCollection.Add(line);
                            line = new Line3d(new Position(-width1 / 2, -diameter1 / 2 - thickness1 - dim2, 0), new Position(-width1 / 2, -gap2 / 2 - thickness1, height1));
                            curveCollection.Add(line);
                            line = new Line3d(new Position(-width1 / 2, -gap2 / 2 - thickness1, height1), new Position(-width1 / 2, -gap2 / 2 - thickness1, gussetCalc1));
                            curveCollection.Add(line);

                            ComplexString3d gusstet1Collection = new ComplexString3d(curveCollection);
                            Vector gusset1Vector = new Vector(1, 0, 0);
                            Projection3d gusset1 = new Projection3d(gusstet1Collection, gusset1Vector, thickness2, true);
                            outputs.Add(outputName + "Gusset1", gusset1);
                            objectCollection[1] = outputName + "Gusset1";

                            curveCollection = new Collection<ICurve>();
                            matrix = new Matrix4X4();
                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                            symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                            matrix.SetIdentity();
                            matrix.Rotate(2 * Math.PI + gussetAngle2 * Math.PI / 180, new Vector(0, 0, 1));
                            Arc3d arc2 = symbolGeometryHelper.CreateArc(null, (diameter1 / 2 + thickness1), (-Math.PI - gussetAngle1 * Math.PI / 180 - gussetAngle2 * Math.PI / 180));
                            arc2.Transform(matrix);

                            matrix = new Matrix4X4();
                            matrix.SetIdentity();
                            matrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                            arc2.Transform(matrix);

                            matrix = new Matrix4X4();
                            matrix.SetIdentity();
                            matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                            arc2.Transform(matrix);

                            matrix = new Matrix4X4();
                            matrix.SetIdentity();
                            matrix.Translate(new Vector(width1 / 2, 0, 0));
                            arc2.Transform(matrix);
                            curveCollection.Add(arc2);

                            line = new Line3d(new Position(width1 / 2, -gap2 / 2 - thickness1, -gussetCalc2), new Position(width1 / 2, -gap2 / 2 - thickness1, -height2));
                            curveCollection.Add(line);
                            line = new Line3d(new Position(width1 / 2, -gap2 / 2 - thickness1, -height2), new Position(width1 / 2, -diameter1 / 2 - thickness1 - dim2, 0));
                            curveCollection.Add(line);
                            line = new Line3d(new Position(width1 / 2, -diameter1 / 2 - thickness1 - dim2, 0), new Position(width1 / 2, -gap2 / 2 - thickness1, height1));
                            curveCollection.Add(line);
                            line = new Line3d(new Position(width1 / 2, -gap2 / 2 - thickness1, height1), new Position(width1 / 2, -gap2 / 2 - thickness1, gussetCalc1));
                            curveCollection.Add(line);

                            ComplexString3d gusstet3Collection = new ComplexString3d(curveCollection);
                            Vector gusset3Vector = new Vector(1, 0, 0);
                            Projection3d gusset3 = new Projection3d(gusstet3Collection, gusset3Vector, -thickness2, true);
                            outputs.Add(outputName + "Gusset3", gusset3);
                            objectCollection[3] = outputName + "Gusset3";
                        }
                    }

                    if (topSide == true)
                    {
                        if (width2 >= 0)
                        {
                            if (HgrCompareDoubleService.cmpdbl(dim1, 0) == false)
                            {
                                if (dim1 > 0)
                                {
                                    curveCollection = new Collection<ICurve>();
                                    matrix = new Matrix4X4();
                                    line = new Line3d(new Position(-width1 / 2, gap2 / 2 + thickness1, -gussetCalc2), new Position(-width1 / 2, gap2 / 2 + thickness1, -height2));
                                    curveCollection.Add(line);
                                    line = new Line3d(new Position(-width1 / 2, gap2 / 2 + thickness1, -height2), new Position(-width1 / 2, gap2 / 2 + thickness1 + dim1, -height2));
                                    curveCollection.Add(line);
                                    line = new Line3d(new Position(-width1 / 2, gap2 / 2 + thickness1 + dim1, -height2), new Position(-width1 / 2, diameter1 / 2 + thickness1 + dim2, 0));
                                    curveCollection.Add(line);
                                    line = new Line3d(new Position(-width1 / 2, diameter1 / 2 + thickness1 + dim2, 0), new Position(-width1 / 2, gap2 / 2 + thickness1 + dim1, height1));
                                    curveCollection.Add(line);
                                    line = new Line3d(new Position(-width1 / 2, gap2 / 2 + thickness1 + dim1, height1), new Position(-width1 / 2, gap2 / 2 + thickness1, height1));
                                    curveCollection.Add(line);
                                    line = new Line3d(new Position(-width1 / 2, gap2 / 2 + thickness1, height1), new Position(-width1 / 2, gap2 / 2 + thickness1, gussetCalc1));
                                    curveCollection.Add(line);

                                    symbolGeometryHelper = new SymbolGeometryHelper();
                                    symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                                    matrix.SetIdentity();
                                    matrix.Rotate(Math.PI + gussetAngle1 * Math.PI / 180, new Vector(0, 0, 1));
                                    Arc3d arc1 = symbolGeometryHelper.CreateArc(null, (diameter1 / 2 + thickness1), (Math.PI - gussetAngle2 * Math.PI / 180 - gussetAngle1 * Math.PI / 180));
                                    arc1.Transform(matrix);

                                    matrix = new Matrix4X4();
                                    matrix.SetIdentity();
                                    matrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                                    arc1.Transform(matrix);

                                    matrix = new Matrix4X4();
                                    matrix.SetIdentity();
                                    matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                                    arc1.Transform(matrix);

                                    matrix = new Matrix4X4();
                                    matrix.SetIdentity();
                                    matrix.Translate(new Vector(-width1 / 2, 0, 0));
                                    arc1.Transform(matrix);
                                    curveCollection.Add(arc1);

                                    ComplexString3d gusstetCollection = new ComplexString3d(curveCollection);
                                    Vector gussetVector = new Vector(1, 0, 0);
                                    Projection3d gusset = new Projection3d(gusstetCollection, gussetVector, thickness2, true);
                                    outputs.Add(outputName + "Gusset", gusset);
                                    objectCollection[0] = outputName + "Gusset";

                                    curveCollection = new Collection<ICurve>();
                                    matrix = new Matrix4X4();
                                    line = new Line3d(new Position(width1 / 2, gap2 / 2 + thickness1, -gussetCalc2), new Position(width1 / 2, gap2 / 2 + thickness1, -height2));
                                    curveCollection.Add(line);
                                    line = new Line3d(new Position(width1 / 2, gap2 / 2 + thickness1, -height2), new Position(width1 / 2, gap2 / 2 + thickness1 + dim1, -height2));
                                    curveCollection.Add(line);
                                    line = new Line3d(new Position(width1 / 2, gap2 / 2 + thickness1 + dim1, -height2), new Position(width1 / 2, diameter1 / 2 + thickness1 + dim2, 0));
                                    curveCollection.Add(line);
                                    line = new Line3d(new Position(width1 / 2, diameter1 / 2 + thickness1 + dim2, 0), new Position(width1 / 2, gap2 / 2 + thickness1 + dim1, height1));
                                    curveCollection.Add(line);
                                    line = new Line3d(new Position(width1 / 2, gap2 / 2 + thickness1 + dim1, height1), new Position(width1 / 2, gap2 / 2 + thickness1, height1));
                                    curveCollection.Add(line);
                                    line = new Line3d(new Position(width1 / 2, gap2 / 2 + thickness1, height1), new Position(width1 / 2, gap2 / 2 + thickness1, gussetCalc1));
                                    curveCollection.Add(line);

                                    symbolGeometryHelper = new SymbolGeometryHelper();
                                    symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                                    matrix.SetIdentity();
                                    matrix.Rotate(Math.PI + gussetAngle1 * Math.PI / 180, new Vector(0, 0, 1));
                                    Arc3d arc2 = symbolGeometryHelper.CreateArc(null, (diameter1 / 2 + thickness1), (Math.PI - gussetAngle2 * Math.PI / 180 - gussetAngle1 * Math.PI / 180));
                                    arc2.Transform(matrix);

                                    matrix = new Matrix4X4();
                                    matrix.SetIdentity();
                                    matrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                                    arc2.Transform(matrix);

                                    matrix = new Matrix4X4();
                                    matrix.SetIdentity();
                                    matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                                    arc2.Transform(matrix);

                                    matrix = new Matrix4X4();
                                    matrix.SetIdentity();
                                    matrix.Translate(new Vector(width1 / 2, 0, 0));
                                    arc2.Transform(matrix);
                                    curveCollection.Add(arc2);

                                    ComplexString3d gusstet2Collection = new ComplexString3d(curveCollection);
                                    Vector gusset2Vector = new Vector(1, 0, 0);
                                    Projection3d gusset2 = new Projection3d(gusstet2Collection, gusset2Vector, -thickness2, true);
                                    outputs.Add(outputName + "Gusset2", gusset2);
                                    objectCollection[2] = outputName + "Gusset2";
                                }
                                else
                                {
                                    curveCollection = new Collection<ICurve>();
                                    matrix = new Matrix4X4();
                                    symbolGeometryHelper = new SymbolGeometryHelper();
                                    symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                                    matrix.SetIdentity();
                                    matrix.Rotate(Math.PI + gussetAngle1 * Math.PI / 180, new Vector(0, 0, 1));
                                    Arc3d arc1 = symbolGeometryHelper.CreateArc(null, (diameter1 / 2 + thickness1), (Math.PI - gussetAngle2 * Math.PI / 180 - gussetAngle1 * Math.PI / 180));
                                    arc1.Transform(matrix);

                                    matrix = new Matrix4X4();
                                    matrix.SetIdentity();
                                    matrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                                    arc1.Transform(matrix);

                                    matrix = new Matrix4X4();
                                    matrix.SetIdentity();
                                    matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                                    arc1.Transform(matrix);

                                    matrix = new Matrix4X4();
                                    matrix.SetIdentity();
                                    matrix.Translate(new Vector(-width1 / 2, 0, 0));
                                    arc1.Transform(matrix);
                                    curveCollection.Add(arc1);

                                    curveCollection = new Collection<ICurve>();
                                    line = new Line3d(new Position(-width1 / 2, gap2 / 2 + thickness1 + dim1, -gussetCalc2), new Position(-width1 / 2, gap2 / 2 + thickness1 + dim1, -height2));
                                    curveCollection.Add(line);
                                    line = new Line3d(new Position(-width1 / 2, gap2 / 2 + thickness1 + dim1, -height2), new Position(-width1 / 2, diameter1 / 2 + thickness1 + dim2, 0));
                                    curveCollection.Add(line);
                                    line = new Line3d(new Position(-width1 / 2, diameter1 / 2 + thickness1 + dim2, 0), new Position(-width1 / 2, gap2 / 2 + thickness1 + dim1, height1));
                                    curveCollection.Add(line);
                                    line = new Line3d(new Position(-width1 / 2, gap2 / 2 + thickness1 + dim1, height1), new Position(-width1 / 2, gap2 / 2 + thickness1 + dim1, gussetCalc1));
                                    curveCollection.Add(line);

                                    ComplexString3d gusstetCollection = new ComplexString3d(curveCollection);
                                    Vector gussetVector = new Vector(1, 0, 0);
                                    Projection3d gusset = new Projection3d(gusstetCollection, gussetVector, thickness2, true);
                                    outputs.Add(outputName + "Gusset", gusset);
                                    objectCollection[0] = outputName + "Gusset";

                                    curveCollection = new Collection<ICurve>();
                                    matrix = new Matrix4X4();
                                    symbolGeometryHelper = new SymbolGeometryHelper();
                                    symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                                    matrix.SetIdentity();
                                    matrix.Rotate(Math.PI + gussetAngle1 * Math.PI / 180, new Vector(0, 0, 1));
                                    Arc3d arc2 = symbolGeometryHelper.CreateArc(null, (diameter1 / 2 + thickness1), (Math.PI - gussetAngle2 * Math.PI / 180 - gussetAngle1 * Math.PI / 180));
                                    arc2.Transform(matrix);

                                    matrix = new Matrix4X4();
                                    matrix.SetIdentity();
                                    matrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                                    arc2.Transform(matrix);

                                    matrix = new Matrix4X4();
                                    matrix.SetIdentity();
                                    matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                                    arc2.Transform(matrix);

                                    matrix = new Matrix4X4();
                                    matrix.SetIdentity();
                                    matrix.Translate(new Vector(width1 / 2, 0, 0));
                                    arc2.Transform(matrix);
                                    curveCollection.Add(arc2);

                                    line = new Line3d(new Position(width1 / 2, gap2 / 2 + thickness1 + dim1, -gussetCalc2), new Position(width1 / 2, gap2 / 2 + thickness1 + dim1, -height2));
                                    curveCollection.Add(line);
                                    line = new Line3d(new Position(width1 / 2, gap2 / 2 + thickness1 + dim1, -height2), new Position(width1 / 2, diameter1 / 2 + thickness1 + dim2, 0));
                                    curveCollection.Add(line);
                                    line = new Line3d(new Position(width1 / 2, diameter1 / 2 + thickness1 + dim2, 0), new Position(width1 / 2, gap2 / 2 + thickness1 + dim1, height1));
                                    curveCollection.Add(line);
                                    line = new Line3d(new Position(width1 / 2, gap2 / 2 + thickness1 + dim1, height1), new Position(width1 / 2, gap2 / 2 + thickness1 + dim1, gussetCalc1));
                                    curveCollection.Add(line);

                                    ComplexString3d gusstet2Collection = new ComplexString3d(curveCollection);
                                    Vector gusset2Vector = new Vector(1, 0, 0);
                                    Projection3d gusset2 = new Projection3d(gusstet2Collection, gusset2Vector, -thickness2, true);
                                    outputs.Add(outputName + "Gusset2", gusset2);
                                    objectCollection[2] = outputName + "Gusset2";

                                }
                            }
                            else
                            {
                                curveCollection = new Collection<ICurve>();
                                matrix = new Matrix4X4();
                                line = new Line3d(new Position(-width1 / 2, gap2 / 2 + thickness1, -gussetCalc2), new Position(-width1 / 2, gap2 / 2 + thickness1, -height2));
                                curveCollection.Add(line);
                                line = new Line3d(new Position(-width1 / 2, gap2 / 2 + thickness1, -height2), new Position(-width1 / 2, diameter1 / 2 + thickness1 + dim2, 0));
                                curveCollection.Add(line);
                                line = new Line3d(new Position(-width1 / 2, diameter1 / 2 + thickness1 + dim2, 0), new Position(-width1 / 2, gap2 / 2 + thickness1, height1));
                                curveCollection.Add(line);
                                line = new Line3d(new Position(-width1 / 2, gap2 / 2 + thickness1, height1), new Position(-width1 / 2, gap2 / 2 + thickness1, gussetCalc1));
                                curveCollection.Add(line);

                                symbolGeometryHelper = new SymbolGeometryHelper();
                                symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                                symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                                matrix.SetIdentity();
                                matrix.Rotate(Math.PI + gussetAngle1 * Math.PI / 180, new Vector(0, 0, 1));
                                Arc3d arc1 = symbolGeometryHelper.CreateArc(null, (diameter1 / 2 + thickness1), (Math.PI - gussetAngle2 * Math.PI / 180 - gussetAngle1 * Math.PI / 180));
                                arc1.Transform(matrix);

                                matrix = new Matrix4X4();
                                matrix.SetIdentity();
                                matrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                                arc1.Transform(matrix);

                                matrix = new Matrix4X4();
                                matrix.SetIdentity();
                                matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                                arc1.Transform(matrix);

                                matrix = new Matrix4X4();
                                matrix.SetIdentity();
                                matrix.Translate(new Vector(-width1 / 2, 0, 0));
                                arc1.Transform(matrix);
                                curveCollection.Add(arc1);

                                ComplexString3d gusstetCollection = new ComplexString3d(curveCollection);
                                Vector gussetVector = new Vector(1, 0, 0);
                                Projection3d gusset = new Projection3d(gusstetCollection, gussetVector, thickness2, true);
                                outputs.Add(outputName + "Gusset", gusset);
                                objectCollection[0] = outputName + "Gusset";

                                curveCollection = new Collection<ICurve>();
                                matrix = new Matrix4X4();
                                line = new Line3d(new Position(width1 / 2, gap2 / 2 + thickness1, -gussetCalc2), new Position(width1 / 2, gap2 / 2 + thickness1, -height2));
                                curveCollection.Add(line);
                                line = new Line3d(new Position(width1 / 2, gap2 / 2 + thickness1, -height2), new Position(width1 / 2, diameter1 / 2 + thickness1 + dim2, 0));
                                curveCollection.Add(line);
                                line = new Line3d(new Position(width1 / 2, diameter1 / 2 + thickness1 + dim2, 0), new Position(width1 / 2, gap2 / 2 + thickness1, height1));
                                curveCollection.Add(line);
                                line = new Line3d(new Position(width1 / 2, gap2 / 2 + thickness1, height1), new Position(width1 / 2, gap2 / 2 + thickness1, gussetCalc1));
                                curveCollection.Add(line);

                                symbolGeometryHelper = new SymbolGeometryHelper();
                                symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                                symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                                matrix.SetIdentity();
                                matrix.Rotate(Math.PI + gussetAngle1 * Math.PI / 180, new Vector(0, 0, 1));
                                Arc3d arc2 = symbolGeometryHelper.CreateArc(null, (diameter1 / 2 + thickness1), (Math.PI - gussetAngle2 * Math.PI / 180 - gussetAngle1 * Math.PI / 180));
                                arc2.Transform(matrix);

                                matrix = new Matrix4X4();
                                matrix.SetIdentity();
                                matrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                                arc2.Transform(matrix);

                                matrix = new Matrix4X4();
                                matrix.SetIdentity();
                                matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                                arc2.Transform(matrix);

                                matrix = new Matrix4X4();
                                matrix.SetIdentity();
                                matrix.Translate(new Vector(width1 / 2, 0, 0));
                                arc2.Transform(matrix);
                                curveCollection.Add(arc2);

                                ComplexString3d gusstet2Collection = new ComplexString3d(curveCollection);
                                Vector gusset2Vector = new Vector(1, 0, 0);
                                Projection3d gusset2 = new Projection3d(gusstet2Collection, gusset2Vector, -thickness2, true);
                                outputs.Add(outputName + "Gusset2", gusset2);
                                objectCollection[2] = outputName + "Gusset2";
                            }
                        }
                    }

                    Matrix4X4 rotateMatrix = new Matrix4X4();
                    Geometry3d transformObject;
                    if (HgrCompareDoubleService.cmpdbl(rotAngle, 0) == false)
                    {
                        rotateMatrix.Rotate(rotAngle, new Vector(1, 0, 0));
                        for (int i = 0; i < objectCollection.Length; i++)
                        {
                            if (objectCollection[i] != null)
                            {
                                transformObject = (Geometry3d)outputs[objectCollection[i]];
                                transformObject.Transform(rotateMatrix);
                            }
                        }
                    }
                    if (isRaiser)
                    {
                        rotateMatrix = new Matrix4X4();
                        rotateMatrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                        for (int i = 0; i < objectCollection.Length; i++)
                        {
                            if (objectCollection[i] != null)
                            {
                                transformObject = (Geometry3d)outputs[objectCollection[i]];
                                transformObject.Transform(rotateMatrix);
                            }
                        }
                    }
                }
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddGussetsMethod, "Error in AddGussets");
                }
            }
        }
        /// <summary>
        /// Adds the PipeClamp inputs.
        /// </summary>        
        /// <param name="startIndex">The start index.</param>
        /// <param name="endIndex">The end index.</param>
        /// <param name="additionalInputs">The additional inputs.</param>
        /// <code>
        /// int endIndex;
        /// List<Input> additionalInputs = new List<Input>();
        /// AddPipeClampInputs(2, out endIndex, additionalInputs);
        /// </code>
        public void AddPipeClampInputs(int startIndex, out int endIndex, List<Input> additionalInputs)
        {
            try
            {
                additionalInputs.Add(new InputDouble(startIndex, "Diameter1", "Diameter1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Thickness1", "Thickness1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Width1", "Width1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Width2", "Width2", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Height1", "Height1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Height2", "Height2", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Gap1", "Gap1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Gap2", "Gap2", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Angle1", "Angle1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Pin1Diameter", "Pin1Diameter", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Pin1Length", "Pin1Length", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "ClampCfg", "ClampCfg", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Angle3", "Angle3", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Width3", "Width3", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Height3", "Height3", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Length", "Length", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Dim1", "Dim1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Dim2", "Dim2", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Thickness2", "Thickness2", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Diameter4", "Diameter4", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Width4", "Width4", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "ShapeType", "ShapeType", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Thickness3", "Thickness3", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Width5", "Width5", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Width6", "Width6", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Angle2", "Angle2", 0, false));
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddPipeClampInputs, "Error in adding PipeClamp inputs");
                }
            }
            endIndex = ++startIndex;

            for (int nutnumber = 1; nutnumber <= 6; nutnumber++)
            {
                AddBoltRowInputs(endIndex, out endIndex, additionalInputs, nutnumber);
            }
        }
        /// <summary>
        /// Adds the PipeClamp outputs.
        /// </summary>       
        /// <param name="aspectName">Name of the aspect.</param>
        /// <param name="additionalOutputs">The additional outputs.</param>
        /// <code>
        ///  List<OutputDefinition> additionalOutputs = new List<OutputDefinition>();
        ///  AddPipeClampOutputs(aspectName, additionalOutputs);
        /// </code>
        public void AddPipeClampOutputs(string aspectName, List<OutputDefinition> additionalOutputs, string output)
        {

            try
            {

                //outputs
                additionalOutputs.Add(new OutputDefinition(output + "side1", output + "side1"));
                additionalOutputs.Add(new OutputDefinition(output + "side2", output + "side2"));

                //bolts
                for (int i = 1; i <= 6; i++)
                {
                    for (int m = 0; m <= 5; m++)
                    {
                        additionalOutputs.Add(new OutputDefinition(output + "bolt" + i + m, output + "bolt"));

                    }
                }

                //gussests
                additionalOutputs.Add(new OutputDefinition(output + "Gusset", output + "Gusset"));
                additionalOutputs.Add(new OutputDefinition(output + "Gusset1", output + "Gusset1"));
                additionalOutputs.Add(new OutputDefinition(output + "Gusset2", output + "Gusset2"));
                additionalOutputs.Add(new OutputDefinition(output + "Gusset3", output + "Gusset3"));

                //connection nut
                additionalOutputs.Add(new OutputDefinition(output + "Nut", output + "Nut"));

                //liner

                additionalOutputs.Add(new OutputDefinition(output + "Liner", output + "Liner"));

            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddPipeClampOutputs, "Error in adding PipeClamp outputs");
                }
            }
        }
        /// <summary>
        /// Loads the PipeClamp data.
        /// </summary>        
        /// <param name="startIndex">The start index.</param>
        ///  <code>
        ///  PipeClampInputs pipeClamp = LoadPipeClampData(2);
        /// </code>
        /// <returns></returns>
        public PipeClampInputs LoadPipeClampData(int startIndex, out int endIndex)
        {
            PipeClampInputs PipeClamp = new PipeClampInputs();
            endIndex = startIndex;
            int boltEndIndex;
            try
            {
                PipeClamp.Diameter1 = GetDoubleInputValue(startIndex);
                PipeClamp.Thickness1 = GetDoubleInputValue(++startIndex);
                PipeClamp.Width1 = GetDoubleInputValue(++startIndex);
                if (HgrCompareDoubleService.cmpdbl(PipeClamp.Width1, 0) == true)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidWidth1NZero, "Width1 value should not be zero");
                }
                PipeClamp.Width2 = GetDoubleInputValue(++startIndex);
                PipeClamp.Height1 = GetDoubleInputValue(++startIndex);
                PipeClamp.Height2 = GetDoubleInputValue(++startIndex);
                PipeClamp.Gap1 = GetDoubleInputValue(++startIndex);
                PipeClamp.Gap2 = GetDoubleInputValue(++startIndex);
                PipeClamp.Angle1 = GetDoubleInputValue(++startIndex);
                PipeClamp.Pin1Diameter = GetDoubleInputValue(++startIndex);
                if (PipeClamp.BoltRow1.MultiQty > 0 || PipeClamp.BoltRow2.MultiQty > 0 || PipeClamp.BoltRow3.MultiQty > 0 || PipeClamp.BoltRow4.MultiQty > 0 || PipeClamp.BoltRow5.MultiQty > 0 || PipeClamp.BoltRow6.MultiQty > 0)
                {
                    if (PipeClamp.Pin1Diameter <= 0)
                    {
                        RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidPinDiameterNLTZero, "Pin1Diameter value should not be 0 or negative");
                    }
                }
                PipeClamp.Pin1Length = GetDoubleInputValue(++startIndex);
                PipeClamp.ClampCfg = (int)GetDoubleInputValue(++startIndex);
                PipeClamp.Angle3 = GetDoubleInputValue(++startIndex);
                PipeClamp.Width3 = GetDoubleInputValue(++startIndex);
                PipeClamp.Height3 = GetDoubleInputValue(++startIndex);
                PipeClamp.Length = GetDoubleInputValue(++startIndex);
                PipeClamp.Dim1 = GetDoubleInputValue(++startIndex);
                PipeClamp.Dim2 = GetDoubleInputValue(++startIndex);
                PipeClamp.Thickness2 = GetDoubleInputValue(++startIndex);
                PipeClamp.Diameter4 = GetDoubleInputValue(++startIndex);
                PipeClamp.Width4 = GetDoubleInputValue(++startIndex);
                PipeClamp.ShapeType = (int)GetDoubleInputValue(++startIndex);
                PipeClamp.Thickness3 = GetDoubleInputValue(++startIndex);
                PipeClamp.Width5 = GetDoubleInputValue(++startIndex);
                PipeClamp.Width6 = GetDoubleInputValue(++startIndex);
                PipeClamp.Angle2 = GetDoubleInputValue(++startIndex);

                PipeClamp.BoltRow1 = LoadBoltRowData(++startIndex, out boltEndIndex);
                PipeClamp.BoltRow2 = LoadBoltRowData(boltEndIndex, out boltEndIndex);  //LoadBoltRowData(32);
                PipeClamp.BoltRow3 = LoadBoltRowData(boltEndIndex, out boltEndIndex);  //LoadBoltRowData(36);
                PipeClamp.BoltRow4 = LoadBoltRowData(boltEndIndex, out boltEndIndex);  //LoadBoltRowData(40);
                PipeClamp.BoltRow5 = LoadBoltRowData(boltEndIndex, out boltEndIndex);  //LoadBoltRowData(44);
                PipeClamp.BoltRow6 = LoadBoltRowData(boltEndIndex, out boltEndIndex);  //LoadBoltRowData(48);

                endIndex = boltEndIndex;
            }
            catch (SmartPartSymbolException hgrEx)
            {
                throw hgrEx;
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadPipeClampData, "Error in LoadPipeClampData");
                }
            }
            return PipeClamp;
        }
        /// <summary>
        /// Create the graphical representation of a PipeClmap.
        /// </summary>
        /// <param name="pipeClamp">pipeClamp</param>
        /// <param name="matrix">The matrix.</param>
        /// <param name="outputs">The outputs.</param>
        /// <param name="outputName">Name of the output.</param>
        ///<code>
        ///Matrix4X4 matrix = new Matrix4X4();
        ///matrix.Origin = new Position(0,0,0);
        ///AddPipeClamp(PipeClampInputs pipeClamp, Matrix4X4 matrix, OutputDictionary outputs, String outputName);
        ///</code>
        public void AddPipeClamp(PipeClampInputs pipeClamp, Matrix4X4 matrix, OutputDictionary outputs, String outputName)
        {
            try
            {
                Double rotationAngle = 0, angle1 = 0, angle3Deg = 0;
                string[] boltrows = new string[24];
                const Double tempValue = 0.000001;
                const Double angleValue = 0.999999;
                StringBuilder error = new StringBuilder();

                SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();

                if (pipeClamp.Angle1 < -angleValue || pipeClamp.Angle1 > angleValue)
                    angle1 = (pipeClamp.Angle1) * 180 / Math.PI;
                if (HgrCompareDoubleService.cmpdbl(pipeClamp.Angle2, 0) == false)
                    pipeClamp.Angle2 = (pipeClamp.Angle2) * (180 / Math.PI);

                if (HgrCompareDoubleService.cmpdbl(pipeClamp.Angle3, 0) == false)
                    angle3Deg = (pipeClamp.Angle3) * (180 / Math.PI);
                if (pipeClamp.Angle1 > -angleValue && pipeClamp.Angle1 <= angleValue)
                    angle1 = 180;
                if (pipeClamp.Diameter1 <= 0)
                    error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidDiameter1Value, "Diameter1 must be greater than zero"));
                if (pipeClamp.Thickness1 <= 0)
                    error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidThickness1GTZero, "Thickness1 must be greater than zero"));
                if (pipeClamp.Width1 > -tempValue && pipeClamp.Width1 < tempValue)
                    error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidWidth1NZero, "Width1 can not be equal to zero"));
                if (pipeClamp.Gap1 < 0)
                    error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidGap1ValueNLTZero, "Gap1 can not be a negative number"));
                if (pipeClamp.Gap2 < 0)
                    error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidGap2ValueNLTZero, "Gap2 can not be a negative number"));
                if (pipeClamp.Angle1 < 0)
                {
                    error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidAngle1ValueNLTZero, "Angle1 must be 0 or greater.  Using the absolute value of Angle1"));
                    angle1 = Math.Abs(pipeClamp.Angle1);
                }
                if (pipeClamp.ShapeType != 0)
                {
                    if (pipeClamp.Width5 <= 0)
                        error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidWidth5ValueGTZero, "Width5 must be greater then 0 to place side connector.  Ignoring side connector"));
                }
                if (pipeClamp.Width1 < 0 && pipeClamp.Width2 < 0)
                    error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidWidth1andWidth2ValuesGTZero, "Width1 or Width2 must be a positive number"));

                boltrows[0] = pipeClamp.BoltRow1.Offset.ToString();
                boltrows[1] = pipeClamp.BoltRow1.MultiQty.ToString();
                boltrows[2] = pipeClamp.BoltRow1.MultiLocateBy.ToString();
                boltrows[3] = pipeClamp.BoltRow1.MultiLocation.ToString();

                boltrows[4] = pipeClamp.BoltRow2.Offset.ToString();
                boltrows[5] = pipeClamp.BoltRow2.MultiQty.ToString();
                boltrows[6] = pipeClamp.BoltRow2.MultiLocateBy.ToString();
                boltrows[7] = pipeClamp.BoltRow2.MultiLocation.ToString();

                boltrows[8] = pipeClamp.BoltRow3.Offset.ToString();
                boltrows[9] = pipeClamp.BoltRow3.MultiQty.ToString();
                boltrows[10] = pipeClamp.BoltRow3.MultiLocateBy.ToString();
                boltrows[11] = pipeClamp.BoltRow3.MultiLocation.ToString();

                boltrows[12] = pipeClamp.BoltRow4.Offset.ToString();
                boltrows[13] = pipeClamp.BoltRow4.MultiQty.ToString();
                boltrows[14] = pipeClamp.BoltRow4.MultiLocateBy.ToString();
                boltrows[15] = pipeClamp.BoltRow4.MultiLocation.ToString();

                boltrows[16] = pipeClamp.BoltRow5.Offset.ToString();
                boltrows[17] = pipeClamp.BoltRow5.MultiQty.ToString();
                boltrows[18] = pipeClamp.BoltRow5.MultiLocateBy.ToString();
                boltrows[19] = pipeClamp.BoltRow5.MultiLocation.ToString();

                boltrows[20] = pipeClamp.BoltRow6.Offset.ToString();
                boltrows[21] = pipeClamp.BoltRow6.MultiQty.ToString();
                boltrows[22] = pipeClamp.BoltRow6.MultiLocateBy.ToString();
                boltrows[23] = pipeClamp.BoltRow6.MultiLocation.ToString();

                int clampconfig = pipeClamp.ClampCfg;
                switch (clampconfig)
                {
                    case 1:   // Rod Hanger

                        if (pipeClamp.BoltRow1.Offset > -tempValue && pipeClamp.BoltRow1.Offset <= tempValue)
                        {
                            error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidOffset1GTZero, "Offset1 must be greater then 0.  Using the outside diameter of the pipe clamp"));
                            pipeClamp.BoltRow1.Offset = (pipeClamp.Diameter1 / 2) + pipeClamp.Thickness1;
                        }
                        AddClamp(pipeClamp.Diameter1, pipeClamp.Thickness1, pipeClamp.Width1, pipeClamp.Width2, pipeClamp.Height1, pipeClamp.Height2, pipeClamp.Gap1, pipeClamp.Gap2, angle1, 0, 0, outputs, outputName, "Clamp");

                        AddBoltRows(pipeClamp.Width1, boltrows, pipeClamp.Pin1Diameter, pipeClamp.Pin1Length, angle1, outputs, outputName);

                        if (pipeClamp.ShapeType != 0 && pipeClamp.Width5 > 0)
                            CreateSideConnection(pipeClamp.Diameter1, pipeClamp.Thickness1, pipeClamp.Thickness3, pipeClamp.Width5, pipeClamp.Width6, 0, pipeClamp.Diameter1 / 2, pipeClamp.Thickness1, Convert.ToInt64(pipeClamp.ShapeType), 0, outputs, outputName);

                        if (HgrCompareDoubleService.cmpdbl(pipeClamp.Thickness2, 0) == false && HgrCompareDoubleService.cmpdbl(angle1, 180.0) == true)
                            AddGussets(pipeClamp.Diameter1, pipeClamp.Width2, pipeClamp.Thickness1, pipeClamp.Thickness2, pipeClamp.Gap1, pipeClamp.Gap2, pipeClamp.Width1, pipeClamp.Height1, pipeClamp.Height2, pipeClamp.Dim1, pipeClamp.Dim2, outputs, outputName, 0, false, true, true);
                        break;

                    case 2:  // Side Mounted

                        if (pipeClamp.BoltRow1.Offset > -tempValue && pipeClamp.BoltRow1.Offset <= tempValue)
                        {
                            error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidOffset1GTZero, "Offset1 must be greater then 0.  Using the outside diameter of the pipe clamp"));
                            pipeClamp.BoltRow1.Offset = (pipeClamp.Diameter1 / 2) + pipeClamp.Thickness1;
                        }

                        if (HgrCompareDoubleService.cmpdbl(angle3Deg, 0) == true)
                            rotationAngle = Math.PI / 2;
                        else
                            rotationAngle = Math.PI / 2 + angle3Deg * Math.PI / 180;

                        AddClamp(pipeClamp.Diameter1, pipeClamp.Thickness1, pipeClamp.Width1, pipeClamp.Width2, pipeClamp.Height1, pipeClamp.Height2, pipeClamp.Gap1, pipeClamp.Gap2, angle1, 0, 0, outputs, outputName, "clamp", rotationAngle);

                        AddBoltRows(pipeClamp.Width1, boltrows, pipeClamp.Pin1Diameter, pipeClamp.Pin1Length, angle1, outputs, outputName, rotationAngle);

                        if (pipeClamp.ShapeType != 0 && pipeClamp.Width5 > 0)
                            CreateSideConnection(pipeClamp.Diameter1, pipeClamp.Thickness1, pipeClamp.Thickness3, pipeClamp.Width5, pipeClamp.Width6, 0, pipeClamp.Diameter1 / 2, pipeClamp.Thickness1, Convert.ToInt64(pipeClamp.ShapeType), Math.PI / 2, outputs, outputName);

                        if (HgrCompareDoubleService.cmpdbl(pipeClamp.Thickness2, 0) == false && HgrCompareDoubleService.cmpdbl(angle1, 180.0) == true)
                            AddGussets(pipeClamp.Diameter1, pipeClamp.Width2, pipeClamp.Thickness1, pipeClamp.Thickness2, pipeClamp.Gap1, pipeClamp.Gap2, pipeClamp.Width1, pipeClamp.Height1, pipeClamp.Height2, pipeClamp.Dim1, pipeClamp.Dim2, outputs, outputName, Math.PI / 2 + angle3Deg, false, true, true);
                        break;

                    case 3:   //  Side Mounted Two Port

                        if (pipeClamp.Width3 > (pipeClamp.Diameter1 + (pipeClamp.Thickness1 * 2)))
                            error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidWidth3NGTDiameter, "Width3 can not be greater than the outside diameter of the pipe"));

                        if (HgrCompareDoubleService.cmpdbl(angle3Deg, 0) == true)
                            rotationAngle = Math.PI / 2;
                        else
                            rotationAngle = Math.PI / 2 + angle3Deg * Math.PI / 180;

                        AddClamp(pipeClamp.Diameter1, pipeClamp.Thickness1, pipeClamp.Width1, pipeClamp.Width2, pipeClamp.Height1, pipeClamp.Height2, pipeClamp.Gap1, pipeClamp.Gap2, angle1, 0, 0, outputs, outputName, "Clamp", rotationAngle);

                        AddBoltRows(pipeClamp.Width1, boltrows, pipeClamp.Pin1Diameter, pipeClamp.Pin1Length, angle1, outputs, outputName, rotationAngle);

                        if (pipeClamp.ShapeType != 0 && pipeClamp.Width5 > 0)
                            CreateSideConnection(pipeClamp.Diameter1, pipeClamp.Thickness1, pipeClamp.Thickness3, pipeClamp.Width5, pipeClamp.Width6, 0, pipeClamp.Diameter1 / 2, pipeClamp.Thickness1, Convert.ToInt64(pipeClamp.ShapeType), Math.PI / 2, outputs, outputName);

                        if (HgrCompareDoubleService.cmpdbl(pipeClamp.Thickness2, 0) == false && HgrCompareDoubleService.cmpdbl(angle1, 180.0) == true)
                            AddGussets(pipeClamp.Diameter1, pipeClamp.Width2, pipeClamp.Thickness1, pipeClamp.Thickness2, pipeClamp.Gap1, pipeClamp.Gap2, pipeClamp.Width1, pipeClamp.Height1, pipeClamp.Height2, pipeClamp.Dim1, pipeClamp.Dim2, outputs, outputName, Math.PI / 2 + angle3Deg, false, true, true);
                        break;

                    case 4:   //  Direct Bolted

                        if (pipeClamp.Width3 > (pipeClamp.Height1 + pipeClamp.Height2))
                        {
                            error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidWidth3GTHeight, "Width3 is greater than the heights of the pipe clamp"));
                            pipeClamp.Width3 = (pipeClamp.Height1 + pipeClamp.Height2);
                        }

                        if (pipeClamp.Width3 > (0 - tempValue) && pipeClamp.Width3 <= (0 + tempValue))
                        {
                            error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidClampWidth3GTZero, "Width3 must be greater then 0.  Using the outside diameter of the pipe clamp"));
                            pipeClamp.Width3 = pipeClamp.Diameter1 + (2 * pipeClamp.Thickness1);
                        }

                        AddClamp(pipeClamp.Diameter1, pipeClamp.Thickness1, pipeClamp.Width1, pipeClamp.Width2, pipeClamp.Height1, pipeClamp.Height2, pipeClamp.Gap1, pipeClamp.Gap2, angle1, 0, 0, outputs, outputName, "Clamp", Math.PI / 2);

                        if (HgrCompareDoubleService.cmpdbl(pipeClamp.Thickness2, 0) == false)
                            AddGussets(pipeClamp.Diameter1, pipeClamp.Width2, pipeClamp.Thickness1, pipeClamp.Thickness2, pipeClamp.Gap1, pipeClamp.Gap2, pipeClamp.Width1, pipeClamp.Height1, pipeClamp.Height2, pipeClamp.Dim1, pipeClamp.Dim2, outputs, outputName, Math.PI / 2, false, true, true);

                        if (pipeClamp.ShapeType != 0 && pipeClamp.Width5 > 0)
                            CreateSideConnection(pipeClamp.Diameter1, pipeClamp.Thickness1, pipeClamp.Thickness3, pipeClamp.Width5, pipeClamp.Width6, 0, pipeClamp.Diameter1 / 2, pipeClamp.Thickness1, Convert.ToInt64(pipeClamp.ShapeType), Math.PI / 2, outputs, outputName);
                        break;

                    case 5:   //   Riser Rod Hanger

                        if (pipeClamp.BoltRow1.Offset > -tempValue && pipeClamp.BoltRow1.Offset <= tempValue)
                        {
                            error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidOffset1GTZero, "Offset1 must be greater then 0.  Using the outside diameter of the pipe clamp"));
                            pipeClamp.BoltRow1.Offset = (pipeClamp.Diameter1 / 2) + pipeClamp.BoltRow1.Offset;
                        }

                        if (pipeClamp.BoltRow2.Offset > -tempValue && pipeClamp.BoltRow2.Offset <= tempValue)
                        {
                            error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidOffset2GTZero, "Offset2S must be greater then 0.  Using the outside diameter of the pipe clamp"));
                            pipeClamp.BoltRow2.Offset = (pipeClamp.Diameter1 / 2) + pipeClamp.BoltRow2.Offset;
                        }

                        AddClamp(pipeClamp.Diameter1, pipeClamp.Thickness1, pipeClamp.Width1, pipeClamp.Width2, pipeClamp.Height1, pipeClamp.Height2, pipeClamp.Gap1, pipeClamp.Gap2, angle1, 0, 0, outputs, outputName, "Clamp", Math.PI / 2, true);

                        AddBoltRows(pipeClamp.Width1, boltrows, pipeClamp.Pin1Diameter, pipeClamp.Pin1Length, angle1, outputs, outputName, Math.PI / 2, true);

                        if (HgrCompareDoubleService.cmpdbl(pipeClamp.Thickness2, 0) == false && HgrCompareDoubleService.cmpdbl(angle1, 180.0) == true)
                            AddGussets(pipeClamp.Diameter1, pipeClamp.Width2, pipeClamp.Thickness1, pipeClamp.Thickness2, pipeClamp.Gap1, pipeClamp.Gap2, pipeClamp.Width1, pipeClamp.Height1, pipeClamp.Height2, pipeClamp.Dim1, pipeClamp.Dim2, outputs, outputName, Math.PI / 2, true, true, true);

                        if (pipeClamp.ShapeType != 0 && pipeClamp.Width5 > 0)
                            CreateSideConnection(pipeClamp.Diameter1, pipeClamp.Thickness1, pipeClamp.Thickness3, pipeClamp.Width5, pipeClamp.Width6, 0, pipeClamp.Diameter1 / 2, pipeClamp.Thickness1, Convert.ToInt64(pipeClamp.ShapeType), Math.PI / 2, outputs, outputName, true);
                        break;

                    case 6:   //  Riser on Structure

                        if (pipeClamp.Width3 > -tempValue && pipeClamp.Width3 <= tempValue)
                        {
                            error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidClampWidth3GTZero, "Width3 must be greater then 0.  Using the outside diameter of the pipe clamp"));
                            pipeClamp.Width3 = pipeClamp.Diameter1 + (2 * pipeClamp.Thickness1);
                        }
                        AddClamp(pipeClamp.Diameter1, pipeClamp.Thickness1, pipeClamp.Width1, pipeClamp.Width2, pipeClamp.Height1, pipeClamp.Height2, pipeClamp.Gap1, pipeClamp.Gap2, angle1, 0, 0, outputs, outputName, "Clamp", Math.PI / 2, true);

                        AddBoltRows(pipeClamp.Width1, boltrows, pipeClamp.Pin1Diameter, pipeClamp.Pin1Length, angle1, outputs, outputName, Math.PI / 2, true);

                        if (HgrCompareDoubleService.cmpdbl(pipeClamp.Thickness2, 0) == false && HgrCompareDoubleService.cmpdbl(angle1, 180.0) == true)
                            AddGussets(pipeClamp.Diameter1, pipeClamp.Width2, pipeClamp.Thickness1, pipeClamp.Thickness2, pipeClamp.Gap1, pipeClamp.Gap2, pipeClamp.Width1, pipeClamp.Height1, pipeClamp.Height2, pipeClamp.Dim1, pipeClamp.Dim2, outputs, outputName, Math.PI / 2, true, true, true);

                        if (pipeClamp.ShapeType != 0 && pipeClamp.Width5 > 0)
                            CreateSideConnection(pipeClamp.Diameter1, pipeClamp.Thickness1, pipeClamp.Thickness3, pipeClamp.Width5, pipeClamp.Width6, 0, pipeClamp.Diameter1 / 2, pipeClamp.Thickness1, Convert.ToInt64(pipeClamp.ShapeType), Math.PI / 2, outputs, outputName, true);
                        break;

                    case 7:   //   Offset Pipe Clamp

                        if (pipeClamp.Height2 <= tempValue)
                        {
                            error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidHeight2GTZero, "Height2 must be greater than 0.  Using the value for height1"));
                            pipeClamp.Height2 = pipeClamp.Height1;
                        }

                        if (pipeClamp.Length > -tempValue && pipeClamp.Length <= tempValue)
                        {
                            error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidnLengthValue, "Length must be greater then zero"));
                            pipeClamp.Length = pipeClamp.Diameter1 / 2 + pipeClamp.Thickness1;
                        }
                        if (angle1 > 359.999999 && angle1 < 360.000001)
                        {
                            error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidnOffset, "Offset PipeClamp Configuration is not applicable for a SplitPipe Ring"));
                            pipeClamp.Length = 0;
                        }

                        if (pipeClamp.Width3 <= 0.000001)
                        {
                            error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidnWidth3, "Width3 is needed, Setting it to Height1 + Height2"));
                            pipeClamp.Width3 = pipeClamp.Height1 + pipeClamp.Height2;
                        }
                        if (HgrCompareDoubleService.cmpdbl(angle3Deg, 0) == true)
                            rotationAngle = Math.PI / 2 - Math.PI;
                        else
                            rotationAngle = -angle3Deg;

                        AddClamp(pipeClamp.Diameter1, pipeClamp.Thickness1, pipeClamp.Width1, pipeClamp.Width2, pipeClamp.Height1, pipeClamp.Height2, pipeClamp.Gap1, pipeClamp.Gap2, angle1, pipeClamp.Length, pipeClamp.Width3, outputs, outputName, "Clamp", rotationAngle);

                        AddBoltRows(pipeClamp.Width1, boltrows, pipeClamp.Pin1Diameter, pipeClamp.Pin1Length, angle1, outputs, outputName, rotationAngle);

                        if (HgrCompareDoubleService.cmpdbl(pipeClamp.Thickness2, 0) == false && HgrCompareDoubleService.cmpdbl(angle1, 180.0) == true)
                            AddGussets(pipeClamp.Diameter1, pipeClamp.Width2, pipeClamp.Thickness1, pipeClamp.Thickness2, pipeClamp.Gap1, pipeClamp.Gap2, pipeClamp.Width1, pipeClamp.Height1, pipeClamp.Height2, pipeClamp.Dim1, pipeClamp.Dim2, outputs, outputName, Math.PI / 2, false, true, false);
                        break;
                }

                if (pipeClamp.Diameter4 > 0 && pipeClamp.Width4 > 0)
                {
                    if (pipeClamp.ClampCfg == 5 || pipeClamp.ClampCfg == 4)
                    {
                        symbolGeometryHelper.ActivePosition = new Position(0, 0, -pipeClamp.Width4 / 2);
                        symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        Projection3d liner = symbolGeometryHelper.CreateCylinder(null, pipeClamp.Diameter4 / 2, pipeClamp.Width4);
                        outputs.Add(outputName + "Liner", liner);
                    }
                    else
                    {
                        symbolGeometryHelper.ActivePosition = new Position(-pipeClamp.Width4 / 2, 0, 0);
                        symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        Projection3d liner = symbolGeometryHelper.CreateCylinder(null, pipeClamp.Diameter4 / 2, pipeClamp.Width4);
                        outputs.Add(outputName + "Liner", liner);
                    }
                }

                if (error.Length != 0)
                    ToDoListMessage = new ToDoListMessage(ToDoMessageTypes.ToDoMessageWarning, error.ToString());

                //   Try to rotate and translate the Graphic to a new location wrt local origin

                Geometry3d transformObject;
                int m = 0, objectCount = 0;
                String[] objectCollection = new String[objectCount];

                //  Clamps
                objectCount = objectCount + 1;
                Array.Resize(ref objectCollection, objectCount);
                objectCollection[objectCount - 1] = outputName + "side1";

                objectCount = objectCount + 1;
                Array.Resize(ref objectCollection, objectCount);
                objectCollection[objectCount - 1] = outputName + "side2";

                // bolts
                if (pipeClamp.BoltRow1.MultiQty > 0)
                {
                    for (m = 1; m <= pipeClamp.BoltRow1.MultiQty; m++)
                    {
                        objectCount = objectCount + 1;
                        Array.Resize(ref objectCollection, objectCount);
                        objectCollection[objectCount - 1] = outputName + "bolt" + 1 + (m - 1);
                    }
                }

                if (pipeClamp.BoltRow2.MultiQty > 0)
                {
                    for (m = 1; m <= pipeClamp.BoltRow2.MultiQty; m++)
                    {
                        objectCount = objectCount + 1;
                        Array.Resize(ref objectCollection, objectCount);
                        objectCollection[objectCount - 1] = outputName + "bolt" + 2 + (m - 1);
                    }
                }

                if (pipeClamp.BoltRow3.MultiQty > 0)
                {
                    for (m = 1; m <= pipeClamp.BoltRow3.MultiQty; m++)
                    {
                        objectCount = objectCount + 1;
                        Array.Resize(ref objectCollection, objectCount);
                        objectCollection[objectCount - 1] = outputName + "bolt" + 3 + (m - 1);
                    }
                }

                if (pipeClamp.BoltRow4.MultiQty > 0)
                {
                    for (m = 1; m <= pipeClamp.BoltRow4.MultiQty; m++)
                    {
                        objectCount = objectCount + 1;
                        Array.Resize(ref objectCollection, objectCount);
                        objectCollection[objectCount - 1] = outputName + "bolt" + 4 + (m - 1);
                    }
                }

                if (pipeClamp.BoltRow5.MultiQty > 0)
                {
                    for (m = 1; m <= pipeClamp.BoltRow5.MultiQty; m++)
                    {
                        objectCount = objectCount + 1;
                        Array.Resize(ref objectCollection, objectCount);
                        objectCollection[objectCount - 1] = outputName + "bolt" + 5 + (m - 1);
                    }
                }

                if (pipeClamp.BoltRow6.MultiQty > 0)
                {
                    for (m = 1; m <= pipeClamp.BoltRow6.MultiQty; m++)
                    {
                        objectCount = objectCount + 1;
                        Array.Resize(ref objectCollection, objectCount);
                        objectCollection[objectCount - 1] = outputName + "bolt" + 6 + (m - 1);
                    }
                }

                objectCount = objectCount + 1;
                Array.Resize(ref objectCollection, objectCount);
                objectCollection[objectCount - 1] = outputName + "Gusset";

                objectCount = objectCount + 1;
                Array.Resize(ref objectCollection, objectCount);
                objectCollection[objectCount - 1] = outputName + "Gusset1";

                objectCount = objectCount + 1;
                Array.Resize(ref objectCollection, objectCount);
                objectCollection[objectCount - 1] = outputName + "Gusset2";

                objectCount = objectCount + 1;
                Array.Resize(ref objectCollection, objectCount);
                objectCollection[objectCount - 1] = outputName + "Gusset3";

                objectCount = objectCount + 1;
                Array.Resize(ref objectCollection, objectCount);
                objectCollection[objectCount - 1] = outputName + "Nut";

                objectCount = objectCount + 1;
                Array.Resize(ref objectCollection, objectCount);
                objectCollection[objectCount - 1] = outputName + "Liner";

                for (int k = 0; k <= objectCount - 1; k++)
                {
                    transformObject = (Geometry3d)outputs[objectCollection[k]];
                    if (transformObject != null)
                        transformObject.Transform(matrix);
                }
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddPipeClampMethod, "Error in AddPipeClamp");
                }
            }
        }
        /// <summary>
        ///  Defines the Clevis input parameter type.
        /// </summary>
        public struct ClevisInputs
        {
            /// <summary>
            /// Creating a refernce variable for propertywith name  NutInputs
            /// </summary>
            public NutInputs nut;
            /// <summary>
            /// Declaring a imput variable in Clevis Block with coloumn name Opening1 in Data Sheet
            /// </summary>
            public double Opening1;
            /// <summary>
            /// Outside diameter of round ends of clevis. If zero or negative, the round ends are not drawn.
            /// </summary>
            public double Diameter2;
            /// <summary>
            /// Thickness of round ends of clevis. If zero or negative, the round ends are not drawn.
            /// </summary>
            public double Thickness2;
            /// <summary>
            /// Gap between round ends of clevis. Often called GRIP in manufacturer catalogs. Can be zero but not negative. If negative, zero is used.
            /// </summary>
            public double Gap2;
            /// <summary>
            ///  Width of the side blocks. If zero or negative, the side blocks are not drawn.
            /// </summary>
            public double Width3;
            /// <summary>
            /// Thickness of the side blocks. 
            /// </summary>
            public double thickness3;
            /// <summary>
            /// Gap between the rectangular side blocks.
            /// </summary>
            public double Gap3;
            /// <summary>
            /// Amount to extend side blocks past the inside face of the End Nut Shape.
            /// </summary>
            public double OverLength1;
            /// <summary>
            /// Amount to extend side blocks past the bolt / pin centerline. Can be positive or negative 
            /// </summary>
            public double OverLength2;
            /// <summary>
            /// Diameter of bolt / pin. If zero or negative, the pin is not drawn.
            ///  pin Diameter
            /// </summary>
            public double Pin1Diameter;
            /// <summary>
            /// Length of bolt / pin. If, zero or negative, the pin is not drawn.
            ///  pin length
            /// </summary>
            public double Pin1Length;

        }
        /// <summary>
        /// Defines the Rod input parameter type.
        /// </summary>
        public struct RodInputs
        {
            /// <summary>
            /// Outside diameter of rod that attaches to the eye nut.
            /// Diameter of Rod
            /// </summary>
            public double RodDiameter;
            /// <summary>
            /// Distance between the pin port and the port at the end of the rod. Represents the amount that the clevis takes out of the overall rod lengths.
            /// </summary>
            public double RodTakeOut;
        }
        /// <summary>
        /// This method adds inputs for RodInputs.User symbol calls this method during  DefineAdditionalInputs
        /// to define additional inputs. The list of inputs returned by this method will be the inputs for the user symbol in addition
        /// to the inputs that are already defined as member variables.
        /// </summary>
        /// <param name="startIndex">start Index.</param>
        /// <param name="endIndex">Out - end Index.</param>
        /// <param name="additionalInputs">The list of additional Inputs for the symbol in addition
        /// to the inputs that are already defined as member variables.</param>
        ///<code>
        /// public override void DefineAdditionalInputs(out List(Input) additionalInputs)
        /// {
        ///    int endIndex;
        ///    additionalInputs = new List(Input)();
        ///    //Example , I have added the tclevis with staring index 4.
        ///    AddRodInputs(2, out endIndex, additionalInputs);
        /// }
        ///</code>
        public void AddRodInputs(int startIndex, out int endIndex, List<Input> additionalInputs)
        {
            try
            {

                additionalInputs.Add(new InputDouble(startIndex, "RodDiameter", "RodDiameter", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "RodTakeOut", "RodTakeOut", 0, false));
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddRodInputs, "Error in adding Rod inputs");
            }
            endIndex = startIndex;
        }
        /// <summary>
        /// This method adds inputs for tclevis.User symbol calls this method during  DefineAdditionalInputs
        /// to define additional inputs. The list of inputs returned by this method will be the inputs for the user symbol in addition
        /// to the inputs that are already defined as member variables.
        /// </summary>
        /// <param name="startIndex">start Index.</param>
        /// <param name="endIndex">Out - end Index.</param>
        /// <param name="additionalInputs">The list of additional Inputs for the symbol in addition
        /// to the inputs that are already defined as member variables.</param>
        ///<code>
        /// public override void DefineAdditionalInputs(out List(Input) additionalInputs)
        /// {
        ///    int endIndex;
        ///    additionalInputs = new List(Input)();
        ///    //Example , I have added the tclevis with staring index 4.
        ///    AddClevisInputs(4, out endIndex, additionalInputs);
        /// }
        ///</code>
        public void AddClevisInputs(int startIndex, out int endIndex, List<Input> additionalInputs)
        {
            try
            {

                additionalInputs.Add(new InputDouble(startIndex, "Opening1", "Opening1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Diameter2", "Diameter2", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Thickness2", "Thickness2", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Gap2", "Gap2", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Width3", "Width3", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Thickness3", "Thickness3", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Gap3", "Gap3", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "OverLength1", "OverLength1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "OverLength2", "OverLength2", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Pin1Diameter", "Pin1Diameter", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Pin1Length", "Pin1Length", 0, false));
                AddNutInputs(++startIndex, out endIndex, additionalInputs);
                ++startIndex;
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrClevisAdditionalInputs, "Error in adding Clevis Inputs");
            }
            endIndex = startIndex;
        }
        /// <summary>
        /// Adds the Clevis outputs.User symbol calls this method during DefineAdditionalOutputs
        /// to define additional outputs for an aspect. The list of outputs returned by this method will be the outputs for the aspect
        /// in addition to the outputs that are already defined as attributes on the aspect.
        /// </summary>
        /// <param name="additionalOutputs">The additional outputs.</param>
        ///<code>
        /// public override void DefineAdditionalOutputs(out List<OutputDefinition> additionalOutputs)
        /// {        
        ///    additionalOutputs = new List(OutputDefinition)();
        ///    AddClevisOutputs(additionalOutputs);
        /// }
        ///</code> 
        public void AddClevisOutputs(string aspectName, List<OutputDefinition> additionalOutputs)
        {
            try
            {
                additionalOutputs.Add(new OutputDefinition("Clevis" + "RoundEnds1", "Clevis" + "RoundEnds1"));
                additionalOutputs.Add(new OutputDefinition("Clevis" + "RoundEnds2", "Clevis" + "RoundEnds2"));
                additionalOutputs.Add(new OutputDefinition("Clevis" + "SideBlocks1", "Clevis" + "SideBlocks1"));
                additionalOutputs.Add(new OutputDefinition("Clevis" + "SideBlocks2", "Clevis" + "SideBlocks2"));
                additionalOutputs.Add(new OutputDefinition("Clevis" + "Bolt", "Clevis" + "Bolt"));
                additionalOutputs.Add(new OutputDefinition("Clevis" + "Nut", "Clevis" + "Nut"));
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrClevisAdditionalOutputs, "Error in adding Clevis outputs");
            }
        }
        /// <summary>
        /// This method will be called by user symbol to get value of an input(in this case, Nut input structure)during construction of outputs. 
        /// Given the start index, this method will return the value of the Clevisindex struct object.
        /// </summary>
        /// <param name="startIndex">The start index.</param>
        /// <returns></returns>
        ///<code>
        /// ClevisInputs clevis = LoadClevisData(4);
        ///</code>
        public ClevisInputs LoadClevisData(int startIndex)
        {
            ClevisInputs Clevis = new ClevisInputs();
            try
            {
                Clevis.Opening1 = GetDoubleInputValue(startIndex);
                Clevis.Diameter2 = GetDoubleInputValue(++startIndex);
                Clevis.Thickness2 = GetDoubleInputValue(++startIndex);
                Clevis.Gap2 = GetDoubleInputValue(++startIndex);
                Clevis.Width3 = GetDoubleInputValue(++startIndex);
                if (Clevis.Width3 <= 0)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidWidth3GTZero, "Width3 value should not be less than or equal to zero");
                }
                Clevis.thickness3 = GetDoubleInputValue(++startIndex);
                if (Clevis.thickness3 <= 0)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidThickness3GTZero, "thickness3 value should not be less than or equal to zero");
                }
                Clevis.Gap3 = GetDoubleInputValue(++startIndex);
                Clevis.OverLength1 = GetDoubleInputValue(++startIndex);
                Clevis.OverLength2 = GetDoubleInputValue(++startIndex);
                Clevis.Pin1Diameter = GetDoubleInputValue(++startIndex);
                Clevis.Pin1Length = GetDoubleInputValue(++startIndex);
                Clevis.nut = LoadNutData(++startIndex);
            }
            catch (SmartPartSymbolException hgrEx)
            {
                throw hgrEx;
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadClevisData, "Error in Loding Clevis Data");
            }
            return Clevis;

        }
        /// <summary>
        /// This method will be called by user symbol to get value of an input(in this case, Rod input structure)during construction of outputs. 
        /// Given the start index, this method will return the value of the Rod Index struct object.
        /// </summary>
        /// <param name="startIndex">The start index.</param>
        /// <returns></returns>
        ///<code>
        /// tRodRelative trod = LoadRodData(2);
        ///</code>
        public RodInputs LoadRodData(int startIndex)
        {
            RodInputs rod;
            rod.RodDiameter = GetDoubleInputValue(startIndex);
            rod.RodTakeOut = GetDoubleInputValue(++startIndex);
            return rod;
        }
        /// <summary>
        /// Create the graphical representation of a Clevis.
        /// </summary>
        /// <param name="myClevis">Structure for specifying the inputs for the Clevis ClevisInputs Properties.</param>
        /// <param name="strMatrix">Matrix to specify the position and oreintation the graphics - Matrix4X4.</param>
        /// <param name="Outputcoll">Collection of declared outputs, which is indexed by the name of the outputs declared as defining SymbolOutputs on the AspectDefinition field- OutputDictionary.</param>
        /// <param name="output">OutputName that this graphic is being placed on-String.</param>
        ///<code>
        /// Matrix4X4 matrix = new Matrix4X4();
        /// matrix.Origin = new Position(0, 0, 0);
        /// matrix.SetOrientation(new Vector(0, 1, 0), new Vector(0, 0, 1));
        ///AddClevis(Clevis, matrix, m_oSymbolic.Outputs, "Clevis");
        ///</code>
        #region "Clevis"
        public void AddClevis(ClevisInputs Clevis, Matrix4X4 matrix, OutputDictionary outputs, String output)
        {
            try
            {
                Boolean noRoundEnd = true, noSideBlock = true;
                SymbolGeometryHelper symbolGeomHlpr;
                
                //Round Ends
                if ((Clevis.Diameter2 > 0) && (Clevis.Thickness2 > 0))
                {
                    if (Clevis.Gap2 < 0)
                    {
                        //Gap Between Round Ends must be a positive number or zero
                        ToDoListMessage = new ToDoListMessage(ToDoMessageTypes.ToDoMessageWarning, SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidGap2NLTZero, "A negative GRIP(Gap2) was specified, a GRIP of zero was used instead AddClevis"));
                        Clevis.Gap2 = 0;
                    }
                    symbolGeomHlpr = new SymbolGeometryHelper();
                    symbolGeomHlpr.ActivePosition = new Position(0, -Clevis.Gap2 / 2, 0);
                    symbolGeomHlpr.SetOrientation(new Vector(0, -1, 0), new Vector(0, 0, 1));
                    Projection3d roundEnds1 = (Projection3d)symbolGeomHlpr.CreateCylinder(null, Clevis.Diameter2 / 2, Clevis.Thickness2);//connection,radis,length
                    roundEnds1.Transform(matrix);
                    outputs.Add(output + "RoundEnds1", roundEnds1);
                
                    symbolGeomHlpr = new SymbolGeometryHelper();
                    symbolGeomHlpr.ActivePosition = new Position(0, Clevis.Gap2 / 2, 0);
                    symbolGeomHlpr.SetOrientation(new Vector(0, 1, 0), new Vector(0, 0, 1));
                    Projection3d roundEnds2 = (Projection3d)symbolGeomHlpr.CreateCylinder(null, Clevis.Diameter2 / 2, Clevis.Thickness2);///connection,radius,length
                    roundEnds2.Transform(matrix);                                                                                                                                         
                    outputs.Add(output + "RoundEnds2", roundEnds2);
                    noRoundEnd = false;
                }
                //Side Blocks
                if ((Clevis.Width3 > 0) && (Clevis.thickness3 >= 0))
                {
                    if (Clevis.thickness3 == 0)
                        Clevis.thickness3 = Clevis.Thickness2;
                    if (Clevis.Gap3 <= 0)
                        Clevis.Gap3 = Clevis.Gap2;
                    if (Clevis.Gap3 < 0)
                        Clevis.Gap3 = 0;
                }
                if (Clevis.thickness3 > 0)   // Draws if Gap3 is still zero!
                {
                    symbolGeomHlpr = new SymbolGeometryHelper();
                    symbolGeomHlpr.ActivePosition = new Position(0, -(Clevis.Gap3 / 2 + Clevis.thickness3 / 2), -Clevis.OverLength2);
                    symbolGeomHlpr.SetOrientation(new Vector(0, 0, 1), new Vector(1, 0, 0));
                    Projection3d sideBlocks1 = (Projection3d)symbolGeomHlpr.CreateBox(null, (Clevis.OverLength2 + Clevis.OverLength1 + Clevis.Opening1), Clevis.Width3, Clevis.thickness3);
                    sideBlocks1.Transform(matrix);
                    outputs.Add(output + "SideBlocks1", sideBlocks1);
                
                    symbolGeomHlpr = new SymbolGeometryHelper();
                    symbolGeomHlpr.ActivePosition = new Position(0, (Clevis.Gap3 / 2 + Clevis.thickness3 / 2), -Clevis.OverLength2);
                    symbolGeomHlpr.SetOrientation(new Vector(0, 0, 1), new Vector(1, 0, 0));
                    Projection3d sideBlocks2 = (Projection3d)symbolGeomHlpr.CreateBox(null, (Clevis.OverLength2 + Clevis.OverLength1 + Clevis.Opening1), Clevis.Width3, Clevis.thickness3);
                    sideBlocks2.Transform(matrix);
                    outputs.Add(output + "SideBlocks2", sideBlocks2);
                    noSideBlock = false;
                }
                if (Clevis.nut.ShapeLength > 0)
                {
                    Matrix4X4 nutMatrix = new Matrix4X4();
                    nutMatrix.Origin = new Position(0, 0, Clevis.Opening1);
                    AddNut(Clevis.nut, nutMatrix, outputs, output + "Nut");

                }

                if (Clevis.Pin1Diameter > 0 && Clevis.Pin1Length > 0)
                {
                    symbolGeomHlpr = new SymbolGeometryHelper();
                    symbolGeomHlpr.ActivePosition = new Position(0, -Clevis.Pin1Length / 2, 0);
                    symbolGeomHlpr.SetOrientation(new Vector(0, 1, 0), new Vector(0, 0, 1));
                    Projection3d bolt = (Projection3d)symbolGeomHlpr.CreateCylinder(null, Clevis.Pin1Diameter / 2, Clevis.Pin1Length);
                    bolt.Transform(matrix);
                    outputs.Add(output + "Bolt", bolt);
                    
                }
                
                //If both the Round End and the Side Blocks have not been drawn, warn the user.
                if (noRoundEnd && noSideBlock)
                    ToDoListMessage = new ToDoListMessage(ToDoMessageTypes.ToDoMessageWarning, SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidRoundEndsSideBlocks, " Clevis has neither Round Ends or Side Blocks AddCreateBoxClevis"));
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddClevisMethod, "Error in AddClevis");
                    return;
                }
            }

        }
        #endregion

        /// <summary>
        /// Defines the EyeNut input parameter type.
        /// </summary>
        public struct EyeNutInputs
        {
            /// <summary>
            /// ShapeType The graphic shape to use for the nut or washer. Codelist hsShapeType 1 – Round,2 - Square, 3 - Hex.
            /// </summary>
            public double InnerWidth1;
            /// <summary>
            /// The outside dimension of the nut or washer.
            /// </summary>
            public double InnerWidth2;
            /// <summary>
            /// The “other” outside dimension of the nut or washer.If zero, negative, or undefined, this attribute is ignored. Also ignored for Hex shape.   
            /// </summary>
            public double InnerLength1;
            /// <summary>
            ///The length of the nut or washer.
            /// </summary>
            public double InnerLength2;
            /// <summary>
            /// The “other” outside dimension of the nut or washer.If zero, negative, or undefined, this attribute is ignored. Also ignored for Hex shape.   
            /// </summary>
            public double Thickness1;
            /// <summary>
            ///The length of the nut or washer.
            /// </summary>
            public double OverLength1;
            /// <summary>
            ///The Nut input parameter type.
            /// </summary>
            public NutInputs Nut;
        }
        /// <summary>
        /// This property adds inputs for EyeNut.User symbol calls this property AdditionalInputs
        /// to define additional inputs. The list of inputs returned by this method will be the inputs for the user symbol in addition
        /// to the inputs that are already defined as member variables.
        /// </summary>    
        ///<code>
        /// public override IEnumerable<Input> AdditionalInputs
        /// {
        ///     get
        ///     {
        ///      int endIndex;
        ///      List<Input> additionalInputs = new List<Input>();
        ///      AddEyeNutInputs(4, out endIndex, additionalInputs);
        ///      return additionalInputs;
        ///     }
        /// }
        ///</code>
        public void AddEyeNutInputs(int startIndex, out int endIndex, List<Input> additionalInputs)
        {
            try
            {
                additionalInputs.Add((Input)new InputDouble(startIndex, "InnerWidth1", "InnerWidth1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "InnerWidth2", "InnerWidth2", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "InnerLength1", "InnerLength1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "InnerLength2", "InnerLength2", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Thickness1", "Thickness1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "OverLength1", "OverLength1", 0, false));
                ++startIndex;
                endIndex = startIndex;
                AddNutInputs(startIndex, out endIndex, additionalInputs);
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrEyeNutAdditionalInputs, "Error in adding EyeNut Inputs");
            }
            endIndex = ++startIndex;
        }
        /// <summary>
        /// This property adds outputs for EyeNut.User symbol calls this property AdditionalInputs
        /// to define additional inputs. The list of inputs returned by this method will be the inputs for the user symbol in addition
        /// to the inputs that are already defined as member variables.
        /// </summary>
        /// <param name="additionalOutputs">The additional outputs.</param>
        ///<code>
        ///public override IEnumerable<OutputDefinition> AdditionalOutputs(string aspectName)
        ///{
        ///    List<OutputDefinition> additionalOutputs = new List<OutputDefinition>();
        ///    if (aspectName == "Symbolic")
        ///    {
        ///        AddEyeNutOutputs(additionalOutputs);
        ///    }
        ///    return additionalOutputs;
        ///}
        ///</code> 
        public void AddEyeNutOutputs(List<OutputDefinition> additionalOutputs)
        {
            try
            {
                additionalOutputs.Add(new OutputDefinition("EyeNut" + "TOP_CYL_1", "EyeNut" + "TOP_CYL_1"));
                additionalOutputs.Add(new OutputDefinition("EyeNut" + "TOP_CYL_2", "EyeNut" + "TOP_CYL_2"));
                additionalOutputs.Add(new OutputDefinition("EyeNut" + "BOT_CYL_1", "EyeNut" + "BOT_CYL_1"));
                additionalOutputs.Add(new OutputDefinition("EyeNut" + "BOT_CYL_2", "EyeNut" + "BOT_CYL_2"));
                additionalOutputs.Add(new OutputDefinition("EyeNut" + "BOTTOM", "EyeNut" + "BOTTOM"));
                additionalOutputs.Add(new OutputDefinition("EyeNut" + "Nut1", "EyeNut" + "Nut1"));
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddEyeNutOutputs, "Error in adding EyeNut outputs");
                }
            }
        }
        /// <summary>
        /// This method will be called by user symbol to get value of an input(in this case, EyeNut input structure)during construction of outputs. 
        /// Given the start index, this method will return the value of the EyeNutInputs struct object.
        /// </summary>
        /// <param name="startIndex">The start index.</param>
        /// <returns></returns>
        ///<code>
        /// EyeNutInputs eyenut = LoadEyeNutData(4);
        ///</code>
        public EyeNutInputs LoadEyeNutData(int startIndex)
        {
            EyeNutInputs eyeNut = new EyeNutInputs();
            int endIndex;
            try
            {
                eyeNut.InnerWidth1 = GetDoubleInputValue(startIndex);
                eyeNut.InnerWidth2 = GetDoubleInputValue(++startIndex);
                if (eyeNut.InnerWidth2 < 0)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInnerWidth2Argument, "InnerWidth2 should not be less than zero");
                }
                eyeNut.InnerLength1 = GetDoubleInputValue(++startIndex);
                eyeNut.InnerLength2 = GetDoubleInputValue(++startIndex);
                if (eyeNut.InnerLength2 <= 0)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInnerLength2Argument, "InnerLength2 should not be less than zero or zero");
                }
                eyeNut.Thickness1 = GetDoubleInputValue(++startIndex);
                if (eyeNut.Thickness1 <= 0)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidThickness1NLTZero, "Thickness1 value should not be less than zero");
                }
                eyeNut.OverLength1 = GetDoubleInputValue(++startIndex);
                eyeNut.Nut = LoadNutData(++startIndex, out endIndex);
                startIndex = endIndex;
            }
            catch (SmartPartSymbolException hgrEx)
            {
                throw hgrEx;
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadEyeNutData, "Error in loading EyeNut data");
            }
            return eyeNut;
        }

        /// <summary>
        /// Create the graphical representation of a EyeNut
        /// </summary>        
        /// <param name="eyeNut">Structure for specifying the inputs for the EyeNut -EyeNutInputs.</param>
        /// <param name="outputs">Collection of declared outputs, which is indexed by the name of the outputs declared as defining SymbolOutputs on the AspectDefinition field- OutputDictionary.</param>
        /// <param name="outputName">OutputName that this graphic is being placed on-String.</param>
        /// <param name="objectColl">ArrayList that Gives ObjectCollection out</param>
        ///<code>
        ///        ArrayList objColl;
        ///            AddEyeNut(eyeNut, outputs, outputName + "EyeNut",out objColl);
        ///            tempMatrix.SetIdentity();
        ///            tempMatrix.Rotate(Math.PI, new Vector(0, 1, 0), new Position(0, 0, 0));
        ///            foreach (string item in objColl)
        ///            {
        ///                geometry3d = (Geometry3d)outputs[item];
        ///                geometry3d.Transform(tempMatrix);
        ///            }
        ///</code>
        public void AddEyeNut(EyeNutInputs eyeNut, OutputDictionary outputs, String outputName, out ArrayList objectColl)
        {
            objectColl = new ArrayList();
            try
            {
                int objectCount = 0;
                Matrix4X4 nutMatrix = new Matrix4X4();
                nutMatrix.Origin = new Position(0, 0, eyeNut.OverLength1);
                AddNut(eyeNut.Nut, nutMatrix, outputs, outputName + "Nut1");
                ++objectCount;
                objectColl.Add(outputName + "Nut1");
                Collection<ICurve> curveCollection = new Collection<ICurve>();

                Circle3d circle = new Circle3d(new Position(-(eyeNut.InnerWidth1 / 2 + eyeNut.Thickness1 / 2), 0, eyeNut.OverLength1), new Vector(0, 0, 1), eyeNut.Thickness1 / 2);
                ++objectCount;
                outputs.Add(outputName + "TOP_CYL_1", circle);
                objectColl.Add(outputName + "TOP_CYL_1");


                Line3d line1 = new Line3d(new Position(-(eyeNut.InnerWidth1 / 2 + eyeNut.Thickness1 / 2), 0, eyeNut.OverLength1), new Position(-(eyeNut.InnerWidth2 / 2 + eyeNut.Thickness1 / 2), 0, eyeNut.OverLength1 - eyeNut.InnerLength1));
                curveCollection.Add(line1);
                ++objectCount;
                outputs.Add(outputName + "TOP_CYL_2", line1);
                objectColl.Add(outputName + "TOP_CYL_2");

                EllipticalArc3d ellipticalArc = new EllipticalArc3d(new Position(0, 0, -(eyeNut.InnerLength1 - eyeNut.OverLength1)), new Vector(0, -1, 0), new Vector(-(eyeNut.InnerWidth2 / 2 + eyeNut.Thickness1 / 2), 0, 0), ((eyeNut.InnerLength2 - eyeNut.InnerLength1 + eyeNut.Thickness1 / 2) / (eyeNut.InnerWidth2 / 2 + eyeNut.Thickness1 / 2)), 0, -Math.PI);
                curveCollection.Add(ellipticalArc);
                ++objectCount;
                outputs.Add(outputName + "BOT_CYL_1", ellipticalArc);
                objectColl.Add(outputName + "BOT_CYL_1");

                Line3d line2 = new Line3d(new Position((eyeNut.InnerWidth1 / 2 + eyeNut.Thickness1 / 2), 0, eyeNut.OverLength1), new Position((eyeNut.InnerWidth2 / 2 + eyeNut.Thickness1 / 2), 0, eyeNut.OverLength1 - eyeNut.InnerLength1));
                curveCollection.Add(line2);
                ++objectCount;
                outputs.Add(outputName + "BOT_CYL_2", line2);
                objectColl.Add(outputName + "BOT_CYL_2");

                ComplexString3d lineString = new ComplexString3d(curveCollection);

                Position stNorm = null;
                Position enNorm = new Position(eyeNut.InnerWidth1 / 2 + eyeNut.Thickness1 / 2, 0, eyeNut.OverLength1);
                Vector stNormVector = null;
                Vector enNormVector = new Vector(0, 0, 1);
                Collection<Surface3d> eyeNutSurfaces = new Collection<Surface3d>();

                eyeNutSurfaces = Surface3d.GetSweepSurfacesFromCurve(lineString, circle, (SurfaceSweepOptions)2, stNorm, stNormVector, enNorm, enNormVector);
                foreach (Surface3d item in eyeNutSurfaces)
                {
                    ++objectCount;
                    outputs.Add("EyeNut" + objectCount, item);
                    objectColl.Add("EyeNut" + objectCount);
                }
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddEyeNutMethod, "Error in AddEyeNut");
                }
            }
        }

        /// <summary>
        /// Defines the YokeClamp input parameter type.
        /// </summary>
        public struct YokeClampInputs
        {
            /// <summary>
            /// ShapeType The graphic shape to use for the nut or washer. Codelist hsShapeType 1 – Round,2 - Square, 3 - Hex.
            /// </summary>
            public double Diameter1;
            /// <summary>
            /// The outside dimension of the nut or washer.
            /// </summary>
            public int PinOrLug;
            /// <summary>
            /// The “other” outside dimension of the nut or washer.If zero, negative, or undefined, this attribute is ignored. Also ignored for Hex shape.   
            /// </summary>
            public int Orientation;
            /// <summary>
            ///The length of the nut or washer.
            /// </summary>
            public double RodTakeOut;
            /// <summary>
            /// The “other” outside dimension of the nut or washer.If zero, negative, or undefined, this attribute is ignored. Also ignored for Hex shape.   
            /// </summary>
            public double Height3;
            /// <summary>
            ///The length of the nut or washer.
            /// </summary>
            public double Height4;
            /// <summary>
            /// ShapeType The graphic shape to use for the nut or washer. Codelist hsShapeType 1 – Round,2 - Square, 3 - Hex.
            /// </summary>
            public double Height5;
            /// <summary>
            /// The outside dimension of the nut or washer.
            /// </summary>
            public double Height6;
            /// <summary>
            /// The “other” outside dimension of the nut or washer.If zero, negative, or undefined, this attribute is ignored. Also ignored for Hex shape.   
            /// </summary>
            public double Length3;
            /// <summary>
            ///The length of the nut or washer.
            /// </summary>
            public double Length4;
            /// <summary>
            /// The “other” outside dimension of the nut or washer.If zero, negative, or undefined, this attribute is ignored. Also ignored for Hex shape.   
            /// </summary>
            public double Length5;
            /// <summary>
            ///The length of the nut or washer.
            /// </summary>
            public double Length6;
            /// <summary>
            /// ShapeType The graphic shape to use for the nut or washer. Codelist hsShapeType 1 – Round,2 - Square, 3 - Hex.
            /// </summary>
            public double Length7;
            /// <summary>
            /// The outside dimension of the nut or washer.
            /// </summary>
            public double Width3;
            /// <summary>
            /// The “other” outside dimension of the nut or washer.If zero, negative, or undefined, this attribute is ignored. Also ignored for Hex shape.   
            /// </summary>
            public double Width4;
            /// <summary>
            ///The length of the nut or washer.
            /// </summary>
            public double Pin1Diameter;
            /// <summary>
            /// The “other” outside dimension of the nut or washer.If zero, negative, or undefined, this attribute is ignored. Also ignored for Hex shape.   
            /// </summary>
            public double Pin1Length;
            /// <summary>
            ///The length of the nut or washer.
            /// </summary>
            public double Gap1;
            /// <summary>
            /// ShapeType The graphic shape to use for the nut or washer. Codelist hsShapeType 1 – Round,2 - Square, 3 - Hex.
            /// </summary>
            public double Height1;
            /// <summary>
            /// The outside dimension of the nut or washer.
            /// </summary>
            public double Width1;
            /// <summary>
            /// The “other” outside dimension of the nut or washer.If zero, negative, or undefined, this attribute is ignored. Also ignored for Hex shape.   
            /// </summary>
            public double Length1;
            /// <summary>
            ///The length of the nut or washer.
            /// </summary>
            public double Height2;
            /// <summary>
            /// The “other” outside dimension of the nut or washer.If zero, negative, or undefined, this attribute is ignored. Also ignored for Hex shape.   
            /// </summary>
            public double Width2;
            /// <summary>
            ///The length of the nut or washer.
            /// </summary>
            public double Length2;
            /// <summary>
            /// ShapeType The graphic shape to use for the nut or washer. Codelist hsShapeType 1 – Round,2 - Square, 3 - Hex.
            /// </summary>
            public double Multi1Qty;
            /// <summary>
            /// The outside dimension of the nut or washer.
            /// </summary>
            public double Multi1LocateBy;
            /// <summary>
            /// The “other” outside dimension of the nut or washer.If zero, negative, or undefined, this attribute is ignored. Also ignored for Hex shape.   
            /// </summary>
            public double Multi1Location;
            /// <summary>
            ///The length of the nut or washer.
            /// </summary>
            public double Multi2Qty;
            /// <summary>
            /// The “other” outside dimension of the nut or washer.If zero, negative, or undefined, this attribute is ignored. Also ignored for Hex shape.   
            /// </summary>
            public double Multi2LocateBy;
            /// <summary>
            ///The length of the nut or washer.
            /// </summary>
            public double Multi2Location;
            /// <summary>
            ///The UBolt input parameter type.
            /// </summary
            public UBoltInputs UBolt;
            /// <summary>
            ///The Nut input parameter type.
            /// </summary>
            public NutInputs Nut1;
            /// <summary>
            ///The Nut input parameter type.
            /// </summary>
            public NutInputs Nut2;
            /// <summary>
            ///The Nut input parameter type.
            /// </summary>
            public NutInputs Nut3;
            /// <summary>
            ///The Nut input parameter type.
            /// </summary>
            public NutInputs Nut4;
            /// <summary>
            ///The Strap input parameter type.
            /// </summary>
            public StrapInputs Strap;
            /// <summary>
            ///The Strap input parameter type.
            /// </summary>
            public double Height7;
            /// <summary>
            ///The Strap input parameter type.
            /// </summary>
            public double TopBlockWidth;
        }
        /// <summary>
        /// Defines the UBoltInputs input parameter type.
        /// </summary>
        public struct UBoltInputs
        {
            /// <summary>
            /// Inside distance between two end nuts. Can be zero.
            /// </summary>
            public double UBoltWidth;
            /// <summary>
            /// The thickness of the end nut shapes. Both ends are the same size.If zero, the end nut shapes are not displayed.
            /// </summary>
            public double UBoltCenterToEnd;
            /// <summary>
            /// Width of the side blocks. If zero, the blocks will not be displayed.
            /// </summary>
            public double UBoltRodDia;
            /// <summary>
            ///Length of the side blocks. If zero, the blocks will not be displayed.
            /// </summary>
            public double UBoltDia2;
            /// <summary>
            ///Opening between the two size blocks. Ignored if the block is not displayed.
            /// </summary>
            public double UBoltDia2Start;
            /// <summary>
            ///Diameter of optional round center tube. If zero, the center tube is not displayed.
            ///The tube is the same length as Opening1, and fits between the two end nut shapes.
            ///Generally used without side blocks but can both be used at the same time.
            /// </summary>
            public double UBoltFlatSpot;
            /// <summary>
            ///Opening between the two size blocks. Ignored if the block is not displayed.
            /// </summary>
            public double UBoltTopGap;
            /// <summary>
            ///Opening between the two size blocks. Ignored if the block is not displayed.
            /// </summary>
            public int UBoltOneSided;
        }
        /// <summary>
        /// This property adds inputs for YokeClamp.User symbol calls this property AdditionalInputs
        /// to define additional inputs. The list of inputs returned by this method will be the inputs for the user symbol in addition
        /// to the inputs that are already defined as member variables.
        /// </summary>
        ///<code>
        /// public override IEnumerable<Input> AdditionalInputs
        /// {
        ///     get
        ///     {
        ///      int endIndex;
        ///      List<Input> additionalInputs = new List<Input>();
        ///      AddYokeClampInputs(2, out endIndex, additionalInputs);
        ///      return additionalInputs;
        ///     }
        /// }
        ///</code>
        public void AddYokeClampInputs(int startIndex, out int endIndex, List<Input> additionalInputs)
        {
            try
            {
                additionalInputs.Add((Input)new InputDouble(startIndex, "Diameter1", "Diameter1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "PinOrLug", "PinOrLug", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Orientation", "Orientation", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "RodTakeOut", "RodTakeOut", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Height3", "Height3", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Height4", "Height4", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Height5", "Height5", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Height6", "Height6", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Length3", "Length3", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Length4", "Length4", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Length5", "Length5", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Length6", "Length6", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Length7", "Length7", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Width3", "Width3", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Width4", "Width4", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Pin1Diameter", "Pin1Diameter", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Pin1Length", "Pin1Length", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Gap1", "Gap1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Height1", "Height1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Width1", "Width1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Length1", "Length1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Height2", "Height2", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Width2", "Width2", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Length2", "Length2", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Multi1Qty", "Multi1Qty", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Multi1LocateBy", "Multi1LocateBy", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Multi1Location", "Multi1Location", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Multi2Qty", "Multi2Qty", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Multi2LocateBy", "Multi2LocateBy", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Multi2Location", "Multi2Location", 0, false));

                AddUBoltInputs(++startIndex, out endIndex, additionalInputs);
                startIndex = endIndex;

                AddNutInputs(startIndex, 4, out endIndex, additionalInputs);
                startIndex = endIndex;

                AddStrapInputs(++startIndex, out endIndex, additionalInputs);
                startIndex = endIndex;

                additionalInputs.Add((Input)new InputDouble(++startIndex, "Height7", "Height7", 0, true));

            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrYokeClampAdditionalInputs, "Error in adding YokeClamp Inputs");
            }
            endIndex = startIndex;
        }
        /// <summary>
        /// Adds the YokeClamp outputs.User symbol calls this method during AdditionalOutputs
        /// to define additional outputs for an aspect. The list of outputs returned by this method will be the outputs for the aspect
        /// in addition to the outputs that are already defined as attributes on the aspect.
        /// </summary>
        /// <param name="additionalOutputs">The additional outputs.</param>
        ///<code>
        ///public override IEnumerable<OutputDefinition> AdditionalOutputs(string aspectName)
        ///{
        ///    List<OutputDefinition> additionalOutputs = new List<OutputDefinition>();
        ///    if (aspectName == "Symbolic")
        ///    {
        ///        AddYokeClampOutputs(additionalOutputs);
        ///    }
        ///    return additionalOutputs;
        ///}
        ///</code>
        public void AddYokeClampOutputs(List<OutputDefinition> additionalOutputs)
        {
            try
            {
                additionalOutputs.Add(new OutputDefinition("YokeClamp" + "TopShp", "YokeClamp" + "TopShp"));
                additionalOutputs.Add(new OutputDefinition("YokeClamp" + "PinBoxLeft", "YokeClamp" + "PinBoxLeft"));
                additionalOutputs.Add(new OutputDefinition("YokeClamp" + "PinBoxRight", "YokeClamp" + "PinBoxRight"));
                additionalOutputs.Add(new OutputDefinition("YokeClamp" + "PinCylinder", "YokeClamp" + "PinCylinder"));
                additionalOutputs.Add(new OutputDefinition("YokeClamp" + "Blocks", "YokeClamp" + "Blocks"));
                for (int i = 1; i <= 4; i++)
                {
                    additionalOutputs.Add(new OutputDefinition("YokeClamp" + "Nut" + i, "YokeClamp" + "Nut" + i));
                }
                for (int j = 1; j <= 10; j++)
                {
                    additionalOutputs.Add(new OutputDefinition("YokeClamp" + "UBolt" + j + "StraightDia1Left", "YokeClamp" + "UBolt" + j + "StraightDia1Left"));
                    additionalOutputs.Add(new OutputDefinition("YokeClamp" + "UBolt" + j + "StraightDia1Right", "YokeClamp" + "UBolt" + j + "StraightDia1Right"));
                    additionalOutputs.Add(new OutputDefinition("YokeClamp" + "UBolt" + j + "StraightDia2Left", "YokeClamp" + "UBolt" + j + "StraightDia2Left"));
                    additionalOutputs.Add(new OutputDefinition("YokeClamp" + "UBolt" + j + "StraightDia2Right", "YokeClamp" + "UBolt" + j + "StraightDia2Right"));
                    additionalOutputs.Add(new OutputDefinition("YokeClamp" + "UBolt" + j + "Elbow", "YokeClamp" + "UBolt" + j + "Elbow"));
                    additionalOutputs.Add(new OutputDefinition("YokeClamp" + "UBolt" + j + "FlatElbowLeft", "YokeClamp" + "UBolt" + j + "FlatElbowLeft"));
                    additionalOutputs.Add(new OutputDefinition("YokeClamp" + "UBolt" + j + "FlatElbowRight", "YokeClamp" + "UBolt" + j + "FlatElbowRight"));
                    additionalOutputs.Add(new OutputDefinition("YokeClamp" + "UBolt" + j + "FlatSpot", "YokeClamp" + "UBolt" + j + "FlatSpot"));
                }
                for (int k = 0; k <= 10; k++)
                {
                    additionalOutputs.Add(new OutputDefinition("YokeClamp" + "Strap" + k, "YokeClamp" + "Strap" + k));
                    additionalOutputs.Add(new OutputDefinition("YokeClamp" + "Strap" + k + "Left", "YokeClamp" + "Strap" + k + "Left"));
                }
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddYokeClampOutputs, "Error in adding YokeClamp outputs");
                }
            }
        }
        /// <summary>
        /// Defines the inputs for the DummyLeg 
        /// </summary>
        public struct DummyLegInputs
        {
            /// <summary>
            /// Attribute used to specify which Dummy Leg/ stanchion shape to use.  
            /// </summary>
            public string botShape;
            /// <summary>
            /// Attribute used to specify which Dummy Leg/ stanchion shape to use.  
            /// </summary>
            public string topShape;
            /// <summary>
            /// The total height of the dummy leg, from the pipe centerline to the bottom of the stanchion, including all plates.
            /// </summary>
            public double length;
            /// <summary>
            /// The distance between the bottom of the pipe and the top of the stanchion 
            /// </summary>
            public double stanGap;
            /// <summary>
            /// The diameter of the pipe
            /// </summary>
            public double diameter1;
            /// <summary>
            /// The offset from the Centerline of the pipe to the centerline of the dummy leg.
            /// </summary>
            public double offset1;
            /// <summary>
            /// Attribute that allows user to specify the amount the 2 shapes overlap each other
            /// </summary>
            public double offset2;
            /// <summary>
            /// The Radius of the elbow.
            /// </summary>
            public double elbowRadius;
            /// <summary>
            ///This distance between the Face of the elbow to the Center.
            /// </summary>
            public double faceToCenter;
            /// <summary>
            /// Is the part a stanchion rather than a dummy leg.
            /// </summary>
            public int isStanchion;
            /// <summary>
            /// Attribute used to specify which reinforcing pad shape to use
            /// </summary>
            public string repadShape;
            /// <summary>
            ///  defines the length from the Port location to the base of the TopDummy.
            /// </summary>
            public double minLen;
            /// <summary>
            ///  defines the length from the Port location to the base of the BotDummy.
            /// </summary>
            public double maxLen;
        }
        /// <summary>
        /// This property adds inputs for Nut.User symbol calls this property AdditionalInputs
        /// to define additional inputs. The list of inputs returned by this method will be the inputs for the user symbol in addition
        /// to the inputs that are already defined as member variables.
        /// </summary>
        ///<code>
        ///startIndex=endIndex;
        /// //Example: Getting endIndex from previous Input Method and sending that as startIndex in this Method.
        /// //Example: Here 4 is the Number of Nuts needed.
        ///AddNutInputs(startIndex, 4, out endIndex, additionalInputs);
        ///</code>
        public void AddNutInputs(int startIndex, int numberOfNuts, out int endIndex, List<Input> additionalInputs)
        {
            try
            {
                for (int i = 1; i <= numberOfNuts; i++)
                {
                    ++startIndex;
                    additionalInputs.Add((Input)new InputDouble(startIndex, "Shape" + i + "Type", "Shape" + i + "Type", 1, false));
                    additionalInputs.Add((Input)new InputDouble(++startIndex, "Shape" + i + "Width1", "Shape" + i + "Width1", 0, false));
                    additionalInputs.Add((Input)new InputDouble(++startIndex, "Shape" + i + "Width2", "Shape" + i + "Width2", 0, false));
                    additionalInputs.Add((Input)new InputDouble(++startIndex, "Shape" + i + "Length", "Shape" + i + "Length", 0, false));
                }
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrNutAdditionalInputs, "Error in adding Nut inputs");
            }
            endIndex = startIndex;
        }
        /// <summary>
        /// Adds the nut outputs.User symbol calls this method during AdditionalOutputs
        /// to define additional outputs for an aspect. The list of outputs returned by this method will be the outputs for the aspect
        /// in addition to the outputs that are already defined as attributes on the aspect.
        /// </summary>
        /// <param name="additionalOutputs">The additional outputs.</param>
        /// <param name="numberOfNuts">Here will get the Number of Nuts Used.</param>
        ///<code>
        ///public override IEnumerable<OutputDefinition> AdditionalOutputs(string aspectName)
        ///{
        ///    List<OutputDefinition> additionalOutputs = new List<OutputDefinition>();
        ///    if (aspectName == "Symbolic")
        ///    {
        ///        AddNutOutputs(4,additionalOutputs);
        ///    }
        ///    return additionalOutputs;
        ///}
        ///</code> 
        public void AddNutOutputs(int numberOfNuts, List<OutputDefinition> additionalOutputs)
        {
            try
            {
                for (int i = 1; i <= numberOfNuts; i++)
                {
                    additionalOutputs.Add(new OutputDefinition("Nut" + i, "Nut" + i));
                }
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrNutAdditionalOutputs, "Error in AddNutOutputs.");
            }
        }
        /// <summary>
        /// This property adds inputs for UBolt.User symbol calls this property AdditionalInputs
        /// to define additional inputs. The list of inputs returned by this method will be the inputs for the user symbol in addition
        /// to the inputs that are already defined as member variables.
        /// </summary>
        ///<code>
        /// public override IEnumerable<Input> AdditionalInputs
        /// {
        ///     get
        ///     {
        ///      int endIndex;
        ///      List<Input> additionalInputs = new List<Input>();
        ///      //Example , I have added the UBolts with staring index 2.
        ///      AddUBoltInputs(2, out endIndex, additionalInputs);
        ///      return additionalInputs;
        ///     }
        /// }
        ///</code>
        public void AddUBoltInputs(int startIndex, out int endIndex, List<Input> additionalInputs)
        {
            try
            {
                additionalInputs.Add((Input)new InputDouble(startIndex, "UBoltWidth", "UBoltWidth", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "UBoltCenterToEnd", "UBoltCenterToEnd", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "UBoltRodDia", "UBoltRodDia", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "UBoltDia2", "UBoltDia2", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "UBoltDia2Start", "UBoltDia2Start", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "UBoltFlatSpot", "UBoltFlatSpot", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "UBoltTopGap", "UBoltTopGap", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "UBoltOneSided", "UBoltOneSided", 0, false));
                //++startIndex;

            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrUBoltAdditionalInputs, "Error in adding UBolt inputs");
            }
            endIndex = startIndex;
        }
        /// <summary>
        /// Adds the Strap inputs.
        /// </summary>
        /// <param name="startIndex">The start index.</param>
        /// <param name="endIndex">The end index.</param>
        /// <param name="additionalInputs">The additional inputs.</param>
        /// <code> AddStrapInputs(2, out endIndex, additionalInputs);</code>
        public void AddStrapInputs(int startIndex, out int endIndex, List<Input> additionalInputs)
        {
            try
            {
                additionalInputs.Add(new InputDouble(startIndex, "StrapWidthInside", "StrapWidthInside", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "StrapHeightInside", "StrapHeightInside", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "StrapThickness", "StrapThickness", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "StrapStockWidth", "StrapStockWidth", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "StrapFlatSpot", "StrapFlatSpot", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "StrapTopGap", "StrapTopGap", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "StrapWidthWings", "StrapWidthWings", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "StrapOneSided", "StrapOneSided", 1, false));
                additionalInputs.Add(new InputDouble(++startIndex, "StrapSplitGap", "StrapSplitGap", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "StrapSplitExtension", "StrapSplitExtension", 0, false));

            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddStrapInputs, "Error in AddStrap");
                }

            }
            endIndex = startIndex;
        }
        /// <summary>
        /// Adds the Strap outputs.
        /// </summary>
        /// <param name="aspectName">Name of the aspect.</param>
        /// <param name="additionalOutputs">The additional outputs.</param>
        /// <code>AddStrapOutputs(additionalOutputs);</code>
        public void AddStrapOutputs(List<OutputDefinition> additionalOutputs)
        {
            try
            {
                additionalOutputs.Add(new OutputDefinition("Strap", "Strap"));
                additionalOutputs.Add(new OutputDefinition("Strap" + "Left", "Strap" + "Left"));
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddStrapOutputs, "Error in adding Strap outputs");
                }

            }
        }
        /// <summary>
        /// This method will be called by user symbol to get value of an input(in this case, YokeClamp input structure)during construction of outputs. 
        /// Given the start index, this method will return the value of the YokeClampInputs struct object.
        /// </summary>
        /// <param name="startIndex">The start index.</param>
        /// <returns></returns>
        ///<code>
        ///YokeClampInput yokeClamp = LoadYokeClampData(2);
        ///</code>
        public YokeClampInputs LoadYokeClampData(int startIndex, Part part = null)
        {
            YokeClampInputs yokeClamp = new YokeClampInputs();
            try
            {
                int endIndex;
                yokeClamp.Diameter1 = GetDoubleInputValue(startIndex);
                yokeClamp.PinOrLug = (int)GetDoubleInputValue(++startIndex);
                yokeClamp.Orientation = (int)GetDoubleInputValue(++startIndex);
                yokeClamp.RodTakeOut = GetDoubleInputValue(++startIndex);
                if (yokeClamp.RodTakeOut <= 0)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidRodTakeOut, "RodTakeOut Should not be less then or equal to Zero");
                }
                yokeClamp.Height3 = GetDoubleInputValue(++startIndex);
                yokeClamp.Height4 = GetDoubleInputValue(++startIndex);
                yokeClamp.Height5 = GetDoubleInputValue(++startIndex);
                yokeClamp.Height6 = GetDoubleInputValue(++startIndex);
                if (yokeClamp.Height6 < 0)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidHeigth6GTZero, "Heigth6 Should not be less then Zero");
                }
                yokeClamp.Length3 = GetDoubleInputValue(++startIndex);
                yokeClamp.Length4 = GetDoubleInputValue(++startIndex);
                if (yokeClamp.Length4 <= 0)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidLength4GTZero, "Length4 Should not be less then or equal to Zero");
                }
                yokeClamp.Length5 = GetDoubleInputValue(++startIndex);
                yokeClamp.Length6 = GetDoubleInputValue(++startIndex);
                yokeClamp.Length7 = GetDoubleInputValue(++startIndex);
                yokeClamp.Width3 = GetDoubleInputValue(++startIndex);
                yokeClamp.Width4 = GetDoubleInputValue(++startIndex);
                if (yokeClamp.Width4 <= 0)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidWidth4GTZero, "Width4 Should not be less then or equal to Zero");
                }
                yokeClamp.Pin1Diameter = GetDoubleInputValue(++startIndex);
                yokeClamp.Pin1Length = GetDoubleInputValue(++startIndex);
                yokeClamp.Gap1 = GetDoubleInputValue(++startIndex);
                yokeClamp.Height1 = GetDoubleInputValue(++startIndex);
                yokeClamp.Width1 = GetDoubleInputValue(++startIndex);
                yokeClamp.Length1 = GetDoubleInputValue(++startIndex);
                yokeClamp.Height2 = GetDoubleInputValue(++startIndex);
                yokeClamp.Width2 = GetDoubleInputValue(++startIndex);
                yokeClamp.Length2 = GetDoubleInputValue(++startIndex);
                yokeClamp.Multi1Qty = GetDoubleInputValue(++startIndex);
                yokeClamp.Multi1LocateBy = GetDoubleInputValue(++startIndex);
                yokeClamp.Multi1Location = GetDoubleInputValue(++startIndex);
                yokeClamp.Multi2Qty = GetDoubleInputValue(++startIndex);
                yokeClamp.Multi2LocateBy = GetDoubleInputValue(++startIndex);
                yokeClamp.Multi2Location = GetDoubleInputValue(++startIndex);

                yokeClamp.UBolt = LoadUBoltData(++startIndex, out endIndex);
                startIndex = endIndex;

                yokeClamp.Nut1 = LoadNutData(++startIndex, out endIndex);
                startIndex = endIndex;

                yokeClamp.Nut2 = LoadNutData(++startIndex, out endIndex);
                startIndex = endIndex;

                yokeClamp.Nut3 = LoadNutData(++startIndex, out endIndex);
                startIndex = endIndex;

                yokeClamp.Nut4 = LoadNutData(++startIndex, out endIndex);
                startIndex = endIndex;

                yokeClamp.Strap = LoadStrapData(++startIndex, out endIndex);
                startIndex = endIndex;

                try
                {
                    if (part.SupportsInterface("IJUAhsHeight7"))
                        yokeClamp.Height7 = GetDoubleInputValue(++startIndex);
                    else
                        ++startIndex;
                }
                catch
                {
                    yokeClamp.Height7 = 0;
                }

            }
            catch (SmartPartSymbolException hgrEx)
            {
                throw hgrEx;
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadYokeClampData, "Error in Loading YokeClamp Data");
            }
            return yokeClamp;
        }
        /// <summary>
        /// This method will be called by user symbol to get value of an input(in this case, Nut input structure)during construction of outputs. 
        /// Given the start index, this method will return the value of the NutInputs struct object.
        /// </summary>
        /// <param name="startIndex">The start index.</param>
        /// <returns></returns>
        ///<code>
        ///yokeClamp.Nut1 = LoadNutData(++startIndex, out endIndex);
        ///startIndex = endIndex;
        ///</code>
        public NutInputs LoadNutData(int startIndex, out int endIndex)
        {
            NutInputs nut = new NutInputs();
            try
            {

                nut.ShapeType = (int)GetDoubleInputValue(startIndex);
                if (nut.ShapeType == -1)
                    nut.ShapeType = 0;
                if (nut.ShapeType < 0 || nut.ShapeType > 3)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrShapeTypeCodeListValue, "ShapeType code list value should be between 0 and 3");
                }
                nut.ShapeWidth1 = GetDoubleInputValue(++startIndex);
                nut.ShapeWidth2 = GetDoubleInputValue(++startIndex);
                nut.ShapeLength = GetDoubleInputValue(++startIndex);
            }
            catch (SmartPartSymbolException hgrEx)
            {
                throw hgrEx;
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadNutData, "Error in loading Nut data");
            }
            endIndex = startIndex;
            return nut;

        }
        /// <summary>
        /// This method will be called by user symbol to get value of an input(in this case, UBolt input structure)during construction of outputs. 
        /// Given the start index, this method will return the value of the NutInputs struct object.
        /// </summary>
        /// <param name="startIndex">The start index.</param>
        /// <returns></returns>
        ///<code>
        ///yokeClamp.UBolt = LoadUBoltData(++startIndex, out endIndex);
        ///startIndex = endIndex;
        ///</code>
        public UBoltInputs LoadUBoltData(int startIndex, out int endIndex)
        {
            UBoltInputs uBolt = new UBoltInputs();
            try
            {
                uBolt.UBoltWidth = GetDoubleInputValue(startIndex);
                uBolt.UBoltCenterToEnd = GetDoubleInputValue(++startIndex);
                uBolt.UBoltRodDia = GetDoubleInputValue(++startIndex);
                uBolt.UBoltDia2 = GetDoubleInputValue(++startIndex);
                uBolt.UBoltDia2Start = GetDoubleInputValue(++startIndex);
                uBolt.UBoltFlatSpot = GetDoubleInputValue(++startIndex);
                uBolt.UBoltTopGap = GetDoubleInputValue(++startIndex);
                uBolt.UBoltOneSided = (int)GetDoubleInputValue(++startIndex);
                if (uBolt.UBoltOneSided < 1 || uBolt.UBoltOneSided > 2)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrUBoltUBoltOneSidedCodeListValue, "UBoltOneSided code list value should be 1 or 2");
                }
            }
            catch (SmartPartSymbolException hgrEx)
            {
                throw hgrEx;
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadUBoltData, "Error in loading UBolt data");
            }
            endIndex = startIndex;
            return uBolt;
        }
        /// <summary>
        /// Loads the Strap data.
        /// </summary>
        /// <param name="startIndex">The start index.</param>
        ///<code>StrapInputs strap = LoadStrapData(2);</code>
        public StrapInputs LoadStrapData(int startIndex)
        {
            StrapInputs strap = new StrapInputs();
            try
            {
                strap.StrapWidthInside = GetDoubleInputValue(startIndex);
                strap.StrapHeightInside = GetDoubleInputValue(++startIndex);
                strap.StrapThickness = GetDoubleInputValue(++startIndex);
                strap.StrapStockWidth = GetDoubleInputValue(++startIndex);
                strap.StrapFlatSpot = GetDoubleInputValue(++startIndex);
                strap.StrapTopGap = GetDoubleInputValue(++startIndex);
                strap.StrapWidthWings = GetDoubleInputValue(++startIndex);
                strap.StrapOneSided = (int)GetDoubleInputValue(++startIndex);
                strap.StrapSplitGap = GetDoubleInputValue(++startIndex);
                strap.StrapSplitExtension = GetDoubleInputValue(++startIndex);

            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadStrapData, "Error in LoadStrapData");
                }
            }
            return strap;
        }
        /// <summary>
        /// This method will be called by user symbol to get value of an input(in this case, EyeNut input structure)during construction of outputs. 
        /// Given the start index, this method will return the value of the NutInputs struct object.
        /// </summary>
        /// <param name="startIndex">The start index.</param>
        /// <returns></returns>
        ///<code>
        ///yokeClamp.Strap = LoadStrapData(++startIndex, out endIndex);
        ///startIndex = endIndex;
        ///</code>
        public StrapInputs LoadStrapData(int startIndex, out int endIndex)
        {
            StrapInputs strap = new StrapInputs();
            try
            {

                strap.StrapWidthInside = GetDoubleInputValue(startIndex);
                strap.StrapHeightInside = GetDoubleInputValue(++startIndex);
                strap.StrapThickness = GetDoubleInputValue(++startIndex);
                strap.StrapStockWidth = GetDoubleInputValue(++startIndex);
                strap.StrapFlatSpot = GetDoubleInputValue(++startIndex);
                strap.StrapTopGap = GetDoubleInputValue(++startIndex);
                strap.StrapWidthWings = GetDoubleInputValue(++startIndex);
                strap.StrapOneSided = (int)GetDoubleInputValue(++startIndex);
                strap.StrapSplitGap = GetDoubleInputValue(++startIndex);
                strap.StrapSplitExtension = GetDoubleInputValue(++startIndex);
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadStrapData, "Error in LoadStrapData");
                }
            }
            endIndex = startIndex;
            return strap;
        }
        /// <summary>
        /// Adds the YokeClamp.
        /// </summary>
        /// <param name="yokeClamp">My YokeClamp shape.</param>
        /// <param name="matrix">The matrix.</param>
        /// <param name="outputs">The outputs.</param>
        /// <param name="outputName">Name of the output.</param>
        /// <code>
        ///   Matrix4X4 yokeClampMatrix = new Matrix4X4();
        ///     yokeClampMatrix.Origin = new Position(0, 0, 0);
        ///      AddYokeClamp(yokeClamp, yokeClampMatrix, m_PhysicalAspect.Outputs, "YokeClamp");
        /// </code>
        public void AddYokeClamp(YokeClampInputs yokeClamp, Matrix4X4 matrix, OutputDictionary outputs, String outputName)
        {
            try
            {

                int objectCount = 0;
                String[] objectColl = new String[objectCount];
                StringBuilder error = new StringBuilder();
                SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();
                symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(1, 0, 0));
                //Initialisations
                if (yokeClamp.Diameter1 < 0)
                    error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrDiameterGTZero, "Enter Positive value for Diameter1"));

                //Check the value TakeOut
                if (yokeClamp.RodTakeOut <= (0.5 * yokeClamp.Diameter1 + 0.5 * yokeClamp.Pin1Diameter))
                    error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrRodTakeOut, "Rod Takeout Should greater than half of the Diamter1 plus half of the Pin1 Diameter"));

                //Check the value Pin1Diameter
                if (yokeClamp.Pin1Diameter < 0)
                    error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrPin1DiameterGTZero, "Enter Positive value for Pin1 Diameter"));

                //Check the value Height3
                if (yokeClamp.Height3 < 0)
                    yokeClamp.Height3 = 0.25 * yokeClamp.Diameter1;

                //Check the value Height4
                if (yokeClamp.Height4 <= yokeClamp.Height3)
                    yokeClamp.Height4 = yokeClamp.Height3 + 2 * yokeClamp.Pin1Diameter;

                //Check the value Height5
                if (yokeClamp.Height5 <= 0.5 * yokeClamp.Diameter1)
                    yokeClamp.Height5 = 0.5 * yokeClamp.Diameter1 + yokeClamp.Height4 - yokeClamp.Height3;

                //Check the value Height6
                if (yokeClamp.Height6 <= 0.5 * yokeClamp.Pin1Diameter)
                    yokeClamp.Height6 = 1.5 * yokeClamp.Pin1Diameter;

                //Check the value Height7
                if (yokeClamp.Height7 > 0)
                {
                    if (yokeClamp.Height7 <= 0.5 * yokeClamp.Diameter1)
                        yokeClamp.Height7 = 0.5 * yokeClamp.Diameter1;
                }
                //Check the value Length3
                if (yokeClamp.Length3 <= yokeClamp.UBolt.UBoltWidth + yokeClamp.UBolt.UBoltRodDia)
                    yokeClamp.Length3 = yokeClamp.UBolt.UBoltWidth + 2 * yokeClamp.UBolt.UBoltDia2;

                //Check the value Width3
                if (yokeClamp.Width3 < yokeClamp.Pin1Diameter)
                    yokeClamp.Width3 = 2 * yokeClamp.Pin1Diameter;

                //Check the value Width4
                if (yokeClamp.Width4 < yokeClamp.Pin1Diameter)
                    yokeClamp.Width4 = yokeClamp.Width3;


                //Check the value Length4
                if (yokeClamp.PinOrLug == 1)
                {
                    if (yokeClamp.Length4 <= 0)
                        yokeClamp.Length4 = 1.5*yokeClamp.Pin1Diameter;
                }
                else if (yokeClamp.PinOrLug == 2)
                {
                    if (yokeClamp.Length4 <= 0)
                        yokeClamp.Length4 = 0.5*yokeClamp.Pin1Diameter;

                    if (yokeClamp.Length4 > yokeClamp.Width3)
                        yokeClamp.Length4 = yokeClamp.Width3;
                }

                //Check the value Length5
                if (yokeClamp.PinOrLug == 1)
                    if ((yokeClamp.Length5 <= 0) || (yokeClamp.Length5 >= yokeClamp.Length4))
                        yokeClamp.Length5 = yokeClamp.Pin1Diameter;
                //Check the value Length7
                if (yokeClamp.Length7 < yokeClamp.Length5)
                    yokeClamp.Length7 = yokeClamp.Length5;

                if (yokeClamp.Length7 > yokeClamp.Length3)
                    yokeClamp.Length7 = yokeClamp.Length3;

                //Check the value Length6
                if (HgrCompareDoubleService.cmpdbl(yokeClamp.Length6, 0) == true || (yokeClamp.Length6 > yokeClamp.Length3))
                    yokeClamp.Length6 = yokeClamp.Length3;

                if ((HgrCompareDoubleService.cmpdbl(yokeClamp.Length6, 0) == false) && (yokeClamp.Length6 < yokeClamp.Length7))
                    yokeClamp.Length6 = yokeClamp.Length7;

                //Check the value Pin1 Length
                if (yokeClamp.PinOrLug == 2)
                    yokeClamp.Pin1Length = yokeClamp.Length4;
                else
                    if (yokeClamp.Pin1Length < yokeClamp.Length4)
                        yokeClamp.Pin1Length = yokeClamp.Length4 + yokeClamp.Pin1Diameter;

                //Check the value UBoltRodDia
                if (yokeClamp.UBolt.UBoltRodDia < 0)
                    yokeClamp.UBolt.UBoltRodDia = yokeClamp.Pin1Diameter;

                //Check the value UboltWidth
                if (yokeClamp.UBolt.UBoltWidth < yokeClamp.Diameter1 + yokeClamp.UBolt.UBoltRodDia)
                    yokeClamp.UBolt.UBoltWidth = yokeClamp.Diameter1 + yokeClamp.UBolt.UBoltRodDia;

                if (yokeClamp.UBolt.UBoltWidth > yokeClamp.Length3 - yokeClamp.UBolt.UBoltRodDia)
                    yokeClamp.UBolt.UBoltWidth = yokeClamp.Length3 - yokeClamp.UBolt.UBoltRodDia;

                //Check the value UBoltCenterToEnd
                if (yokeClamp.UBolt.UBoltCenterToEnd < yokeClamp.Height4)
                    yokeClamp.UBolt.UBoltCenterToEnd = yokeClamp.Height4;

                //Top Detail
                if ((HgrCompareDoubleService.cmpdbl(yokeClamp.Length6, yokeClamp.Length3) == false) && (HgrCompareDoubleService.cmpdbl(yokeClamp.Length6, yokeClamp.Length7) == false))
                {
                    Collection<Position> pointCollection = new Collection<Position>();

                    pointCollection.Add(new Position(-yokeClamp.Width3 / 2, -yokeClamp.Length7 / 2, yokeClamp.Height5));
                    pointCollection.Add(new Position(-yokeClamp.Width3 / 2, -yokeClamp.Length6 / 2, yokeClamp.Height4));
                    pointCollection.Add(new Position(-yokeClamp.Width3 / 2, -yokeClamp.Length3 / 2, yokeClamp.Height4));
                    pointCollection.Add(new Position(-yokeClamp.Width3 / 2, -yokeClamp.Length3 / 2, yokeClamp.Height3));
                    pointCollection.Add(new Position(-yokeClamp.Width3 / 2, -yokeClamp.Length6 / 2, yokeClamp.Height3));

                    if (yokeClamp.Height7 > 0)
                    {
                        pointCollection.Add(new Position(-yokeClamp.Width3 / 2, -yokeClamp.Length7 / 2, yokeClamp.Height7));
                        pointCollection.Add(new Position(-yokeClamp.Width3 / 2, yokeClamp.Length7 / 2, yokeClamp.Height7));
                    }
                    else
                    {
                        pointCollection.Add(new Position(-yokeClamp.Width3 / 2, -yokeClamp.Length7 / 2, yokeClamp.Height5 - (yokeClamp.Height4 - yokeClamp.Height3)));
                        pointCollection.Add(new Position(-yokeClamp.Width3 / 2, yokeClamp.Length7 / 2, yokeClamp.Height5 - (yokeClamp.Height4 - yokeClamp.Height3)));
                    }

                    pointCollection.Add(new Position(-yokeClamp.Width3 / 2, yokeClamp.Length6 / 2, yokeClamp.Height3));
                    pointCollection.Add(new Position(-yokeClamp.Width3 / 2, yokeClamp.Length3 / 2, yokeClamp.Height3));
                    pointCollection.Add(new Position(-yokeClamp.Width3 / 2, yokeClamp.Length3 / 2, yokeClamp.Height4));
                    pointCollection.Add(new Position(-yokeClamp.Width3 / 2, yokeClamp.Length6 / 2, yokeClamp.Height4));
                    pointCollection.Add(new Position(-yokeClamp.Width3 / 2, yokeClamp.Length7 / 2, yokeClamp.Height5));
                    pointCollection.Add(new Position(-yokeClamp.Width3 / 2, -yokeClamp.Length7 / 2, yokeClamp.Height5));

                    Collection<ICurve> curveCollection = new Collection<ICurve>();
                    curveCollection.Add(new LineString3d(pointCollection));

                    Vector projectionVector = new Vector(yokeClamp.Width3, 0, 0);
                    Projection3d body = new Projection3d((ICurve)(new ComplexString3d(curveCollection)), projectionVector, projectionVector.Length, true);
                    body.Transform(matrix);
                    outputs.Add(outputName + "TopShp", body);
                }
                else
                {
                    double tempLength;
                    tempLength = yokeClamp.Length7 + (yokeClamp.Length3 - yokeClamp.Length7) / 2;
                    Collection<Position> pointCollection = new Collection<Position>();

                    pointCollection.Add(new Position(-yokeClamp.Width3 / 2, -yokeClamp.Length7 / 2, yokeClamp.Height5));
                    pointCollection.Add(new Position(-yokeClamp.Width3 / 2, -yokeClamp.Length3 / 2, yokeClamp.Height4));
                    pointCollection.Add(new Position(-yokeClamp.Width3 / 2, -yokeClamp.Length3 / 2, yokeClamp.Height3));
                    pointCollection.Add(new Position(-yokeClamp.Width3 / 2, -tempLength / 2, yokeClamp.Height3));
                    pointCollection.Add(new Position(-yokeClamp.Width3 / 2, -yokeClamp.Length7 / 2, yokeClamp.Height5 - (yokeClamp.Height4 - yokeClamp.Height3)));
                    pointCollection.Add(new Position(-yokeClamp.Width3 / 2, yokeClamp.Length7 / 2, yokeClamp.Height5 - (yokeClamp.Height4 - yokeClamp.Height3)));
                    pointCollection.Add(new Position(-yokeClamp.Width3 / 2, tempLength / 2, yokeClamp.Height3));
                    pointCollection.Add(new Position(-yokeClamp.Width3 / 2, yokeClamp.Length3 / 2, yokeClamp.Height3));
                    pointCollection.Add(new Position(-yokeClamp.Width3 / 2, yokeClamp.Length3 / 2, yokeClamp.Height4));
                    pointCollection.Add(new Position(-yokeClamp.Width3 / 2, yokeClamp.Length7 / 2, yokeClamp.Height5));
                    pointCollection.Add(new Position(-yokeClamp.Width3 / 2, -yokeClamp.Length7 / 2, yokeClamp.Height5));

                    Collection<ICurve> curveCollection = new Collection<ICurve>();
                    curveCollection.Add(new LineString3d(pointCollection));

                    Vector projectionVector = new Vector(yokeClamp.Width3, 0, 0);
                    Projection3d body = new Projection3d((ICurve)(new ComplexString3d(curveCollection)), projectionVector, projectionVector.Length, true);
                    body.Transform(matrix);
                    outputs.Add(outputName + "TopShp", body);
                }

                //Pin Or Lug
                if (yokeClamp.PinOrLug == 1)
                {
                    if (yokeClamp.Orientation == 1)
                    {
                        symbolGeometryHelper.ActivePosition = new Position(-yokeClamp.Width4 / 2, (yokeClamp.Length4 - yokeClamp.Length5) / 4 + yokeClamp.Length5 / 2, yokeClamp.Height5 + (yokeClamp.RodTakeOut + yokeClamp.Height6 - yokeClamp.Height5) / 2);
                        symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        Projection3d pinBoxLeft = (Projection3d)symbolGeometryHelper.CreateBox(null, yokeClamp.Width4, (yokeClamp.Length4 - yokeClamp.Length5) / 2, yokeClamp.RodTakeOut + yokeClamp.Height6 - yokeClamp.Height5);
                        pinBoxLeft.Transform(matrix);
                        outputs.Add(outputName + "PinBoxLeft", pinBoxLeft);

                        symbolGeometryHelper.ActivePosition = new Position(-yokeClamp.Width4 / 2, -(yokeClamp.Length4 - yokeClamp.Length5) / 4 - yokeClamp.Length5 / 2, yokeClamp.Height5 + (yokeClamp.RodTakeOut + yokeClamp.Height6 - yokeClamp.Height5) / 2);
                        symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        Projection3d pinBoxRight = (Projection3d)symbolGeometryHelper.CreateBox(null, yokeClamp.Width4, (yokeClamp.Length4 - yokeClamp.Length5) / 2, yokeClamp.RodTakeOut + yokeClamp.Height6 - yokeClamp.Height5);
                        pinBoxRight.Transform(matrix);
                        outputs.Add(outputName + "PinBoxRight", pinBoxRight);

                        symbolGeometryHelper = new SymbolGeometryHelper();
                        Vector normal = new Position(0, yokeClamp.Pin1Length / 2, yokeClamp.RodTakeOut).Subtract(new Position(0, -yokeClamp.Pin1Length / 2, yokeClamp.RodTakeOut));
                        Vector orthogonal = normal.GetOrthogonalVector();
                        symbolGeometryHelper.ActivePosition = new Position(0, -yokeClamp.Pin1Length / 2, yokeClamp.RodTakeOut);
                        symbolGeometryHelper.SetOrientation(normal, orthogonal);
                        Projection3d pinCylinder = symbolGeometryHelper.CreateCylinder(null, yokeClamp.Pin1Diameter / 2, normal.Length);
                        pinCylinder.Transform(matrix);
                        outputs.Add(outputName + "PinCylinder", pinCylinder);
                    }
                    else
                    {
                        if (yokeClamp.RodTakeOut > yokeClamp.Height5)
                        {
                            symbolGeometryHelper.ActivePosition = new Position(-yokeClamp.Width4/2,(yokeClamp.Length4 - yokeClamp.Length5)/4 + yokeClamp.Length5/2,yokeClamp.Height5 + (yokeClamp.RodTakeOut + yokeClamp.Height6 - yokeClamp.Height5)/2);
                            symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                            Projection3d pinBoxLeft =(Projection3d)symbolGeometryHelper.CreateBox(null, yokeClamp.Width4,(yokeClamp.Length4 - yokeClamp.Length5)/2,yokeClamp.RodTakeOut + yokeClamp.Height6 - yokeClamp.Height5);
                            pinBoxLeft.Transform(matrix);
                            outputs.Add(outputName + "PinBoxLeft", pinBoxLeft);

                            symbolGeometryHelper.ActivePosition = new Position(-yokeClamp.Width4/2,-(yokeClamp.Length4 - yokeClamp.Length5)/4 - yokeClamp.Length5/2,yokeClamp.Height5 + (yokeClamp.RodTakeOut + yokeClamp.Height6 - yokeClamp.Height5)/2);
                            symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                            Projection3d pinBoxRight = (Projection3d)symbolGeometryHelper.CreateBox(null, yokeClamp.Width4,(yokeClamp.Length4 - yokeClamp.Length5)/2,yokeClamp.RodTakeOut + yokeClamp.Height6 - yokeClamp.Height5);
                            pinBoxRight.Transform(matrix);
                            outputs.Add(outputName + "PinBoxRight", pinBoxRight);
                        }

                        symbolGeometryHelper = new SymbolGeometryHelper();
                        Vector normal = new Position(yokeClamp.Pin1Length / 2, 0, yokeClamp.RodTakeOut).Subtract(new Position(-yokeClamp.Pin1Length / 2, 0, yokeClamp.RodTakeOut));
                        Vector orthogonal = normal.GetOrthogonalVector();
                        symbolGeometryHelper.ActivePosition = new Position(-yokeClamp.Pin1Length / 2, 0, yokeClamp.RodTakeOut);
                        symbolGeometryHelper.SetOrientation(normal, orthogonal);
                        Projection3d pinCylinder = symbolGeometryHelper.CreateCylinder(null, yokeClamp.Pin1Diameter / 2, normal.Length);
                        pinCylinder.Transform(matrix);
                        outputs.Add(outputName + "PinCylinder", pinCylinder);
                    }
                }
                else if (yokeClamp.PinOrLug == 2)
                {
                    symbolGeometryHelper.ActivePosition = new Position(-yokeClamp.Width4 / 2, -(yokeClamp.Length4 - yokeClamp.Length5) / 4 - yokeClamp.Length5 / 2, yokeClamp.Height5 + (yokeClamp.RodTakeOut + yokeClamp.Height6 - yokeClamp.Height5) / 2);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    Projection3d pinBoxLeft = (Projection3d)symbolGeometryHelper.CreateBox(null, yokeClamp.Width4, yokeClamp.Length4, yokeClamp.RodTakeOut + yokeClamp.Height6 - yokeClamp.Height5);
                    pinBoxLeft.Transform(matrix);
                    outputs.Add(outputName + "PinBoxLeft", pinBoxLeft);

                    symbolGeometryHelper = new SymbolGeometryHelper();
                    Vector normal = new Position(0, yokeClamp.Length4 / 2, yokeClamp.RodTakeOut).Subtract(new Position(0, -yokeClamp.Length4 / 2, yokeClamp.RodTakeOut));
                    Vector orthogonal = normal.GetOrthogonalVector();
                    symbolGeometryHelper.ActivePosition = new Position(0, -yokeClamp.Length4 / 2, yokeClamp.RodTakeOut);
                    symbolGeometryHelper.SetOrientation(normal, orthogonal);
                    Projection3d pinCylinder = symbolGeometryHelper.CreateCylinder(null, yokeClamp.Pin1Diameter / 2, normal.Length);
                    pinCylinder.Transform(matrix);
                    outputs.Add(outputName + "PinCylinder", pinCylinder);
                }
                else
                {
                    symbolGeometryHelper.ActivePosition = new Position(-yokeClamp.Width4 / 2, 0, yokeClamp.Height5 + (yokeClamp.Height6) / 2);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    Projection3d pinBoxLeft = (Projection3d)symbolGeometryHelper.CreateBox(null, yokeClamp.Width4, yokeClamp.Length4,yokeClamp.Height6);
                    pinBoxLeft.Transform(matrix);
                    outputs.Add(outputName + "PinBoxLeft", pinBoxLeft);
                }

                double[] uboltXLocation = new double[(int)yokeClamp.Multi1Qty];
                for (int i = 0; i <= yokeClamp.Multi1Qty - 1; i++)
                {
                    uboltXLocation[i] = MultiPosition(yokeClamp.Width3, yokeClamp.Multi1Qty, yokeClamp.Multi1LocateBy, yokeClamp.Multi1Location, yokeClamp.UBolt.UBoltRodDia)[i];
                }

                for (int i = 0; i <= yokeClamp.Multi1Qty - 1; i++)
                {
                    Matrix4X4 uBoltMatrix = new Matrix4X4();
                    uBoltMatrix.SetIdentity();
                    uBoltMatrix.Translate(new Vector(uboltXLocation[i] - yokeClamp.Width3 / 2, 0, 0));
                    uBoltMatrix.Rotate(Math.PI, new Vector(1, 0, 0));
                    AddUBolt(yokeClamp.UBolt, yokeClamp.Diameter1, uBoltMatrix, outputs, outputName + "UBolt" + (i + 1));
                }

                //Nuts
                for (int i = 0; i <= yokeClamp.Multi1Qty - 1; i++)
                {
                    //Left Two Nuts

                    Matrix4X4 nutMatrix = new Matrix4X4();
                    nutMatrix.Origin = new Position(uboltXLocation[i] - yokeClamp.Width3 / 2, yokeClamp.UBolt.UBoltWidth / 2, yokeClamp.Height4);
                    AddNut(yokeClamp.Nut1, nutMatrix, outputs, outputName + "Nut1_" + i);

                    nutMatrix.Origin = new Position(uboltXLocation[i] - yokeClamp.Width3 / 2, yokeClamp.UBolt.UBoltWidth / 2, yokeClamp.Height4 + yokeClamp.Nut1.ShapeLength);
                    AddNut(yokeClamp.Nut2, nutMatrix, outputs, outputName + "Nut2_" + i);

                    //Right Two Nuts
                    nutMatrix.Origin = new Position(uboltXLocation[i] - yokeClamp.Width3 / 2, -yokeClamp.UBolt.UBoltWidth / 2, yokeClamp.Height4);
                    AddNut(yokeClamp.Nut3, nutMatrix, outputs, outputName + "Nut3_" + i);

                    nutMatrix.Origin = new Position(uboltXLocation[i] - yokeClamp.Width3 / 2, -yokeClamp.UBolt.UBoltWidth / 2, yokeClamp.Height4 + yokeClamp.Nut3.ShapeLength);
                    AddNut(yokeClamp.Nut4, nutMatrix, outputs, outputName + "Nut4_" + i);
                }
                for (int i = 0; i <= yokeClamp.Multi1Qty - 1; i++)
                {
                    if ((yokeClamp.Height1 > 0) && (yokeClamp.Width1 > 0) && (yokeClamp.Length1 > 0))
                    {
                        symbolGeometryHelper = new SymbolGeometryHelper();
                        symbolGeometryHelper.ActivePosition = new Position(uboltXLocation[i], 0, yokeClamp.Diameter1 / 2.0 + yokeClamp.Gap1);
                        symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        Projection3d block1 = (Projection3d)symbolGeometryHelper.CreateBox(null, yokeClamp.Length1, yokeClamp.Width1, yokeClamp.Height1);
                        block1.Transform(matrix);
                        outputs.Add(outputName + "Block1_" + i, block1);
                    }
                    if ((yokeClamp.Height2 > 0) && (yokeClamp.Width2 > 0) && (yokeClamp.Length2 > 0))
                    {
                        symbolGeometryHelper = new SymbolGeometryHelper();
                        symbolGeometryHelper.ActivePosition = new Position(uboltXLocation[i], 0, yokeClamp.Diameter1 / 2.0 + yokeClamp.Gap1 - yokeClamp.Height2);
                        symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        Projection3d block2 = (Projection3d)symbolGeometryHelper.CreateBox(null, yokeClamp.Length2, yokeClamp.Width2, yokeClamp.Height2);
                        block2.Transform(matrix);
                        outputs.Add(outputName + "Block2_" + i, block2);
                    }
                }

                //Straps
                double[] strapXLocation = new double[(int)yokeClamp.Multi2Qty];
                for (int i = 0; i <= yokeClamp.Multi2Qty - 1; i++)
                {
                    strapXLocation[i] = MultiPosition(yokeClamp.Width3, yokeClamp.Multi2Qty, yokeClamp.Multi2LocateBy, yokeClamp.Multi2Location, yokeClamp.Strap.StrapStockWidth)[i];
                }

                for (int i = 0; i <= yokeClamp.Multi2Qty - 1; i++)
                {
                    if ((HgrCompareDoubleService.cmpdbl(yokeClamp.Strap.StrapWidthWings, 0) == false) || (yokeClamp.Strap.StrapWidthWings > (yokeClamp.Strap.StrapWidthInside + (2 * yokeClamp.Strap.StrapThickness))))
                    {
                        Matrix4X4 strapMatrix = new Matrix4X4();
                        strapMatrix.SetIdentity();
                        strapMatrix.Translate(new Vector(strapXLocation[i] - yokeClamp.Width3 / 2, 0, 0));
                        strapMatrix.Rotate(Math.PI, new Vector(1, 0, 0));
                        AddStrap(yokeClamp.Strap, yokeClamp.Diameter1, strapMatrix, outputs, outputName + "Strap" + (i + 1));
                    }
                    else
                    {
                        Matrix4X4 strapMatrix = new Matrix4X4();
                        strapMatrix.SetIdentity();
                        strapMatrix.Translate(new Vector(strapXLocation[i] - yokeClamp.Width3 / 2, 0, 0));
                        strapMatrix.Rotate(Math.PI, new Vector(1, 0, 0));
                        AddStrap(yokeClamp.Strap, yokeClamp.Diameter1, strapMatrix, outputs, outputName + "Strap" + (i + 1));
                    }
                }
                if (error.Length != 0)
                {
                    // PF_EventHandler sError, Err, MODULE, METHOD, True
                    ToDoListMessage = new ToDoListMessage(ToDoMessageTypes.ToDoMessageWarning, error.ToString());
                }
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddYokeClampMethod, "Error in AddYokeClamp");
                }
            }
        }

        /// <summary>
        /// Adds the ubolts.
        /// </summary>
        /// <param name="uBolt">UBolt shape.</param>
        /// <param name="pipeOD">Pipe Outer Diameter.</param>
        /// <param name="matrix">Matrix to specify the position and orientation of the graphics - Matrix4X4.</param>
        /// <param name="outputs">Collection of declared outputs, which is indexed by the name of the outputs declared as defining SymbolOutputs on the AspectDefinition field- OutputDictionary.</param>
        /// <param name="outputName">OutputName that this graphic is being placed on-String.</param>
        /// <code>
        ///  uBoltMatrix = new Matrix4X4();
        ///  uBoltMatrix.Translate(new Vector(uboltXLocation[i] - yokeClamp.Width3 / 2, 0, 0));
        ///  uBoltMatrix.Rotate(Math.PI, new Vector(1, 0, 0));
        ///  AddUBolt(yokeClamp.UBolt, yokeClamp.Diameter1, uBoltMatrix, outputs, outputName + "UBolt" + (i + 1));
        /// </code>
        public void AddUBolt(UBoltInputs uBolt, Double pipeOD, Matrix4X4 matrix, OutputDictionary outputs, String outputName)
        {
            try
            {
                bool boolValue = false;
                double tempValue = uBolt.UBoltWidth - uBolt.UBoltRodDia;
                SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();
                Vector normal = new Vector(0, 0, 1);
                Vector orthogonal = normal.GetOrthogonalVector();
                double uBoltOffsetZ;               //Z Offset for UBolt to adapt to changes in RodDia and PipeOD
                uBoltOffsetZ = -((uBolt.UBoltWidth - uBolt.UBoltRodDia) / 2 - pipeOD / 2);
                double lengthExtend;               //Amount to Extend Straight section of UBolt if there is a Flat Spot
                lengthExtend = 0;
                if (uBolt.UBoltFlatSpot > 0)
                {
                    lengthExtend = uBolt.UBoltWidth / 2.0 - (uBolt.UBoltWidth - uBolt.UBoltFlatSpot) / 2.0;
                    if (uBolt.UBoltDia2 > 0)
                        lengthExtend = uBolt.UBoltWidth / 2.0 - (uBolt.UBoltWidth - uBolt.UBoltFlatSpot) / 2.0;
                }
                boolValue = pipeOD <= tempValue;
                if (uBolt.UBoltWidth > 0 && (uBolt.UBoltRodDia > 0 || uBolt.UBoltDia2 > 0))
                {
                    if (boolValue)
                    {
                        if (uBolt.UBoltRodDia <= 0)
                            uBolt.UBoltRodDia = uBolt.UBoltDia2;
                        if ((uBolt.UBoltDia2Start > 0) && (uBolt.UBoltRodDia != 0))
                        {
                            //draw 4 cylinders, Two with UBoltRodDia and two with UBoltDia2
                            if (!(uBolt.UBoltDia2 > 0))// this makes UBoltDia2Start not to be considered to limit the bottom/StraightDia1Left cylinder when UBoltDia2 is less than or equal to zero.
                                uBolt.UBoltDia2Start = 0;

                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(0, uBolt.UBoltWidth / 2, -uBolt.UBoltCenterToEnd + uBoltOffsetZ + uBolt.UBoltTopGap);
                            symbolGeometryHelper.SetOrientation(normal, orthogonal);
                            Projection3d straightDia1Left = symbolGeometryHelper.CreateCylinder(null, uBolt.UBoltRodDia / 2, uBolt.UBoltCenterToEnd - uBolt.UBoltDia2Start);
                            straightDia1Left.Transform(matrix);
                            outputs.Add(outputName + "StraightDia1Left", straightDia1Left);

                            if (uBolt.UBoltDia2 > 0)
                            {
                                symbolGeometryHelper = new SymbolGeometryHelper();
                                symbolGeometryHelper.ActivePosition = new Position(0, uBolt.UBoltWidth / 2, -uBolt.UBoltDia2Start + uBoltOffsetZ + uBolt.UBoltTopGap);
                                symbolGeometryHelper.SetOrientation(normal, orthogonal);
                                Projection3d straightDia2Left = symbolGeometryHelper.CreateCylinder(null, uBolt.UBoltDia2 / 2, uBolt.UBoltDia2Start + lengthExtend);
                                straightDia2Left.Transform(matrix);
                                outputs.Add(outputName + "StraightDia2Left", straightDia2Left);
                            }
                            if (uBolt.UBoltOneSided == 2)
                            {
                                symbolGeometryHelper = new SymbolGeometryHelper();
                                symbolGeometryHelper.ActivePosition = new Position(0, -uBolt.UBoltWidth / 2, -uBolt.UBoltCenterToEnd + uBoltOffsetZ + uBolt.UBoltTopGap);
                                symbolGeometryHelper.SetOrientation(normal, orthogonal);
                                Projection3d straightDia1Right1 = symbolGeometryHelper.CreateCylinder(null, uBolt.UBoltRodDia / 2, uBolt.UBoltCenterToEnd - uBolt.UBoltDia2Start);
                                straightDia1Right1.Transform(matrix);
                                outputs.Add(outputName + "StraightDia1Right", straightDia1Right1);

                                if (uBolt.UBoltDia2 > 0)
                                {
                                    symbolGeometryHelper = new SymbolGeometryHelper();
                                    symbolGeometryHelper.ActivePosition = new Position(0, -uBolt.UBoltWidth / 2, -uBolt.UBoltDia2Start + uBoltOffsetZ + uBolt.UBoltTopGap);
                                    symbolGeometryHelper.SetOrientation(normal, orthogonal);
                                    Projection3d straightDia2Left = symbolGeometryHelper.CreateCylinder(null, uBolt.UBoltDia2 / 2, uBolt.UBoltDia2Start + lengthExtend);
                                    straightDia2Left.Transform(matrix);
                                    outputs.Add(outputName + "StraightDia2Right", straightDia2Left);
                                }
                            }
                        }
                        else
                        {
                            //Draw 2 cylinders with UBoltRodDia
                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(0, uBolt.UBoltWidth / 2, -uBolt.UBoltCenterToEnd + uBoltOffsetZ + uBolt.UBoltTopGap);
                            symbolGeometryHelper.SetOrientation(normal, orthogonal);
                            Projection3d straightDia1Left1 = symbolGeometryHelper.CreateCylinder(null, uBolt.UBoltRodDia / 2, uBolt.UBoltCenterToEnd + lengthExtend);
                            straightDia1Left1.Transform(matrix);
                            outputs.Add(outputName + "StraightDia1Left", straightDia1Left1);

                            if (uBolt.UBoltOneSided == 2)
                            {
                                symbolGeometryHelper = new SymbolGeometryHelper();
                                symbolGeometryHelper.ActivePosition = new Position(0, -uBolt.UBoltWidth / 2, -uBolt.UBoltCenterToEnd + uBoltOffsetZ + uBolt.UBoltTopGap);
                                symbolGeometryHelper.SetOrientation(normal, orthogonal);
                                Projection3d straightDia1Right1 = symbolGeometryHelper.CreateCylinder(null, uBolt.UBoltRodDia / 2, uBolt.UBoltCenterToEnd + lengthExtend);
                                straightDia1Right1.Transform(matrix);
                                outputs.Add(outputName + "StraightDia1Right", straightDia1Right1);
                            }
                        }
                        //Curved Section of the U Bolt
                        double rodD;
                        if (uBolt.UBoltDia2 > 0)
                            rodD = uBolt.UBoltDia2;
                        else
                            rodD = uBolt.UBoltRodDia;
                        if (uBolt.UBoltFlatSpot <= 0)
                        {
                            //Draw Bend with no Flat Spot
                            if (uBolt.UBoltDia2 > 0)
                            {
                                //Draw ubolt with Dia2
                                Revolution3d elbow = new Revolution3d((new Circle3d(new Position(0, uBolt.UBoltWidth / 2, uBoltOffsetZ + uBolt.UBoltTopGap), new Vector(0, 0, 1), uBolt.UBoltDia2 / 2)), new Vector(1, 0, 0), new Position(0, 0, uBoltOffsetZ + uBolt.UBoltTopGap), Math.PI, true);
                                elbow.Transform(matrix);
                                outputs.Add(outputName + "Elbow", elbow);
                            }
                            else if (uBolt.UBoltDia2 == 0)
                            {
                                //Draw ubolt with Dia1
                                Revolution3d elbow = new Revolution3d((new Circle3d(new Position(0, uBolt.UBoltWidth / 2, uBoltOffsetZ + uBolt.UBoltTopGap), new Vector(0, 0, 1), uBolt.UBoltRodDia / 2)), new Vector(1, 0, 0), new Position(0, 0, uBoltOffsetZ + uBolt.UBoltTopGap), Math.PI, true);
                                elbow.Transform(matrix);
                                outputs.Add(outputName + "Elbow", elbow);
                            }
                            else
                            {
                                //Dont Draw About
                            }
                        }
                        else if ((uBolt.UBoltFlatSpot > 0) && (uBolt.UBoltFlatSpot < (uBolt.UBoltWidth - rodD)))
                        {
                            //Draw a Flat Spot
                            double radius;
                            double bendOffset;
                            Matrix4X4 cylinderMatrix = new Matrix4X4();
                            radius = (uBolt.UBoltWidth - uBolt.UBoltFlatSpot) / 2.0;
                            bendOffset = pipeOD / 2 + uBolt.UBoltTopGap + uBolt.UBoltRodDia / 2.0 - radius;    // + dGap1 '[RCM] dGap1 is not declared or set anywhere

                            Revolution3d flatElbowLeft = new Revolution3d((new Circle3d(new Position(0, uBolt.UBoltWidth / 2, bendOffset), new Vector(0, 0, 1), rodD / 2)), new Vector(1, 0, 0), new Position(0, uBolt.UBoltWidth / 2.0 - radius, bendOffset), Math.PI / 2, true);
                            flatElbowLeft.Transform(matrix);
                            outputs.Add(outputName + "FlatElbowLeft", flatElbowLeft);

                            Revolution3d flatElbowRight = new Revolution3d((new Circle3d(new Position(0, -uBolt.UBoltWidth / 2, bendOffset), new Vector(0, 0, -1), rodD / 2)), new Vector(-1, 0, 0), new Position(0, -(uBolt.UBoltWidth / 2.0 - radius), bendOffset), Math.PI / 2, true);
                            flatElbowRight.Transform(matrix);
                            outputs.Add(outputName + "FlatElbowRight", flatElbowRight);


                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.SetOrientation(normal, orthogonal);
                            cylinderMatrix = new Matrix4X4();
                            cylinderMatrix.SetIdentity();
                            cylinderMatrix.Rotate(Math.PI / 2, new Vector(1, 0, 0), new Position(0, 0, 0));
                            cylinderMatrix.Translate(new Vector(0, uBolt.UBoltFlatSpot / 2, bendOffset + radius));
                            Projection3d flatSpot = symbolGeometryHelper.CreateCylinder(null, rodD / 2.0, uBolt.UBoltFlatSpot);
                            flatSpot.Transform(cylinderMatrix);
                            flatSpot.Transform(matrix);
                            outputs.Add(outputName + "FlatSpot", flatSpot);
                        }
                        else
                            //UBoltFlatSpot is to large for the selected U Bolt
                            ToDoListMessage = new ToDoListMessage(ToDoMessageTypes.ToDoMessageWarning, SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidWidthFlatSpot, "Width of Flat Spot is too large for the U Bolt"));
                    }
                    else
                        //Pipe OD Can't be larger then the inside diameter of the U Bolt
                        ToDoListMessage = new ToDoListMessage(ToDoMessageTypes.ToDoMessageWarning, SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidPipeOD, "Outside Pipe Diameter is too large for the U Bolt"));
                }
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddUBoltMethod, "Error in AddUBolt");
                }
            }
        }

        /// <summary>
        /// Defines the inputs required to construct ouputs of a StrutB. 
        /// </summary>
        public struct StrutBInputs
        {
            /// <summary>
            /// Length of this part, meaning the distance between Port1 and Port2.
            /// </summary>
            public double length;
            /// <summary>
            /// Determines graphic shape use for the Rod End.
            /// </summary>
            public int rodEndType;
            /// <summary>
            /// Sets the thickness of the rod end.
            /// </summary>
            public double thickness1;
            /// <summary>
            /// sets the length from the base of the spade to the port location, 
            /// </summary>
            public double length1;
            /// <summary>
            /// Sets the outside diameter of the rod ends.
            /// </summary>
            public double diameter1;
            /// <summary>
            /// if positive, creates a double spade end, with two identical spades separated by the gap
            /// </summary>
            public double gap1;
            /// <summary>
            ///The Nut input parameter type.
            /// </summary>
            public NutInputs Nut;
        }
        /// <summary>
        /// This property adds inputs for StrutB.User symbol calls this property AdditionalInputs
        /// to define additional inputs. The list of inputs returned by this method will be the inputs for the user symbol in addition
        /// to the inputs that are already defined as member variables.
        /// </summary>
        ///<code>
        /// public override IEnumerable<Input> AdditionalInputs
        /// {
        ///     get
        ///     {
        ///         int endIndex;
        ///         additionalInputs = new List(Input)();
        ///         //Example , I have added the nut with staring index 3.
        ///         AddStrutBInputs(3, out endIndex, additionalInputs);
        ///         return additionalInputs; 
        ///    }
        /// }
        ///</code>
        public void AddStrutBInputs(int startIndex, out int endIndex, List<Input> additionalInputs)
        {
            try
            {
                additionalInputs.Add((Input)new InputDouble(startIndex, "Length", "Length", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "RodEnd1Type", "RodEnd1Type", 2, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Thickness1", "Thickness1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Length1", "Length1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Diameter1", "Diameter1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Gap1", "Gap1", 0, false));
                ++startIndex;
                endIndex = startIndex;
                AddNutInputs(startIndex, out endIndex, additionalInputs);

            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrStrutBAdditionalInputs, "Error in adding StrutB Inputs");
                endIndex = startIndex;
            }
        }
        /// <summary>
        /// Adds the StrutB outputs.User symbol calls this method during AdditionalOutputs
        /// to define additional outputs for an aspect. The list of outputs returned by this method will be the outputs for the aspect
        /// in addition to the outputs that are already defined as attributes on the aspect.
        /// </summary>
        /// <param name="additionalOutputs">The additional outputs.</param>
        ///<code>
        ///public override IEnumerable<OutputDefinition> AdditionalOutputs(string aspectName)
        ///{
        ///    List<OutputDefinition> additionalOutputs = new List<OutputDefinition>();
        ///    if (aspectName == "Symbolic")
        ///    {
        ///       AddStrutBOutputs(additionalOutputs);
        ///    }
        ///    return additionalOutputs;
        ///}
        ///</code> 
        public void AddStrutBOutputs(List<OutputDefinition> additionalOutputs)
        {
            try
            {
                additionalOutputs.Add(new OutputDefinition("StrutB" + "RodEnd1", "StrutB" + "RodEnd1"));
                additionalOutputs.Add(new OutputDefinition("StrutB" + "RodEnd2", "StrutB" + "RodEnd2"));
                additionalOutputs.Add(new OutputDefinition("StrutB" + "Shape1", "StrutB" + "Shape1"));

            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrStrutBAdditionalOutputs, "Error in adding StrutB outputs");
            }
        }
        /// <summary>
        /// This method will be called by user symbol to get value of an input(in this case, StrutB input structure)during construction of outputs. 
        /// Given the start index, this method will return the value of the StrutBData struct object.
        /// </summary>
        /// <param name="startIndex">The start index.</param>
        /// <returns></returns>
        ///<code>
        ///NutInputs nut = LoadStrutBData(3);
        ///</code>
        public StrutBInputs LoadStrutBData(int startIndex)
        {
            StrutBInputs strutB = new StrutBInputs();
            try
            {
                strutB.length = GetDoubleInputValue(startIndex);
                strutB.rodEndType = (int)GetDoubleInputValue(++startIndex);
                if (strutB.rodEndType < 1 || strutB.rodEndType > 5)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvRodEndTypeeCodeListValue, "RodEndType code list value should be between 1 and 5");
                }
                strutB.thickness1 = GetDoubleInputValue(++startIndex);
                if (strutB.thickness1 == 0)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidThickness1NZero, "Thickness1 value should not be equal to zero");
                }
                strutB.length1 = GetDoubleInputValue(++startIndex);
                strutB.diameter1 = GetDoubleInputValue(++startIndex);
                if (strutB.diameter1 == 0)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidDiameter1NZero, "Diameter1 value should not be equal to zero");
                }
                strutB.gap1 = GetDoubleInputValue(++startIndex);
                strutB.Nut = LoadNutData(++startIndex);
            }
            catch (SmartPartSymbolException hgrEx)
            {
                throw hgrEx;
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadStrutBData, "Error in loading StrutB data");
            }
            return strutB;
        }
        /// <summary>
        ///Create the graphical representation of a StrutB.  Specify the inputs and StringMatrix.
        /// </summary>
        ///<param name="strutB">Structure for specifying the inputs for the StrutB -StrutBinputs </param>
        ///<param name="matrix">string to specify the position and oreintation the graphics - String.</param>
        /// <param name="outputs">Collection of declared outputs, which is indexed by the name of the outputs declared as defining SymbolOutputs on the AspectDefinition field- OutputDictionary</param>
        /// <param name="outputName">Output that this graphic is being placed on-String</param>
        ///<code>
        /// AddStrutB(strutB, matrix, m_PhysicalAspect.Outputs, "Strut");
        ///</code>
        public void AddStrutB(StrutBInputs strutB, Matrix4X4 matrix, OutputDictionary outputs, String outputName)
        {
            try
            {
                SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();
                Line3d line;

                int rodEndType = strutB.rodEndType;
                Matrix4X4 arcMatrix = new Matrix4X4();
                double cur_Zpos = 0;
                if (rodEndType == 2)
                {
                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(0, -strutB.thickness1 / 2, 0);
                    symbolGeometryHelper.SetOrientation(new Vector(0, 1, 0), new Vector(1, 0, 0));
                    Projection3d cylinder = (Projection3d)symbolGeometryHelper.CreateCylinder(null, strutB.diameter1 / 2, strutB.thickness1);
                    cylinder.Transform(matrix);
                    outputs.Add(outputName + "RodEnd1", cylinder);

                    cur_Zpos = strutB.diameter1 / 2;
                }

                else if (rodEndType == 3)
                {
                    cur_Zpos = strutB.length1;
                    if (strutB.gap1 > 0)
                    {
                        Collection<ICurve> curveCollection = new Collection<ICurve>();
                        symbolGeometryHelper = new SymbolGeometryHelper();
                        symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                        symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(Math.PI, new Vector(0, 0, 1));
                        Arc3d arc1 = symbolGeometryHelper.CreateArc(null, (strutB.diameter1 / 2), (2 * (Math.PI) - (Math.PI)));
                        arc1.Transform(arcMatrix);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                        arc1.Transform(arcMatrix);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(Math.PI / 2, new Vector(1, 0, 0));
                        arc1.Transform(arcMatrix);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Translate(new Vector(-strutB.thickness1 - strutB.gap1 / 2, 0, 0));
                        arc1.Transform(arcMatrix);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(Math.PI / 2, new Vector(0, 0, 1));
                        arc1.Transform(arcMatrix);
                        curveCollection.Add(arc1);

                        line = new Line3d(new Position(-strutB.diameter1 / 2, -strutB.thickness1 - strutB.gap1 / 2, 0), new Position(-strutB.diameter1 / 2, -strutB.thickness1 - strutB.gap1 / 2, strutB.length1));
                        curveCollection.Add(line);

                        line = new Line3d(new Position(-strutB.diameter1 / 2, -strutB.thickness1 - strutB.gap1 / 2, strutB.length1), new Position(strutB.diameter1 / 2, -strutB.thickness1 - strutB.gap1 / 2, strutB.length1));
                        curveCollection.Add(line);

                        line = new Line3d(new Position(strutB.diameter1 / 2, -strutB.thickness1 - strutB.gap1 / 2, strutB.length1), new Position(strutB.diameter1 / 2, -strutB.thickness1 - strutB.gap1 / 2, 0));
                        curveCollection.Add(line);

                        ComplexString3d complexString1 = new ComplexString3d(curveCollection);
                        Vector lineVector1 = new Vector(0, strutB.thickness1, 0);
                        Projection3d rod1 = new Projection3d(complexString1, lineVector1, lineVector1.Length, true);
                        rod1.Transform(matrix);
                        outputs.Add(outputName + "RodEnd1", rod1);



                        curveCollection = new Collection<ICurve>();
                        symbolGeometryHelper = new SymbolGeometryHelper();
                        symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                        symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(Math.PI, new Vector(0, 0, 1));
                        Arc3d arc2 = symbolGeometryHelper.CreateArc(null, (strutB.diameter1 / 2), (2 * (Math.PI) - (Math.PI)));
                        arc2.Transform(arcMatrix);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                        arc2.Transform(arcMatrix);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(Math.PI / 2, new Vector(1, 0, 0));
                        arc2.Transform(arcMatrix);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Translate(new Vector(strutB.gap1 / 2, 0, 0));
                        arc2.Transform(arcMatrix);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(Math.PI / 2, new Vector(0, 0, 1));
                        arc2.Transform(arcMatrix);
                        curveCollection.Add(arc2);

                        line = new Line3d(new Position(-strutB.diameter1 / 2, strutB.gap1 / 2, 0), new Position(-strutB.diameter1 / 2, strutB.gap1 / 2, strutB.length1));
                        curveCollection.Add(line);

                        line = new Line3d(new Position(-strutB.diameter1 / 2, strutB.gap1 / 2, strutB.length1), new Position(strutB.diameter1 / 2, strutB.gap1 / 2, strutB.length1));
                        curveCollection.Add(line);

                        line = new Line3d(new Position(strutB.diameter1 / 2, strutB.gap1 / 2, strutB.length1), new Position(strutB.diameter1 / 2, strutB.gap1 / 2, 0));
                        curveCollection.Add(line);

                        ComplexString3d complexString2 = new ComplexString3d(curveCollection);
                        Vector lineVector2 = new Vector(0, strutB.thickness1, 0);
                        Projection3d rod2 = new Projection3d(complexString2, lineVector2, lineVector2.Length, true);
                        rod2.Transform(matrix);
                        outputs.Add(outputName + "RodEnd2", rod2);

                    }
                    else
                    {
                        Collection<ICurve> curveCollection = new Collection<ICurve>();
                        symbolGeometryHelper = new SymbolGeometryHelper();
                        symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                        symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(Math.PI, new Vector(0, 0, 1));
                        Arc3d arc3 = symbolGeometryHelper.CreateArc(null, (strutB.diameter1 / 2), (2 * (Math.PI) - (Math.PI)));
                        arc3.Transform(arcMatrix);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                        arc3.Transform(arcMatrix);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(Math.PI / 2, new Vector(1, 0, 0));
                        arc3.Transform(arcMatrix);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Translate(new Vector(-strutB.thickness1 / 2, 0, 0));
                        arc3.Transform(arcMatrix);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(Math.PI / 2, new Vector(0, 0, 1));
                        arc3.Transform(arcMatrix);
                        curveCollection.Add(arc3);

                        line = new Line3d(new Position(-strutB.diameter1 / 2, -strutB.thickness1 / 2, 0), new Position(-strutB.diameter1 / 2, -strutB.thickness1 / 2, strutB.length1));
                        curveCollection.Add(line);

                        line = new Line3d(new Position(-strutB.diameter1 / 2, -strutB.thickness1 / 2, strutB.length1), new Position(strutB.diameter1 / 2, -strutB.thickness1 / 2, strutB.length1));
                        curveCollection.Add(line);

                        line = new Line3d(new Position(strutB.diameter1 / 2, -strutB.thickness1 / 2, strutB.length1), new Position(strutB.diameter1 / 2, -strutB.thickness1 / 2, 0));
                        curveCollection.Add(line);

                        ComplexString3d complexString3 = new ComplexString3d(curveCollection);
                        Vector lineVector1 = new Vector(0, strutB.thickness1, 0);
                        Projection3d rod1 = new Projection3d(complexString3, lineVector1, lineVector1.Length, true);
                        rod1.Transform(matrix);
                        outputs.Add(outputName + "RodEnd1", rod1);

                    }
                }

                else if (rodEndType == 4 || rodEndType == 5)
                {
                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(0, 0, -strutB.thickness1);
                    symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(1, 0, 0));
                    Projection3d cylinder = (Projection3d)symbolGeometryHelper.CreateCylinder(null, strutB.diameter1 / 2, -strutB.thickness1);
                    cylinder.Transform(matrix);
                    outputs.Add(outputName + "RodEnd1", cylinder);

                }

                double offsetZ;
                if (strutB.rodEndType == 2 && strutB.Nut.ShapeWidth1 < strutB.diameter1)
                {
                    offsetZ = (strutB.diameter1 / 2) - Math.Sqrt(Math.Pow((strutB.diameter1 / 2), 2) - (Math.Pow((strutB.Nut.ShapeWidth1 / 2), 2)));
                    strutB.Nut.ShapeLength = strutB.Nut.ShapeLength + offsetZ;
                }
                else
                {
                    offsetZ = 0;
                }

                arcMatrix = new Matrix4X4();
                arcMatrix.SetIdentity();
                arcMatrix.Translate(new Vector(0, 0, cur_Zpos - offsetZ));
                AddNut(strutB.Nut, arcMatrix, outputs, outputName + "Shape1");

                Geometry3d nut = (Geometry3d)outputs[outputName + "Shape1"];
                if (nut != null)
                    nut.Transform(matrix);

            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddStrutBMethod, "Error in AddStrutB");
                }
            }
        }

        /// <summary>
        /// Create the graphical representation of multiple plates in a row.
        /// </summary>
        /// <param name="width">Width of item that we want position on-Double</param>
        /// <param name="Qty">Quantity of plates to be placed-Double</param>
        /// <param name="LocateBy">Can be 0 - Nothing, 1 - Center or 2 - Edge-Double</param>
        /// <param name="Location">distance from Locate by to position the plate-Double</param>
        /// <param name="PlateWidth">Width of the Gusset Plate-Double</param>
        /// <param name="PlateHeight">Height of the Gusset Plate-Double</param>
        /// <param name="PlateThickness">Thickness of the Gusset-Double</param>
        /// <param name="matrix">Transformation matrix for the row. (ie: rotation and translation)-Matrix4X4</param> 
        /// <param name="outputcoll">Collection of declared outputs, which is indexed by the name of the outputs declared as defining SymbolOutputs on the AspectDefinition field- OutputDictionary.</param>
        /// <param name="Output">Specifies the distance between the structure port and the RodEnd port-Double.</param>
        ///<code>
        ///Matrix4X4 matrix = new Matrix4X4();
        ///matrix.Origin = new Position(0,0,0);
        ///AddGussetsByRow(guide.Length2, multi1Qty, multi1LocateBy, multi1Location, width5, length5, thickness5, width6, length6, matrix, m_PhysicalAspect.Outputs, "Gussets", 2);
        ///</code>
        public void AddGussetsByRow(Double width, Double qty, Double locateBy, Double location, Double plateWidth, Double plateHeight, Double plateThickness, Matrix4X4 matrix, OutputDictionary outputs, String outputName, int row)
        {
            try
            {
                SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();

                double[] XLocation = new double[(int)(qty)];
                int i;

                for (i = 0; i <= qty - 1; i++)
                {
                    XLocation[i] = MultiPosition(width, qty, locateBy, location, plateThickness)[i];
                }

                PlateInputs plateShape = new PlateInputs();
                plateShape.width1 = plateWidth;
                plateShape.length1 = plateHeight;
                plateShape.thickness1 = plateThickness;
                plateShape.trCornerType = 3;
                Matrix4X4 plateMatrix = new Matrix4X4();

                for (i = 0; i <= qty - 1; i++)
                {
                    if (row % 2 == 0)
                    {
                        plateMatrix.SetIdentity();
                        plateMatrix.Rotate((Math.PI / 2), new Vector(1, 0, 0));

                        plateMatrix.Rotate(3 * (Math.PI / 2), new Vector(0, 0, 1));

                        plateMatrix.Translate(new Vector(-(-width / 2 + XLocation[i] - plateThickness / 2), 0, 0));

                        AddPlate(plateShape, plateMatrix, outputs, outputName + i + row);
                        Projection3d pro = (Projection3d)outputs[outputName + i + row];
                        pro.Transform(matrix);
                    }
                    else
                    {
                        plateMatrix.SetIdentity();
                        plateMatrix.Rotate((Math.PI / 2), new Vector(1, 0, 0));

                        plateMatrix.Rotate(3 * (Math.PI / 2), new Vector(0, 0, 1));

                        plateMatrix.Translate(new Vector(-width / 2 + XLocation[i] + plateThickness / 2, 0, 0));

                        AddPlate(plateShape, plateMatrix, outputs, outputName + i + row);
                        Projection3d pro = (Projection3d)outputs[outputName + i + row];
                        pro.Transform(matrix);
                    }

                }
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddGussetsByRow, "Error in AddGussetsByRow");
            }
        }
        /// <summary>
        /// Adds the UBolt outputs.User symbol calls this method during AdditionalOutputs
        /// to define additional outputs for an aspect. The list of outputs returned by this method will be the outputs for the aspect
        /// in addition to the outputs that are already defined as attributes on the aspect.
        /// </summary>
        /// <param name="additionalOutputs">The additional outputs.</param>
        ///<code>
        ///public override IEnumerable<OutputDefinition> AdditionalOutputs(string aspectName)
        ///{
        ///    List<OutputDefinition> additionalOutputs = new List<OutputDefinition>();
        ///    if (aspectName == "Symbolic")
        ///    {
        ///       AddUBoltOutputs(additionalOutputs);
        ///    }
        ///    return additionalOutputs;
        ///}
        ///</code> 
        public void AddUBoltOutputs(List<OutputDefinition> additionalOutputs)
        {
            try
            {
                additionalOutputs.Add(new OutputDefinition("UBolt" + "StraightDia1Left", "UBolt" + "StraightDia1Left"));
                additionalOutputs.Add(new OutputDefinition("UBolt" + "StraightDia1Right", "UBolt" + "StraightDia1Right"));
                additionalOutputs.Add(new OutputDefinition("UBolt" + "StraightDia2Left", "UBolt" + "StraightDia2Left"));
                additionalOutputs.Add(new OutputDefinition("UBolt" + "StraightDia2Right", "UBolt" + "StraightDia2Right"));
                additionalOutputs.Add(new OutputDefinition("UBolt" + "Elbow", "UBolt" + "Elbow"));
                additionalOutputs.Add(new OutputDefinition("UBolt" + "FlatElbowLeft", "UBolt" + "FlatElbowLeft"));
                additionalOutputs.Add(new OutputDefinition("UBolt" + "FlatElbowRight", "UBolt" + "FlatElbowRight"));
                additionalOutputs.Add(new OutputDefinition("UBolt" + "FlatSpot", "UBolt" + "FlatSpot"));
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrUBoltAdditionalOutputs, "Error in adding UBolt outputs");
            }
        }
        ///BlockClamp
        /// <summary>
        /// Defines the inputs for the BlockClamp.
        /// </summary>
        public struct BlockClampInputs
        {
            /// <summary>
            /// Determines the diameter of the first pipe the block clamp is for
            /// </summary>
            public double Diameter1;
            /// <summary>
            /// Determines the diameter of the second pipe the block clamp is for
            /// </summary>
            public double Diameter2;
            /// <summary>
            /// The distance from the pipe CL to where the rod connects.
            /// </summary>
            public double RodTakeOut;
            /// <summary>
            /// The thickness of the top plate. If left blank, the top Plate is not drawn
            /// </summary>
            public double Thickness1;
            /// <summary>
            /// The length of the top plate.
            /// </summary>
            public double Length1;
            /// <summary>
            /// The width of the top plate
            /// </summary>
            public double Width1;
            /// <summary>
            /// The thickness of the bottom plate. If left blank, the top Plate is not drawn
            /// </summary>
            public double Thickness2;
            /// <summary>
            /// The length of the bottom plate
            /// </summary>
            public double Length2;
            /// <summary>
            /// The width of the bottom plate
            /// </summary>
            public double Width2;
            /// <summary>
            /// Name of middle bottom Plate shape. The middle bottom plate is modeled using the existing plate shape. In case of two pipes, two plate shapes are used side by side.
            /// The pipe dents are also modeled using the attributes provided by the plate shape. If more than two pipes are supported then the pipe holes/dents are not drawn
            /// </summary>
            public string MidPlateBotShape;
            /// <summary>
            /// Name of middle top Plate shape. The middle top plate is modeled using the existing plate shape. In case of two pipes, two plate shapes are used side by side.
            /// The pipe dents/holes are also modeled using the attributes provided by the plate shape. If more than two pipes are supported then the pipe holes/dents are not drawn
            /// </summary>
            public string MidPlateTopShape;
            /// <summary>
            /// The thickness of the base plate. If not provided or Thickness3 = 0, the base plate is not drawn
            /// </summary>
            public double Thickness3;
            /// <summary>
            ///The length of the base plate
            /// </summary>
            public double Length3;
            /// <summary>
            /// The width of the base plate
            /// </summary>
            public double Width3;
            /// <summary>
            /// The thickness of the vertical plate or stanchion. Thickness4 must be > 0 for the vertical plate or stanchion to be drawn
            /// </summary>
            public double Thickness4;
            /// <summary>
            /// The length of the vertical plate. If the Length4 = 0, a stanchion is drawn instead of a vertical plate
            /// </summary>
            public double Length4;
            /// <summary>
            /// The width of the vertical plate. If Length4 = 0,  Width4 specifies the diameter of the stanchion
            /// </summary>
            public double Width4;
            /// <summary>
            /// The thickness of the channel clips. The channel clips are only  drawn if Thickness5 > 0 
            /// </summary>
            public double Thickness5;
            /// <summary>
            /// The length of the channel clips.
            /// </summary>
            public double Length5;
            /// <summary>
            /// The width of the channel clips
            /// </summary>
            public double Width5;
            /// <summary>
            /// The distance between the channel clips
            /// </summary>
            public double Width6;
            /// <summary>
            /// The length of the bolt. Pin1Diameter and Pin1Length must be greater than 0 for the bolts to be drawn
            /// </summary>
            public double Pin1Length;
            /// <summary>
            /// The diameter of the bolt. Pin1Diameter and Pin1Length must be greater than 0 for the bolts to be drawn
            /// </summary>
            public double Pin1Diameter;
            /// <summary>
            /// Distance from Pipe CL of the first pipe to the top of the Block Clamp
            /// </summary>
            public double Height1;
            /// <summary>
            /// Distance from Pipe CL  of the first pipe to the bottom of the Block Clamp
            /// </summary>
            public double Height2;
            /// <summary>
            /// The distance from the bottom of the block clamp to the Pipe CL of the second pipe
            /// </summary>
            public double Height3;
            /// <summary>
            /// Lateral offset if block clamp is not centered around the pipe. If the number of pipes is greater than 1, offset1 defines the distance between the pipes
            /// </summary>
            public double Offset1;
            /// <summary>
            /// Lateral distance from the center of the pipe to the edge of the block. Only used if number of pipes less than 2  and offset1 = 0 
            /// </summary>
            public double Offset2;
            /// <summary>
            /// Distance between blocks. Only used if there are two blocks. If less than Block Width  then only 1 block is shown.If greater than or equal to the block width then two are drawn
            /// </summary>
            public double Offset3;
            /// <summary>
            /// Distance from the center of the block clamp to the center of the bolt. Offset4 is used to offset  bolt row 1 
            /// </summary>
            public double Offset4;
            /// <summary>
            /// Specifies the Quantity of bolts in each bolt row. See the multi-position spec for more details. If the Qty is zero for any row, there will be no bolt graphics in that row.
            /// </summary>
            public double Multi1Qty;
            /// <summary>
            /// Defines how to locate the bolts in a respective row. Allowed options are by center or by edge
            /// </summary>
            public double Multi1LocateBy;
            /// <summary>
            /// Specifies the spacing of the location based of the locate-by attribute. See the multi-position spec for more details
            /// </summary>
            public double Multi1Location;
            /// <summary>
            /// Distance from the center of the block clamp to the center of the bolt. Offset5  is used to offset  bolt row 2
            /// </summary>
            public double Offset5;
            /// <summary>
            /// Specifies the Quantity of bolts in each bolt row. See the multi-position spec for more details. If the Qty is zero for any row, there will be no bolt graphics in that row.
            /// </summary>
            public double Multi2Qty;
            /// <summary>
            /// Defines how to locate the bolts in a respective row. Allowed options are by center or by edge
            /// </summary>
            public double Multi2LocateBy;
            /// <summary>
            /// Specifies the spacing of the location based of the locate-by attribute. See the multi-position spec for more details
            /// </summary>
            public double Multi2Location;
            /// <summary>
            /// The graphic shape to use for the top connection graphic.
            /// </summary>
            public double ShapeType;
            /// <summary>
            /// The thickness of top/down connection shape, from the outside face of the clamp, to the outside face of the side connection. 
            /// </summary>
            public double Thickness6;
            /// <summary>
            /// The outside dimension of the top/down connection shape.
            /// </summary>
            public double Width7;
            /// <summary>
            /// For NutShape 2 (square), use Width8 to create a rectangle shape instead of a square. If zero or not specified, NutShape 2 will be drawn square shape
            /// </summary>
            public double Width8;

        }
        /// <summary>
        /// Adds the BlockClamp inputs.
        /// </summary>        
        /// <param name="startIndex">The start index.</param>
        /// <param name="endIndex">The end index.</param>
        /// <param name="additionalInputs">The additional inputs.</param>
        /// <code>
        /// int endIndex;
        /// List<Input> additionalInputs = new List<Input>();
        /// AddBlockClampInputs(2, out endIndex, additionalInputs);
        /// </code>
        public void AddBlockClampInputs(int startIndex, out int endIndex, List<Input> additionalInputs)
        {
            try
            {
                additionalInputs.Add(new InputDouble(startIndex, "Diameter1", "Diameter1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Diameter2", "Diameter2", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "RodTakeOut", "RodTakeOut", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Thickness1", "Thickness1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Length1", "Length1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Width1", "Width1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Thickness2", "Thickness2", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Length2", "Length2", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Width2", "Width2", 0, false));
                additionalInputs.Add(new InputString(++startIndex, "MidPlateBotShape", "MidPlateBotShape", "No Value", false));
                additionalInputs.Add(new InputString(++startIndex, "MidPlateTopShape", "MidPlateTopShape", "No Value", false));
                additionalInputs.Add(new InputDouble(++startIndex, "Thickness3", "Thickness3", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Length3", "Length3", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Width3", "Width3", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Thickness4", "Thickness4", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Length4", "Length4", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Width4", "Width4", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Thickness5", "Thickness5", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Length5", "Length5", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Width5", "Width5", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Width6", "Width6", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Pin1Length", "Pin1Length", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Pin1Diameter", "Pin1Diameter", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Height1", "Height1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Height2", "Height2", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Height3", "Height3", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Offset1", "Offset1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Offset2", "Offset2", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Offset3", "Offset3", 0, false));

                // Bolt Rows
                additionalInputs.Add(new InputDouble(++startIndex, "Offset4", "Offset4", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Multi1Qty", "Multi1Qty", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Multi1LocateBy", "Multi1LocateBy", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Multi1Location", "Multi1Location", 0, false));

                additionalInputs.Add(new InputDouble(++startIndex, "Offset5", "Offset5", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Multi2Qty", "Multi2Qty", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Multi2LocateBy", "Multi2LocateBy", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Multi2Location", "Multi2Location", 0, false));

                additionalInputs.Add(new InputDouble(++startIndex, "ShapeType", "ShapeType", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Thickness6", "Thickness6", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Width7", "Width7", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Width8", "Width8", 0, false));

            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddBlockClampInputs, "Error in adding adding BlockClamp Inputs");
                }
            }
            endIndex = ++startIndex;
        }
        /// <summary>
        /// Adds the BlockClamp outputs.
        /// </summary>       
        /// <param name="aspectName">Name of the aspect.</param>
        /// <param name="additionalOutputs">The additional outputs.</param>
        /// <code>
        ///  List<OutputDefinition> additionalOutputs = new List<OutputDefinition>();
        ///  AddBlockClampOutputs(aspectName, additionalOutputs);
        /// </code>
        public void AddBlockClampOutputs(string aspectName, List<OutputDefinition> additionalOutputs)
        {
            try
            {   //These are the outputs for the Block Clamp
                additionalOutputs.Add(new OutputDefinition("BlockClamp", "TopPlate"));
                additionalOutputs.Add(new OutputDefinition("BlockClamp", "BotPlate"));
                additionalOutputs.Add(new OutputDefinition("BlockClamp", "MiddleTop"));
                additionalOutputs.Add(new OutputDefinition("BlockClamp", "MiddleBot"));
                additionalOutputs.Add(new OutputDefinition("BlockClamp", "BasePlate"));
                additionalOutputs.Add(new OutputDefinition("BlockClamp", "Stanchion"));
                additionalOutputs.Add(new OutputDefinition("BlockClamp", "ChannelClip1"));
                additionalOutputs.Add(new OutputDefinition("BlockClamp", "ChannelClip2"));
                additionalOutputs.Add(new OutputDefinition("BlockClamp", "ThreadedConnection"));

                //bolts
                for (int I = 1; I <= 2; I++)
                {
                    for (int M = 0; M <= 1; M++)
                        additionalOutputs.Add(new OutputDefinition("BlockClamp" + "Bolt" + I + M, "BlockClamp" + "Bolt" + I + M));
                }


            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddBlockClampOutputs, "Error in adding BlockClamp outputs");
                }
            }
        }
        /// <summary>
        /// Loads the BlockClamp data.
        /// </summary>        
        /// <param name="startIndex">The start index.</param>
        /// /// <code>
        ///  BlockClampInputs blockClamp = LoadBlockClampData(2);
        /// </code>
        public BlockClampInputs LoadBlockClampData(int startIndex)
        {
            BlockClampInputs BlockClamp = new BlockClampInputs();
            try
            {
                BlockClamp.Diameter1 = GetDoubleInputValue(startIndex);
                BlockClamp.Diameter2 = GetDoubleInputValue(++startIndex);
                BlockClamp.RodTakeOut = GetDoubleInputValue(++startIndex);
                BlockClamp.Thickness1 = GetDoubleInputValue(++startIndex);
                BlockClamp.Length1 = GetDoubleInputValue(++startIndex);
                BlockClamp.Width1 = GetDoubleInputValue(++startIndex);
                BlockClamp.Thickness2 = GetDoubleInputValue(++startIndex);
                BlockClamp.Length2 = GetDoubleInputValue(++startIndex);
                BlockClamp.Width2 = GetDoubleInputValue(++startIndex);
                BlockClamp.MidPlateBotShape = GetStringInputValue(++startIndex);
                BlockClamp.MidPlateTopShape = GetStringInputValue(++startIndex);

                BlockClamp.Thickness3 = GetDoubleInputValue(++startIndex);
                BlockClamp.Length3 = GetDoubleInputValue(++startIndex);
                BlockClamp.Width3 = GetDoubleInputValue(++startIndex);
                BlockClamp.Thickness4 = GetDoubleInputValue(++startIndex);
                BlockClamp.Length4 = GetDoubleInputValue(++startIndex);
                BlockClamp.Width4 = GetDoubleInputValue(++startIndex);
                BlockClamp.Thickness5 = GetDoubleInputValue(++startIndex);
                BlockClamp.Length5 = GetDoubleInputValue(++startIndex);
                BlockClamp.Width5 = GetDoubleInputValue(++startIndex);
                BlockClamp.Width6 = GetDoubleInputValue(++startIndex);
                BlockClamp.Pin1Length = GetDoubleInputValue(++startIndex);
                BlockClamp.Pin1Diameter = GetDoubleInputValue(++startIndex);
                BlockClamp.Height1 = GetDoubleInputValue(++startIndex);
                BlockClamp.Height2 = GetDoubleInputValue(++startIndex);
                BlockClamp.Height3 = GetDoubleInputValue(++startIndex);
                BlockClamp.Offset1 = GetDoubleInputValue(++startIndex);
                BlockClamp.Offset2 = GetDoubleInputValue(++startIndex);
                BlockClamp.Offset3 = GetDoubleInputValue(++startIndex);

                BlockClamp.Offset4 = GetDoubleInputValue(++startIndex);
                BlockClamp.Multi1Qty = GetDoubleInputValue(++startIndex);
                BlockClamp.Multi1LocateBy = GetDoubleInputValue(++startIndex);
                BlockClamp.Multi1Location = GetDoubleInputValue(++startIndex);

                BlockClamp.Offset5 = GetDoubleInputValue(++startIndex);
                BlockClamp.Multi2Qty = GetDoubleInputValue(++startIndex);
                BlockClamp.Multi2LocateBy = GetDoubleInputValue(++startIndex);
                BlockClamp.Multi2Location = GetDoubleInputValue(++startIndex);

                BlockClamp.ShapeType = GetDoubleInputValue(++startIndex);
                BlockClamp.Thickness6 = GetDoubleInputValue(++startIndex);
                BlockClamp.Width7 = GetDoubleInputValue(++startIndex);
                BlockClamp.Width8 = GetDoubleInputValue(++startIndex);

                return BlockClamp;
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadBlockClampData, "Error in LoadBlockClampData");
                }
                return BlockClamp;
            }
        }
        /// <summary>
        /// Loads the values associated to the given shape into the PlateInputs type 
        /// This is done by querying the database for the given name.
        /// </summary>
        /// <param name="startIndex">refShapeName</param>
        /// <returns></returns>
        ///<code>
        ///PlateInputs plate = LoadPlateDataByQuery(blockClamp.MidPlateTopShape);
        ///</code>
        public PlateInputs LoadPlateDataByQuery(string refShapeName)
        {
            PlateInputs plate = new PlateInputs();
            try
            {
                if (!(refShapeName == string.Empty || refShapeName == "No Value" || refShapeName == null))
                {
                    Catalog plantCatalog = MiddleServiceProvider.SiteMgr.ActiveSite.ActivePlant.PlantCatalog;
                    BusinessObject plateAuxilaryTable = plantCatalog.GetNamedObject(refShapeName);
                    // Basic Plate Dimensions
                    GetDoublePropertyValue(plateAuxilaryTable, "IJUAhsWidth1", "Width1", ref  plate.width1);
                    GetDoublePropertyValue(plateAuxilaryTable, "IJUAhsLength1", "Length1", ref plate.length1);
                    GetDoublePropertyValue(plateAuxilaryTable, "IJUAhsThickness1", "Thickness1", ref plate.thickness1);

                    // Top Left Corner
                    GetCodeListValue(plateAuxilaryTable, "IJUAhsTLCorner", "TLCornerType", ref plate.tlCornerType);
                    GetDoublePropertyValue(plateAuxilaryTable, "IJUAhsTLCorner", "TLCornerX", ref plate.tlCornerX);
                    GetDoublePropertyValue(plateAuxilaryTable, "IJUAhsTLCorner", "TLCornerY", ref plate.tlCornerY);
                    GetDoublePropertyValue(plateAuxilaryTable, "IJUAhsTLCorner", "TLCornerRadius", ref plate.tlCornerRad);

                    // Top Right Corner
                    GetCodeListValue(plateAuxilaryTable, "IJUAhsTRCorner", "TRCornerType", ref plate.trCornerType);
                    GetDoublePropertyValue(plateAuxilaryTable, "IJUAhsTRCorner", "TRCornerX", ref plate.trCornerX);
                    GetDoublePropertyValue(plateAuxilaryTable, "IJUAhsTRCorner", "TRCornerY", ref plate.trCornerY);
                    GetDoublePropertyValue(plateAuxilaryTable, "IJUAhsTRCorner", "TRCornerRadius", ref plate.trCornerRad);

                    //Bottom Left Corner
                    GetCodeListValue(plateAuxilaryTable, "IJUAhsBLCorner", "BLCornerType", ref plate.blCornerType);
                    GetDoublePropertyValue(plateAuxilaryTable, "IJUAhsBLCorner", "BLCornerX", ref plate.blCornerX);
                    GetDoublePropertyValue(plateAuxilaryTable, "IJUAhsBLCorner", "BLCornerY", ref plate.blCornerY);
                    GetDoublePropertyValue(plateAuxilaryTable, "IJUAhsBLCorner", "BLCornerRadius", ref plate.blCornerRad);

                    // Bottom Right Corner                   
                    GetCodeListValue(plateAuxilaryTable, "IJUAhsBRCorner", "BRCornerType", ref plate.brCornerType);
                    GetDoublePropertyValue(plateAuxilaryTable, "IJUAhsBRCorner", "BRCornerX", ref plate.brCornerX);
                    GetDoublePropertyValue(plateAuxilaryTable, "IJUAhsBRCorner", "BRCornerY", ref plate.brCornerY);
                    GetDoublePropertyValue(plateAuxilaryTable, "IJUAhsBRCorner", "BRCornerRadius", ref plate.brCornerRad);

                    // Curved End                    
                    GetDoublePropertyValue(plateAuxilaryTable, "IJUAhsCurvedEnd", "CurvedEndRad", ref plate.curvedEndRad);
                    GetDoublePropertyValue(plateAuxilaryTable, "IJUAhsCurvedEnd", "CurvedEndX", ref plate.curvedEndX);
                    GetDoublePropertyValue(plateAuxilaryTable, "IJUAhsCurvedEnd", "CurvedEndY", ref plate.curvedEndY);

                }

                return plate;
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadPlateDataByQuery, "Error in LoadPlateDataByQuery");
                }
                return plate;
            }
        }
        /// <summary>
        /// This method will be called to check property is available on the supportcomponent and support return its value.
        /// </summary>
        /// <param name="part">supportcomponent or support is of type bussiness object</param>
        /// <param name="interfaceName">Interface to which the property belongs.</param>
        /// <param name="propertyName">Name of property.</param>
        /// <param name="propertyValue">Returns Property Value</param>
        /// <returns></returns>
        /// <code>
        /// GetDoublePropertyValue(part, "IJUAhsHeight1","Height1",ref propertyValue)
        /// </code>
        public static void GetDoublePropertyValue(BusinessObject part, string interfaceName, string propertyName, ref double propertyValue)
        {
            try
            {
                propertyValue = (double)((PropertyValueDouble)part.GetPropertyValue(interfaceName, propertyName)).PropValue;
            }
            catch
            {
                propertyValue = 0;
            }
        }
        /// <summary>
        /// This method will be called to check property is available on the supportcomponent and support return its value.
        /// </summary>
        /// <param name="part">supportcomponent or support is of type bussiness object</param>
        /// <param name="interfaceName">Interface to which the property belongs.</param>
        /// <param name="propertyName">Name of property.</param>
        /// <param name="propertyValue">Returns Property Value</param>
        /// <returns></returns>
        /// <code>
        /// GetCodeListValue(part, "IJUAhsHeight1","Height1",ref propertyValue)
        /// </code>
        public static void GetCodeListValue(BusinessObject part, string interfaceName, string propertyName, ref int propertyValue)
        {
            try
            {

                propertyValue = (int)((PropertyValueCodelist)part.GetPropertyValue(interfaceName, propertyName)).PropValue;
            }
            catch
            {
                propertyValue = 0;
            }
        }


        /// <summary>
        /// Create the graphical representation of a BlockClamp.
        /// </summary>
        /// <param name="blockClamp">Structure for specifying the inputs for the blockclamp -BlockClampInputs </param>
        /// <param name="matrix">string to specify the position and oreintation the graphics - String.</param>
        /// <param name="outputs">Collection of declared outputs, which is indexed by the name of the outputs declared as defining SymbolOutputs on the AspectDefinition field- OutputDictionary</param>
        /// <param name="outputName">Output that this graphic is being placed on-String</param>
        ///<code>
        ///Matrix4X4 matrix = new Matrix4X4();
        ///matrix.Origin = new Position(0,0,0);
        ///AddBlockClamp(BlockClampInputs blockClamp, Matrix4X4 matrix, OutputDictionary outputs, String outputName);
        ///</code>
        public void AddBlockClamp(BlockClampInputs blockClamp, Matrix4X4 matrix, OutputDictionary outputs, String outputName)
        {
            try
            {
                // Middle Plates
                PlateInputs midTopPlate = LoadPlateDataByQuery(blockClamp.MidPlateTopShape);
                PlateInputs midBotPlate = LoadPlateDataByQuery(blockClamp.MidPlateBotShape);

                // Make graphics
                // Base Plate
                SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();
                Matrix4X4 rotateMatrix = new Matrix4X4();
                if (blockClamp.Width3 > 0 && blockClamp.Length3 > 0 && blockClamp.Thickness3 > 0)
                {
                    if (HgrCompareDoubleService.cmpdbl(blockClamp.Width2, 0) == true && HgrCompareDoubleService.cmpdbl(blockClamp.Length2, 0) == true && HgrCompareDoubleService.cmpdbl(blockClamp.Thickness2, 0) == true && midBotPlate.curvedEndY > 0)
                    {
                        symbolGeometryHelper.ActivePosition = new Position(-(blockClamp.Width3 / 2), -(blockClamp.Length3 / 2), -midBotPlate.length1 - midBotPlate.curvedEndY - blockClamp.Thickness4 - blockClamp.Thickness3);
                        Projection3d basePlate = (Projection3d)symbolGeometryHelper.CreateBox(null, blockClamp.Width3, blockClamp.Length3, blockClamp.Thickness3, 9);
                        rotateMatrix.Rotate(3 * Math.PI / 2, new Vector(0, 0, 1));
                        basePlate.Transform(rotateMatrix);
                        basePlate.Transform(matrix);
                        outputs.Add(outputName + "BasePlate", basePlate);
                    }
                    else if (HgrCompareDoubleService.cmpdbl(blockClamp.Width2, 0) == true && HgrCompareDoubleService.cmpdbl(blockClamp.Length2, 0) == true && HgrCompareDoubleService.cmpdbl(blockClamp.Thickness2, 0) == true && midBotPlate.curvedEndY < 0)
                    {
                        symbolGeometryHelper.ActivePosition = new Position(-(blockClamp.Width3 / 2), -(blockClamp.Length3 / 2), -midBotPlate.length1 - midBotPlate.curvedEndY - blockClamp.Thickness4 - blockClamp.Thickness3);
                        Projection3d basePlate = (Projection3d)symbolGeometryHelper.CreateBox(null, blockClamp.Width3, blockClamp.Length3, blockClamp.Thickness3, 9);
                        rotateMatrix.Rotate(3 * Math.PI / 2, new Vector(0, 0, 1));
                        basePlate.Transform(rotateMatrix);
                        basePlate.Transform(matrix);
                        outputs.Add(outputName + "BasePlate", basePlate);
                    }
                    else if (HgrCompareDoubleService.cmpdbl(blockClamp.Width2, 0) == true && HgrCompareDoubleService.cmpdbl(blockClamp.Length2, 0) == true && HgrCompareDoubleService.cmpdbl(blockClamp.Thickness2, 0) == true && HgrCompareDoubleService.cmpdbl(midBotPlate.curvedEndY, 0) == true && HgrCompareDoubleService.cmpdbl(midBotPlate.curvedEndRad, 0) == true)
                    {
                        symbolGeometryHelper.ActivePosition = new Position(-(blockClamp.Width4 / 2), -(blockClamp.Length4 / 2), -midBotPlate.length1 - blockClamp.Diameter1 / 2 - blockClamp.Thickness4 - blockClamp.Thickness3);
                        Projection3d basePlate = (Projection3d)symbolGeometryHelper.CreateBox(null, blockClamp.Width3, blockClamp.Length3, blockClamp.Thickness3, 9);
                        rotateMatrix.Rotate(3 * Math.PI / 2, new Vector(0, 0, 1));
                        basePlate.Transform(rotateMatrix);
                        basePlate.Transform(matrix);
                        outputs.Add(outputName + "BasePlate", basePlate);
                    }
                    else
                    {
                        symbolGeometryHelper.ActivePosition = new Position(-(blockClamp.Width3 / 2), -(blockClamp.Length3 / 2), -blockClamp.Height2 - blockClamp.Thickness4 - blockClamp.Thickness3);
                        Projection3d basePlate = (Projection3d)symbolGeometryHelper.CreateBox(null, blockClamp.Width3, blockClamp.Length3, blockClamp.Thickness3, 9);
                        rotateMatrix.Rotate(3 * Math.PI / 2, new Vector(0, 0, 1));
                        basePlate.Transform(rotateMatrix);
                        basePlate.Transform(matrix);
                        outputs.Add(outputName + "BasePlate", basePlate);
                    }
                }

                // Stanchion
                if (blockClamp.Width4 > 0 && blockClamp.Length4 > 0 && blockClamp.Thickness4 > 0)
                {
                    symbolGeometryHelper = new SymbolGeometryHelper();
                    if (HgrCompareDoubleService.cmpdbl(blockClamp.Width2, 0) == true && HgrCompareDoubleService.cmpdbl(blockClamp.Length2, 0) == true && HgrCompareDoubleService.cmpdbl(blockClamp.Thickness2, 0) == true && midBotPlate.curvedEndY > 0)
                    {
                        symbolGeometryHelper.ActivePosition = new Position(-(blockClamp.Width4 / 2), -(blockClamp.Length4 / 2), -midBotPlate.length1 - midBotPlate.curvedEndY - blockClamp.Thickness4);
                        Projection3d stanchion = (Projection3d)symbolGeometryHelper.CreateBox(null, blockClamp.Width4, blockClamp.Length4, blockClamp.Thickness4, 9);
                        rotateMatrix = new Matrix4X4();
                        rotateMatrix.Rotate(3 * Math.PI / 2, new Vector(0, 0, 1));
                        stanchion.Transform(rotateMatrix);
                        stanchion.Transform(matrix);
                        outputs.Add(outputName + "Stanchion", stanchion);
                    }
                    else if (HgrCompareDoubleService.cmpdbl(blockClamp.Width2, 0) == true && HgrCompareDoubleService.cmpdbl(blockClamp.Length2, 0) == true && HgrCompareDoubleService.cmpdbl(blockClamp.Thickness2, 0) == true && midBotPlate.curvedEndY < 0)
                    {
                        symbolGeometryHelper.ActivePosition = new Position(-(blockClamp.Width4 / 2), -(blockClamp.Length4 / 2), -midBotPlate.length1 - midBotPlate.curvedEndY - blockClamp.Thickness4);
                        Projection3d stanchion = (Projection3d)symbolGeometryHelper.CreateBox(null, blockClamp.Width4, blockClamp.Length4, blockClamp.Thickness4, 9);
                        rotateMatrix = new Matrix4X4();
                        rotateMatrix.Rotate(3 * Math.PI / 2, new Vector(0, 0, 1));
                        stanchion.Transform(rotateMatrix);
                        stanchion.Transform(matrix);
                        outputs.Add(outputName + "Stanchion", stanchion);
                    }
                    else if (HgrCompareDoubleService.cmpdbl(blockClamp.Width2, 0) == true && HgrCompareDoubleService.cmpdbl(blockClamp.Length2, 0) == true && HgrCompareDoubleService.cmpdbl(blockClamp.Thickness2, 0) == true && HgrCompareDoubleService.cmpdbl(midBotPlate.curvedEndY, 0) == true && HgrCompareDoubleService.cmpdbl(midBotPlate.curvedEndRad, 0) == true)
                    {
                        symbolGeometryHelper.ActivePosition = new Position(-(blockClamp.Width4 / 2), -(blockClamp.Length4 / 2), -midBotPlate.length1 - blockClamp.Diameter1 / 2 - blockClamp.Thickness4);
                        Projection3d stanchion = (Projection3d)symbolGeometryHelper.CreateBox(null, blockClamp.Width4, blockClamp.Length4, blockClamp.Thickness4, 9);
                        rotateMatrix = new Matrix4X4();
                        rotateMatrix.Rotate(3 * Math.PI / 2, new Vector(0, 0, 1));
                        stanchion.Transform(rotateMatrix);
                        stanchion.Transform(matrix);
                        outputs.Add(outputName + "Stanchion", stanchion);
                    }
                    else
                    {
                        symbolGeometryHelper.ActivePosition = new Position(-(blockClamp.Width4 / 2), -(blockClamp.Length4 / 2), -blockClamp.Height2 - blockClamp.Thickness4);
                        Projection3d stanchion = (Projection3d)symbolGeometryHelper.CreateBox(null, blockClamp.Width4, blockClamp.Length4, blockClamp.Thickness4, 9);
                        rotateMatrix = new Matrix4X4();
                        rotateMatrix.Rotate(3 * Math.PI / 2, new Vector(0, 0, 1));
                        stanchion.Transform(rotateMatrix);
                        stanchion.Transform(matrix);
                        outputs.Add(outputName + "Stanchion", stanchion);
                    }
                }

                // Block Clamp Shape
                Matrix4X4 clampShapeMatrix = new Matrix4X4();
                if (blockClamp.Diameter1 > 0 && blockClamp.Diameter2 > 0 && blockClamp.Offset1 > 0 && HgrCompareDoubleService.cmpdbl(blockClamp.Height3, 0) == true)
                {
                    clampShapeMatrix.Translate(new Vector(0, -blockClamp.Offset1 / 2, 0));
                    AddBlockClampShape(blockClamp, clampShapeMatrix, outputs, "BlockClampShape1");
                    clampShapeMatrix = new Matrix4X4();
                    clampShapeMatrix.Translate(clampShapeMatrix.Transform(new Vector(0, blockClamp.Offset1 / 2, 0)));
                    AddBlockClampShape(blockClamp, clampShapeMatrix, outputs, "BlockClampShape2");
                }
                else if (blockClamp.Diameter1 > 0 && blockClamp.Diameter2 > 0 && blockClamp.Offset1 > 0 && blockClamp.Height3 > 0)
                {
                    if (HgrCompareDoubleService.cmpdbl(blockClamp.Width1, 0) == true && HgrCompareDoubleService.cmpdbl(blockClamp.Width2, 0) == true)
                    {
                        clampShapeMatrix.Translate(new Vector(0, -blockClamp.Offset1 / 2, 0));
                        AddBlockClampShape(blockClamp, clampShapeMatrix, outputs, "BlockClampShape1");
                        clampShapeMatrix = new Matrix4X4();
                        clampShapeMatrix.Rotate(Math.PI, new Vector(1, 0, 0));
                        clampShapeMatrix.Translate(new Vector(0, blockClamp.Offset1 / 2, blockClamp.Height3 - blockClamp.Height2));
                        AddBlockClampShape(blockClamp, clampShapeMatrix, outputs, "BlockClampShape2");
                    }
                    else
                    {
                        clampShapeMatrix.Translate(new Vector(0, -blockClamp.Offset1 / 2, 0));
                        AddBlockClampShape(blockClamp, clampShapeMatrix, outputs, "BlockClampShape1");
                        clampShapeMatrix = new Matrix4X4();
                        clampShapeMatrix.Rotate(Math.PI, new Vector(1, 0, 0));
                        clampShapeMatrix.Translate(new Vector(0, blockClamp.Offset1 / 2, 0));
                        AddBlockClampShape(blockClamp, clampShapeMatrix, outputs, "BlockClampShape2");
                    }
                }
                else if (blockClamp.Diameter1 > 0 && blockClamp.Offset3 > 0)
                {
                    clampShapeMatrix.SetIdentity();
                    clampShapeMatrix.Translate(new Vector(-blockClamp.Offset3 / 2, 0, 0));
                    AddBlockClampShape(blockClamp, clampShapeMatrix, outputs, "BlockClampShape1");
                    clampShapeMatrix = new Matrix4X4();
                    clampShapeMatrix.SetIdentity();
                    clampShapeMatrix.Translate(new Vector(blockClamp.Offset3 / 2, 0, 0));
                    AddBlockClampShape(blockClamp, clampShapeMatrix, outputs, "BlockClampShape2");
                }
                else if (blockClamp.Diameter1 > 0)
                    AddBlockClampShape(blockClamp, clampShapeMatrix, outputs, "BlockClampShape1");

                // Threaded Connection
                if (blockClamp.Thickness6 > 0 && blockClamp.Width7 > 0 && blockClamp.Width8 > 0)
                {
                    NutInputs nutShape;
                    nutShape.ShapeType = (int)blockClamp.ShapeType;
                    nutShape.ShapeWidth1 = blockClamp.Width7;
                    nutShape.ShapeWidth2 = blockClamp.Width8;
                    nutShape.ShapeLength = blockClamp.Thickness6;

                    Matrix4X4 nutMatrix = new Matrix4X4();

                    if (HgrCompareDoubleService.cmpdbl(blockClamp.Width1, 0) == true && HgrCompareDoubleService.cmpdbl(blockClamp.Length1, 0) == true && HgrCompareDoubleService.cmpdbl(blockClamp.Thickness1, 0) == true && midTopPlate.curvedEndY > 0)
                    {
                        nutMatrix.Origin = new Position(0, 0, midTopPlate.length1 + midTopPlate.curvedEndY);
                        AddNut(nutShape, nutMatrix, outputs, outputName + "ThreadedConnection");
                        Projection3d nut1 = (Projection3d)outputs[outputName + "ThreadedConnection"];
                        nut1.Transform(matrix);
                    }

                    else if (HgrCompareDoubleService.cmpdbl(blockClamp.Width1, 0) == true && HgrCompareDoubleService.cmpdbl(blockClamp.Length1, 0) == true && HgrCompareDoubleService.cmpdbl(blockClamp.Thickness1, 0) == true && midTopPlate.curvedEndY < 0)
                    {
                        nutMatrix.Origin = new Position(0, 0, midTopPlate.length1 + midTopPlate.curvedEndY);
                        AddNut(nutShape, nutMatrix, outputs, outputName + "ThreadedConnection");
                        Projection3d nut1 = (Projection3d)outputs[outputName + "ThreadedConnection"];
                        nut1.Transform(matrix);
                    }
                    else if (HgrCompareDoubleService.cmpdbl(blockClamp.Width1, 0) == true && HgrCompareDoubleService.cmpdbl(blockClamp.Length1, 0) == true && HgrCompareDoubleService.cmpdbl(blockClamp.Thickness1, 0) == true && HgrCompareDoubleService.cmpdbl(midBotPlate.curvedEndY, 0) == true && HgrCompareDoubleService.cmpdbl(midBotPlate.curvedEndRad, 0) == true)
                    {
                        if (HgrCompareDoubleService.cmpdbl(midTopPlate.trCornerY, 0) == false)
                        {
                            nutMatrix.Origin = new Position(0, 0, midTopPlate.length1 + Math.Abs(midTopPlate.trCornerY));
                            AddNut(nutShape, nutMatrix, outputs, outputName + "ThreadedConnection");
                            Projection3d nut1 = (Projection3d)outputs[outputName + "ThreadedConnection"];
                            nut1.Transform(matrix);
                        }
                        else
                        {
                            nutMatrix.Origin = new Position(0, 0, midTopPlate.length1 + blockClamp.Diameter1 / 2);
                            AddNut(nutShape, nutMatrix, outputs, outputName + "ThreadedConnection");
                            Projection3d nut1 = (Projection3d)outputs[outputName + "ThreadedConnection"];
                            nut1.Transform(matrix);
                        }
                    }
                    else
                    {
                        nutMatrix.Origin = new Position(0, 0, blockClamp.Height1);
                        AddNut(nutShape, nutMatrix, outputs, outputName + "ThreadedConnection");
                        Projection3d nut1 = (Projection3d)outputs[outputName + "ThreadedConnection"];
                        nut1.Transform(matrix);
                    }
                }

                // Channel Clips
                if (blockClamp.Width5 > 0 && blockClamp.Length5 > 0 && blockClamp.Thickness5 > 0)
                {
                    if (HgrCompareDoubleService.cmpdbl(blockClamp.Diameter2, 0) == true)
                    {
                        if (HgrCompareDoubleService.cmpdbl(blockClamp.Width2, 0) == true && HgrCompareDoubleService.cmpdbl(blockClamp.Length2, 0) == true && HgrCompareDoubleService.cmpdbl(blockClamp.Thickness2, 0) == true && midBotPlate.curvedEndY > 0)
                        {
                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(-blockClamp.Width6 / 2 - blockClamp.Width5 / 2, -blockClamp.Length5 / 2, -midBotPlate.length1 - midBotPlate.curvedEndY - blockClamp.Thickness5);
                            Projection3d channelClip1 = (Projection3d)symbolGeometryHelper.CreateBox(null, blockClamp.Width5, blockClamp.Length5, blockClamp.Thickness5, 9);
                            rotateMatrix = new Matrix4X4();
                            rotateMatrix.Rotate(3 * Math.PI / 2, new Vector(0, 0, 1));
                            channelClip1.Transform(rotateMatrix);
                            channelClip1.Transform(matrix);
                            outputs.Add(outputName + "ChannelClip1", channelClip1);

                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(blockClamp.Width6 / 2 - blockClamp.Width5 / 2, -blockClamp.Length5 / 2, -midBotPlate.length1 - midBotPlate.curvedEndY - blockClamp.Thickness5);
                            Projection3d channelClip2 = (Projection3d)symbolGeometryHelper.CreateBox(null, blockClamp.Width5, blockClamp.Length5, blockClamp.Thickness5, 9);
                            rotateMatrix = new Matrix4X4();
                            rotateMatrix.Rotate(3 * Math.PI / 2, new Vector(0, 0, 1));
                            channelClip2.Transform(rotateMatrix);
                            channelClip2.Transform(matrix);
                            outputs.Add(outputName + "ChannelClip2", channelClip2);
                        }
                        else if (HgrCompareDoubleService.cmpdbl(blockClamp.Width2, 0) == true && HgrCompareDoubleService.cmpdbl(blockClamp.Length2, 0) == true && HgrCompareDoubleService.cmpdbl(blockClamp.Thickness2, 0) == true && midBotPlate.curvedEndY < 0)
                        {
                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(-blockClamp.Width6 / 2 - blockClamp.Width5 / 2, -blockClamp.Length5 / 2, -midBotPlate.length1 - midBotPlate.curvedEndY - blockClamp.Thickness5);
                            Projection3d channelClip1 = (Projection3d)symbolGeometryHelper.CreateBox(null, blockClamp.Width5, blockClamp.Length5, blockClamp.Thickness5, 9);
                            rotateMatrix = new Matrix4X4();
                            rotateMatrix.Rotate(3 * Math.PI / 2, new Vector(0, 0, 1));
                            channelClip1.Transform(rotateMatrix);
                            channelClip1.Transform(matrix);
                            outputs.Add(outputName + "ChannelClip1", channelClip1);

                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(blockClamp.Width6 / 2 - blockClamp.Width5 / 2, -blockClamp.Length5 / 2, -midBotPlate.length1 - midBotPlate.curvedEndY - blockClamp.Thickness5);
                            Projection3d channelClip2 = (Projection3d)symbolGeometryHelper.CreateBox(null, blockClamp.Width5, blockClamp.Length5, blockClamp.Thickness5, 9);
                            rotateMatrix = new Matrix4X4();
                            rotateMatrix.Rotate(3 * Math.PI / 2, new Vector(0, 0, 1));
                            channelClip2.Transform(rotateMatrix);
                            channelClip2.Transform(matrix);
                            outputs.Add(outputName + "ChannelClip2", channelClip2);
                        }
                        else if (HgrCompareDoubleService.cmpdbl(blockClamp.Width2, 0) == true && HgrCompareDoubleService.cmpdbl(blockClamp.Length2, 0) == true && HgrCompareDoubleService.cmpdbl(blockClamp.Thickness2, 0) == true && HgrCompareDoubleService.cmpdbl(midBotPlate.curvedEndY, 0) == true && HgrCompareDoubleService.cmpdbl(midBotPlate.curvedEndRad, 0) == true)
                        {
                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(-blockClamp.Width6 / 2 - blockClamp.Width5 / 2, -blockClamp.Length5 / 2, -midBotPlate.length1 - blockClamp.Diameter1 / 2 - blockClamp.Thickness5);
                            Projection3d channelClip1 = (Projection3d)symbolGeometryHelper.CreateBox(null, blockClamp.Width5, blockClamp.Length5, blockClamp.Thickness5, 9);
                            rotateMatrix = new Matrix4X4();
                            rotateMatrix.Rotate(3 * Math.PI / 2, new Vector(0, 0, 1));
                            channelClip1.Transform(rotateMatrix);
                            channelClip1.Transform(matrix);
                            outputs.Add(outputName + "ChannelClip1", channelClip1);

                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(blockClamp.Width6 / 2 - blockClamp.Width5 / 2, -blockClamp.Length5 / 2, -midBotPlate.length1 - blockClamp.Diameter1 / 2 - blockClamp.Thickness5);
                            Projection3d channelClip2 = (Projection3d)symbolGeometryHelper.CreateBox(null, blockClamp.Width5, blockClamp.Length5, blockClamp.Thickness5, 9);
                            rotateMatrix = new Matrix4X4();
                            rotateMatrix.Rotate(3 * Math.PI / 2, new Vector(0, 0, 1));
                            channelClip2.Transform(rotateMatrix);
                            channelClip2.Transform(matrix);
                            outputs.Add(outputName + "ChannelClip2", channelClip2);
                        }
                        else
                        {
                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(-blockClamp.Width6 / 2 - blockClamp.Width5 / 2, -blockClamp.Length5 / 2, -blockClamp.Height2 - blockClamp.Thickness5);
                            Projection3d channelClip1 = (Projection3d)symbolGeometryHelper.CreateBox(null, blockClamp.Width5, blockClamp.Length5, blockClamp.Thickness5, 9);
                            rotateMatrix = new Matrix4X4();
                            rotateMatrix.Rotate(3 * Math.PI / 2, new Vector(0, 0, 1));
                            channelClip1.Transform(rotateMatrix);
                            channelClip1.Transform(matrix);
                            outputs.Add(outputName + "ChannelClip1", channelClip1);

                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(blockClamp.Width6 / 2 - blockClamp.Width5 / 2, -blockClamp.Length5 / 2, -blockClamp.Height2 - blockClamp.Thickness5);
                            Projection3d channelClip2 = (Projection3d)symbolGeometryHelper.CreateBox(null, blockClamp.Width5, blockClamp.Length5, blockClamp.Thickness5, 9);
                            rotateMatrix = new Matrix4X4();
                            rotateMatrix.Rotate(3 * Math.PI / 2, new Vector(0, 0, 1));
                            channelClip2.Transform(rotateMatrix);
                            channelClip2.Transform(matrix);
                            outputs.Add(outputName + "ChannelClip2", channelClip2);
                        }
                    }
                    if (HgrCompareDoubleService.cmpdbl(blockClamp.Diameter1, 0) == false && HgrCompareDoubleService.cmpdbl(blockClamp.Diameter2, 0) == false && HgrCompareDoubleService.cmpdbl(blockClamp.Offset1, 0) == false)
                    {
                        if (HgrCompareDoubleService.cmpdbl(blockClamp.Width2, 0) == true && HgrCompareDoubleService.cmpdbl(blockClamp.Length2, 0) == true && HgrCompareDoubleService.cmpdbl(blockClamp.Thickness2, 0) == true && midBotPlate.curvedEndY > 0)
                        {
                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(-blockClamp.Offset1 / 2 - midBotPlate.width1 / 2, -blockClamp.Length5 / 2, -midBotPlate.length1 - midBotPlate.curvedEndY - blockClamp.Thickness5);
                            Projection3d channelClip1 = (Projection3d)symbolGeometryHelper.CreateBox(null, blockClamp.Width5, blockClamp.Length5, blockClamp.Thickness5, 9);
                            rotateMatrix = new Matrix4X4();
                            rotateMatrix.Rotate(3 * Math.PI / 2, new Vector(0, 0, 1));
                            channelClip1.Transform(rotateMatrix);
                            channelClip1.Transform(matrix);
                            outputs.Add(outputName + "ChannelClip1", channelClip1);

                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(blockClamp.Offset1 / 2 + midBotPlate.width1 / 2 - blockClamp.Width5, -blockClamp.Length5 / 2 - blockClamp.Width5, -midBotPlate.length1 - midBotPlate.curvedEndY - blockClamp.Thickness5);
                            Projection3d channelClip2 = (Projection3d)symbolGeometryHelper.CreateBox(null, blockClamp.Width5, blockClamp.Length5, blockClamp.Thickness5, 9);
                            rotateMatrix = new Matrix4X4();
                            rotateMatrix.Rotate(3 * Math.PI / 2, new Vector(0, 0, 1));
                            channelClip2.Transform(rotateMatrix);
                            channelClip2.Transform(matrix);
                            outputs.Add(outputName + "ChannelClip2", channelClip2);
                        }
                        else if (HgrCompareDoubleService.cmpdbl(blockClamp.Width2, 0) == true && HgrCompareDoubleService.cmpdbl(blockClamp.Length2, 0) == true && HgrCompareDoubleService.cmpdbl(blockClamp.Thickness2, 0) == true && midBotPlate.curvedEndY < 0)
                        {
                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(-blockClamp.Offset1 / 2 - midBotPlate.width1 / 2, -blockClamp.Length5 / 2, -midBotPlate.length1 - midBotPlate.curvedEndY - blockClamp.Thickness5);
                            Projection3d channelClip1 = (Projection3d)symbolGeometryHelper.CreateBox(null, blockClamp.Width5, blockClamp.Length5, blockClamp.Thickness5, 9);
                            rotateMatrix = new Matrix4X4();
                            rotateMatrix.Rotate(3 * Math.PI / 2, new Vector(0, 0, 1));
                            channelClip1.Transform(rotateMatrix);
                            channelClip1.Transform(matrix);
                            outputs.Add(outputName + "ChannelClip1", channelClip1);

                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(blockClamp.Offset1 / 2 + midBotPlate.width1 / 2 - blockClamp.Width5, -blockClamp.Length5 / 2 - blockClamp.Width5, -midBotPlate.length1 - midBotPlate.curvedEndY - blockClamp.Thickness5);
                            Projection3d channelClip2 = (Projection3d)symbolGeometryHelper.CreateBox(null, blockClamp.Width5, blockClamp.Length5, blockClamp.Thickness5, 9);
                            rotateMatrix = new Matrix4X4();
                            rotateMatrix.Rotate(3 * Math.PI / 2, new Vector(0, 0, 1));
                            channelClip2.Transform(rotateMatrix);
                            channelClip2.Transform(matrix);
                            outputs.Add(outputName + "ChannelClip2", channelClip2);
                        }
                        else if (HgrCompareDoubleService.cmpdbl(blockClamp.Width2, 0) == true && HgrCompareDoubleService.cmpdbl(blockClamp.Length2, 0) == true && HgrCompareDoubleService.cmpdbl(blockClamp.Thickness2, 0) == true && HgrCompareDoubleService.cmpdbl(midBotPlate.curvedEndY, 0) == true && HgrCompareDoubleService.cmpdbl(midBotPlate.curvedEndRad, 0) == true)
                        {
                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(-blockClamp.Offset1 / 2 - midBotPlate.width1 / 2, -blockClamp.Length5 / 2, -midBotPlate.length1 - blockClamp.Diameter1 / 2 - blockClamp.Thickness5);
                            Projection3d channelClip1 = (Projection3d)symbolGeometryHelper.CreateBox(null, blockClamp.Width5, blockClamp.Length5, blockClamp.Thickness5, 9);
                            rotateMatrix = new Matrix4X4();
                            rotateMatrix.Rotate(3 * Math.PI / 2, new Vector(0, 0, 1));
                            channelClip1.Transform(rotateMatrix);
                            channelClip1.Transform(matrix);
                            outputs.Add(outputName + "ChannelClip1", channelClip1);

                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(blockClamp.Offset1 / 2 + midBotPlate.width1 / 2 - blockClamp.Width5, -blockClamp.Length5 / 2 - blockClamp.Width5, -midBotPlate.length1 - blockClamp.Diameter1 / 2 - blockClamp.Thickness5);
                            Projection3d channelClip2 = (Projection3d)symbolGeometryHelper.CreateBox(null, blockClamp.Width5, blockClamp.Length5, blockClamp.Thickness5, 9);
                            rotateMatrix = new Matrix4X4();
                            rotateMatrix.Rotate(3 * Math.PI / 2, new Vector(0, 0, 1));
                            channelClip2.Transform(rotateMatrix);
                            channelClip2.Transform(matrix);
                            outputs.Add(outputName + "ChannelClip2", channelClip2);
                        }
                        else
                        {
                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(-blockClamp.Offset1 / 2 - blockClamp.Width2 / 2, -blockClamp.Length5 / 2, -blockClamp.Height2 - blockClamp.Thickness5);
                            Projection3d channelClip1 = (Projection3d)symbolGeometryHelper.CreateBox(null, blockClamp.Width5, blockClamp.Length5, blockClamp.Thickness5, 9);
                            rotateMatrix = new Matrix4X4();
                            rotateMatrix.Rotate(3 * Math.PI / 2, new Vector(0, 0, 1));
                            channelClip1.Transform(rotateMatrix);
                            channelClip1.Transform(matrix);
                            outputs.Add(outputName + "ChannelClip1", channelClip1);

                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(blockClamp.Offset1 / 2 + blockClamp.Width2 / 2 - blockClamp.Width5, -blockClamp.Length5 / 2, -blockClamp.Height2 - blockClamp.Thickness5);
                            Projection3d channelClip2 = (Projection3d)symbolGeometryHelper.CreateBox(null, blockClamp.Width5, blockClamp.Length5, blockClamp.Thickness5, 9);
                            rotateMatrix = new Matrix4X4();
                            rotateMatrix.Rotate(3 * Math.PI / 2, new Vector(0, 0, 1));
                            channelClip2.Transform(rotateMatrix);
                            channelClip2.Transform(matrix);
                            outputs.Add(outputName + "ChannelClip2", channelClip2);
                        }
                    }
                }

                //Add Bolt Rows
                if (blockClamp.Pin1Diameter > 0 && blockClamp.Pin1Length > 0 && blockClamp.Multi1Qty > 0)
                {
                    if (blockClamp.Diameter1 > 0 && blockClamp.Offset3 > 0)
                    {
                        AddBoltsByRow(blockClamp.Length1 + blockClamp.Offset3, blockClamp.Multi1Qty, blockClamp.Multi1LocateBy, blockClamp.Multi1Location, blockClamp.Pin1Diameter, blockClamp.Pin1Length, -blockClamp.Offset4, 90, 1, outputs, outputName + "Bolt", outputName + "Bolt", 0, false, 0);
                        Projection3d bolt10 = (Projection3d)outputs[outputName + "Bolt10"];
                        bolt10.Transform(matrix);
                        Projection3d bolt11 = (Projection3d)outputs[outputName + "Bolt11"];
                        bolt11.Transform(matrix);

                        AddBoltsByRow(blockClamp.Length1 + blockClamp.Offset3, blockClamp.Multi2Qty, blockClamp.Multi2LocateBy, blockClamp.Multi2Location, blockClamp.Pin1Diameter, blockClamp.Pin1Length, blockClamp.Offset5, 90, 2, outputs, outputName + "Bolt", outputName + "Bolt", 0, false, 0);
                        Projection3d bolt20 = (Projection3d)outputs[outputName + "Bolt20"];
                        bolt20.Transform(matrix);
                        Projection3d bolt21 = (Projection3d)outputs[outputName + "Bolt21"];
                        bolt21.Transform(matrix);
                    }
                    else if (blockClamp.Diameter1 > 0 && blockClamp.Diameter2 > 0 && blockClamp.Offset1 > 0)
                    {
                        AddBoltsByRow(blockClamp.Width1 + blockClamp.Offset1, blockClamp.Multi1Qty, blockClamp.Multi1LocateBy, blockClamp.Multi1Location, blockClamp.Pin1Diameter, blockClamp.Pin1Length, -blockClamp.Offset4, 90, 1, outputs, outputName + "Bolt", outputName + "Bolt", 0, false, 0);
                        Projection3d bolt10 = (Projection3d)outputs[outputName + "Bolt10"];
                        bolt10.Transform(matrix);
                        Projection3d bolt11 = (Projection3d)outputs[outputName + "Bolt11"];
                        bolt11.Transform(matrix);

                        AddBoltsByRow(blockClamp.Width1 + blockClamp.Offset1, blockClamp.Multi2Qty, blockClamp.Multi2LocateBy, blockClamp.Multi2Location, blockClamp.Pin1Diameter, blockClamp.Pin1Length, blockClamp.Offset5, 90, 2, outputs, outputName + "Bolt", outputName + "Bolt", 0, false, 0);
                        Projection3d bolt20 = (Projection3d)outputs[outputName + "Bolt20"];
                        bolt20.Transform(matrix);
                        Projection3d bolt21 = (Projection3d)outputs[outputName + "Bolt21"];
                        bolt21.Transform(matrix);
                    }
                    else
                    {
                        AddBoltsByRow(blockClamp.Length1, blockClamp.Multi1Qty, blockClamp.Multi1LocateBy, blockClamp.Multi1Location, blockClamp.Pin1Diameter, blockClamp.Pin1Length, -blockClamp.Offset4, 90, 1, outputs, outputName + "Bolt", outputName + "Bolt", 0, false, 0);
                        Projection3d bolt10 = (Projection3d)outputs[outputName + "Bolt10"];
                        bolt10.Transform(matrix);
                        Projection3d bolt11 = (Projection3d)outputs[outputName + "Bolt11"];
                        bolt11.Transform(matrix);

                        AddBoltsByRow(blockClamp.Length1, blockClamp.Multi2Qty, blockClamp.Multi2LocateBy, blockClamp.Multi2Location, blockClamp.Pin1Diameter, blockClamp.Pin1Length, blockClamp.Offset5, 90, 2, outputs, outputName + "Bolt", outputName + "Bolt", 0, false, 0);
                        Projection3d bolt20 = (Projection3d)outputs[outputName + "Bolt20"];
                        bolt20.Transform(matrix);
                        Projection3d bolt21 = (Projection3d)outputs[outputName + "Bolt21"];
                        bolt21.Transform(matrix);
                    }
                }
            }

            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddBlockClamp, "Error in AddBlockClamp");
                }
            }
        }
        /// <summary>
        /// Create the graphical representation of the BlockClampShape
        /// </summary>
        /// <param name="blockClamp">Structure for specifying the inputs for the blockclamp -BlockClampInputs </param>
        /// <param name="matrix">string to specify the position and oreintation the graphics - String.</param>
        /// <param name="outputs">Collection of declared outputs, which is indexed by the name of the outputs declared as defining SymbolOutputs on the AspectDefinition field- OutputDictionary</param>
        /// <param name="outputName">Output that this graphic is being placed on-String</param>
        ///<code>
        ///clampShapeMatrix = new Matrix4X4();
        ///clampShapeMatrix.SetIdentity();
        ///clampShapeMatrix.Translate(new Vector());
        ///AddBlockClampShape(BlockClampInputs blockClamp, Matrix4X4 matrix, OutputDictionary outputs, String outputName);
        ///</code>
        public void AddBlockClampShape(BlockClampInputs blockClamp, Matrix4X4 matrix, OutputDictionary outputs, String outputName)
        {
            try
            {

                SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();
                Matrix4X4 rotateMatrix = new Matrix4X4();
                // Top Plate
                if (blockClamp.Width1 > 0 && blockClamp.Length1 > 0 && blockClamp.Thickness1 > 0)
                {
                    symbolGeometryHelper.ActivePosition = new Position(-blockClamp.Width1 / 2, -blockClamp.Length1 / 2, blockClamp.Height1 - blockClamp.Thickness1);
                    Projection3d topPlate = (Projection3d)symbolGeometryHelper.CreateBox(null, blockClamp.Width1, blockClamp.Length1, blockClamp.Thickness1, 9);
                    rotateMatrix.Rotate(3 * Math.PI / 2, new Vector(0, 0, 1));
                    topPlate.Transform(rotateMatrix);
                    topPlate.Transform(matrix);
                    outputs.Add(outputName + "TopPlate", topPlate);
                }

                // Bottom Plate
                if (blockClamp.Width2 > 0 && blockClamp.Length2 > 0 && blockClamp.Thickness2 > 0)
                {
                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(-blockClamp.Width2 / 2, -blockClamp.Length2 / 2, -blockClamp.Height2);
                    Projection3d botPlate = (Projection3d)symbolGeometryHelper.CreateBox(null, blockClamp.Width2, blockClamp.Length2, blockClamp.Thickness2, 9);
                    rotateMatrix = new Matrix4X4();
                    rotateMatrix.Rotate(3 * Math.PI / 2, new Vector(0, 0, 1));
                    botPlate.Transform(rotateMatrix);
                    botPlate.Transform(matrix);
                    outputs.Add(outputName + "BotPlate", botPlate);
                }

                // Middle Plates
                PlateInputs midTopPlate = LoadPlateDataByQuery(blockClamp.MidPlateTopShape);
                PlateInputs midBotPlate = LoadPlateDataByQuery(blockClamp.MidPlateBotShape);

                // Top Middle Plate
                Matrix4X4 plateMatrix = new Matrix4X4();
                if (HgrCompareDoubleService.cmpdbl(blockClamp.Width1, 0) == true && HgrCompareDoubleService.cmpdbl(blockClamp.Length1, 0) == true && HgrCompareDoubleService.cmpdbl(blockClamp.Thickness1, 0) == true && midTopPlate.curvedEndY > 0)
                {
                    plateMatrix.SetIdentity();

                    AddPlate(midTopPlate, plateMatrix, outputs, outputName + "MiddleTop");
                    Projection3d middleTop = (Projection3d)outputs[outputName + "MiddleTop"];
                    plateMatrix.SetIdentity();
                    plateMatrix.Rotate(3 * Math.PI / 2, new Vector(1, 0, 0));
                    middleTop.Transform(plateMatrix);

                    plateMatrix = new Matrix4X4();
                    plateMatrix.Translate(new Vector(-midTopPlate.width1 / 2, -midTopPlate.thickness1 / 2, midTopPlate.length1 + midTopPlate.curvedEndY));
                    middleTop.Transform(plateMatrix);

                    plateMatrix = new Matrix4X4();
                    plateMatrix.Rotate(Math.PI / 2, new Vector(0, 0, 1));
                    middleTop.Transform(plateMatrix);

                    middleTop.Transform(matrix);
                }
                else if (HgrCompareDoubleService.cmpdbl(blockClamp.Width1, 0) == true && HgrCompareDoubleService.cmpdbl(blockClamp.Length1, 0) == true && HgrCompareDoubleService.cmpdbl(blockClamp.Thickness1, 0) == true && midTopPlate.curvedEndY < 0)
                {
                    plateMatrix.SetIdentity();

                    AddPlate(midTopPlate, plateMatrix, outputs, outputName + "MiddleTop");
                    Projection3d middleTop = (Projection3d)outputs[outputName + "MiddleTop"];
                    plateMatrix.SetIdentity();
                    plateMatrix.Rotate(3 * Math.PI / 2, new Vector(1, 0, 0));
                    middleTop.Transform(plateMatrix);

                    plateMatrix = new Matrix4X4();
                    plateMatrix.Translate(new Vector(-midTopPlate.width1 / 2, -midTopPlate.thickness1 / 2, midTopPlate.length1 + midTopPlate.curvedEndY));
                    middleTop.Transform(plateMatrix);

                    plateMatrix = new Matrix4X4();
                    plateMatrix.Rotate(Math.PI / 2, new Vector(0, 0, 1));
                    middleTop.Transform(plateMatrix);
                    middleTop.Transform(matrix);
                }
                else if (HgrCompareDoubleService.cmpdbl(blockClamp.Width1, 0) == true && HgrCompareDoubleService.cmpdbl(blockClamp.Length1, 0) == true && HgrCompareDoubleService.cmpdbl(blockClamp.Thickness1, 0) == true && HgrCompareDoubleService.cmpdbl(midTopPlate.curvedEndY, 0) == true && HgrCompareDoubleService.cmpdbl(midTopPlate.curvedEndRad, 0) == true)
                {
                    if (midTopPlate.trCornerY != 0)
                    {
                        plateMatrix.SetIdentity();

                        AddPlate(midTopPlate, plateMatrix, outputs, outputName + "MiddleTop");
                        Projection3d middleTop = (Projection3d)outputs[outputName + "MiddleTop"];
                        plateMatrix.SetIdentity();
                        plateMatrix.Rotate(3 * Math.PI / 2, new Vector(1, 0, 0));
                        middleTop.Transform(plateMatrix);

                        plateMatrix = new Matrix4X4();
                        plateMatrix.Translate(new Vector(-midTopPlate.width1, -midTopPlate.thickness1 / 2, midTopPlate.length1 + Math.Abs(midTopPlate.trCornerY)));
                        middleTop.Transform(plateMatrix);

                        plateMatrix = new Matrix4X4();
                        plateMatrix.Rotate(Math.PI / 2, new Vector(0, 0, 1));
                        middleTop.Transform(plateMatrix);
                        middleTop.Transform(matrix);
                    }
                    else
                    {

                        plateMatrix.SetIdentity();

                        AddPlate(midTopPlate, plateMatrix, outputs, outputName + "MiddleTop");
                        Projection3d middleTop = (Projection3d)outputs[outputName + "MiddleTop"];
                        plateMatrix.SetIdentity();
                        plateMatrix.Rotate(3 * Math.PI / 2, new Vector(1, 0, 0));
                        middleTop.Transform(plateMatrix);

                        plateMatrix = new Matrix4X4();
                        plateMatrix.Translate(new Vector(-midTopPlate.width1 / 2, -midTopPlate.thickness1 / 2, midTopPlate.length1 + blockClamp.Diameter1 / 2));
                        middleTop.Transform(plateMatrix);

                        plateMatrix = new Matrix4X4();
                        plateMatrix.Rotate(Math.PI / 2, new Vector(0, 0, 1));
                        middleTop.Transform(plateMatrix);
                        middleTop.Transform(matrix);
                    }
                }
                else
                {
                    plateMatrix.SetIdentity();
                    AddPlate(midTopPlate, plateMatrix, outputs, outputName + "MiddleTop");
                    Projection3d middleTop = (Projection3d)outputs[outputName + "MiddleTop"];

                    plateMatrix.SetIdentity();
                    plateMatrix.Rotate(3 * Math.PI / 2, new Vector(1, 0, 0));
                    middleTop.Transform(plateMatrix);

                    plateMatrix = new Matrix4X4();
                    plateMatrix.Translate(new Vector(-blockClamp.Width1 / 2, -blockClamp.Length1 / 2, blockClamp.Height1 - blockClamp.Thickness1));
                    middleTop.Transform(plateMatrix);

                    plateMatrix = new Matrix4X4();
                    plateMatrix.Rotate(Math.PI / 2, new Vector(0, 0, 1));
                    middleTop.Transform(plateMatrix);
                    middleTop.Transform(matrix);
                }

                // Bottom Middle Plate
                if (HgrCompareDoubleService.cmpdbl(blockClamp.Width2, 0) == true && HgrCompareDoubleService.cmpdbl(blockClamp.Length2, 0) == true && HgrCompareDoubleService.cmpdbl(blockClamp.Thickness2, 0) == true && midBotPlate.curvedEndY > 0)
                {
                    plateMatrix = new Matrix4X4();
                    plateMatrix.SetIdentity();

                    AddPlate(midBotPlate, plateMatrix, outputs, outputName + "MiddleBot");
                    Projection3d middleBot = (Projection3d)outputs[outputName + "MiddleBot"];
                    plateMatrix.SetIdentity();
                    plateMatrix.Rotate(Math.PI / 2, new Vector(1, 0, 0));
                    middleBot.Transform(plateMatrix);

                    plateMatrix = new Matrix4X4();
                    plateMatrix.Translate(new Vector(-midBotPlate.width1 / 2, midBotPlate.thickness1 / 2, -midBotPlate.length1 - midBotPlate.curvedEndY));
                    middleBot.Transform(plateMatrix);

                    plateMatrix = new Matrix4X4();
                    plateMatrix.Rotate(Math.PI / 2, new Vector(0, 0, 1));
                    middleBot.Transform(plateMatrix);
                    middleBot.Transform(matrix);
                }
                else if (HgrCompareDoubleService.cmpdbl(blockClamp.Width2, 0) == true && HgrCompareDoubleService.cmpdbl(blockClamp.Length2, 0) == true && HgrCompareDoubleService.cmpdbl(blockClamp.Thickness2, 0) == true && midBotPlate.curvedEndY < 0)
                {
                    plateMatrix = new Matrix4X4();
                    plateMatrix.SetIdentity();

                    AddPlate(midBotPlate, plateMatrix, outputs, outputName + "MiddleBot");
                    Projection3d middleBot = (Projection3d)outputs[outputName + "MiddleBot"];
                    plateMatrix.SetIdentity();
                    plateMatrix.Rotate(Math.PI / 2, new Vector(1, 0, 0));
                    middleBot.Transform(plateMatrix);

                    plateMatrix = new Matrix4X4();
                    plateMatrix.Translate(new Vector(-midBotPlate.width1 / 2, midBotPlate.thickness1 / 2, -midBotPlate.length1 - midBotPlate.curvedEndY));
                    middleBot.Transform(plateMatrix);

                    plateMatrix = new Matrix4X4();
                    plateMatrix.Rotate(Math.PI / 2, new Vector(0, 0, 1));
                    middleBot.Transform(plateMatrix);
                    middleBot.Transform(matrix);
                }
                else if (HgrCompareDoubleService.cmpdbl(blockClamp.Width2, 0) == true && HgrCompareDoubleService.cmpdbl(blockClamp.Length2, 0) == true && HgrCompareDoubleService.cmpdbl(blockClamp.Thickness2, 0) == true && HgrCompareDoubleService.cmpdbl(midBotPlate.curvedEndY, 0) == true && HgrCompareDoubleService.cmpdbl(midBotPlate.curvedEndRad, 0) == true)
                {
                    plateMatrix = new Matrix4X4();
                    plateMatrix.SetIdentity();

                    AddPlate(midBotPlate, plateMatrix, outputs, outputName + "MiddleBot");
                    Projection3d middleBot = (Projection3d)outputs[outputName + "MiddleBot"];
                    plateMatrix.SetIdentity();
                    plateMatrix.Rotate(Math.PI / 2, new Vector(1, 0, 0));
                    middleBot.Transform(plateMatrix);

                    plateMatrix = new Matrix4X4();
                    plateMatrix.Translate(new Vector(-midBotPlate.width1 / 2, midBotPlate.thickness1 / 2, -midBotPlate.length1 - blockClamp.Diameter1 / 2));
                    middleBot.Transform(plateMatrix);

                    plateMatrix = new Matrix4X4();
                    plateMatrix.Rotate(Math.PI / 2, new Vector(0, 0, 1));
                    middleBot.Transform(plateMatrix);
                    middleBot.Transform(matrix);
                }
                else
                {
                    plateMatrix = new Matrix4X4();
                    plateMatrix.SetIdentity();

                    AddPlate(midBotPlate, plateMatrix, outputs, outputName + "MiddleBot");
                    Projection3d middleBot = (Projection3d)outputs[outputName + "MiddleBot"];

                    plateMatrix.SetIdentity();
                    plateMatrix.Rotate(Math.PI / 2, new Vector(1, 0, 0));
                    middleBot.Transform(plateMatrix);

                    plateMatrix = new Matrix4X4();
                    plateMatrix.Translate(new Vector(-blockClamp.Width2 / 2, blockClamp.Length2 / 2, blockClamp.Thickness2 - blockClamp.Height2));
                    middleBot.Transform(plateMatrix);

                    plateMatrix = new Matrix4X4();
                    plateMatrix.Rotate(Math.PI / 2, new Vector(0, 0, 1));
                    middleBot.Transform(plateMatrix);
                    middleBot.Transform(matrix);
                }

            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddBlockClampShape, "Error in AddBlockClampShape");
                }
            }
        }

        ///Shield
        /// <summary>
        /// Defines the inputs for the Shield shape.
        /// </summary>
        public struct ShieldInputs
        {
            /// <summary>
            /// Outside diameter the pipe that the Shield is for.
            /// </summary>
            public double PipeOD;
            /// <summary>
            /// This is a string attribute that may be used to select the correct shield, or perhaps may need to be reported for BOMs.
            /// </summary>
            public string Size;
            /// <summary>
            /// The thickness of the lower curved plate.
            /// </summary>
            public double Thickness1;
            /// <summary>
            /// The length of the plate.
            /// </summary>
            public double Length1;
            /// <summary>
            /// The angle from vertical cl of the pipe to the left edge of the plate.
            /// </summary>
            public double Angle1;
            /// <summary>
            /// The angle from vertical cl of the pipe to the right edge of the plate.
            /// </summary>
            public double Angle2;
            /// <summary>
            /// The distance from vertical CL of the pipe to the left inside edge of the plate.
            /// </summary>
            public double Width1;
            /// <summary>
            /// The distance from vertical CL of the pipe to the right inside edge of the plate.
            /// </summary>
            public double Width2;
            /// <summary>
            /// The thickness of the upper curved plate.
            /// </summary>
            public double Thickness2;
            /// <summary>
            /// The length of the plate.
            /// </summary>
            public double Length2;
            /// <summary>
            /// The angle from vertical cl of the pipe to the left edge of the top plate.
            /// </summary>
            public double Angle3;
            /// <summary>
            /// The angle from vertical cl of the pipe to the right edge of the top plate.
            /// </summary>
            public double Angle4;
            /// <summary>
            /// The distance from vertical CL of the pipe to the left inside edge of the top plate.
            /// </summary>
            public double Width3;
            /// <summary>
            /// The distance from vertical CL of the pipe to the right inside edge of the top plate.
            /// </summary>
            public double Width4;
            /// <summary>
            /// The thickness of the weld plate \ bolting block. All plates \ blocks have the same thickness.
            /// </summary>
            public double thickness3;
            /// <summary>
            /// The total angle of the plate. Plate is always centered on the pipe centerline. The weld plates on both sides of the pipe will have the same dimensions.
            /// </summary>
            public double Angle5;
            /// <summary>
            /// The height of the left plate. Measured from the inside bottom corner to the inside top corner. Plate is always centered on the pipe centerline.
            /// </summary>
            public double Height1;
            /// <summary>
            /// The length of the plate \ Block.
            /// </summary>
            public double Length3;
            /// <summary>
            /// This is the number of plates. Will be the same on both sides.
            /// </summary>
            public int Multi1Qty;
            /// <summary>
            /// This is how the plates will be located. Will be the same on both sides.
            /// </summary>
            public double Multi1LocateBy;
            /// <summary>
            /// This is their location. Will be the same on both sides.
            /// </summary>
            public double Multi1Location;
            /// <summary>
            /// The inside diameter of the plate.
            /// </summary>
            public double Diameter1;
            /// <summary>
            /// The offset of the graphics from the route port. The Route port will remain the origin (0,0,0).
            /// </summary>
            public double Offset1;

        }
        /// <summary>
        /// Defines the inputs for the ShieldLine.
        /// </summary>
        public struct ShieldLineInputs
        {
            /// <summary>
            ///The SideLine1 input parameter type.
            /// </summary>
            public LineInputs SideLine1;
            /// <summary>
            ///The SideLine2 input parameter type.
            /// </summary>
            public LineInputs SideLine2;
            /// <summary>
            ///The SideLine3 input parameter type.
            /// </summary>
            public LineInputs SideLine3;
            /// <summary>
            ///The SideLine4 input parameter type.
            /// </summary>
            public LineInputs SideLine4;
            /// <summary>
            /// The Angle1.
            /// </summary>
            public double Angle1;
            /// <summary>
            /// The Angle2.
            /// </summary>
            public double Angle2;
            /// <summary>
            /// The Angle3.
            /// </summary>
            public double Angle3;
            /// <summary>
            /// The Angle4.
            /// </summary>
            public double Angle4;
        }
        /// <summary>
        /// Adds the Shield inputs.
        /// </summary>        
        /// <param name="startIndex">The start index.</param>
        /// <param name="endIndex">The end index.</param>
        /// <param name="additionalInputs">The additional inputs.</param>
        /// <code>
        /// int endIndex;
        /// List<Input> additionalInputs = new List<Input>();
        /// AddShieldInputs(2, out endIndex, additionalInputs);
        /// </code>
        public void AddShieldInputs(int startIndex, out int endIndex, List<Input> additionalInputs)
        {
            try
            {
                additionalInputs.Add(new InputDouble(startIndex, "PipeOD", "PipeOD", 0, false));
                additionalInputs.Add(new InputString(++startIndex, "Size", "Size", "No Value", false));
                additionalInputs.Add(new InputDouble(++startIndex, "Thickness1", "Thickness1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Length1", "Length1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Angle1", "Angle1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Angle2", "Angle2", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Width1", "Width1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Width2", "Width2", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Thickness2", "Thickness2", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Length2", "Length2", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Angle3", "Angle3", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Angle4", "Angle4", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Width3", "Width3", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Width4", "Width4", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Thickness3", "Thickness3", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Angle5", "Angle5", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Height1", "Height1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Length3", "Length3", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Multi1Qty", "Multi1Qty", 1, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Multi1LocateBy", "Multi1LocateBy", 1, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Multi1Location", "Multi1Location", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Diameter1", "Diameter1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Offset1", "Offset1", 0, false));
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddShieldInputs, "Error in adding Shield inputs");
                }
            }
            endIndex = ++startIndex;
        }
        /// <summary>
        /// Adds the Shield outputs.
        /// </summary>       
        /// <param name="aspectName">Name of the aspect.</param>
        /// <param name="additionalOutputs">The additional outputs.</param>
        /// <code>
        ///  List<OutputDefinition> additionalOutputs = new List<OutputDefinition>();
        ///  AddShieldOutputs(additionalOutputs);
        /// </code>
        public void AddShieldOutputs(List<OutputDefinition> additionalOutputs)
        {
            try
            {   //Outputs
                additionalOutputs.Add(new OutputDefinition("shield1" + "PLT1", "shield1" + "PLT1"));
                additionalOutputs.Add(new OutputDefinition("shield1" + "PLT2", "shield1" + "PLT2"));
                for (int i = 0; i <= 8; i++)
                {
                    additionalOutputs.Add(new OutputDefinition("shield1" + "Num" + i + "PLT1", "shield1" + "Num" + i + "PLT1"));
                    additionalOutputs.Add(new OutputDefinition("shield1" + "Num" + i + "PLT2", "shield1" + "Num" + i + "PLT2"));
                }
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddShieldOutputs, "Error in AddShieldOutputs.");
                }
            }
        }
        /// <summary>
        /// Loads the Shield data.
        /// </summary>        
        /// <param name="startIndex">The start index.</param>
        ///  <code>
        ///  ShieldInputs Shield = LoadPipeClampData(2);
        /// </code>
        /// <returns>ShieldInputs</returns>
        public ShieldInputs LoadShieldData(int startIndex)
        {
            ShieldInputs Shield = new ShieldInputs();
            try
            {
                Shield.PipeOD = GetDoubleInputValue(startIndex);
                if (Shield.PipeOD == 0)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidShieldPipeOD, "PipeOD value should not be zero");
                }
                Shield.Size = GetStringInputValue(++startIndex);
                Shield.Thickness1 = GetDoubleInputValue(++startIndex);
                Shield.Length1 = GetDoubleInputValue(++startIndex);
                Shield.Angle1 = GetDoubleInputValue(++startIndex);
                Shield.Angle2 = GetDoubleInputValue(++startIndex);
                Shield.Width1 = GetDoubleInputValue(++startIndex);
                Shield.Width2 = GetDoubleInputValue(++startIndex);
                Shield.Thickness2 = GetDoubleInputValue(++startIndex);
                Shield.Length2 = GetDoubleInputValue(++startIndex);
                Shield.Angle3 = GetDoubleInputValue(++startIndex);
                Shield.Angle4 = GetDoubleInputValue(++startIndex);
                Shield.Width3 = GetDoubleInputValue(++startIndex);
                Shield.Width4 = GetDoubleInputValue(++startIndex);
                Shield.thickness3 = GetDoubleInputValue(++startIndex);
                Shield.Angle5 = GetDoubleInputValue(++startIndex);
                Shield.Height1 = GetDoubleInputValue(++startIndex);
                Shield.Length3 = GetDoubleInputValue(++startIndex);
                Shield.Multi1Qty = (int)GetDoubleInputValue(++startIndex);
                Shield.Multi1LocateBy = GetDoubleInputValue(++startIndex);
                Shield.Multi1Location = GetDoubleInputValue(++startIndex);
                Shield.Diameter1 = GetDoubleInputValue(++startIndex);
                Shield.Offset1 = GetDoubleInputValue(++startIndex);
            }
            catch (SmartPartSymbolException hgrEx)
            {
                throw hgrEx;
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadShieldData, "Error in loadShieldData");
                }
            }
            return Shield;
        }
        /// <summary>
        /// Create the graphical representation of the shield.
        /// </summary>        
        /// <param name="shield">Structure for specifying the inputs for the shield -ShieldInputs.</param>
        /// <param name="matrix">Matrix to specify the position and oreintation the graphics - Matrix4X4.</param>
        /// <param name="outputs">Collection of declared outputs, which is indexed by the name of the outputs declared as defining SymbolOutputs on the AspectDefinition field- OutputDictionary.</param>
        /// <param name="outputName">OutputName that this graphic is being placed on-String.</param>
        ///<code>
        /// ShieldInputs shield = LoadShieldData(2);
        ///Matrix4X4 matrix = new Matrix4X4(); 
        ///AddShield(shield, matrix, m_PhysicalAspect.Outputs, "shield1");
        ///</code>
        public void AddShield(ShieldInputs shield, Matrix4X4 matrix, OutputDictionary outputs, String outputName)
        {
            try
            {
                SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();
                //double[] Angle = new double[4];
                StringBuilder error = new StringBuilder();
                string[] objectCollection = new string[4];
                double angle1 = shield.Angle1;
                double angle2 = shield.Angle2;
                double angle3 = shield.Angle3;
                double angle4 = shield.Angle4;
                double pipeOD = shield.PipeOD;
                double length3 = shield.Length3;
                int outputIndex = 0;
                Matrix4X4 rotateMatrix = new Matrix4X4();
                //Define rules and warnings
                if (shield.Thickness1 <= 0)
                    error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidThickness1GTZero, "Thichness1 must be greater than zero"));
                else
                {
                    if (shield.Length1 <= 0)
                        error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidLength1GTZero, "Length1 must be greater than zero"));

                    if (HgrCompareDoubleService.cmpdbl(angle1, 0) == true && HgrCompareDoubleService.cmpdbl(angle2, 0) == true)
                    {
                        if (shield.Width1 < pipeOD / 2 && shield.Width1 > 0 && shield.Width2 < pipeOD / 2 && shield.Width2 > 0)
                        {
                            angle1 = Math.Asin(shield.Width1 / (pipeOD / 2));
                            angle2 = Math.Asin(shield.Width2 / (pipeOD / 2));
                        }
                        else
                            error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidWidth1andWidth2GTZeroAndLTPipeOD, "Width1 and Width2 must be greater than 0 and less than PipeOD/2"));
                    }
                    else
                    {
                        //check if all the angles are defined
                        if (HgrCompareDoubleService.cmpdbl(angle1, 0) == true || HgrCompareDoubleService.cmpdbl(angle2, 0) == true)
                            error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidAngle1andAngle2GTZero, "Angle1 and Angle2 must be greater than zero"));
                    }
                }

                if (HgrCompareDoubleService.cmpdbl(shield.Thickness2, 0) == false)
                {
                    if (shield.Length2 <= 0)
                        error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidLength2GTZero, "Length2 must be greater than zero"));

                    if (HgrCompareDoubleService.cmpdbl(angle3, 0) == true && HgrCompareDoubleService.cmpdbl(angle4, 0) == true)
                    {
                        if (shield.Width3 < pipeOD / 2 && shield.Width3 > 0 && shield.Width4 < pipeOD / 2 && shield.Width4 > 0)
                        {
                            angle3 = Math.Asin(shield.Width3 / (pipeOD / 2));
                            angle4 = Math.Asin(shield.Width4 / (pipeOD / 2));
                        }
                        else
                            error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidWidth1andWidth2GTZeroAndLTPipeOD, "Width1 and Width2 must be greater than 0 and less than PipeOD/2"));
                    }
                    else
                    {
                        //check if all the angles are defined
                        if (HgrCompareDoubleService.cmpdbl(angle3, 0) == true || HgrCompareDoubleService.cmpdbl(angle4, 0) == true)
                            error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidAngle3andAngle4GTZero, "Angle3 and Angle4 must be greater than zero"));
                    }
                }

                if (shield.Thickness2 <= 0)
                {
                    if (angle1 + angle2 > 360)
                        error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidAngle1andAngle2NGT360, "Angle1 + Angle2 must not be greater than 360 degrees"));
                }

                if (shield.Thickness2 > 0)
                {
                    if (angle1 + angle2 + angle3 + angle4 > 360)
                        error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidAngle1andAngle2andAngle3andAngle4NGT360, "Angle1 + Angle2+ Angle3 + Angle4  must not be greater than 360 degrees"));
                }

                if (shield.Diameter1 > pipeOD && shield.Diameter1 > 0)
                {
                    Double totalAngle;
                    totalAngle = (angle1 * 180) / Math.PI + (angle2 * 180) / Math.PI + (angle3 * 180) / Math.PI + (angle4 * 180) / Math.PI;
                    if (totalAngle < 360.00001 && totalAngle > 359.9999)
                        pipeOD = shield.Diameter1;
                    else
                        error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidAngle1andAngle2andAngle3andAngle4E360, "Angle1 + Angle2 + Angle3 + Angle4 must be equal to 360"));
                }

                if (shield.thickness3 > 0)
                {
                    if (length3 <= 0)
                    {
                        if (shield.Length1 < shield.Length2)
                            length3 = shield.Length1;
                        else
                            length3 = shield.Length2;
                    }

                    if (!(shield.Height1 > 0 || shield.Angle5 > 0))
                        error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidAngle5andHeight1GTZero, "Angle5 or Height1 must be specified"));
                }

                if (error.Length != 0)
                    ToDoListMessage = new ToDoListMessage(ToDoMessageTypes.ToDoMessageWarning, error.ToString());

                //Add double/single shield shape
                AddShieldShape(angle1, angle2, angle3, angle4, pipeOD, shield.Thickness1, shield.Thickness2, shield.Length1, shield.Length2, 0, shield.Offset1, 0, outputs, outputName);

                //Determime outputs for the shield shape
                Double[] sidePlateXLocation = new double[shield.Multi1Qty];
                outputIndex = outputIndex + 1;
                Array.Resize(ref objectCollection, outputIndex);
                objectCollection[outputIndex - 1] = outputName + "PLT1";

                if (shield.Thickness2 > 0 && angle1 > 0 && angle2 > 0)
                {
                    outputIndex = outputIndex + 1;
                    Array.Resize(ref objectCollection, outputIndex);
                    objectCollection[outputIndex - 1] = outputName + "PLT2";
                }

                if (shield.thickness3 > 0)
                {
                    Double blockYOffset;
                    Double blockInsertOffset;

                    blockInsertOffset = shield.Thickness1 + pipeOD / 2 - (Math.Sqrt(((pipeOD / 2 + shield.Thickness1) * (pipeOD / 2 + shield.Thickness1)) - ((shield.Height1 / 2) * (shield.Height1 / 2))));
                    blockYOffset = (shield.thickness3 + blockInsertOffset) / 2 + shield.Thickness1 + pipeOD / 2 - blockInsertOffset;

                    //Add specified curved plates or blocks using a loop
                    for (int i = 0; i <= shield.Multi1Qty - 1; i++)
                    {
                        sidePlateXLocation[i] = ShieldMultiPosition(shield.Length1, shield.Multi1Qty, shield.Multi1LocateBy, shield.Multi1Location, length3)[i];
                        if (shield.Angle5 > 0)
                            AddShieldShape(shield.Angle5 / 2, shield.Angle5 / 2, shield.Angle5 / 2, shield.Angle5 / 2, pipeOD + shield.Thickness1 + shield.Thickness1, shield.thickness3, shield.thickness3, length3, length3, Math.PI / 2, 0, -shield.Length1 / 2 + sidePlateXLocation[i] + shield.Offset1, outputs, outputName + "Num" + (i));
                        else if (shield.Height1 > 0)
                        {
                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(-shield.Length1 / 2 + sidePlateXLocation[i] + shield.Offset1 - length3 / 2, blockYOffset, 0);
                            BusinessObject plate1 = symbolGeometryHelper.CreateBox(null, length3, shield.thickness3 + blockInsertOffset, shield.Height1, 5);
                            outputs.Add(outputName + "Num" + (i) + "PLT1", plate1);

                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(-shield.Length1 / 2 + sidePlateXLocation[i] + shield.Offset1 - length3 / 2, -blockYOffset, 0);
                            BusinessObject plate2 = symbolGeometryHelper.CreateBox(null, length3, shield.thickness3 + blockInsertOffset, shield.Height1, 5);
                            outputs.Add(outputName + "Num" + (i) + "PLT2", plate2);
                        }

                        outputIndex = outputIndex + 2;
                        Array.Resize(ref objectCollection, outputIndex);
                        objectCollection[outputIndex - 2] = outputName + "Num" + (i) + "PLT1";
                        objectCollection[outputIndex - 1] = outputName + "Num" + (i) + "PLT2";
                    }
                }
                //Try to rotate and translate the Graphic to a new location wrt local origin
                for (int i = 0; i < outputIndex; i++)
                {
                    Geometry3d geom3dObject = (Geometry3d)outputs[objectCollection[i]];
                    geom3dObject.Transform(matrix);
                }
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddSheild, "Error in AddSheild");
                }
            }
        }
        /// <summary>
        /// Create the graphical representation of the Shield shape
        /// </summary>
        /// <param name="angle1">- Double -Lower right sweep angle</param>
        /// <param name="angle2">- Double -Lower left  sweep angle.</param>
        /// <param name="angle3">- Double - Upper right sweep angle.</param>
        /// <param name="angle4">- Double - Upper left sweep angle.</param>
        /// <param name="diameter">- Double -Inside diameter of the shield.</param>
        /// <param name="thickness1">- Double - Thickness of lower curved plate.</param>
        /// <param name="thickness2">- Double - Thickness of upper curved plate.</param>
        /// <param name="length1">- Double - Length of lower plate.</param>
        /// <param name="length2">- Double - Length of upper plate</param>
        /// <param name="rotAngle">- Double -rotation angle of pair(on X-axis) </param>
        /// <param name="offset1">- Double - Offset from the center</param>
        /// <param name="xOffset">- Double - Offset along the x -axis</param>
        /// <param name="outputs">The outputs</param>
        /// <param name="outputName">- string -The Name Of The Output</param> 
        /// <Code>
        /// AddShieldShape(angle1, angle2, angle3, angle4, pipeOD, shield.Thickness1, shield.Thickness2, shield.Length1, shield.Length2, 0, shield.Offset1, 0, outputs, outputName);
        /// </Code>
        public void AddShieldShape(Double angle1, Double angle2, Double angle3, Double angle4, Double diameter, Double thickness1, Double thickness2, Double length1, Double length2, Double rotAngle, Double offset1, Double xOffset, OutputDictionary outputs, String outputName)
        {
            try
            {
                ShieldLineInputs angledLines = new ShieldLineInputs();
                Double radius;
                Double[] angle = new Double[4];

                angle[0] = (angle1) * 180 / Math.PI;
                angle[1] = (angle2) * 180 / Math.PI;
                angle[2] = (angle3) * 180 / Math.PI;
                angle[3] = (angle4) * 180 / Math.PI;

                radius = diameter / 2;
                offset1 = offset1 + xOffset;

                SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();
                Matrix4X4 matrix = new Matrix4X4();
                Line3d line;
                Collection<ICurve> collection = new Collection<ICurve>();

                //Load shield line config data
                LoadLineData(radius, thickness1, thickness2, angle, ref angledLines);

                //make lower curved plate
                //LOWER_OUTER_ARC1
                symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                Arc3d arc1 = symbolGeometryHelper.CreateArc(null, radius + thickness1, angle[0] * Math.PI / 180);

                matrix = new Matrix4X4();
                matrix.SetIdentity();
                matrix.Rotate((Math.PI / 2), new Vector(0, 1, 0));
                arc1.Transform(matrix);

                matrix = new Matrix4X4();
                matrix.SetIdentity();
                matrix.Translate(new Vector(offset1 - length1 / 2, 0, 0));
                arc1.Transform(matrix);
                collection.Add(arc1);

                //LOWER_OUTER_ARC2
                symbolGeometryHelper = new SymbolGeometryHelper();
                symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                Arc3d arc2 = symbolGeometryHelper.CreateArc(null, radius + thickness1, angle[1] * Math.PI / 180);

                matrix = new Matrix4X4();
                matrix.SetIdentity();
                matrix.Rotate((Math.PI / 2), new Vector(0, 1, 0));
                arc2.Transform(matrix);

                matrix = new Matrix4X4();
                matrix.SetIdentity();
                matrix.Translate(new Vector(-offset1 + length1 / 2, 0, 0));
                arc2.Transform(matrix);

                matrix = new Matrix4X4();
                matrix.SetIdentity();
                matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                arc2.Transform(matrix);
                collection.Add(arc2);

                //LEFTLINE
                line = new Line3d(new Position(offset1 - length1 / 2, angledLines.SideLine1.StartY, angledLines.SideLine1.StartZ), new Position(offset1 - length1 / 2, angledLines.SideLine1.EndY, angledLines.SideLine1.EndZ));
                collection.Add(line);

                //LOWER_INNER_ARC1
                symbolGeometryHelper = new SymbolGeometryHelper();
                symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                Arc3d arc3 = symbolGeometryHelper.CreateArc(null, radius, angle[0] * Math.PI / 180);

                matrix = new Matrix4X4();
                matrix.SetIdentity();
                matrix.Rotate((Math.PI / 2), new Vector(0, 1, 0));
                arc3.Transform(matrix);

                matrix = new Matrix4X4();
                matrix.SetIdentity();
                matrix.Translate(new Vector(offset1 - length1 / 2, 0, 0));
                arc3.Transform(matrix);
                collection.Add(arc3);

                //LOWER_INNER_ARC2
                symbolGeometryHelper = new SymbolGeometryHelper();
                symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                Arc3d arc4 = symbolGeometryHelper.CreateArc(null, radius, angle[1] * Math.PI / 180);

                matrix = new Matrix4X4();
                matrix.SetIdentity();
                matrix.Rotate((Math.PI / 2), new Vector(0, 1, 0));
                arc4.Transform(matrix);

                matrix = new Matrix4X4();
                matrix.SetIdentity();
                matrix.Translate(new Vector(-offset1 + length1 / 2, 0, 0));
                arc4.Transform(matrix);

                matrix = new Matrix4X4();
                matrix.SetIdentity();
                matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                arc4.Transform(matrix);
                collection.Add(arc4);

                //RIGHTLINE
                line = new Line3d(new Position(offset1 - length1 / 2, angledLines.SideLine2.StartY, angledLines.SideLine2.StartZ), new Position(offset1 - length1 / 2, angledLines.SideLine2.EndY, angledLines.SideLine2.EndZ));
                collection.Add(line);

                ComplexString3d plate1Collection = new ComplexString3d(collection);
                Vector plate1Vector = new Vector(1, 0, 0);
                Projection3d plate1 = new Projection3d(plate1Collection, plate1Vector, length1, true);
                outputs.Add(outputName + "PLT1", plate1);

                //make upper curved plate
                if (thickness2 > 0 && angle1 > 0 && angle2 > 0)
                {
                    collection = new Collection<ICurve>();

                    //OUTER ARC
                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    Arc3d arc5 = symbolGeometryHelper.CreateArc(null, radius + thickness2, angle[2] * Math.PI / 180);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Rotate(-Math.PI / 2, new Vector(0, 1, 0));
                    arc5.Transform(matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Translate(new Vector(offset1 - length2 / 2, 0, 0));
                    arc5.Transform(matrix);
                    collection.Add(arc5);

                    //OUTER_ARC
                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    Arc3d arc6 = symbolGeometryHelper.CreateArc(null, radius + thickness2, angle[3] * Math.PI / 180);


                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Rotate(-Math.PI / 2, new Vector(0, 1, 0));
                    arc6.Transform(matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Translate(new Vector(-offset1 + length2 / 2, 0, 0));
                    arc6.Transform(matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                    arc6.Transform(matrix);
                    collection.Add(arc6);


                    //LEFTLINE
                    line = new Line3d(new Position(offset1 - length2 / 2, angledLines.SideLine3.StartY, angledLines.SideLine3.StartZ), new Position(offset1 - length2 / 2, angledLines.SideLine3.EndY, angledLines.SideLine3.EndZ));
                    collection.Add(line);

                    //INNER_ARC
                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    Arc3d arc7 = symbolGeometryHelper.CreateArc(null, radius, angle[2] * Math.PI / 180);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Rotate(-Math.PI / 2, new Vector(0, 1, 0));
                    arc7.Transform(matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Translate(new Vector(offset1 - length2 / 2, 0, 0));
                    arc7.Transform(matrix);
                    collection.Add(arc7);

                    //INNER_ARC
                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    Arc3d arc8 = symbolGeometryHelper.CreateArc(null, radius, angle[3] * Math.PI / 180);


                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Rotate(-Math.PI / 2, new Vector(0, 1, 0));
                    arc8.Transform(matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Translate(new Vector(-offset1 + length2 / 2, 0, 0));
                    arc8.Transform(matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                    arc8.Transform(matrix);
                    collection.Add(arc8);

                    //RIGHT
                    line = new Line3d(new Position(offset1 - length2 / 2, angledLines.SideLine4.StartY, angledLines.SideLine4.StartZ), new Position(offset1 - length2 / 2, angledLines.SideLine4.EndY, angledLines.SideLine4.EndZ));
                    collection.Add(line);

                    ComplexString3d plate2Collection = new ComplexString3d(collection);
                    Vector plate2Vector = new Vector(1, 0, 0);
                    Projection3d plate2 = new Projection3d(plate2Collection, plate2Vector, length2, true);
                    outputs.Add(outputName + "PLT2", plate2);
                }

                Geometry3d transformObject;
                Matrix4X4 rotateMatrix = new Matrix4X4();
                if (rotAngle > 0)
                {
                    rotateMatrix.Rotate(rotAngle, new Vector(1, 0, 0));
                    transformObject = (Geometry3d)outputs[outputName + "PLT1"];
                    transformObject.Transform(rotateMatrix);

                    transformObject = (Geometry3d)outputs[outputName + "PLT2"];
                    transformObject.Transform(rotateMatrix);
                }

            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddSheildShape, "Error in AddShieldShape");
                }
            }
        }
        /// <summary>
        /// Calculates the start and end points of for the lines need to create a basic shields/repard.         
        /// </summary>
        /// <param name="radius">Double-The Inside radius.</param>
        /// <param name="thickness1">Double-The Thickness of  the top shield.</param>
        /// <param name="thickness2">Double-The Thickness of  the lower shield.</param>
        /// <param name="angle[]">Double-The Array of Angles.</param>
        /// <param name="angledLines">ShieldLineInputs-The object containing  line data.</param>
        /// <returns></returns>
        ///<code>
        /// ShieldLineInputs angledLines = new ShieldLineInputs();                
        /// Double[] angle = new Double[4]; 
        /// angle[0] = (angle1) * 180 / Math.PI;
        /// angle[1] = (angle2) * 180 / Math.PI;
        /// angle[2] = (angle3) * 180 / Math.PI;
        /// angle[3] = (angle4) * 180 / Math.PI;
        /// LoadLineData(radius, thickness1, thickness2, angle,ref angledLines);
        ///</code>
        public void LoadLineData(Double radius, Double thickness1, Double thickness2, Double[] angle, ref ShieldLineInputs angledLines)
        {
            try
            {
                Double[] acuteAngle = new Double[4];
                const int acutAngle = 0;
                const int rightAngle = 90;
                const int straightAngle = 180;
                const int reflexAngle = 270;
                const int rotationAngle = 360;

                //make acute angles for use with sine rule
                for (int i = 0; i < 4; i++)
                {
                    if ((angle[i]) > acutAngle && (angle[i]) < rightAngle)
                        acuteAngle[i] = (angle[i]);
                    else if ((angle[i]) >= rightAngle && (angle[i]) < straightAngle)
                        acuteAngle[i] = (angle[i]) - rightAngle;
                    else if ((angle[i]) >= straightAngle && (angle[i]) < reflexAngle)
                        acuteAngle[i] = (angle[i]) - straightAngle;
                    else if ((angle[i]) >= reflexAngle && (angle[i]) < rotationAngle)
                        acuteAngle[i] = (angle[i]) - reflexAngle;
                }

                angledLines.Angle1 = acuteAngle[0];
                angledLines.Angle2 = acuteAngle[1];
                angledLines.Angle3 = acuteAngle[2];
                angledLines.Angle4 = acuteAngle[3];

                //Straight SideLine1 start and End points
                if (angle[0] >= reflexAngle && angle[0] < rotationAngle)
                {
                    angledLines.SideLine1.StartY = -(Math.Cos(acuteAngle[0] * (Math.PI / 180)) * (radius + thickness1));
                    angledLines.SideLine1.StartZ = -(Math.Sin(acuteAngle[0] * (Math.PI / 180)) * (radius + thickness1));
                    angledLines.SideLine1.EndY = -(Math.Cos(acuteAngle[0] * (Math.PI / 180)) * (radius));
                    angledLines.SideLine1.EndZ = -(Math.Sin(acuteAngle[0] * (Math.PI / 180)) * (radius));
                }

                if (angle[0] >= straightAngle && angle[0] < reflexAngle)
                {
                    angledLines.SideLine1.StartZ = (Math.Cos(acuteAngle[0] * (Math.PI / 180)) * (radius + thickness1));
                    angledLines.SideLine1.StartY = -(Math.Sin(acuteAngle[0] * (Math.PI / 180)) * (radius + thickness1));
                    angledLines.SideLine1.EndZ = (Math.Cos(acuteAngle[0] * (Math.PI / 180)) * (radius));
                    angledLines.SideLine1.EndY = -(Math.Sin(acuteAngle[0] * (Math.PI / 180)) * (radius));
                }

                if (angle[0] >= rightAngle && angle[0] < straightAngle)
                {
                    angledLines.SideLine1.StartY = (Math.Cos(acuteAngle[0] * (Math.PI / 180)) * (radius + thickness1));
                    angledLines.SideLine1.StartZ = (Math.Sin(acuteAngle[0] * (Math.PI / 180)) * (radius + thickness1));
                    angledLines.SideLine1.EndY = (Math.Cos(acuteAngle[0] * (Math.PI / 180)) * (radius));
                    angledLines.SideLine1.EndZ = (Math.Sin(acuteAngle[0] * (Math.PI / 180)) * (radius));
                }

                if (angle[0] > acutAngle && angle[0] < rightAngle)
                {
                    angledLines.SideLine1.StartZ = -(Math.Cos(acuteAngle[0] * (Math.PI / 180)) * (radius + thickness1));
                    angledLines.SideLine1.StartY = (Math.Sin(acuteAngle[0] * (Math.PI / 180)) * (radius + thickness1));
                    angledLines.SideLine1.EndZ = -(Math.Cos(acuteAngle[0] * (Math.PI / 180)) * (radius));
                    angledLines.SideLine1.EndY = (Math.Sin(acuteAngle[0] * (Math.PI / 180)) * (radius));
                }
                //Straight SideLine2 start and End points
                if (angle[1] > acutAngle && angle[1] < rightAngle)
                {
                    angledLines.SideLine2.StartZ = -(Math.Cos(acuteAngle[1] * (Math.PI / 180)) * (radius + thickness1));
                    angledLines.SideLine2.StartY = -(Math.Sin(acuteAngle[1] * (Math.PI / 180)) * (radius + thickness1));
                    angledLines.SideLine2.EndZ = -(Math.Cos(acuteAngle[1] * (Math.PI / 180)) * (radius));
                    angledLines.SideLine2.EndY = -(Math.Sin(acuteAngle[1] * (Math.PI / 180)) * (radius));
                }

                if (angle[1] >= rightAngle && angle[1] < straightAngle)
                {
                    angledLines.SideLine2.StartY = -(Math.Cos(acuteAngle[1] * (Math.PI / 180)) * (radius + thickness1));
                    angledLines.SideLine2.StartZ = (Math.Sin(acuteAngle[1] * (Math.PI / 180)) * (radius + thickness1));
                    angledLines.SideLine2.EndY = -(Math.Cos(acuteAngle[1] * (Math.PI / 180)) * (radius));
                    angledLines.SideLine2.EndZ = (Math.Sin(acuteAngle[1] * (Math.PI / 180)) * (radius));
                }

                if (angle[1] >= straightAngle && angle[1] < reflexAngle)
                {
                    angledLines.SideLine2.StartZ = (Math.Cos(acuteAngle[1] * (Math.PI / 180)) * (radius + thickness1));
                    angledLines.SideLine2.StartY = (Math.Sin(acuteAngle[1] * (Math.PI / 180)) * (radius + thickness1));
                    angledLines.SideLine2.EndZ = (Math.Cos(acuteAngle[1] * (Math.PI / 180)) * (radius));
                    angledLines.SideLine2.EndY = (Math.Sin(acuteAngle[1] * (Math.PI / 180)) * (radius));
                }

                if (angle[1] >= reflexAngle && angle[1] < rotationAngle)
                {
                    angledLines.SideLine2.StartY = (Math.Cos(acuteAngle[1] * (Math.PI / 180)) * (radius + thickness1));
                    angledLines.SideLine2.StartZ = -(Math.Sin(acuteAngle[1] * (Math.PI / 180)) * (radius + thickness1));
                    angledLines.SideLine2.EndY = (Math.Cos(acuteAngle[1] * (Math.PI / 180)) * (radius));
                    angledLines.SideLine2.EndZ = -(Math.Sin(acuteAngle[1] * (Math.PI / 180)) * (radius));
                }

                //Straight SideLine3 start && End points
                if (angle[2] >= straightAngle && angle[2] < reflexAngle)
                {
                    angledLines.SideLine3.StartZ = -(Math.Cos(acuteAngle[2] * (Math.PI / 180)) * (radius + thickness2));
                    angledLines.SideLine3.StartY = -(Math.Sin(acuteAngle[2] * (Math.PI / 180)) * (radius + thickness2));
                    angledLines.SideLine3.EndZ = -(Math.Cos(acuteAngle[2] * (Math.PI / 180)) * (radius));
                    angledLines.SideLine3.EndY = -(Math.Sin(acuteAngle[2] * (Math.PI / 180)) * (radius));
                }

                if (angle[2] >= reflexAngle && angle[2] < rotationAngle)
                {
                    angledLines.SideLine3.StartY = -(Math.Cos(acuteAngle[2] * (Math.PI / 180)) * (radius + thickness2));
                    angledLines.SideLine3.StartZ = (Math.Sin(acuteAngle[2] * (Math.PI / 180)) * (radius + thickness2));
                    angledLines.SideLine3.EndY = -(Math.Cos(acuteAngle[2] * (Math.PI / 180)) * (radius));
                    angledLines.SideLine3.EndZ = (Math.Sin(acuteAngle[2] * (Math.PI / 180)) * (radius));
                }

                if (angle[2] > acutAngle && angle[2] < rightAngle)
                {
                    angledLines.SideLine3.StartZ = (Math.Cos(acuteAngle[2] * (Math.PI / 180)) * (radius + thickness2));
                    angledLines.SideLine3.StartY = (Math.Sin(acuteAngle[2] * (Math.PI / 180)) * (radius + thickness2));
                    angledLines.SideLine3.EndZ = (Math.Cos(acuteAngle[2] * (Math.PI / 180)) * (radius));
                    angledLines.SideLine3.EndY = (Math.Sin(acuteAngle[2] * (Math.PI / 180)) * (radius));
                }

                if (angle[2] >= rightAngle && angle[2] < straightAngle)
                {
                    angledLines.SideLine3.StartY = (Math.Cos(acuteAngle[2] * (Math.PI / 180)) * (radius + thickness2));
                    angledLines.SideLine3.StartZ = -(Math.Sin(acuteAngle[2] * (Math.PI / 180)) * (radius + thickness2));
                    angledLines.SideLine3.EndY = (Math.Cos(acuteAngle[2] * (Math.PI / 180)) * (radius));
                    angledLines.SideLine3.EndZ = -(Math.Sin(acuteAngle[2] * (Math.PI / 180)) * (radius));
                }

                //Straight SideLine4 start && End points
                if (angle[3] > acutAngle && angle[3] < rightAngle)
                {    //1
                    angledLines.SideLine4.StartZ = (Math.Cos(acuteAngle[3] * (Math.PI / 180)) * (radius + thickness2));
                    angledLines.SideLine4.StartY = -(Math.Sin(acuteAngle[3] * (Math.PI / 180)) * (radius + thickness2));
                    angledLines.SideLine4.EndZ = (Math.Cos(acuteAngle[3] * (Math.PI / 180)) * (radius));
                    angledLines.SideLine4.EndY = -(Math.Sin(acuteAngle[3] * (Math.PI / 180)) * (radius));
                }

                if (angle[3] >= rightAngle && angle[3] < straightAngle)
                {    //'2
                    angledLines.SideLine4.StartY = -(Math.Cos(acuteAngle[3] * (Math.PI / 180)) * (radius + thickness2));
                    angledLines.SideLine4.StartZ = -(Math.Sin(acuteAngle[3] * (Math.PI / 180)) * (radius + thickness2));
                    angledLines.SideLine4.EndY = -(Math.Cos(acuteAngle[3] * (Math.PI / 180)) * (radius));
                    angledLines.SideLine4.EndZ = -(Math.Sin(acuteAngle[3] * (Math.PI / 180)) * (radius));
                }

                if (angle[3] >= straightAngle && angle[3] < reflexAngle)
                {    //'3
                    angledLines.SideLine4.StartZ = -(Math.Cos(acuteAngle[3] * (Math.PI / 180)) * (radius + thickness2));
                    angledLines.SideLine4.StartY = (Math.Sin(acuteAngle[3] * (Math.PI / 180)) * (radius + thickness2));
                    angledLines.SideLine4.EndZ = -(Math.Cos(acuteAngle[3] * (Math.PI / 180)) * (radius));
                    angledLines.SideLine4.EndY = (Math.Sin(acuteAngle[3] * (Math.PI / 180)) * (radius));
                }

                if (angle[3] >= reflexAngle && angle[3] <= rotationAngle)
                {    //'4
                    angledLines.SideLine4.StartY = (Math.Cos(acuteAngle[3] * (Math.PI / 180)) * (radius + thickness2));
                    angledLines.SideLine4.StartZ = (Math.Sin(acuteAngle[3] * (Math.PI / 180)) * (radius + thickness2));
                    angledLines.SideLine4.EndY = (Math.Cos(acuteAngle[3] * (Math.PI / 180)) * (radius));
                    angledLines.SideLine4.EndZ = (Math.Sin(acuteAngle[3] * (Math.PI / 180)) * (radius));
                }
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadLineData, "Error in LoadLineData");
                }
                return;
            }
        }
        /// <summary>
        /// Returns array representing a location for placement (along X axis)
        /// </summary>
        /// <param name="width">- Double - Width of item that we want position on</param>
        /// <param name="qty">- Double  - Quantity of bolts to be placed</param>
        /// <param name="locateBy">- Double - Can be 0 - Nothing, 1 - Center or 2 - Edge</param>
        /// <param name="distance">- Double - Distance from the locateBy that we want the location of</param>
        /// <param name="multiWidth">- Double - Width of the graphics that will be place at the returned location</param>
        /// <Code>
        /// Double[] sidePlateXLocation = new double[shield.Multi1Qty];
        /// sidePlateXLocation[i] = ShieldMultiPosition(shield.Length1, shield.Multi1Qty, shield.Multi1LocateBy, shield.Multi1Location, length3)[i];
        /// </Code>
        public Double[] ShieldMultiPosition(Double width, Double qty, Double locateBy, Double distance, Double multiWidth)
        {
            Double[] tempArray = new Double[Convert.ToInt64(qty)];
            try
            {
                StringBuilder error = new StringBuilder();

                if ((int)qty == 1)
                {
                    if ((int)locateBy == 1 && HgrCompareDoubleService.cmpdbl(distance, 0) == true)
                        tempArray[0] = width / 2;
                    else if ((int)locateBy == 1 && HgrCompareDoubleService.cmpdbl(distance, 0) == false)
                        tempArray[0] = (width / 2) - distance;
                    else if ((int)locateBy == 2 && HgrCompareDoubleService.cmpdbl(distance, 0) == true)
                        tempArray[0] = multiWidth / 2;
                    else if ((int)locateBy == 2 && HgrCompareDoubleService.cmpdbl(distance, 0) == false)
                        tempArray[0] = (multiWidth / 2) + distance;
                }

                if ((int)qty == 2)
                {
                    if ((int)locateBy == 1 && HgrCompareDoubleService.cmpdbl(distance, 0) == false)
                    {
                        tempArray[0] = (width / 2) - distance / 2;
                        tempArray[1] = (width / 2) + distance / 2;
                    }
                    else if ((int)locateBy == 2 && HgrCompareDoubleService.cmpdbl(distance, 0) == true)
                    {
                        tempArray[0] = multiWidth / 2;
                        tempArray[1] = width - (multiWidth / 2);
                    }
                    else if ((int)locateBy == 2 && HgrCompareDoubleService.cmpdbl(distance, 0) == false)
                    {
                        tempArray[0] = (multiWidth / 2) + distance;
                        tempArray[1] = width - ((multiWidth / 2) + distance);
                    }
                    else
                    {
                        tempArray[0] = width / 2;
                        tempArray[1] = width / 2;
                        error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidQty2, "You should not pass a Qty of 2 located by center with a distance of zero"));
                    }
                }

                if ((int)qty == 3)
                {
                    if ((int)locateBy == 1 && HgrCompareDoubleService.cmpdbl(distance, 0) == false)
                    {
                        tempArray[0] = (width / 2) - distance;
                        tempArray[1] = (width / 2);
                        tempArray[2] = width / 2 + distance;
                    }
                    else if ((int)locateBy == 2 && HgrCompareDoubleService.cmpdbl(distance, 0) == true)
                    {

                        tempArray[0] = multiWidth / 2;
                        tempArray[1] = width / 2;
                        tempArray[2] = width - (multiWidth / 2);
                    }
                    else if ((int)locateBy == 2 && HgrCompareDoubleService.cmpdbl(distance, 0) == false)
                    {
                        tempArray[0] = (multiWidth / 2) + distance;
                        tempArray[1] = width / 2;
                        tempArray[2] = width - ((multiWidth / 2) + distance); ;
                    }
                    else
                    {
                        tempArray[0] = width / 2;
                        tempArray[1] = width / 2;
                        tempArray[2] = width / 2;
                        error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidQty3, "You should not have a Quantity of 3 located by center with a distance of zero"));
                    }
                }

                if (qty > 3)
                {
                    if (distance > 0)
                    {
                        int i = 1;
                        Double tempDistance = 0, startDistance = 0;

                        if ((int)qty % 2 == 0)
                            startDistance = ((width / 2) - (distance / 2)) - (((qty / 2) - 1) * distance);
                        else
                            startDistance = (width / 2) - (((qty - 1) / 2) * distance);
                        tempArray[0] = startDistance;
                        tempDistance = startDistance;

                        for (i = 1; i <= qty - 1; i++)
                        {
                            tempArray[i] = tempDistance + distance;
                            tempDistance = tempDistance + distance;
                        }
                        if (((qty - 1) * distance) > width)
                            error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidWidthQty, "The Width is too small for the distance and Quantity"));

                    }
                    else
                    {
                        error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidDistance, "There should be a distance greater than zero"));
                    }
                }
                if (error.Length != 0)
                {
                    ToDoListMessage = new ToDoListMessage(ToDoMessageTypes.ToDoMessageWarning, error.ToString());
                }
                return tempArray;
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrShieldMultiPosition, "Error in ShieldMultiPosition");
                }
                return tempArray;
            }
        }

        ///Rod
        /// <summary>
        /// Defines the inputs required to construct ouputs of a Rod. 
        /// </summary>
        public struct Rod1Inputs
        {
            /// <summary>
            /// Outside diameter of rod.
            /// </summary>
            public double rodDiameter;
            /// <summary>
            /// Length of rod, if variable length, to be determined by the user during placement.
            /// </summary>
            public double length;
            /// <summary>
            /// Determines graphic shape used at End1 
            /// </summary>
            public int rodEnd1Type;
            /// <summary>
            /// Determines graphic shape used at End2 
            /// </summary>
            public int rodEnd2Type;
            /// <summary>
            /// Determines graphic shape used at Center 
            /// </summary>
            public int rodCenterType;
            /// <summary>
            /// If there is a center feature (ie. RodCenterType is Round, Square or LinkedEyes), Offset1 determines the location of the feature along the rod.
            /// </summary>
            public double offset1;
            /// <summary>
            /// Sets the thickness of the Spade and Bolt end type features.
            /// </summary>
            public double thickness1;
            /// <summary>
            /// Sets the outside diameter of the optional end and center features
            /// </summary>
            public double diameter1;
            /// <summary>
            ///Graphically extends or retracts the visible length of the rod at End1 and End2.
            /// </summary>
            public double overLength1;
            /// <summary>
            /// Graphically extends or retracts the visible length of the rod at End1 and End2.
            /// </summary>
            public double overLength2;
            /// <summary>
            /// For the Spade End type, defines the length from the Port location to the base of the spade.
            /// </summary>
            public double length1;
        }
        /// <summary>
        /// This property adds inputs for Rod.User symbol calls this property AdditionalInputs
        /// to define additional inputs. The list of inputs returned by this method will be the inputs for the user symbol in addition
        /// to the inputs that are already defined as member variables.
        /// </summary>
        ///<code>
        /// public override IEnumerable<Input> AdditionalInputs
        /// {
        ///     get
        ///     {
        ///         int endIndex;
        ///         additionalInputs = new List(Input)();
        ///         //Example , I have added the rod with staring index 3.
        ///         AddRod1Inputs(3, out endIndex, additionalInputs);
        ///         return additionalInputs; 
        ///    }
        /// }
        ///</code>
        public void AddRod1Inputs(int startIndex, out int endIndex, List<Input> additionalInputs)
        {
            try
            {
                additionalInputs.Add((Input)new InputDouble(startIndex, "RodDiameter", "RodDiameter", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Length", "Length", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "RodEnd1Type", "RodEnd1Type", 1, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "RodEnd2Type", "RodEnd2Type", 1, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "RodCenterType", "RodCenterType", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Offset1", "Offset1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Thickness1", "Thickness1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Diameter1", "Diameter1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "OverLength1", "OverLength1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "OverLength2", "OverLength2", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Length1", "Length1", 0, false));
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddRod1Inputs, "Error in adding Rod inputs");
                }
            }
            endIndex = startIndex;
        }
        /// <summary>
        /// Adds the Rod outputs.User symbol calls this method during AdditionalOutputs
        /// to define additional outputs for an aspect. The list of outputs returned by this method will be the outputs for the aspect
        /// in addition to the outputs that are already defined as attributes on the aspect.
        /// </summary>
        /// <param name="additionalOutputs">The additional outputs.</param>
        ///<code>
        ///public override IEnumerable<OutputDefinition> AdditionalOutputs(string aspectName)
        ///{
        ///    List<OutputDefinition> additionalOutputs = new List<OutputDefinition>();
        ///    if (aspectName == "Symbolic")
        ///    {
        ///       AddRod1Outputs(additionalOutputs);
        ///    }
        ///    return additionalOutputs;
        ///}
        ///</code> 
        public void AddRod1Outputs(List<OutputDefinition> additionalOutputs)
        {
            try
            {
                additionalOutputs.Add(new OutputDefinition("Rod" + "ROD", "Rod" + "ROD"));
                additionalOutputs.Add(new OutputDefinition("Rod" + "EndType1", "Rod" + "EndType1"));
                additionalOutputs.Add(new OutputDefinition("Rod" + "EndType2", "Rod" + "EndType2"));
                additionalOutputs.Add(new OutputDefinition("Rod" + "CenterType1", "Rod" + "CenterType1"));
                additionalOutputs.Add(new OutputDefinition("Rod" + "CenterType2", "Rod" + "CenterType2"));

            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddRod1Outputs, "Error in AddRod1Outputs");
                }
            }
        }
        /// <summary>
        /// This method will be called by user symbol to get value of an input(in this case, Rod input structure)during construction of outputs. 
        /// Given the start index, this method will return the value of the RodData struct object.
        /// </summary>
        /// <param name="startIndex">The start index.</param>
        /// <returns></returns>
        ///<code>
        ///Rod1Inputs nut = LoadRod1Data(3);
        ///</code>
        public Rod1Inputs LoadRod1Data(int startIndex)
        {
            Rod1Inputs rod1 = new Rod1Inputs();
            try
            {
                rod1.rodDiameter = GetDoubleInputValue(startIndex);
                rod1.length = GetDoubleInputValue(++startIndex);
                rod1.rodEnd1Type = (int)GetDoubleInputValue(++startIndex);
                rod1.rodEnd2Type = (int)GetDoubleInputValue(++startIndex);
                rod1.rodCenterType = (int)GetDoubleInputValue(++startIndex);
                rod1.offset1 = GetDoubleInputValue(++startIndex);
                rod1.thickness1 = GetDoubleInputValue(++startIndex);
                rod1.diameter1 = GetDoubleInputValue(++startIndex);
                rod1.overLength1 = GetDoubleInputValue(++startIndex);
                rod1.overLength2 = GetDoubleInputValue(++startIndex);
                rod1.length1 = GetDoubleInputValue(++startIndex);
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadRod1Data, "Error in LoadRod1Data Method.");
                }
            }
            return rod1;
        }
        /// <summary>
        ///Create the graphical representation of a Rod.  Specify the inputs and StringMatrix.
        /// </summary>
        ///<param name="Rod">Structure for specifying the inputs for the Rod -Rod1inputs </param>
        ///<param name="matrix">matrix to specify the position and oreintation the graphics - matrix.</param>
        /// <param name="outputs">Collection of declared outputs, which is indexed by the name of the outputs declared as defining SymbolOutputs on the AspectDefinition field- OutputDictionary</param>
        /// <param name="outputName">Output that this graphic is being placed on-String</param>
        ///<code>
        /// AddRod(rod, matrix, m_PhysicalAspect.Outputs, "Rod");
        ///</code>
        public void AddRod(Rod1Inputs rod, Matrix4X4 matrix, OutputDictionary outputs, String outputName)
        {
            try
            {
                SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();
                Line3d line;
                Matrix4X4 arcMatrix;



                if (rod.diameter1 < 0 && (rod.rodEnd1Type != 1 || rod.rodEnd2Type != 1 || rod.rodCenterType != 1))
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidDiameter1NGZero, "Diameter1 should be greater than zero");
                }
                if (HgrCompareDoubleService.cmpdbl(rod.rodDiameter, 0) == true)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidRodDiameter, "RodDiameter should be greater than zero");
                }

                //This will add the rod, this may be all that is needed but if either RodEnd1Type or RodEnd2Type
                //are set to anything other than 1 then we will need to add addtional graphics and make sure that
                //the length of the rod considers the dimensions of the additional ends.
                if (HgrCompareDoubleService.cmpdbl(rod.length + rod.overLength1 + rod.overLength2, 0) == false)
                {
                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(0, 0, -rod.overLength1);
                    symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(1, 0, 0));
                    Projection3d cylinder1 = (Projection3d)symbolGeometryHelper.CreateCylinder(null, rod.rodDiameter / 2, (rod.length + rod.overLength1 + rod.overLength2));
                    cylinder1.Transform(matrix);
                    outputs.Add(outputName + "ROD", cylinder1);
                }

                //If lRodEnd1Type has any value other than 1 (plain end) then we will have to add graphics
                //on the Rod End 1.
                //if RodEnd1Type = 2 then we will need to place an eye end.
                //if rodEnd1Type = 3 then we will need to place a spade end.
                //if rodEnd1Type = 4 then we will need to place a bolt end
                if (rod.rodEnd1Type > 1)
                {
                    if (rod.rodEnd1Type == 2)
                    {
                        symbolGeometryHelper = new SymbolGeometryHelper();
                        symbolGeometryHelper.ActivePosition = new Position(0, 0, -rod.rodDiameter / 2);
                        symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(0, 1, 0));
                        Projection3d cylinder2 = (Projection3d)symbolGeometryHelper.CreateCylinder(null, rod.diameter1 / 2, rod.rodDiameter);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                        cylinder2.Transform(arcMatrix);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(Math.PI / 2, new Vector(0, 0, 1));
                        cylinder2.Transform(arcMatrix);
                        cylinder2.Transform(matrix);
                        outputs.Add(outputName + "EndType1", cylinder2);

                    }
                    else if (rod.rodEnd1Type == 3)
                    {

                        Collection<ICurve> curveCollection = new Collection<ICurve>();
                        symbolGeometryHelper = new SymbolGeometryHelper();
                        symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                        symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(Math.PI, new Vector(0, 0, 1));
                        Arc3d arc1 = symbolGeometryHelper.CreateArc(null, (rod.diameter1 / 2), (2 * (Math.PI) - (Math.PI)));
                        arc1.Transform(arcMatrix);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                        arc1.Transform(arcMatrix);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(Math.PI / 2, new Vector(1, 0, 0));
                        arc1.Transform(arcMatrix);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Translate(new Vector(-rod.thickness1 / 2, 0, 0));
                        arc1.Transform(arcMatrix);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(Math.PI / 2, new Vector(0, 0, 1));
                        arc1.Transform(arcMatrix);
                        curveCollection.Add(arc1);

                        line = new Line3d(new Position(rod.diameter1 / 2, -rod.thickness1 / 2, 0), new Position(rod.diameter1 / 2, -rod.thickness1 / 2, rod.length1));
                        curveCollection.Add(line);

                        line = new Line3d(new Position(rod.diameter1 / 2, -rod.thickness1 / 2, rod.length1), new Position(-rod.diameter1 / 2, -rod.thickness1 / 2, rod.length1));
                        curveCollection.Add(line);

                        line = new Line3d(new Position(-rod.diameter1 / 2, -rod.thickness1 / 2, rod.length1), new Position(-rod.diameter1 / 2, -rod.thickness1 / 2, 0));
                        curveCollection.Add(line);

                        ComplexString3d complexString3 = new ComplexString3d(curveCollection);
                        Vector lineVector1 = new Vector(0, rod.thickness1, 0);
                        Projection3d rod1 = new Projection3d(complexString3, lineVector1, lineVector1.Length, true);
                        rod1.Transform(matrix);
                        outputs.Add(outputName + "EndType1", rod1);

                    }

                    else if (rod.rodEnd1Type == 4)
                    {
                        if (HgrCompareDoubleService.cmpdbl(rod.thickness1, 0) == false)
                        {

                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(0, 0, -rod.thickness1);
                            symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(1, 0, 0));
                            Projection3d cylinder3 = (Projection3d)symbolGeometryHelper.CreateCylinder(null, rod.diameter1 / 2, rod.thickness1);
                            cylinder3.Transform(matrix);
                            outputs.Add(outputName + "EndType1", cylinder3);

                        }
                    }
                    else if (rod.rodEnd1Type == 5)
                    {
                        if (HgrCompareDoubleService.cmpdbl(rod.thickness1, 0) == false)
                        {
                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(0, 0, -rod.thickness1);
                            symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(1, 0, 0));
                            Projection3d cylinder4 = (Projection3d)symbolGeometryHelper.CreateCylinder(null, rod.diameter1 / 2, rod.thickness1);
                            cylinder4.Transform(matrix);
                            outputs.Add(outputName + "EndType1", cylinder4);
                        }
                    }

                }

                //If lRodEnd2Type has any value other than 1 (plain end) then we will have to add graphics
                //on the Rod End 2.
                //if RodEnd2Type = 2 then we will need to place an eye end.
                //if rodEnd2Type = 3 then we will need to place a spade end.
                //if rodEnd2Type = 4 then we will need to place a bolt end
                if (rod.rodEnd2Type > 1)
                {
                    if (rod.rodEnd2Type == 2)
                    {

                        symbolGeometryHelper = new SymbolGeometryHelper();
                        symbolGeometryHelper.ActivePosition = new Position(-rod.length, 0, -rod.rodDiameter / 2);
                        symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(0, 1, 0));
                        Projection3d cylinder5 = (Projection3d)symbolGeometryHelper.CreateCylinder(null, rod.diameter1 / 2, rod.rodDiameter);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                        cylinder5.Transform(arcMatrix);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(Math.PI / 2, new Vector(0, 0, 1));
                        cylinder5.Transform(arcMatrix);
                        cylinder5.Transform(matrix);
                        outputs.Add(outputName + "EndType2", cylinder5);

                    }
                    else if (rod.rodEnd2Type == 3)
                    {

                        Collection<ICurve> curveCollection = new Collection<ICurve>();
                        symbolGeometryHelper = new SymbolGeometryHelper();
                        symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                        symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(Math.PI, new Vector(0, 0, 1));
                        Arc3d arc1 = symbolGeometryHelper.CreateArc(null, (rod.diameter1 / 2), (2 * (Math.PI) - (Math.PI)));
                        arc1.Transform(arcMatrix);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                        arc1.Transform(arcMatrix);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate((3 * (Math.PI / 2)), new Vector(1, 0, 0));
                        arc1.Transform(arcMatrix);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Translate(new Vector(-rod.thickness1 / 2, 0, rod.length));
                        arc1.Transform(arcMatrix);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(Math.PI / 2, new Vector(0, 0, 1));
                        arc1.Transform(arcMatrix);
                        curveCollection.Add(arc1);

                        line = new Line3d(new Position(rod.diameter1 / 2, -rod.thickness1 / 2, rod.length), new Position(rod.diameter1 / 2, -rod.thickness1 / 2, -rod.length1 + rod.length));
                        curveCollection.Add(line);

                        line = new Line3d(new Position(rod.diameter1 / 2, -rod.thickness1 / 2, -rod.length1 + rod.length), new Position(-rod.diameter1 / 2, -rod.thickness1 / 2, -rod.length1 + rod.length));
                        curveCollection.Add(line);

                        line = new Line3d(new Position(-rod.diameter1 / 2, -rod.thickness1 / 2, -rod.length1 + rod.length), new Position(-rod.diameter1 / 2, -rod.thickness1 / 2, rod.length));
                        curveCollection.Add(line);

                        ComplexString3d complexString3 = new ComplexString3d(curveCollection);
                        Vector lineVector1 = new Vector(0, rod.thickness1, 0);
                        Projection3d rod1 = new Projection3d(complexString3, lineVector1, lineVector1.Length, true);
                        rod1.Transform(matrix);
                        outputs.Add(outputName + "EndType2", rod1);

                    }


                    else if (rod.rodEnd2Type == 4)
                    {
                        if (HgrCompareDoubleService.cmpdbl(rod.thickness1, 0) == false)
                        {
                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(0, 0, rod.length);
                            symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(1, 0, 0));
                            Projection3d cylinder6 = (Projection3d)symbolGeometryHelper.CreateCylinder(null, rod.diameter1 / 2, rod.thickness1);
                            cylinder6.Transform(matrix);
                            outputs.Add(outputName + "EndType2", cylinder6);
                        }
                    }
                    else if (rod.rodEnd2Type == 5)
                    {
                        if (HgrCompareDoubleService.cmpdbl(rod.thickness1, 0) == false)
                        {
                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(0, 0, rod.length);
                            symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(1, 0, 0));
                            Projection3d cylinder7 = (Projection3d)symbolGeometryHelper.CreateCylinder(null, rod.diameter1 / 2, rod.thickness1);
                            cylinder7.Transform(matrix);
                            outputs.Add(outputName + "EndType2", cylinder7);
                        }
                    }
                }
                //If RodCenterType is set to anything other that 1 then we will need to add an additional graphic at
                //the value of Offset1.
                //if RodCenterType = 2 then we will need a round graphic at Offset1
                //if RodCenterType = 3 then we will need a Square graphic at Offset1
                //if RodCenterType = 4 then we will need a Linked eye graphic at offset1
                //If there is no offset1 value then we will place the graphics in the middle length of the rod.
                if (rod.rodCenterType > 1)
                {
                    if (rod.rodCenterType == 2)
                    {
                        if (HgrCompareDoubleService.cmpdbl(rod.offset1, 0) == true)
                        {


                            if (HgrCompareDoubleService.cmpdbl(rod.length1, 0) == false)
                            {
                                symbolGeometryHelper = new SymbolGeometryHelper();
                                symbolGeometryHelper.ActivePosition = new Position(0, 0, rod.length / 2 - rod.length1 / 2);
                                symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(1, 0, 0));
                                Projection3d cylinder8 = (Projection3d)symbolGeometryHelper.CreateCylinder(null, rod.diameter1 / 2, rod.length1);
                                cylinder8.Transform(matrix);
                                outputs.Add(outputName + "CenterType1", cylinder8);
                            }
                        }
                        else
                        {

                            if (HgrCompareDoubleService.cmpdbl(rod.length1, 0) == false)
                            {
                                symbolGeometryHelper = new SymbolGeometryHelper();
                                symbolGeometryHelper.ActivePosition = new Position(0, 0, rod.offset1);
                                symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(1, 0, 0));
                                Projection3d cylinder9 = (Projection3d)symbolGeometryHelper.CreateCylinder(null, rod.diameter1 / 2, rod.length1);
                                cylinder9.Transform(matrix);
                                outputs.Add(outputName + "CenterType1", cylinder9);
                            }
                        }
                    }
                    else if (rod.rodCenterType == 3)
                    {
                        if (HgrCompareDoubleService.cmpdbl(rod.offset1, 0) == true)
                        {
                            if (rod.length1 > 0)
                            {
                                symbolGeometryHelper = new SymbolGeometryHelper();
                                symbolGeometryHelper.ActivePosition = new Position(-rod.diameter1 / 2, -rod.diameter1 / 2, rod.length / 2 - rod.length1 / 2);
                                symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                                Projection3d box1 = (Projection3d)symbolGeometryHelper.CreateBox(null, rod.diameter1, rod.diameter1, rod.length1, 9);
                                box1.Transform(matrix);
                                outputs.Add(outputName + "CenterType1", box1);
                            }
                        }
                        else
                        {
                            if (rod.length1 > 0)
                            {
                                symbolGeometryHelper = new SymbolGeometryHelper();
                                symbolGeometryHelper.ActivePosition = new Position(-rod.diameter1 / 2, -rod.diameter1 / 2, rod.offset1);
                                symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                                Projection3d box2 = (Projection3d)symbolGeometryHelper.CreateBox(null, rod.diameter1, rod.diameter1, rod.length1, 9);
                                box2.Transform(matrix);
                                outputs.Add(outputName + "CenterType1", box2);
                            }
                        }
                    }
                    else if (rod.rodCenterType == 4)
                    {
                        if (HgrCompareDoubleService.cmpdbl(rod.offset1, 0) == true)
                        {

                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(-rod.length / 2 - rod.diameter1 / 4 + rod.rodDiameter / 4, 0, -rod.rodDiameter / 2);
                            symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(1, 0, 0));
                            Projection3d cylinder10 = (Projection3d)symbolGeometryHelper.CreateCylinder(null, rod.diameter1 / 2, rod.rodDiameter);
                            arcMatrix = new Matrix4X4();
                            arcMatrix.SetIdentity();
                            arcMatrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                            cylinder10.Transform(arcMatrix);
                            cylinder10.Transform(matrix);
                            outputs.Add(outputName + "CenterType1", cylinder10);
                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(-rod.length / 2 + rod.diameter1 / 4 - rod.rodDiameter / 4, 0, -rod.rodDiameter / 2);
                            symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(1, 0, 0));
                            Projection3d cylinder11 = (Projection3d)symbolGeometryHelper.CreateCylinder(null, rod.diameter1 / 2, rod.rodDiameter);
                            arcMatrix = new Matrix4X4();
                            arcMatrix.SetIdentity();
                            arcMatrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                            cylinder11.Transform(arcMatrix);
                            cylinder11.Transform(matrix);
                            arcMatrix = new Matrix4X4();
                            arcMatrix.SetIdentity();
                            arcMatrix.Rotate(Math.PI / 2, new Vector(0, 0, 1));
                            cylinder11.Transform(arcMatrix);
                            cylinder11.Transform(matrix);
                            outputs.Add(outputName + "CenterType2", cylinder11);

                        }
                        else
                        {

                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position((-rod.offset1 - rod.diameter1) + rod.rodDiameter / 2, 0, -rod.rodDiameter / 2);
                            symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(1, 0, 0));
                            Projection3d cylinder12 = (Projection3d)symbolGeometryHelper.CreateCylinder(null, rod.diameter1 / 2, rod.rodDiameter);
                            arcMatrix = new Matrix4X4();
                            arcMatrix.SetIdentity();
                            arcMatrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                            cylinder12.Transform(arcMatrix);
                            cylinder12.Transform(matrix);
                            cylinder12.Transform(matrix);
                            outputs.Add(outputName + "CenterType1", cylinder12);
                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position((-rod.offset1 - rod.diameter1 / 2), 0, -rod.rodDiameter / 2);
                            symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(1, 0, 0));
                            Projection3d cylinder13 = (Projection3d)symbolGeometryHelper.CreateCylinder(null, rod.diameter1 / 2, rod.rodDiameter);
                            arcMatrix = new Matrix4X4();
                            arcMatrix.SetIdentity();
                            arcMatrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                            cylinder13.Transform(arcMatrix);
                            cylinder13.Transform(matrix);
                            arcMatrix = new Matrix4X4();
                            arcMatrix.SetIdentity();
                            arcMatrix.Rotate(Math.PI / 2, new Vector(0, 0, 1));
                            cylinder13.Transform(arcMatrix);
                            cylinder13.Transform(matrix);
                            outputs.Add(outputName + "CenterType2", cylinder13);

                        }
                    }

                }
            }
            catch (SmartPartSymbolException hgrEx)
            {
                throw hgrEx;
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddRod, "Error in AddRod");
                }
            }
        }

        ///Protect Saddle
        /// <summary>
        /// Defines the ProtectSaddleInputs input parameter type.
        /// </summary>
        public struct ProtectSaddleInputs
        {
            /// <summary>
            /// Outside diameter the pipe that the saddle is for.
            /// </summary>
            public Double PipeOD;
            /// <summary>
            /// The outer radius of the saddle.
            /// </summary>
            public double Radius1;
            /// <summary>
            /// The thickness of the saddle.   
            /// </summary>
            public double Thickness1;
            /// <summary>
            ///Option to include the middle plate.  If yes is selected the middle plate is drawn.
            /// </summary>
            public int InclStiffener; //long in vb
            /// <summary>
            ///The thickness of the insulation
            /// </summary>
            public double Thickness2;
            /// <summary>
            ///The length of the plate.
            /// </summary>
            public double Length1;
            /// <summary>
            ///The angle from vertical CL of the pipe to the left leg of the saddle.
            /// </summary>
            public double Angle1;
            /// <summary>
            ///The angle from vertical CL of the pipe to the right leg of the saddle.
            /// </summary>
            public double Angle2;
            /// <summary>
            ///TThe angle from vertical CL of the pipe to the left edge of the curved plate.
            public double Angle3;
            /// <summary>
            ///The angle from vertical CL of the pipe to the right edge of the curved plate.
            /// </summary>
            public double Angle4;
            /// <summary>
            ///The length of the nut or washer.
            /// </summary>
            public int ToEdge;
            /// <summary>
            ///The distance from vertical CL of the pipe to the left outside edge of the saddle.
            /// </summary>
            public double Width1;
            /// <summary>
            ///The distance from vertical CL of the pipe to the right outside edge of the saddle.
            /// </summary>
            public double Width2;
            /// <summary>
            ///The distance from vertical CL of the pipe to the left overhang of the saddle.
            /// </summary>
            public double Width3;
            /// <summary>
            ///The distance from vertical CL of the pipe to the right overhang of the saddle.
            /// </summary>
            public double Width4;
            /// <summary>
            ///The height from the base of the concrete saddle to the top of the saddles curved surface.
            /// </summary>
            public double Height1;
            /// <summary>
            ///The height of the concrete saddle footing.
            /// </summary>
            public double Height2;
            /// <summary>
            ///The length of the footing
            /// </summary>
            public double Length2;
            /// <summary>
            ///The string specifying the name of the clamp.
            /// </summary>
            public string ClampName;
            /// <summary>
            ///The height from the bottom of the pipe to the bottom of the saddle
            /// </summary>
            public double Height3;
        }
        /// <summary>
        /// Defines the Coordinate input parameter type.
        /// </summary>
        public struct CoordinatesInputs
        {
            /// <summary>
            /// The x-Coordinate value
            /// </summary>
            public double X;
            /// <summary>
            /// The y-Coordinate value
            /// </summary>
            public double Y;
            /// <summary>
            /// The z-Coordinate value   
            /// </summary>
            public double Z;
        }
        /// <summary>
        /// Adds the ProtectSaddle outputs.
        /// </summary>       
        /// <param name="aspectName">Name of the aspect.</param>
        /// <param name="additionalOutputs">The additional outputs.</param>
        /// <code>
        ///  List<OutputDefinition> additionalOutputs = new List<OutputDefinition>();
        ///  AddProtectSaddleOutputs(aspectName, additionalOutputs);
        /// </code>
        public void AddProtectSaddleOutputs(string aspectName, List<OutputDefinition> additionalOutputs)
        {

            try
            {
                additionalOutputs.Add(new OutputDefinition("Saddle1" + "PRTSADDLE", "Saddle1" + "PRTSADDLE"));
                additionalOutputs.Add(new OutputDefinition("Saddle1" + "FOOTING", "Saddle1" + "FOOTING"));
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddProtectSaddleOutputs, "Error in adding ProtectSaddle outputs");
                }
            }
        }
        /// <summary>
        /// Loads the ProtectSaddle data.
        /// </summary>        
        /// <param name="startIndex">The start index.</param>
        /// /// <code>
        ///  ProtectSaddleInputs protectSaddle = LoadProtectSaddle(2);
        /// </code>
        public ProtectSaddleInputs LoadProtectSaddle(int startIndex)
        {
            ProtectSaddleInputs saddle = new ProtectSaddleInputs();
            try
            {
                saddle.PipeOD = GetDoubleInputValue(startIndex);
                saddle.Radius1 = GetDoubleInputValue(++startIndex);
                saddle.Thickness1 = GetDoubleInputValue(++startIndex);
                saddle.InclStiffener = (int)GetDoubleInputValue(++startIndex);
                saddle.Thickness2 = GetDoubleInputValue(++startIndex);
                saddle.Length1 = GetDoubleInputValue(++startIndex);
                if (HgrCompareDoubleService.cmpdbl(saddle.Length1, 0) == true)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidLength1NZero, "Length1 value should not be zero");
                }
                saddle.Angle1 = GetDoubleInputValue(++startIndex);
                saddle.Angle2 = GetDoubleInputValue(++startIndex);
                saddle.Angle3 = GetDoubleInputValue(++startIndex); ;
                saddle.Angle4 = GetDoubleInputValue(++startIndex);
                saddle.ToEdge = (int)GetDoubleInputValue(++startIndex);
                saddle.Width1 = GetDoubleInputValue(++startIndex);
                saddle.Width2 = GetDoubleInputValue(++startIndex);
                saddle.Width3 = GetDoubleInputValue(++startIndex);
                saddle.Width4 = GetDoubleInputValue(++startIndex);
                saddle.Height1 = GetDoubleInputValue(++startIndex);
                saddle.Height2 = GetDoubleInputValue(++startIndex);
                saddle.Length2 = GetDoubleInputValue(++startIndex);

                try
                {
                    saddle.ClampName = GetStringInputValue(++startIndex);
                }
                catch
                {
                    saddle.ClampName = null;
                }
                try
                {
                    saddle.Height3 = GetDoubleInputValue(++startIndex);
                }
                catch
                {
                    saddle.Height3 = 0;
                }
            }
            catch (SmartPartSymbolException hgrEx)
            {
                throw hgrEx;
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadProtectSaddle, "Error in LoadProtectSaddle");
                }
            }
            return saddle;
        }
        /// <summary>
        /// Loads the PipeClampDataByQuery data.
        /// </summary>        
        /// <param name="refShapeName">The name of Sheet in excel workbook</param>
        /// /// <code>
        ///  PipeClampInputs pipeClamp = LoadPipeClampDataByQuery(refShapeName);
        /// </code>
        public PipeClampInputs LoadPipeClampDataByQuery(string refShapeName)
        {
            PipeClampInputs PipeClamp = new PipeClampInputs();
            try
            {
                if (!(refShapeName == "" || refShapeName == "No Value" || refShapeName == null))
                {
                    Catalog m_oPlantCatalog = MiddleServiceProvider.SiteMgr.ActiveSite.ActivePlant.PlantCatalog;
                    BusinessObject pipeClampAuxTable = m_oPlantCatalog.GetNamedObject(refShapeName); ;

                    try
                    {
                        PipeClamp.Diameter1 = (double)((PropertyValueDouble)pipeClampAuxTable.GetPropertyValue("IJUAhsDiameter1", "Diameter1")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.Diameter1 = 0;
                    }
                    try
                    {
                        PipeClamp.Thickness1 = (double)((PropertyValueDouble)pipeClampAuxTable.GetPropertyValue("IJUAhsThickness1", "Thickness1")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.Thickness1 = 0;
                    }
                    try
                    {
                        PipeClamp.Width1 = (double)((PropertyValueDouble)pipeClampAuxTable.GetPropertyValue("IJUAhsWidth1", "Width1")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.Width1 = 0;
                    }
                    try
                    {
                        PipeClamp.Width2 = (double)((PropertyValueDouble)pipeClampAuxTable.GetPropertyValue("IJUAhsWidth2", "Width2")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.Width2 = 0;
                    }
                    try
                    {
                        PipeClamp.Height1 = (double)((PropertyValueDouble)pipeClampAuxTable.GetPropertyValue("IJUAhsHeight1", "Height1")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.Height1 = 0;
                    }
                    try
                    {
                        PipeClamp.Height2 = (double)((PropertyValueDouble)pipeClampAuxTable.GetPropertyValue("IJUAhsHeight2", "Height2")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.Height2 = 0;
                    }
                    try
                    {
                        PipeClamp.Gap1 = (double)((PropertyValueDouble)pipeClampAuxTable.GetPropertyValue("IJUAhsGap1", "Gap1")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.Gap1 = 0;
                    }
                    try
                    {
                        PipeClamp.Gap2 = (double)((PropertyValueDouble)pipeClampAuxTable.GetPropertyValue("IJUAhsGap2", "Gap2")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.Gap2 = 0;
                    }
                    try
                    {
                        PipeClamp.Angle1 = (double)((PropertyValueDouble)pipeClampAuxTable.GetPropertyValue("IJUAhsAngle1", "Angle1")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.Angle1 = 0;
                    }
                    try
                    {
                        PipeClamp.Pin1Diameter = (double)((PropertyValueDouble)pipeClampAuxTable.GetPropertyValue("IJUAhsPin1", "Pin1Diameter")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.Pin1Diameter = 0;
                    }
                    try
                    {
                        PipeClamp.Pin1Length = (double)((PropertyValueDouble)pipeClampAuxTable.GetPropertyValue("IJUAhsPin1", "Pin1Length")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.Pin1Length = 0;
                    }
                    try
                    {
                        PipeClamp.BoltRow1.Offset = (double)((PropertyValueDouble)pipeClampAuxTable.GetPropertyValue("IJUAhsOffset1", "Offset1")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.BoltRow1.Offset = 0;
                    }
                    try
                    {
                        PipeClamp.BoltRow1.MultiQty = (double)((PropertyValueDouble)pipeClampAuxTable.GetPropertyValue("IJUAhsMulti1", "Multi1Qty")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.BoltRow1.MultiQty = 0;
                    }
                    try
                    {
                        PipeClamp.BoltRow1.MultiLocateBy = (int)((PropertyValueCodelist)pipeClampAuxTable.GetPropertyValue("IJUAhsMulti1", "Multi1LocateBy")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.BoltRow1.MultiLocateBy = 0;
                    }

                    try
                    {
                        PipeClamp.BoltRow1.MultiLocation = (double)((PropertyValueDouble)pipeClampAuxTable.GetPropertyValue("IJUAhsMulti1", "Multi1Location")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.BoltRow1.MultiLocation = 0;
                    }

                    try
                    {
                        PipeClamp.BoltRow2.Offset = (double)((PropertyValueDouble)pipeClampAuxTable.GetPropertyValue("IJUAhsOffset2", "Offset2")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.BoltRow2.Offset = 0;
                    }
                    try
                    {
                        PipeClamp.BoltRow2.MultiQty = (double)((PropertyValueDouble)pipeClampAuxTable.GetPropertyValue("IJUAhsMulti2", "Multi2Qty")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.BoltRow2.MultiQty = 0;
                    }
                    try
                    {
                        PipeClamp.BoltRow2.MultiLocateBy = (int)((PropertyValueCodelist)pipeClampAuxTable.GetPropertyValue("IJUAhsMulti2", "Multi2LocateBy")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.BoltRow2.MultiLocateBy = 0;
                    }
                    try
                    {
                        PipeClamp.BoltRow2.MultiLocation = (double)((PropertyValueDouble)pipeClampAuxTable.GetPropertyValue("IJUAhsMulti2", "Multi2Location")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.BoltRow2.MultiLocation = 0;
                    } try
                    {
                        PipeClamp.BoltRow3.Offset = (double)((PropertyValueDouble)pipeClampAuxTable.GetPropertyValue("IJUAhsOffset3", "Offset3")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.BoltRow3.Offset = 0;
                    }
                    try
                    {
                        PipeClamp.BoltRow3.MultiQty = (double)((PropertyValueDouble)pipeClampAuxTable.GetPropertyValue("IJUAhsMulti6", "Multi6Qty")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.BoltRow3.MultiQty = 0;
                    }
                    try
                    {
                        PipeClamp.BoltRow3.MultiLocateBy = (int)((PropertyValueCodelist)pipeClampAuxTable.GetPropertyValue("IJUAhsMulti3", "Multi3LocateBy")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.BoltRow3.MultiLocateBy = 0;
                    }
                    try
                    {
                        PipeClamp.BoltRow3.MultiLocation = (double)((PropertyValueDouble)pipeClampAuxTable.GetPropertyValue("IJUAhsMulti3", "Multi3Location")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.BoltRow3.MultiLocation = 0;
                    }
                    try
                    {
                        PipeClamp.BoltRow4.Offset = (double)((PropertyValueDouble)pipeClampAuxTable.GetPropertyValue("IJUAhsOffset4", "Offset4")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.BoltRow4.Offset = 0;
                    }
                    try
                    {
                        PipeClamp.BoltRow4.MultiQty = (double)((PropertyValueDouble)pipeClampAuxTable.GetPropertyValue("IJUAhsMulti4", "Multi4Qty")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.BoltRow4.MultiQty = 0;
                    }
                    try
                    {
                        PipeClamp.BoltRow4.MultiLocateBy = (int)((PropertyValueCodelist)pipeClampAuxTable.GetPropertyValue("IJUAhsMulti4", "Multi4LocateBy")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.BoltRow4.MultiLocateBy = 0;
                    }
                    try
                    {
                        PipeClamp.BoltRow4.MultiLocation = (double)((PropertyValueDouble)pipeClampAuxTable.GetPropertyValue("IJUAhsMulti4", "Multi4Location")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.BoltRow4.MultiLocation = 0;
                    }
                    try
                    {
                        PipeClamp.BoltRow5.Offset = (double)((PropertyValueDouble)pipeClampAuxTable.GetPropertyValue("IJUAhsOffset5", "Offset5")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.BoltRow5.Offset = 0;
                    }
                    try
                    {
                        PipeClamp.BoltRow5.MultiQty = (double)((PropertyValueDouble)pipeClampAuxTable.GetPropertyValue("IJUAhsMulti5", "Multi5Qty")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.BoltRow5.MultiQty = 0;
                    }
                    try
                    {
                        PipeClamp.BoltRow5.MultiLocateBy = (int)((PropertyValueCodelist)pipeClampAuxTable.GetPropertyValue("IJUAhsMulti5", "Multi5LocateBy")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.BoltRow5.MultiLocateBy = 0;
                    }
                    try
                    {
                        PipeClamp.BoltRow5.MultiLocation = (double)((PropertyValueDouble)pipeClampAuxTable.GetPropertyValue("IJUAhsMulti5", "Multi5Location")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.BoltRow5.MultiLocation = 0;
                    }
                    try
                    {
                        PipeClamp.BoltRow6.Offset = (double)((PropertyValueDouble)pipeClampAuxTable.GetPropertyValue("IJUAhsOffset6", "Offset6")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.BoltRow6.Offset = 0;
                    }
                    try
                    {
                        PipeClamp.BoltRow6.MultiQty = (double)((PropertyValueDouble)pipeClampAuxTable.GetPropertyValue("IJUAhsMulti6", "Multi6Qty")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.BoltRow6.MultiQty = 0;
                    }
                    try
                    {
                        PipeClamp.BoltRow6.MultiLocateBy = (int)((PropertyValueCodelist)pipeClampAuxTable.GetPropertyValue("IJUAhsMulti6", "Multi6LocateBy")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.BoltRow6.MultiLocateBy = 0;
                    }
                    try
                    {
                        PipeClamp.BoltRow6.MultiLocation = (double)((PropertyValueDouble)pipeClampAuxTable.GetPropertyValue("IJUAhsMulti6", "Multi6Location")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.BoltRow6.MultiLocation = 0;
                    }
                    try
                    {
                        PipeClamp.ClampCfg = (int)((PropertyValueCodelist)pipeClampAuxTable.GetPropertyValue("IJOAhsClampCfg", "ClampCfg")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.ClampCfg = 0;
                    }
                    try
                    {
                        PipeClamp.Angle3 = (double)((PropertyValueDouble)pipeClampAuxTable.GetPropertyValue("IJUAhsAngle3", "Angle3")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.Angle3 = 0;
                    }
                    try
                    {
                        PipeClamp.Width3 = (double)((PropertyValueDouble)pipeClampAuxTable.GetPropertyValue("IJUAhsWidth3", "Width3")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.Width3 = 0;
                    }
                    try
                    {
                        PipeClamp.Height3 = (double)((PropertyValueDouble)pipeClampAuxTable.GetPropertyValue("IJUAhsHeight3", "Height3")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.Height3 = 0;
                    }
                    try
                    {
                        PipeClamp.Length = (double)((PropertyValueDouble)pipeClampAuxTable.GetPropertyValue("IJUAhsLength", "Length")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.Length = 0;
                    }
                    try
                    {
                        PipeClamp.Dim1 = (double)((PropertyValueDouble)pipeClampAuxTable.GetPropertyValue("IJUAhsDim1", "Dim1")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.Dim1 = 0;
                    }
                    try
                    {
                        PipeClamp.Dim2 = (double)((PropertyValueDouble)pipeClampAuxTable.GetPropertyValue("IJUAhsDim2", "Dim2")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.Dim2 = 0;
                    }
                    try
                    {
                        PipeClamp.Thickness2 = (double)((PropertyValueDouble)pipeClampAuxTable.GetPropertyValue("IJUAhsThickness2", "Thickness2")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.Thickness2 = 0;
                    }

                    try
                    {
                        PipeClamp.Diameter4 = (double)((PropertyValueDouble)pipeClampAuxTable.GetPropertyValue("IJUAhsDiameter4", "Diameter4")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.Diameter4 = 0;
                    }
                    try
                    {
                        PipeClamp.Width4 = (double)((PropertyValueDouble)pipeClampAuxTable.GetPropertyValue("IJUAhsWidth4", "Width4")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.Width4 = 0;
                    }
                    try
                    {
                        PipeClamp.ShapeType = (int)((PropertyValueCodelist)pipeClampAuxTable.GetPropertyValue("IJUAhsShapeType", "ShapeType")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.ShapeType = 0;
                    }
                    try
                    {
                        PipeClamp.Thickness3 = (double)((PropertyValueDouble)pipeClampAuxTable.GetPropertyValue("IJUAhsThickness3", "Thickness3")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.Thickness3 = 0;
                    }
                    try
                    {
                        PipeClamp.Width5 = (double)((PropertyValueDouble)pipeClampAuxTable.GetPropertyValue("IJUAhsWidth5", "Width5")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.Width5 = 0;
                    }
                    try
                    {
                        PipeClamp.Width6 = (double)((PropertyValueDouble)pipeClampAuxTable.GetPropertyValue("IJUAhsWidth6", "Width6")).PropValue;
                    }
                    catch
                    {
                        PipeClamp.Width6 = 0;
                    }
                    try
                    {
                        PipeClamp.Angle2 = (double)((PropertyValueDouble)pipeClampAuxTable.GetPropertyValue("IJUAhsAngle2", "Angle2")).PropValue;

                    }
                    catch
                    {
                        PipeClamp.Angle2 = 0;
                    }
                }

            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadPipeClampDataByQuery, "Error in LoadPipeClampDataByQuery");
                }
            }
            return PipeClamp;
        }
        /// <summary>
        /// Loads the values associated to the given shape into the Shoe UDT. This is done by querying the database for the given name.
        /// </summary>
        /// <param name="refShapeName">part name of the auxiliary table</param>
        /// <returns></returns>
        ///<code>
        ///ShoeInputs shoeInputs  = LoadShoeDataByQuery(repadName);
        ///</code>
        public ShoeInputs LoadShoeDataByQuery(string refShapeName)
        {
            ShoeInputs shoeInputs = new ShoeInputs();
            try
            {

                if (!(refShapeName == "" || refShapeName == "No Value"))
                {
                    Catalog m_oPlantCatalog = MiddleServiceProvider.SiteMgr.ActiveSite.ActivePlant.PlantCatalog;
                    BusinessObject ShoeAuxTable = m_oPlantCatalog.GetNamedObject(refShapeName);

                    shoeInputs.ShoeType = (int)((PropertyValueCodelist)ShoeAuxTable.GetPropertyValue("IJUAhsShoeType", "ShoeType")).PropValue;
                    try
                    {
                        shoeInputs.ShoeHeight = (double)((PropertyValueDouble)ShoeAuxTable.GetPropertyValue("IJUAhsShoeHeight", "ShoeHeight")).PropValue;
                    }
                    catch
                    {
                        shoeInputs.ShoeHeight = 0;
                    }
                    try
                    {
                        shoeInputs.ShoeWidth = (double)((PropertyValueDouble)ShoeAuxTable.GetPropertyValue("IJUAhsShoeWidth", "ShoeWidth")).PropValue;
                    }
                    catch { shoeInputs.ShoeWidth = 0; }
                    try
                    {
                        shoeInputs.ShoeLength = (double)((PropertyValueDouble)ShoeAuxTable.GetPropertyValue("IJUAhsShoeLength", "ShoeLength")).PropValue;
                    }
                    catch { shoeInputs.ShoeLength = 0; }

                    try
                    {
                        shoeInputs.HorizontalPlateLength = (double)((PropertyValueDouble)ShoeAuxTable.GetPropertyValue("IJUAhsHorPlLen", "HorizontalPlateLength")).PropValue;
                    }
                    catch
                    { shoeInputs.HorizontalPlateLength = 0; }
                    try
                    {
                        shoeInputs.VerticalPlateLength = (double)((PropertyValueDouble)ShoeAuxTable.GetPropertyValue("IJUAhsVertPlLen", "VerticalPlateLength")).PropValue;
                    }
                    catch
                    { shoeInputs.VerticalPlateLength = 0; }
                    try
                    {
                        shoeInputs.ShoeThickness1 = (double)((PropertyValueDouble)ShoeAuxTable.GetPropertyValue("IJUAhsShoeThickness1", "ShoeThickness1")).PropValue;
                    }
                    catch
                    { shoeInputs.ShoeThickness1 = 0; }
                    try
                    {
                        shoeInputs.ShoeThickness2 = (double)((PropertyValueDouble)ShoeAuxTable.GetPropertyValue("IJUAhsShoeThickness2", "ShoeThickness2")).PropValue;
                    }
                    catch
                    { shoeInputs.ShoeThickness2 = 0; }
                    try
                    {
                        shoeInputs.TopPlateThickness = (double)((PropertyValueDouble)ShoeAuxTable.GetPropertyValue("IJUAhsTopPlate", "TopPlateThickness")).PropValue;
                    }
                    catch
                    { shoeInputs.TopPlateThickness = 0; }
                    try
                    {
                        shoeInputs.TopPlateLength = (double)((PropertyValueDouble)ShoeAuxTable.GetPropertyValue("IJUAhsTopPlate", "TopPlateLength")).PropValue;
                    }
                    catch
                    { shoeInputs.TopPlateLength = 0; }
                    try
                    {
                        shoeInputs.TopPlateHeight = (double)((PropertyValueDouble)ShoeAuxTable.GetPropertyValue("IJUAhsTopPlate", "TopPlateHeight")).PropValue;
                    }
                    catch
                    { shoeInputs.TopPlateHeight = 0; }

                    try
                    {
                        shoeInputs.ShoeSpacing = (double)((PropertyValueDouble)ShoeAuxTable.GetPropertyValue("IJUAhsShoeSpacing", "ShoeSpacing")).PropValue;
                    }
                    catch
                    { shoeInputs.ShoeSpacing = 0; }
                    try
                    {
                        shoeInputs.SectionName = (string)((PropertyValueString)ShoeAuxTable.GetPropertyValue("IJUAhsSteelSection", "SteelName")).PropValue;
                    }
                    catch
                    { shoeInputs.SectionName = "No Value"; }
                    try
                    {
                        shoeInputs.SectionType = (string)((PropertyValueString)ShoeAuxTable.GetPropertyValue("IJUAhsSteelSection", "SteelType")).PropValue;
                    }
                    catch
                    { shoeInputs.SectionType = "No Value"; }
                    try
                    {
                        shoeInputs.SectionStandard = (string)((PropertyValueString)ShoeAuxTable.GetPropertyValue("IJUAhsSteelSection", "SteelStandard")).PropValue;
                    }
                    catch
                    { shoeInputs.SectionStandard = "No Value"; }
                    try
                    {
                        shoeInputs.LegLowerSpacing = (double)((PropertyValueDouble)ShoeAuxTable.GetPropertyValue("IJUAhsVerticalLeg", "LegLowerSpacing")).PropValue;
                    }
                    catch
                    { shoeInputs.LegLowerSpacing = 0; }
                    try
                    {
                        shoeInputs.TopPlateOffset = (double)((PropertyValueDouble)ShoeAuxTable.GetPropertyValue("IJUAhsTopPlate", "TopPlateOffset")).PropValue;
                    }
                    catch
                    { shoeInputs.TopPlateOffset = 0; }
                    try
                    {
                        shoeInputs.TopPlateGap = (double)((PropertyValueDouble)ShoeAuxTable.GetPropertyValue("IJUAhsTopPlate", "TopPlateGap")).PropValue;
                    }
                    catch
                    { shoeInputs.TopPlateGap = 0; }
                    try
                    {
                        shoeInputs.SlopeAngle = (double)((PropertyValueDouble)ShoeAuxTable.GetPropertyValue("IJUAhsSlopeAngle", "SlopeAngle")).PropValue;
                    }
                    catch
                    { shoeInputs.SlopeAngle = 0; }
                    try
                    {
                        shoeInputs.HasExtension = (bool)((PropertyValueBoolean)ShoeAuxTable.GetPropertyValue("IJUAhsTopPlate", "Extension")).PropValue;
                    }
                    catch
                    { shoeInputs.HasExtension = false; }
                    try
                    {
                        shoeInputs.ExtensionType = (int)((PropertyValueCodelist)ShoeAuxTable.GetPropertyValue("IJUAhsTopPlate", "Inside")).PropValue;
                    }
                    catch
                    { shoeInputs.ExtensionType = 0; }
                    try
                    {
                        shoeInputs.Continous = (int)((PropertyValueCodelist)ShoeAuxTable.GetPropertyValue("IJUAhsContinous", "Continous")).PropValue;
                    }
                    catch
                    { shoeInputs.Continous = 0; }
                    try
                    {
                        shoeInputs.LegHeight = (double)((PropertyValueDouble)ShoeAuxTable.GetPropertyValue("IJUAhsLegHeight", "LegHeight")).PropValue;
                    }
                    catch
                    { shoeInputs.LegHeight = 0; }
                    try
                    {
                        shoeInputs.ExtensionPlateAxialOffset = (double)((PropertyValueDouble)ShoeAuxTable.GetPropertyValue("IJUAhsExtPltOff", "ExtensionPlateAxialOffset")).PropValue;
                    }
                    catch
                    { shoeInputs.ExtensionPlateAxialOffset = 0; }
                    try
                    {
                        shoeInputs.SteelAngle = (double)((PropertyValueDouble)ShoeAuxTable.GetPropertyValue("IJUAhssteelAngle", "SteelAngle")).PropValue;
                    }
                    catch
                    { shoeInputs.SteelAngle = 0; }
                    try
                    {
                        shoeInputs.SteelCpoint = (int)((PropertyValueCodelist)ShoeAuxTable.GetPropertyValue("IJUAhsSteelCPoint", "SteelCpoint")).PropValue;
                        if (shoeInputs.SteelCpoint == -1)
                            shoeInputs.SteelCpoint = 1; // setting the default value
                    }
                    catch
                    { shoeInputs.SteelCpoint = 1; }

                    try
                    {
                        shoeInputs.ShoeSpacingFrm = (int)((PropertyValueCodelist)ShoeAuxTable.GetPropertyValue("IJUAhsShoeSpaceFrm", "ShoeSpaceFrm")).PropValue;
                    }
                    catch
                    { shoeInputs.ShoeSpacingFrm = 0; }
                }
                return shoeInputs;
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadShoeDataByQuery, "Error in LoadShoeDataByQuery");
                }
                return shoeInputs;
            }
        }
        /// <summary>
        /// Loads the values associated to the given shape into the Shield UDT. This is done by querying the database for the given name.
        /// </summary>
        /// <param name="refShapeName">part name of the auxiliary table</param>
        /// <returns></returns>
        ///<code>
        ///ShieldInputs shieldInputs  = LoadSheildDataByQuery(repadName);
        ///</code>
        public ShieldInputs LoadSheildDataByQuery(string refShapeName)
        {

            ShieldInputs shieldInputs = new ShieldInputs();
            try
            {
                if (!(refShapeName == "" || refShapeName == "No Value"))
                {
                    Catalog m_oPlantCatalog = MiddleServiceProvider.SiteMgr.ActiveSite.ActivePlant.PlantCatalog;
                    BusinessObject SheildAuxTable = m_oPlantCatalog.GetNamedObject(refShapeName);
                    try
                    {
                        shieldInputs.PipeOD = (double)((PropertyValueDouble)SheildAuxTable.GetPropertyValue("IJOAhsPipeOD", "PipeOD")).PropValue;
                    }
                    catch
                    {
                        shieldInputs.PipeOD = 0;
                    }

                    try
                    {
                        shieldInputs.Size = (String)((PropertyValueString)SheildAuxTable.GetPropertyValue("IJUAhsSize", "[SIZE]")).PropValue;
                    }
                    catch { shieldInputs.Size = "No Value"; }
                    shieldInputs.Thickness1 = (double)((PropertyValueDouble)SheildAuxTable.GetPropertyValue("IJUAhsThickness1", "Thickness1")).PropValue;
                    try
                    {
                        shieldInputs.Thickness2 = (double)((PropertyValueDouble)SheildAuxTable.GetPropertyValue("IJUAhsThickness2", "Thickness2")).PropValue;
                    }
                    catch { shieldInputs.Thickness2 = 0; }
                    try
                    {
                        shieldInputs.thickness3 = (double)((PropertyValueDouble)SheildAuxTable.GetPropertyValue("IJUAhsThickness3", "Thickness3")).PropValue;
                    }
                    catch { shieldInputs.thickness3 = 0; }
                    shieldInputs.Length1 = (double)((PropertyValueDouble)SheildAuxTable.GetPropertyValue("IJUAhsLength1", "Length1")).PropValue;
                    try
                    {
                        shieldInputs.Length2 = (double)((PropertyValueDouble)SheildAuxTable.GetPropertyValue("IJUAhsLength2", "Length2")).PropValue;
                    }
                    catch { shieldInputs.Length2 = 0; }
                    try
                    {
                        shieldInputs.Length3 = (double)((PropertyValueDouble)SheildAuxTable.GetPropertyValue("IJUAhsLength3", "Length3")).PropValue;
                    }
                    catch { shieldInputs.Length3 = 0; }
                    shieldInputs.Angle1 = (double)((PropertyValueDouble)SheildAuxTable.GetPropertyValue("IJUAhsAngle1", "Angle1")).PropValue;
                    try
                    {
                        shieldInputs.Angle2 = (double)((PropertyValueDouble)SheildAuxTable.GetPropertyValue("IJUAhsAngle2", "Angle2")).PropValue;
                    }
                    catch { shieldInputs.Angle2 = 0; }
                    try
                    {
                        shieldInputs.Angle3 = (double)((PropertyValueDouble)SheildAuxTable.GetPropertyValue("IJUAhsAngle3", "Angle3")).PropValue;
                    }
                    catch { shieldInputs.Angle3 = 0; }
                    try
                    {
                        shieldInputs.Angle4 = (double)((PropertyValueDouble)SheildAuxTable.GetPropertyValue("IJUAhsAngle4", "Angle4")).PropValue;
                    }
                    catch { shieldInputs.Angle4 = 0; }
                    try
                    {
                        shieldInputs.Angle5 = (double)((PropertyValueDouble)SheildAuxTable.GetPropertyValue("IJUAhsAngle5", "Angle5")).PropValue;
                    }
                    catch { shieldInputs.Angle5 = 0; }
                    try
                    {
                        shieldInputs.Width1 = (double)((PropertyValueDouble)SheildAuxTable.GetPropertyValue("IJUAhsWidth1", "Width1")).PropValue;
                    }
                    catch { shieldInputs.Width1 = 0; }
                    try
                    {
                        shieldInputs.Width2 = (double)((PropertyValueDouble)SheildAuxTable.GetPropertyValue("IJUAhsWidth2", "Width2")).PropValue;
                    }
                    catch { shieldInputs.Width2 = 0; }
                    try
                    {
                        shieldInputs.Width3 = (double)((PropertyValueDouble)SheildAuxTable.GetPropertyValue("IJUAhsWidth3", "Width3")).PropValue;
                    }
                    catch { shieldInputs.Width3 = 0; }
                    try
                    {
                        shieldInputs.Width4 = (double)((PropertyValueDouble)SheildAuxTable.GetPropertyValue("IJUAhsWidth4", "Width4")).PropValue;
                    }
                    catch { shieldInputs.Width4 = 0; }
                    try
                    {
                        shieldInputs.Height1 = (double)((PropertyValueDouble)SheildAuxTable.GetPropertyValue("IJUAhsHeight1", "Height1")).PropValue;
                    }
                    catch { shieldInputs.Height1 = 0; }
                    try
                    {
                        shieldInputs.Multi1Qty = (int)((PropertyValueDouble)SheildAuxTable.GetPropertyValue("IJUAhsMulti1", "Multi1Qty")).PropValue;
                    }
                    catch { shieldInputs.Multi1Qty = 0; }
                    try
                    {
                        shieldInputs.Multi1LocateBy = (int)((PropertyValueCodelist)SheildAuxTable.GetPropertyValue("IJUAhsMulti1", "Multi1LocateBy")).PropValue;
                    }
                    catch { shieldInputs.Multi1LocateBy = 0; }
                    try
                    {
                        shieldInputs.Multi1Location = (double)((PropertyValueDouble)SheildAuxTable.GetPropertyValue("IJUAhsMulti1", "Multi1Location")).PropValue;
                    }
                    catch { shieldInputs.Multi1Location = 0; }
                    try
                    {
                        shieldInputs.Diameter1 = (double)((PropertyValueDouble)SheildAuxTable.GetPropertyValue("IJUAhsDiameter1", "Diameter1")).PropValue;
                    }
                    catch { shieldInputs.Diameter1 = 0; }
                    try
                    {
                        shieldInputs.Offset1 = (double)((PropertyValueDouble)SheildAuxTable.GetPropertyValue("IJUAhsOffset1", "Offset1")).PropValue;
                    }
                    catch { shieldInputs.Offset1 = 0; }
                }
                return shieldInputs;
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadSheildDataByQuery, "Error in LoadSheildDataByQuery");
                }
                return shieldInputs;
            }
        }
        /// <summary>
        /// Loads the values associated to the given shape into the UBolt UDT. This is done by querying the database for the given name.
        /// </summary>
        /// <param name="UboltName">Name of the UBolt-String.</param>
        /// <returns></returns>
        ///<code>
        ///UBoltInputs uboltInputs  = LoadUBoltDataByQuery();
        ///</code>
        public UBoltInputs LoadUBoltDataByQuery(string refShapeName)
        {
            UBoltInputs uBoltInputs = new UBoltInputs();
            try
            {

                if (!(refShapeName == "" || refShapeName == "No Value"))
                {
                    Catalog m_oPlantCatalog = MiddleServiceProvider.SiteMgr.ActiveSite.ActivePlant.PlantCatalog;
                    BusinessObject UBoltAuxTable = m_oPlantCatalog.GetNamedObject(refShapeName);
                    try
                    {
                        uBoltInputs.UBoltWidth = (double)((PropertyValueDouble)UBoltAuxTable.GetPropertyValue("IJUAhsUBolt", "UBoltWidth")).PropValue;
                    }
                    catch
                    {
                        uBoltInputs.UBoltWidth = 0;
                    }
                    try
                    {
                        uBoltInputs.UBoltCenterToEnd = (double)((PropertyValueDouble)UBoltAuxTable.GetPropertyValue("IJUAhsUBolt", "UBoltCenterToEnd")).PropValue;
                    }
                    catch
                    {
                        uBoltInputs.UBoltCenterToEnd = 0;
                    }
                    try
                    {
                        uBoltInputs.UBoltRodDia = (double)((PropertyValueDouble)UBoltAuxTable.GetPropertyValue("IJUAhsUBolt", "UBoltRodDia")).PropValue;
                    }
                    catch
                    {
                        uBoltInputs.UBoltRodDia = 0;
                    }
                    try
                    {
                        uBoltInputs.UBoltDia2 = (double)((PropertyValueDouble)UBoltAuxTable.GetPropertyValue("IJUAhsUBolt", "UBoltDia2")).PropValue;
                    }
                    catch { uBoltInputs.UBoltDia2 = 0; }
                    try
                    {
                        uBoltInputs.UBoltDia2Start = (double)((PropertyValueDouble)UBoltAuxTable.GetPropertyValue("IJUAhsUBolt", "UBoltDia2Start")).PropValue;
                    }
                    catch { uBoltInputs.UBoltDia2Start = 0; }
                    try
                    {
                        uBoltInputs.UBoltFlatSpot = (double)((PropertyValueDouble)UBoltAuxTable.GetPropertyValue("IJUAhsUBolt", "UBoltFlatSpot")).PropValue;
                    }
                    catch { uBoltInputs.UBoltFlatSpot = 0; }
                    try
                    {
                        uBoltInputs.UBoltTopGap = (double)((PropertyValueDouble)UBoltAuxTable.GetPropertyValue("IJOAhsUBoltGap", "UBoltTopGap")).PropValue;
                    }
                    catch { uBoltInputs.UBoltTopGap = 0; }
                    try
                    {
                        uBoltInputs.UBoltOneSided = (int)((PropertyValueCodelist)UBoltAuxTable.GetPropertyValue("IJUAhsUBolt", "UBoltOneSided")).PropValue;
                    }
                    catch { uBoltInputs.UBoltOneSided = 0; }

                }
                return uBoltInputs;
            }
            catch
            {

                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadUBoltDataByQuery, "Error in LoadUBoltDataByQuery");
                }
                return uBoltInputs;
            }
        }
        /// <summary>
        /// Loads the values associated to the given shape into the Strap UDT. This is done by querying the database for the given name.
        /// </summary>
        /// <param name="refShapeName">Name of the Strap-String.</param>
        /// <returns></returns>
        ///<code>
        ///StrapInputs strapInputs  = LoadStrapDataByQuery(refShapeName);
        ///</code>
        public StrapInputs LoadStrapDataByQuery(string refShapeName)
        {
            StrapInputs strapInputs = new StrapInputs();
            try
            {

                if (!(refShapeName == "" || refShapeName == "No Value"))
                {
                    Catalog m_oPlantCatalog = MiddleServiceProvider.SiteMgr.ActiveSite.ActivePlant.PlantCatalog;
                    BusinessObject StrapAuxTable = m_oPlantCatalog.GetNamedObject(refShapeName);
                    try
                    {
                        strapInputs.StrapWidthInside = (double)((PropertyValueDouble)StrapAuxTable.GetPropertyValue("IJUAhsStrap", "StrapWidthInside")).PropValue;
                    }
                    catch
                    {
                        strapInputs.StrapWidthInside = 0;
                    }
                    try
                    {
                        strapInputs.StrapHeightInside = (double)((PropertyValueDouble)StrapAuxTable.GetPropertyValue("IJUAhsStrap", "StrapHeightInside")).PropValue;
                    }
                    catch
                    {
                        strapInputs.StrapHeightInside = 0;
                    }
                    try
                    {
                        strapInputs.StrapThickness = (double)((PropertyValueDouble)StrapAuxTable.GetPropertyValue("IJUAhsStrap", "StrapThickness")).PropValue;
                    }
                    catch
                    {
                        strapInputs.StrapThickness = 0;
                    }
                    try
                    {
                        strapInputs.StrapStockWidth = (double)((PropertyValueDouble)StrapAuxTable.GetPropertyValue("IJUAhsStrap", "StrapStockWidth")).PropValue;
                    }
                    catch
                    {
                        strapInputs.StrapStockWidth = 0;
                    }

                    try
                    {
                        strapInputs.StrapFlatSpot = (double)((PropertyValueDouble)StrapAuxTable.GetPropertyValue("IJUAhsStrap", "StrapFlatSpot")).PropValue;
                    }
                    catch { strapInputs.StrapFlatSpot = 0; }
                    try
                    {
                        strapInputs.StrapTopGap = (double)((PropertyValueDouble)StrapAuxTable.GetPropertyValue("IJOAhsStrapGap", "StrapTopGap")).PropValue;
                    }
                    catch { strapInputs.StrapTopGap = 0; }
                    try
                    {
                        strapInputs.StrapWidthWings = (double)((PropertyValueDouble)StrapAuxTable.GetPropertyValue("IJUAhsStrap", "StrapWidthWings")).PropValue;
                    }
                    catch { strapInputs.StrapWidthWings = 0; }
                    try
                    {
                        strapInputs.StrapOneSided = (int)((PropertyValueInt)StrapAuxTable.GetPropertyValue("IJUAhsStrap", "StrapOneSided")).PropValue;
                    }
                    catch { strapInputs.StrapOneSided = 0; }
                    try
                    {
                        strapInputs.StrapSplitGap = (double)((PropertyValueDouble)StrapAuxTable.GetPropertyValue("IJUAhsStrap", "StrapSplitGap")).PropValue;
                    }
                    catch { strapInputs.StrapSplitGap = 0; }
                    try
                    {
                        strapInputs.StrapSplitExtension = (double)((PropertyValueDouble)StrapAuxTable.GetPropertyValue("IJUAhsStrap", "StrapSplitExtension")).PropValue;
                    }
                    catch { strapInputs.StrapSplitExtension = 0; }

                }
                return strapInputs;
            }
            catch
            {

                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadStrapDataByQuery, "Error in LoadStrapDataByQuery");
                }
                return strapInputs;
            }
        }

        /// <summary>
        /// Loads the values associated to the given shape into the Slide UDT. This is done by querying the database for the given name.
        /// </summary>
        /// <param name="guideName">Name of the slide-String.</param>
        /// <returns></returns>
        ///<code>
        ///slideInputs slideInputs  = LoadSlidePlateDataByQuery();
        ///</code>
        public SlidePlateInputs LoadSlidePlateDataByQuery(string refShapeName)
        {
            SlidePlateInputs slidePlate = new SlidePlateInputs();
            try
            {

                if (!(refShapeName == "" || refShapeName == "No Value"))
                {
                    Catalog m_oPlantCatalog = MiddleServiceProvider.SiteMgr.ActiveSite.ActivePlant.PlantCatalog;
                    BusinessObject SlidePlateAuxTable = m_oPlantCatalog.GetNamedObject(refShapeName);
                    try
                    {
                        slidePlate.Width1 = (double)((PropertyValueDouble)SlidePlateAuxTable.GetPropertyValue("IJUAhsWidth1", "Width1")).PropValue;
                    }
                    catch
                    {
                        slidePlate.Width1 = 0;
                    }
                    try
                    {
                        slidePlate.Height1 = (double)((PropertyValueDouble)SlidePlateAuxTable.GetPropertyValue("IJUAhsHeight1", "Height1")).PropValue;
                    }
                    catch
                    {
                        slidePlate.Height1 = 0;
                    }
                    try
                    {
                        slidePlate.Thickness1 = (double)((PropertyValueDouble)SlidePlateAuxTable.GetPropertyValue("IJUAhsThickness1", "Thickness1")).PropValue;
                    }
                    catch
                    {
                        slidePlate.Thickness1 = 0;
                    }
                    try
                    {
                        slidePlate.XPl1 = (double)((PropertyValueDouble)SlidePlateAuxTable.GetPropertyValue("IJUAhsXPl1", "XPl1")).PropValue;
                    }
                    catch
                    {
                        slidePlate.XPl1 = 0;
                    }
                    try
                    {
                        slidePlate.YPl1 = (double)((PropertyValueDouble)SlidePlateAuxTable.GetPropertyValue("IJUAhsYPl1", "YPl1")).PropValue;
                    }
                    catch
                    {
                        slidePlate.YPl1 = 0;
                    }
                    try
                    {
                        slidePlate.ZPl1 = (double)((PropertyValueDouble)SlidePlateAuxTable.GetPropertyValue("IJUAhsZPl1", "ZPl1")).PropValue;
                    }
                    catch
                    {
                        slidePlate.ZPl1 = 0;
                    }
                    try
                    {
                        slidePlate.Width2 = (double)((PropertyValueDouble)SlidePlateAuxTable.GetPropertyValue("IJUAhsWidth2", "Width2")).PropValue;
                    }
                    catch
                    {
                        slidePlate.Width2 = 0;
                    }
                    try
                    {
                        slidePlate.Height2 = (double)((PropertyValueDouble)SlidePlateAuxTable.GetPropertyValue("IJUAhsHeight2", "Height2")).PropValue;
                    }
                    catch
                    {
                        slidePlate.Height2 = 0;
                    }
                    try
                    {
                        slidePlate.Thickness2 = (double)((PropertyValueDouble)SlidePlateAuxTable.GetPropertyValue("IJUAhsThickness2", "Thickness2")).PropValue;
                    }
                    catch
                    {
                        slidePlate.Thickness2 = 0;
                    }
                    try
                    {
                        slidePlate.XPl2 = (double)((PropertyValueDouble)SlidePlateAuxTable.GetPropertyValue("IJUAhsXPl2", "XPl2")).PropValue;
                    }
                    catch
                    {
                        slidePlate.XPl2 = 0;
                    }
                    try
                    {
                        slidePlate.YPl2 = (double)((PropertyValueDouble)SlidePlateAuxTable.GetPropertyValue("IJUAhsYPl2", "YPl2")).PropValue;
                    }
                    catch
                    {
                        slidePlate.YPl2 = 0;
                    }
                    try
                    {
                        slidePlate.ZPl2 = (double)((PropertyValueDouble)SlidePlateAuxTable.GetPropertyValue("IJUAhsZPl2", "ZPl2")).PropValue;
                    }
                    catch
                    {
                        slidePlate.ZPl2 = 0;
                    }
                    try
                    {
                        slidePlate.Width3 = (double)((PropertyValueDouble)SlidePlateAuxTable.GetPropertyValue("IJUAhsWidth3", "Width3")).PropValue;
                    }
                    catch { slidePlate.Width3 = 0; }
                    try
                    {
                        slidePlate.Height3 = (double)((PropertyValueDouble)SlidePlateAuxTable.GetPropertyValue("IJUAhsHeight3", "Height3")).PropValue;
                    }
                    catch { slidePlate.Height3 = 0; }
                    try
                    {
                        slidePlate.Thickness3 = (double)((PropertyValueDouble)SlidePlateAuxTable.GetPropertyValue("IJUAhsThickness3", "Thickness3")).PropValue;
                    }
                    catch { slidePlate.Thickness3 = 0; }
                    try
                    {
                        slidePlate.XPl3 = (double)((PropertyValueDouble)SlidePlateAuxTable.GetPropertyValue("IJUAhsXPl3", "XPl3")).PropValue;
                    }
                    catch { slidePlate.XPl3 = 0; }
                    try
                    {
                        slidePlate.YPl3 = (double)((PropertyValueDouble)SlidePlateAuxTable.GetPropertyValue("IJUAhsYPl3", "YPl3")).PropValue;
                    }
                    catch { slidePlate.YPl3 = 0; }
                    try
                    {
                        slidePlate.ZPl3 = (double)((PropertyValueDouble)SlidePlateAuxTable.GetPropertyValue("IJUAhsZPl3", "ZPl3")).PropValue;
                    }
                    catch { slidePlate.ZPl3 = 0; }
                    try
                    {
                        slidePlate.Width4 = (double)((PropertyValueDouble)SlidePlateAuxTable.GetPropertyValue("IJUAhsWidth4", "Width4")).PropValue;
                    }
                    catch { slidePlate.Width4 = 0; }
                    try
                    {
                        slidePlate.Height4 = (double)((PropertyValueDouble)SlidePlateAuxTable.GetPropertyValue("IJUAhsHeight4", "Height4")).PropValue;
                    }
                    catch { slidePlate.Height4 = 0; }
                    try
                    {
                        slidePlate.Thickness4 = (double)((PropertyValueDouble)SlidePlateAuxTable.GetPropertyValue("IJUAhsThickness4", "Thickness4")).PropValue;
                    }
                    catch { slidePlate.Thickness4 = 0; }
                    try
                    {
                        slidePlate.XPl4 = (double)((PropertyValueDouble)SlidePlateAuxTable.GetPropertyValue("IJUAhsXPl4", "XPl4")).PropValue;
                    }
                    catch { slidePlate.XPl4 = 0; }
                    try
                    {
                        slidePlate.YPl4 = (double)((PropertyValueDouble)SlidePlateAuxTable.GetPropertyValue("IJUAhsYPl4", "YPl4")).PropValue;
                    }
                    catch { slidePlate.YPl4 = 0; }
                    try
                    {
                        slidePlate.ZPl4 = (double)((PropertyValueDouble)SlidePlateAuxTable.GetPropertyValue("IJUAhsZPl4", "ZPl4")).PropValue;
                    }
                    catch { slidePlate.ZPl4 = 0; }
                    try
                    {
                        slidePlate.Width5 = (double)((PropertyValueDouble)SlidePlateAuxTable.GetPropertyValue("IJUAhsWidth5", "Width5")).PropValue;
                    }
                    catch { slidePlate.Width5 = 0; }
                    try
                    {
                        slidePlate.Height5 = (double)((PropertyValueDouble)SlidePlateAuxTable.GetPropertyValue("IJUAhsHeight5", "Height5")).PropValue;
                    }
                    catch { slidePlate.Height5 = 0; }
                    try
                    {
                        slidePlate.Thickness5 = (double)((PropertyValueDouble)SlidePlateAuxTable.GetPropertyValue("IJUAhsThickness5", "Thickness5")).PropValue;
                    }
                    catch { slidePlate.Thickness5 = 0; }
                    try
                    {
                        slidePlate.XPl5 = (double)((PropertyValueDouble)SlidePlateAuxTable.GetPropertyValue("IJUAhsXPl5", "XPl5")).PropValue;
                    }
                    catch { slidePlate.XPl5 = 0; }
                    try
                    {
                        slidePlate.YPl5 = (double)((PropertyValueDouble)SlidePlateAuxTable.GetPropertyValue("IJUAhsYPl5", "YPl5")).PropValue;
                    }
                    catch { slidePlate.YPl5 = 0; }
                    try
                    {
                        slidePlate.ZPl5 = (double)((PropertyValueDouble)SlidePlateAuxTable.GetPropertyValue("IJUAhsZPl5", "ZPl5")).PropValue;
                    }
                    catch { slidePlate.ZPl5 = 0; }
                    try
                    {
                        slidePlate.Width6 = (double)((PropertyValueDouble)SlidePlateAuxTable.GetPropertyValue("IJUAhsWidth6", "Width6")).PropValue;
                    }
                    catch { slidePlate.Width6 = 0; }
                    try
                    {
                        slidePlate.Height6 = (double)((PropertyValueDouble)SlidePlateAuxTable.GetPropertyValue("IJUAhsHeight6", "Height6")).PropValue;
                    }
                    catch { slidePlate.Height6 = 0; }
                    try
                    {
                        slidePlate.Thickness6 = (double)((PropertyValueDouble)SlidePlateAuxTable.GetPropertyValue("IJUAhsThickness6", "Thickness6")).PropValue;
                    }
                    catch { slidePlate.Thickness6 = 0; }
                    try
                    {
                        slidePlate.XPl6 = (double)((PropertyValueDouble)SlidePlateAuxTable.GetPropertyValue("IJUAhsXPl6", "XPl6")).PropValue;
                    }
                    catch { slidePlate.XPl6 = 0; }
                    try
                    {
                        slidePlate.YPl6 = (double)((PropertyValueDouble)SlidePlateAuxTable.GetPropertyValue("IJUAhsYPl6", "YPl6")).PropValue;
                    }
                    catch { slidePlate.YPl6 = 0; }
                    try
                    {
                        slidePlate.ZPl6 = (double)((PropertyValueDouble)SlidePlateAuxTable.GetPropertyValue("IJUAhsZPl6", "ZPl6")).PropValue;

                    }
                    catch { slidePlate.ZPl6 = 0; }
                    try
                    {
                        slidePlate.PipeDia = (double)((PropertyValueDouble)SlidePlateAuxTable.GetPropertyValue("IJUAhsDiameter1", "Diameter1")).PropValue;
                    }
                    catch { slidePlate.PipeDia = 0; }
                    try
                    {
                        slidePlate.ShoeHeight = (double)((PropertyValueDouble)SlidePlateAuxTable.GetPropertyValue("IJUAhsShoeHeight", "ShoeHeight")).PropValue;
                    }
                    catch { slidePlate.ShoeHeight = 0; }


                }
                return slidePlate;
            }
            catch
            {

                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadSlidePlateDataByQuery, "Error in LoadSlidePlateDataByQuery");
                }
                return slidePlate;
            }
        }
        /// <summary>
        /// Create the graphical representation of the Swivel Ring shape
        /// </summary>
        /// <param name="swivel">Collection of all the values for the Swivel Ring inputs -SwivelInputs </param>
        /// <param name="matrix">string to specify the position and oreintation the graphics - String.</param>
        /// <param name="outputcoll">Collection of declared outputs, which is indexed by the name of the outputs declared as defining SymbolOutputs on the AspectDefinition field- OutputDictionary</param>
        /// <param name="output">Output that this graphic is being placed on-String</param>
        /// <code>
        /// AddSwivelRing(Swivel, rotateAngle, new Matrix4X4(), m_PhysicalAspect.Outputs, "SwivelRing");
        /// </code>
        /// <summary>
        /// Adds the ProtectSaddle inputs.
        /// </summary>        
        /// <param name="startIndex">The start index.(int)</param>
        /// <param name="endIndex">The end index.(int)</param>
        /// <param name="additionalInputs">The additional inputs.</param>
        /// <code>
        /// int endIndex;
        /// List<Input> additionalInputs = new List<Input>();
        /// AddProtectSaddleInputs(2, out endIndex, additionalInputs);
        /// </code>
        public void AddProtectSaddleInputs(int startIndex, out int endIndex, List<Input> additionalInputs)
        {
            try
            {
                additionalInputs.Add(new InputDouble(startIndex, "PipeOD", "PipeOD", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Radius1", "Radius1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Thickness1", "Thickness1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "InclStiffener", "InclStiffener", 1, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Thickness2", "Thickness2", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Length1", "Length1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Angle1", "Angle1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Angle2", "Angle2", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Angle3", "Angle3", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Angle4", "Angle4", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "ToEdge", "ToEdge", 1, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Width1", "Width1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Width2", "Width2", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Width3", "Width3", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Width4", "Width4", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Height1", "Height1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Height2", "Height2", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Length2", "Length2", 0, false));
                additionalInputs.Add(new InputString(++startIndex, "ClampName", "ClampName", "No Value", false));
                additionalInputs.Add(new InputDouble(++startIndex, "Height3", "Height3", 0, false));
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddProtectSaddleInputs, "Error in adding ProtectSaddle inputs");
                }
            }
            endIndex = startIndex;
        }
        /// <summary>
        /// Create the graphical representation of a ProtectSaddle.
        /// </summary>
        /// <param name="ProtectSaddle">protectSaddle-(ProtectSaddleInputs)</param>
        /// <param name="matrix">The matrix.</param>
        /// <param name="outputs">The outputs.</param>
        /// <param name="outputName">Name of the output.(String)</param>
        ///<code>
        ///Matrix4X4 matrix = new Matrix4X4();
        ///matrix.Origin = new Position(0,0,0);
        ///AddProtectSaddleShape(ProtectSaddleInputs protectSaddle, Matrix4X4 matrix, OutputDictionary outputs, String outputName);
        ///</code>outputs
        public void AddProtectSaddle(ProtectSaddleInputs protectSaddle, Matrix4X4 matrix, OutputDictionary outputs, String outputName)
        {
            try
            {
                Collection<ICurve> curveCollection = new Collection<ICurve>();
                Matrix4X4 arcMatrix;
                SymbolGeometryHelper symbolGeometryHelper;
                StringBuilder error = new StringBuilder();
                double beta, alpha, gamma;
                CoordinatesInputs leftFootOut, leftFootIn, leftBaseOut, leftBaseIn, rightFootOut, rightFootIn, rightBaseOut, rightBaseIn, stiffenerFootOffset, stiffenerBaseOffset, leftBaseInArcOHStart;
                CoordinatesInputs leftBaseInArcOHEnd, rightBaseInArcOHStart, rightBaseInArcOHEnd, leftBaseOutArcOHEnd, rightBaseOutArcOHEnd;
                double inArcBeginAngle, inArcEndAngle, outerArcBeginAngle, outerArcEndAngle, leftInArcOHEndAngle, rightInArcOHStartAngle, centertoCornerRight, centertoCornerLeft;
                CoordinatesInputs leftBaseLineOut, rightBaseLineOut, leftBaseLineIn, rightBaseLineIn, leftBaseLineInOHStart, rightBaseLineInOHStart, concSaddleLeft, concSaddleRight;
                int numOfLines;
                Boolean withOverHangs = false, withCurvedBase = false, concreteSaddle = false, ushape = false, flatBase = false;
                Double angle1 = protectSaddle.Angle1, angle2 = protectSaddle.Angle2, angle3 = protectSaddle.Angle3, angle4 = protectSaddle.Angle4, width1 = protectSaddle.Width1, width2 = protectSaddle.Width2;
                Double width3 = protectSaddle.Width3, width4 = protectSaddle.Width4, radius1 = protectSaddle.Radius1, length2 = protectSaddle.Length2, xOffset = -protectSaddle.Length1 / 2;

                if (HgrCompareDoubleService.cmpdbl(radius1, 0) == true)
                    radius1 = protectSaddle.PipeOD / 2 + protectSaddle.Thickness1 + protectSaddle.Thickness2;

                if (HgrCompareDoubleService.cmpdbl(width1 + width2 + width3 + width4, 0) == true)
                {
                    withCurvedBase = true;
                    if (angle3 > angle1)
                        withOverHangs = true;
                    if (!(angle2 > 0)) angle2 = angle1;
                    if (!(angle4 > 0)) angle4 = angle3;
                }
                else if (withCurvedBase == false && HgrCompareDoubleService.cmpdbl(protectSaddle.Height1, 0) == true && HgrCompareDoubleService.cmpdbl(protectSaddle.Height3, 0) == true)
                {
                    flatBase = true;
                    if (width3 > width1 && width4 > width2)
                        withOverHangs = true;
                    if (!(width2 > 0)) width2 = width1;
                    if (!(angle1 > 0))
                        angle1 = Math.Atan((width1 / radius1));
                    if (!(angle2 > 0))
                        angle2 = Math.Atan((width2 / radius1));
                }
                else if (protectSaddle.Height1 > 0)
                {
                    concreteSaddle = true;
                    if (!(angle2 > 0)) angle2 = angle1;
                    if (!(width2 > 0)) width2 = width1;
                    if (HgrCompareDoubleService.cmpdbl(width1, 0) == true)
                        error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidWidth1NZero, "Width1 is required"));

                    if (protectSaddle.Height2 > 0 && HgrCompareDoubleService.cmpdbl(length2, 0) == true)
                        length2 = protectSaddle.Length1;
                }
                else if (protectSaddle.Height3 > 0)
                    ushape = true;

                else
                    error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrMissingInputs, "Required inputs are  missing"));

                //Error messages

                if (!(protectSaddle.PipeOD > 0)) error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidPipeODGTZero, "PipeOD is required"));
                if (!(protectSaddle.Thickness1 > 0)) error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidThickness1GTZero, "Thickness1 is required"));
                if (!(protectSaddle.Length1 > 0)) error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidLength1GTZero, "Length1 is required"));
                if (!(protectSaddle.Thickness1 > 0) && !(radius1 > 0)) error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidThickness1AndRadius1NGTZero, "Either Thickness1 or Radius1 should be defined"));
                if (!(angle1 > 0) && (ushape == false)) error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidAngle1GTZero, "Angle1 is required"));
                if (error.Length > 0) ToDoListMessage = new ToDoListMessage(ToDoMessageTypes.ToDoMessageWarning, error.ToString());

                centertoCornerRight = (protectSaddle.Thickness1 / 2) / Math.Cos(angle2);
                centertoCornerLeft = (protectSaddle.Thickness1 / 2) / Math.Cos(angle1);

                if (protectSaddle.ToEdge == 1)
                {
                    beta = ((protectSaddle.Thickness1 / 2) / (protectSaddle.PipeOD / 2));
                    alpha = Math.Asin((protectSaddle.Thickness1 / 2) / radius1);
                    gamma = Math.Asin((protectSaddle.Thickness1 / 2) / (radius1 - protectSaddle.Thickness1));

                    //left side point locations
                    leftFootIn.Y = Math.Sin(angle1 - beta - beta) * (protectSaddle.PipeOD / 2);
                    leftFootIn.Z = Math.Cos(angle1 - beta - beta) * (protectSaddle.PipeOD / 2);
                    leftFootOut.Y = Math.Sin(angle1) * (protectSaddle.PipeOD / 2);
                    leftFootOut.Z = Math.Cos(angle1) * (protectSaddle.PipeOD / 2);
                    leftBaseOut.Y = Math.Sin(angle1) * radius1;
                    leftBaseOut.Z = Math.Cos(angle1) * radius1;
                    leftBaseIn.Y = Math.Sin(angle1 - gamma - gamma) * (radius1 - protectSaddle.Thickness1);
                    leftBaseIn.Z = Math.Cos(angle1 - gamma - gamma) * (radius1 - protectSaddle.Thickness1);

                    //Right point locations
                    rightFootIn.Y = Math.Sin(angle2 - beta - beta) * (protectSaddle.PipeOD / 2);
                    rightFootIn.Z = Math.Cos(angle2 - beta - beta) * (protectSaddle.PipeOD / 2);
                    rightFootOut.Y = Math.Sin(angle2) * (protectSaddle.PipeOD / 2);
                    rightFootOut.Z = Math.Cos(angle2) * (protectSaddle.PipeOD / 2);
                    rightBaseOut.Y = Math.Sin(angle2) * radius1;
                    rightBaseOut.Z = Math.Cos(angle2) * radius1;
                    rightBaseIn.Y = Math.Sin(angle2 - gamma - gamma) * (radius1 - protectSaddle.Thickness1);
                    rightBaseIn.Z = Math.Cos(angle2 - gamma - gamma) * (radius1 - protectSaddle.Thickness1);

                    //stiffener foot points
                    stiffenerFootOffset.Y = Math.Sin(beta) * (protectSaddle.PipeOD / 2);
                    stiffenerFootOffset.Z = Math.Cos(beta) * (protectSaddle.PipeOD / 2);
                    stiffenerBaseOffset.Y = Math.Sin(gamma) * (radius1 - protectSaddle.Thickness1);
                    stiffenerBaseOffset.Z = Math.Cos(gamma) * (radius1 - protectSaddle.Thickness1);

                    //outside overhang left
                    leftBaseInArcOHStart.Y = Math.Sin(angle1) * (radius1 - protectSaddle.Thickness1);
                    leftBaseInArcOHStart.Z = Math.Cos(angle1) * (radius1 - protectSaddle.Thickness1);
                    leftBaseInArcOHEnd.Y = Math.Sin(angle3) * (radius1 - protectSaddle.Thickness1);
                    leftBaseInArcOHEnd.Z = Math.Cos(angle3) * (radius1 - protectSaddle.Thickness1);
                    leftBaseOutArcOHEnd.Y = Math.Sin(angle3) * (radius1);
                    leftBaseOutArcOHEnd.Z = Math.Cos(angle3) * (radius1);

                    //outside overhang right
                    rightBaseInArcOHStart.Y = Math.Sin(angle2) * (radius1 - protectSaddle.Thickness1);
                    rightBaseInArcOHStart.Z = Math.Cos(angle2) * (radius1 - protectSaddle.Thickness1);
                    rightBaseInArcOHEnd.Y = Math.Sin(angle4) * (radius1 - protectSaddle.Thickness1);
                    rightBaseInArcOHEnd.Z = Math.Cos(angle4) * (radius1 - protectSaddle.Thickness1);
                    rightBaseOutArcOHEnd.Y = Math.Sin(angle4) * (radius1);
                    rightBaseOutArcOHEnd.Z = Math.Cos(angle4) * (radius1);

                    //Angles for the Arcs
                    inArcBeginAngle = angle1 - gamma - gamma;
                    inArcEndAngle = angle2 - gamma - gamma;
                    outerArcBeginAngle = angle1;
                    outerArcEndAngle = angle2;
                    leftInArcOHEndAngle = angle1;
                    rightInArcOHStartAngle = angle2;

                    //working curently
                    rightBaseLineOut.Y = (Math.Tan(angle2) * radius1);
                    rightBaseLineIn.Y = (Math.Tan(angle2) * (radius1 - protectSaddle.Thickness1)) - centertoCornerRight - centertoCornerRight;

                    rightBaseLineOut.Z = radius1;
                    rightBaseLineIn.Z = radius1 - protectSaddle.Thickness1;

                    leftBaseLineOut.Y = (Math.Tan(angle1) * radius1);
                    leftBaseLineIn.Y = (Math.Tan(angle1) * (radius1 - protectSaddle.Thickness1)) - centertoCornerLeft - centertoCornerRight;

                    leftBaseLineOut.Z = radius1;
                    leftBaseLineIn.Z = radius1 - protectSaddle.Thickness1;

                    leftBaseLineInOHStart.Y = (Math.Tan(angle1) * (radius1 - protectSaddle.Thickness1));
                    rightBaseLineInOHStart.Y = (Math.Tan(angle2) * (radius1 - protectSaddle.Thickness1));
                }
                else
                {
                    beta = ((protectSaddle.Thickness1 / 2) / (protectSaddle.PipeOD / 2));
                    alpha = Math.Asin((protectSaddle.Thickness1 / 2) / radius1);
                    gamma = Math.Asin((protectSaddle.Thickness1 / 2) / (radius1 - protectSaddle.Thickness1));

                    //left side point locations
                    leftFootIn.Y = Math.Sin(angle1 - beta) * (protectSaddle.PipeOD / 2);
                    leftFootIn.Z = Math.Cos(angle1 - beta) * (protectSaddle.PipeOD / 2);
                    leftFootOut.Y = Math.Sin(angle1 + beta) * (protectSaddle.PipeOD / 2);
                    leftFootOut.Z = Math.Cos(angle1 + beta) * (protectSaddle.PipeOD / 2);
                    leftBaseOut.Y = Math.Sin(angle1 + alpha) * radius1;
                    leftBaseOut.Z = Math.Cos(angle1 + alpha) * radius1;
                    leftBaseIn.Y = Math.Sin(angle1 - gamma) * (radius1 - protectSaddle.Thickness1);
                    leftBaseIn.Z = Math.Cos(angle1 - gamma) * (radius1 - protectSaddle.Thickness1);

                    //Right point locations
                    rightFootIn.Y = Math.Sin(angle2 - beta) * (protectSaddle.PipeOD / 2);
                    rightFootIn.Z = Math.Cos(angle2 - beta) * (protectSaddle.PipeOD / 2);
                    rightFootOut.Y = Math.Sin(angle2 + beta) * (protectSaddle.PipeOD / 2);
                    rightFootOut.Z = Math.Cos(angle2 + beta) * (protectSaddle.PipeOD / 2);
                    rightBaseOut.Y = Math.Sin(angle2 + alpha) * radius1;
                    rightBaseOut.Z = Math.Cos(angle2 + alpha) * radius1;
                    rightBaseIn.Y = Math.Sin(angle2 - gamma) * (radius1 - protectSaddle.Thickness1);
                    rightBaseIn.Z = Math.Cos(angle2 - gamma) * (radius1 - protectSaddle.Thickness1);

                    //stiffener foot points
                    stiffenerFootOffset.Y = Math.Sin(beta) * (protectSaddle.PipeOD / 2);
                    stiffenerFootOffset.Z = Math.Cos(beta) * (protectSaddle.PipeOD / 2);
                    stiffenerBaseOffset.Y = Math.Sin(gamma) * (radius1 - protectSaddle.Thickness1);
                    stiffenerBaseOffset.Z = Math.Cos(gamma) * (radius1 - protectSaddle.Thickness1);

                    //outside overhang
                    leftBaseInArcOHStart.Y = Math.Sin(angle1 + gamma) * (radius1 - protectSaddle.Thickness1);
                    leftBaseInArcOHStart.Z = Math.Cos(angle1 + gamma) * (radius1 - protectSaddle.Thickness1);
                    leftBaseInArcOHEnd.Y = Math.Sin(angle3) * (radius1 - protectSaddle.Thickness1);
                    leftBaseInArcOHEnd.Z = Math.Cos(angle3) * (radius1 - protectSaddle.Thickness1);
                    leftBaseOutArcOHEnd.Y = Math.Sin(angle3) * (radius1);
                    leftBaseOutArcOHEnd.Z = Math.Cos(angle3) * (radius1);

                    rightBaseInArcOHStart.Y = Math.Sin(angle2 + gamma) * (radius1 - protectSaddle.Thickness1);
                    rightBaseInArcOHStart.Z = Math.Cos(angle2 + gamma) * (radius1 - protectSaddle.Thickness1);
                    rightBaseInArcOHEnd.Y = Math.Sin(angle4) * (radius1 - protectSaddle.Thickness1);
                    rightBaseInArcOHEnd.Z = Math.Cos(angle4) * (radius1 - protectSaddle.Thickness1);
                    rightBaseOutArcOHEnd.Y = Math.Sin(angle4) * (radius1);
                    rightBaseOutArcOHEnd.Z = Math.Cos(angle4) * (radius1);

                    //Angles for the Arcs
                    inArcBeginAngle = angle1 - gamma;
                    inArcEndAngle = angle2 - gamma;
                    outerArcBeginAngle = angle1 + alpha;
                    outerArcEndAngle = angle2 + alpha;
                    leftInArcOHEndAngle = angle1 + gamma;
                    rightInArcOHStartAngle = angle2 + gamma;

                    //for flatbase
                    rightBaseLineOut.Y = (Math.Tan(angle2) * radius1) + centertoCornerRight;
                    rightBaseLineIn.Y = (Math.Tan(angle2) * (radius1 - protectSaddle.Thickness1)) - centertoCornerRight;


                    rightBaseLineOut.Z = radius1;
                    rightBaseLineIn.Z = radius1 - protectSaddle.Thickness1;

                    leftBaseLineOut.Y = (Math.Tan(angle1) * radius1) + centertoCornerLeft;
                    leftBaseLineIn.Y = (Math.Tan(angle1) * (radius1 - protectSaddle.Thickness1)) - centertoCornerLeft;

                    leftBaseLineOut.Z = radius1;
                    leftBaseLineIn.Z = radius1 - protectSaddle.Thickness1;

                    leftBaseLineInOHStart.Y = (Math.Tan(angle1) * (radius1 - protectSaddle.Thickness1)) + centertoCornerLeft;
                    rightBaseLineInOHStart.Y = (Math.Tan(angle2) * (radius1 - protectSaddle.Thickness1)) + centertoCornerRight;
                }

                numOfLines = 4;
                if (protectSaddle.InclStiffener == 1) numOfLines = numOfLines + 5;
                else numOfLines = numOfLines + 1;

                if (withOverHangs) numOfLines = numOfLines + 7;
                else numOfLines = numOfLines + 3;

                //FOR THE CURVED ONE
                //Here is where the strap actually gets drawn using preset inputs
                if (withCurvedBase)
                {
                    //in left
                    curveCollection.Add(new Line3d(new Position(xOffset, leftFootIn.Y, -leftFootIn.Z), new Position(xOffset, leftFootOut.Y, -leftFootOut.Z)));
                    curveCollection.Add(new Line3d(new Position(xOffset, leftFootIn.Y, -leftFootIn.Z), new Position(xOffset, leftBaseIn.Y, -leftBaseIn.Z)));
                    if (protectSaddle.InclStiffener == 1)
                    {
                        //inner arc1
                        symbolGeometryHelper = new SymbolGeometryHelper();
                        symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                        symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(-inArcBeginAngle, new Vector(0, 0, 1));
                        Arc3d leftInnerBaseArc = symbolGeometryHelper.CreateArc(null, radius1 - protectSaddle.Thickness1, (-gamma + inArcBeginAngle));
                        leftInnerBaseArc.Transform(arcMatrix);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                        leftInnerBaseArc.Transform(arcMatrix);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(Math.PI, new Vector(0, 0, 1));
                        leftInnerBaseArc.Transform(arcMatrix);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Translate(new Vector(xOffset, 0, 0));
                        leftInnerBaseArc.Transform(arcMatrix);
                        curveCollection.Add(leftInnerBaseArc);

                        curveCollection.Add(new Line3d(new Position(xOffset, stiffenerBaseOffset.Y, -stiffenerBaseOffset.Z), new Position(xOffset, stiffenerFootOffset.Y, -stiffenerFootOffset.Z)));
                        curveCollection.Add(new Line3d(new Position(xOffset, -stiffenerFootOffset.Y, -stiffenerFootOffset.Z), new Position(xOffset, stiffenerFootOffset.Y, -stiffenerFootOffset.Z)));
                        curveCollection.Add(new Line3d(new Position(xOffset, -stiffenerBaseOffset.Y, -stiffenerBaseOffset.Z), new Position(xOffset, -stiffenerFootOffset.Y, -stiffenerFootOffset.Z)));

                        //inner arc2
                        symbolGeometryHelper = new SymbolGeometryHelper();
                        symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                        symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(gamma, new Vector(0, 0, 1));
                        Arc3d rightInnerBaseArc = symbolGeometryHelper.CreateArc(null, radius1 - protectSaddle.Thickness1, (inArcEndAngle - gamma));
                        rightInnerBaseArc.Transform(arcMatrix);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                        rightInnerBaseArc.Transform(arcMatrix);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(Math.PI, new Vector(0, 0, 1));
                        rightInnerBaseArc.Transform(arcMatrix);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Translate(new Vector(xOffset, 0, 0));
                        rightInnerBaseArc.Transform(arcMatrix);
                        curveCollection.Add(rightInnerBaseArc);
                    }
                    else
                    {
                        symbolGeometryHelper = new SymbolGeometryHelper();
                        symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                        symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate((-inArcBeginAngle), new Vector(0, 0, 1));
                        Arc3d innerBaseArc = symbolGeometryHelper.CreateArc(null, radius1 - protectSaddle.Thickness1, (inArcEndAngle + inArcBeginAngle));
                        innerBaseArc.Transform(arcMatrix);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                        innerBaseArc.Transform(arcMatrix);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(Math.PI, new Vector(0, 0, 1));
                        innerBaseArc.Transform(arcMatrix);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Translate(new Vector(xOffset, 0, 0));
                        innerBaseArc.Transform(arcMatrix);
                        curveCollection.Add(innerBaseArc);

                    }
                    //in right
                    curveCollection.Add(new Line3d(new Position(xOffset, -rightFootIn.Y, -rightFootIn.Z), new Position(xOffset, -rightBaseIn.Y, -rightBaseIn.Z)));
                    curveCollection.Add(new Line3d(new Position(xOffset, -rightFootIn.Y, -rightFootIn.Z), new Position(xOffset, -rightFootOut.Y, -rightFootOut.Z)));

                    if (withOverHangs)
                    {
                        curveCollection.Add(new Line3d(new Position(xOffset, leftFootOut.Y, -leftFootOut.Z), new Position(xOffset, leftBaseInArcOHStart.Y, -leftBaseInArcOHStart.Z)));
                        symbolGeometryHelper = new SymbolGeometryHelper();
                        symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                        symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(-angle3, new Vector(0, 0, 1));
                        Arc3d leftOHArc = symbolGeometryHelper.CreateArc(null, radius1 - protectSaddle.Thickness1, (-leftInArcOHEndAngle + angle3));
                        leftOHArc.Transform(arcMatrix);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                        leftOHArc.Transform(arcMatrix);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(Math.PI, new Vector(0, 0, 1));
                        leftOHArc.Transform(arcMatrix);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Translate(new Vector(xOffset, 0, 0));
                        leftOHArc.Transform(arcMatrix);
                        curveCollection.Add(leftOHArc);
                        curveCollection.Add(new Line3d(new Position(xOffset, leftBaseInArcOHEnd.Y, -leftBaseInArcOHEnd.Z), new Position(xOffset, leftBaseOutArcOHEnd.Y, -leftBaseOutArcOHEnd.Z)));
                        symbolGeometryHelper = new SymbolGeometryHelper();
                        symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                        symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(-angle3, new Vector(0, 0, 1));
                        Arc3d outsideBaseArc = symbolGeometryHelper.CreateArc(null, radius1, (angle4 + angle3));
                        outsideBaseArc.Transform(arcMatrix);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                        outsideBaseArc.Transform(arcMatrix);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(Math.PI, new Vector(0, 0, 1));
                        outsideBaseArc.Transform(arcMatrix);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Translate(new Vector(xOffset, 0, 0));
                        outsideBaseArc.Transform(arcMatrix);
                        curveCollection.Add(outsideBaseArc);

                        curveCollection.Add(new Line3d(new Position(xOffset, -rightBaseInArcOHEnd.Y, -rightBaseInArcOHEnd.Z), new Position(xOffset, -rightBaseOutArcOHEnd.Y, -rightBaseOutArcOHEnd.Z)));

                        symbolGeometryHelper = new SymbolGeometryHelper();
                        symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                        symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(rightInArcOHStartAngle, new Vector(0, 0, 1));
                        Arc3d rightOHArc = symbolGeometryHelper.CreateArc(null, radius1 - protectSaddle.Thickness1, (angle4 - (rightInArcOHStartAngle)));
                        rightOHArc.Transform(arcMatrix);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                        rightOHArc.Transform(arcMatrix);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(Math.PI, new Vector(0, 0, 1));
                        rightOHArc.Transform(arcMatrix);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Translate(new Vector(xOffset, 0, 0));
                        rightOHArc.Transform(arcMatrix);
                        curveCollection.Add(rightOHArc);
                        curveCollection.Add(new Line3d(new Position(xOffset, -rightFootOut.Y, -rightFootOut.Z), new Position(xOffset, -rightBaseInArcOHStart.Y, -rightBaseInArcOHStart.Z)));
                    }
                    else
                    {
                        curveCollection.Add(new Line3d(new Position(xOffset, leftFootOut.Y, -leftFootOut.Z), new Position(xOffset, leftBaseOut.Y, -leftBaseOut.Z)));

                        symbolGeometryHelper = new SymbolGeometryHelper();
                        symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                        symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(-outerArcBeginAngle, new Vector(0, 0, 1));
                        Arc3d outsideBaseArc = symbolGeometryHelper.CreateArc(null, radius1, (outerArcEndAngle + outerArcBeginAngle));
                        outsideBaseArc.Transform(arcMatrix);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                        outsideBaseArc.Transform(arcMatrix);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(Math.PI, new Vector(0, 0, 1));
                        outsideBaseArc.Transform(arcMatrix);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Translate(new Vector(xOffset, 0, 0));
                        outsideBaseArc.Transform(arcMatrix);
                        curveCollection.Add(outsideBaseArc);

                        curveCollection.Add(new Line3d(new Position(xOffset, -rightFootOut.Y, -rightFootOut.Z), new Position(xOffset, -rightBaseOut.Y, -rightBaseOut.Z)));

                    }
                    Vector lineVector1 = new Vector(protectSaddle.Length1, 0, 0);
                    Projection3d prtSaddle = new Projection3d(new ComplexString3d(curveCollection), lineVector1, lineVector1.Length, true);
                    prtSaddle.Transform(matrix);
                    outputs.Add(outputName + "PRTSADDLE", prtSaddle);

                }
                else if (flatBase == true)
                {
                    //FOR THE FLAT ONE
                    curveCollection.Add(new Line3d(new Position(xOffset, -rightFootIn.Y, -rightFootIn.Z), new Position(xOffset, -rightFootOut.Y, -rightFootOut.Z)));
                    curveCollection.Add(new Line3d(new Position(xOffset, leftFootIn.Y, -leftFootIn.Z), new Position(xOffset, leftFootOut.Y, -leftFootOut.Z)));
                    curveCollection.Add(new Line3d(new Position(xOffset, leftFootIn.Y, -leftFootIn.Z), new Position(xOffset, leftBaseLineIn.Y, -leftBaseLineIn.Z)));
                    curveCollection.Add(new Line3d(new Position(xOffset, -rightFootIn.Y, -rightFootIn.Z), new Position(xOffset, -rightBaseLineIn.Y, -rightBaseLineIn.Z)));
                    if (protectSaddle.InclStiffener == 1)
                    {
                        curveCollection.Add(new Line3d(new Position(xOffset, leftBaseLineIn.Y, -leftBaseLineIn.Z), new Position(xOffset, protectSaddle.Thickness1 / 2, -rightBaseLineIn.Z)));
                        curveCollection.Add(new Line3d(new Position(xOffset, stiffenerBaseOffset.Y, -(radius1 - protectSaddle.Thickness1)), new Position(xOffset, stiffenerFootOffset.Y, -stiffenerFootOffset.Z)));
                        curveCollection.Add(new Line3d(new Position(xOffset, -stiffenerFootOffset.Y, -stiffenerFootOffset.Z), new Position(xOffset, stiffenerFootOffset.Y, -stiffenerFootOffset.Z)));
                        curveCollection.Add(new Line3d(new Position(xOffset, -stiffenerBaseOffset.Y, -(radius1 - protectSaddle.Thickness1)), new Position(xOffset, -stiffenerFootOffset.Y, -stiffenerFootOffset.Z)));
                        curveCollection.Add(new Line3d(new Position(xOffset, -protectSaddle.Thickness1 / 2, -leftBaseLineIn.Z), new Position(xOffset, -rightBaseLineIn.Y, -rightBaseLineIn.Z)));
                    }
                    else
                        curveCollection.Add(new Line3d(new Position(xOffset, leftBaseLineIn.Y, -leftBaseLineIn.Z), new Position(xOffset, -rightBaseLineIn.Y, -rightBaseLineIn.Z)));

                    if (withOverHangs)
                    {
                        curveCollection.Add(new Line3d(new Position(xOffset, -width4, -rightBaseLineOut.Z), new Position(xOffset, -width4, -leftBaseLineOut.Z + protectSaddle.Thickness1)));
                        curveCollection.Add(new Line3d(new Position(xOffset, width3, -rightBaseLineOut.Z), new Position(xOffset, width3, -leftBaseLineOut.Z + protectSaddle.Thickness1)));
                        curveCollection.Add(new Line3d(new Position(xOffset, -width4, -rightBaseLineOut.Z), new Position(xOffset, width3, -leftBaseLineOut.Z)));
                        curveCollection.Add(new Line3d(new Position(xOffset, leftBaseLineInOHStart.Y, -leftBaseLineIn.Z), new Position(xOffset, width3, -leftBaseLineIn.Z)));
                        curveCollection.Add(new Line3d(new Position(xOffset, -rightBaseLineInOHStart.Y, -rightBaseLineIn.Z), new Position(xOffset, -width4, -leftBaseLineIn.Z)));
                        curveCollection.Add(new Line3d(new Position(xOffset, -rightBaseLineInOHStart.Y, -rightBaseLineIn.Z), new Position(xOffset, -rightFootOut.Y, -rightFootOut.Z)));
                        curveCollection.Add(new Line3d(new Position(xOffset, leftBaseLineInOHStart.Y, -leftBaseLineIn.Z), new Position(xOffset, leftFootOut.Y, -leftFootOut.Z)));
                    }
                    else
                    {
                        curveCollection.Add(new Line3d(new Position(xOffset, -rightFootOut.Y, -rightFootOut.Z), new Position(xOffset, -rightBaseLineOut.Y, -rightBaseLineOut.Z)));
                        curveCollection.Add(new Line3d(new Position(xOffset, -rightBaseLineOut.Y, -rightBaseLineOut.Z), new Position(xOffset, leftBaseLineOut.Y, -leftBaseLineOut.Z)));
                        curveCollection.Add(new Line3d(new Position(xOffset, leftFootOut.Y, -leftFootOut.Z), new Position(xOffset, leftBaseLineOut.Y, -leftBaseLineOut.Z)));
                    }
                    Vector lineVector1 = new Vector(protectSaddle.Length1, 0, 0);
                    Projection3d prtSaddle = new Projection3d(new ComplexString3d(curveCollection), lineVector1, lineVector1.Length, true);
                    prtSaddle.Transform(matrix);
                    outputs.Add(outputName + "PRTSADDLE", prtSaddle);
                }
                else if (concreteSaddle)
                {
                    //CONC SADDLE

                    concSaddleLeft.Y = Math.Sin(angle1) * (protectSaddle.PipeOD / 2);
                    concSaddleLeft.Z = Math.Cos(angle1) * (protectSaddle.PipeOD / 2);
                    concSaddleRight.Y = Math.Sin(angle2) * (protectSaddle.PipeOD / 2);
                    concSaddleRight.Z = Math.Cos(angle2) * (protectSaddle.PipeOD / 2);

                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    arcMatrix = new Matrix4X4();
                    arcMatrix.SetIdentity();
                    arcMatrix.Rotate(-angle1, new Vector(0, 0, 1));
                    Arc3d upperArc = symbolGeometryHelper.CreateArc(null, protectSaddle.PipeOD / 2, (angle2 + angle1));
                    upperArc.Transform(arcMatrix);
                    arcMatrix = new Matrix4X4();
                    arcMatrix.SetIdentity();
                    arcMatrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                    upperArc.Transform(arcMatrix);
                    arcMatrix = new Matrix4X4();
                    arcMatrix.Rotate(Math.PI, new Vector(0, 0, 1));
                    upperArc.Transform(arcMatrix);
                    arcMatrix = new Matrix4X4();
                    arcMatrix.SetIdentity();
                    arcMatrix.Translate(new Vector(xOffset, 0, 0));
                    upperArc.Transform(arcMatrix);
                    curveCollection.Add(upperArc);
                    curveCollection.Add(new Line3d(new Position(xOffset, width1, -(radius1 + protectSaddle.Height1)), new Position(xOffset, -width2, -(radius1 + protectSaddle.Height1))));
                    curveCollection.Add(new Line3d(new Position(xOffset, width1, -concSaddleLeft.Z), new Position(xOffset, concSaddleLeft.Y, -concSaddleLeft.Z)));
                    curveCollection.Add(new Line3d(new Position(xOffset, -width2, -concSaddleRight.Z), new Position(xOffset, -concSaddleRight.Y, -concSaddleRight.Z)));
                    curveCollection.Add(new Line3d(new Position(xOffset, width1, -concSaddleLeft.Z), new Position(xOffset, width1, -(radius1 + protectSaddle.Height1))));
                    curveCollection.Add(new Line3d(new Position(xOffset, -width2, -concSaddleRight.Z), new Position(xOffset, -width2, -(radius1 + protectSaddle.Height1))));

                    Vector lineVector1 = new Vector(protectSaddle.Length1, 0, 0);
                    Projection3d prtSaddle = new Projection3d(new ComplexString3d(curveCollection), lineVector1, lineVector1.Length, true);
                    prtSaddle.Transform(matrix);
                    outputs.Add(outputName + "PRTSADDLE", prtSaddle);
                    double footingXOffset = -length2 / 2;

                    if (protectSaddle.Height2 > 0 && length2 > 0)
                    {
                        curveCollection = new Collection<ICurve>();
                        curveCollection.Add(new Line3d(new Position(footingXOffset, width1, -(radius1 + protectSaddle.Height1)), new Position(footingXOffset, -width2, -(radius1 + protectSaddle.Height1))));
                        curveCollection.Add(new Line3d(new Position(footingXOffset, width1, -(radius1 + protectSaddle.Height1 + protectSaddle.Height2)), new Position(footingXOffset, -width2, -(radius1 + protectSaddle.Height1 + protectSaddle.Height2))));
                        curveCollection.Add(new Line3d(new Position(footingXOffset, width1, -(radius1 + protectSaddle.Height1 + protectSaddle.Height2)), new Position(footingXOffset, width1, -(radius1 + protectSaddle.Height1))));
                        curveCollection.Add(new Line3d(new Position(footingXOffset, -width2, -(radius1 + protectSaddle.Height1 + protectSaddle.Height2)), new Position(footingXOffset, -width2, -(radius1 + protectSaddle.Height1))));

                        Vector footLineVector2 = new Vector(length2, 0, 0);
                        Projection3d footing = new Projection3d(new ComplexString3d(curveCollection), footLineVector2, footLineVector2.Length, true);
                        footing.Transform(matrix);
                        outputs.Add(outputName + "footing", footing);
                    }
                }
                else if (ushape)
                {
                    //USHAPE
                    double outerAngleLeft = Math.Asin(width1 / (protectSaddle.PipeOD / 2));
                    double outerAngleRight = Math.Asin(width2 / (protectSaddle.PipeOD / 2));
                    double innerAngleLeft = Math.Asin((width1 - protectSaddle.Thickness1) / (protectSaddle.PipeOD / 2));
                    double innerAngleRight = Math.Asin((width2 - protectSaddle.Thickness1) / (protectSaddle.PipeOD / 2));
                    double leftFootInZ = Math.Cos(innerAngleLeft) * (protectSaddle.PipeOD / 2);
                    double leftFootOutZ = Math.Cos(outerAngleLeft) * (protectSaddle.PipeOD / 2);
                    double rightFootInZ = Math.Cos(innerAngleRight) * (protectSaddle.PipeOD / 2);
                    double rightFootOutZ = Math.Cos(outerAngleRight) * (protectSaddle.PipeOD / 2);
                    curveCollection.Add(new Line3d(new Position(xOffset, width1, -((protectSaddle.PipeOD / 2) + protectSaddle.Height3)), new Position(xOffset, -width2, -((protectSaddle.PipeOD / 2) + protectSaddle.Height3))));
                    curveCollection.Add(new Line3d(new Position(xOffset, width1 - protectSaddle.Thickness1, -((protectSaddle.PipeOD / 2) + protectSaddle.Height3 - protectSaddle.Thickness1)), new Position(xOffset, -width2 + protectSaddle.Thickness1, -((protectSaddle.PipeOD / 2) + protectSaddle.Height3 - protectSaddle.Thickness1))));
                    curveCollection.Add(new Line3d(new Position(xOffset, width1, -leftFootOutZ), new Position(xOffset, width1, -(protectSaddle.PipeOD / 2 + protectSaddle.Height3))));
                    curveCollection.Add(new Line3d(new Position(xOffset, width1 - protectSaddle.Thickness1, -leftFootInZ), new Position(xOffset, width1 - protectSaddle.Thickness1, -(protectSaddle.PipeOD / 2 + protectSaddle.Height3 - protectSaddle.Thickness1))));
                    curveCollection.Add(new Line3d(new Position(xOffset, width1 - protectSaddle.Thickness1, -leftFootInZ), new Position(xOffset, width1, -leftFootOutZ)));
                    curveCollection.Add(new Line3d(new Position(xOffset, -width2, -rightFootOutZ), new Position(xOffset, -width2, -(protectSaddle.PipeOD / 2 + protectSaddle.Height3))));
                    curveCollection.Add(new Line3d(new Position(xOffset, -width2 + protectSaddle.Thickness1, -rightFootInZ), new Position(xOffset, -width2 + protectSaddle.Thickness1, -(protectSaddle.PipeOD / 2 + protectSaddle.Height3 - protectSaddle.Thickness1))));
                    curveCollection.Add(new Line3d(new Position(xOffset, -width2 + protectSaddle.Thickness1, -rightFootInZ), new Position(xOffset, -width2, -rightFootOutZ)));

                    Vector prtSaddleLineVector2 = new Vector(protectSaddle.Length1, 0, 0);
                    Projection3d prtSaddle1 = new Projection3d(new ComplexString3d(curveCollection), prtSaddleLineVector2, prtSaddleLineVector2.Length, true);
                    prtSaddle1.Transform(matrix);
                    outputs.Add(outputName + "PRTSADDLE", prtSaddle1);
                }
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddProtectSaddle, "Error in AddProtectSaddle");
                }
            }
        }

        /// <summary>
        /// This property adds inputs for ClevisHanger.User symbol calls this property AdditionalInputs
        /// to define additional inputs. The list of inputs returned by this method will be the inputs for the user symbol in addition
        /// to the inputs that are already defined as member variables.
        /// </summary>
        ///<code>
        /// public override IEnumerable<Input> AdditionalInputs
        /// {
        ///     get
        ///     {
        ///         int endIndex;
        ///         additionalInputs = new List(Input)();
        ///         //Example , I have added the ClevisHanger with staring index 3.
        ///         AddClevisHangerInputs(3, out endIndex, additionalInputs);
        ///         return additionalInputs; 
        ///    }
        /// }
        ///</code>
        public void AddClevisHangerInputs(int startIndex, out int endIndex, List<Input> additionalInputs)
        {
            try
            {
                additionalInputs.Add((Input)new InputDouble(startIndex, "Angle1", "Angle1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "ClevisTopShp", "ClevisTopShp", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "ClevisBotShp", "ClevisBotShp", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "RodTakeOut", "RodTakeOut", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Height1", "Height1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Diameter1", "Diameter1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Width1", "Width1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Thickness1", "Thickness1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Width2", "Width2", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Thickness2", "Thickness2", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Pin1Diameter", "Pin1Diameter", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Pin1Length", "Pin1Length", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Height2", "Height2", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Height3", "Height3", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Height4", "Height4", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Length1", "Length1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Length2", "Length2", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Length3", "Length3", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Height5", "Height5", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Height6", "Height6", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Height7", "Height7", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Thickness3", "Thickness3", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Height8", "Height8", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Thickness4", "Thickness4", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Pin2Diameter", "Pin2Diameter", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Pin2Length", "Pin2Length", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Diameter2", "Diameter2", 0, false));

            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddClevisHangerInputs, "Error in adding ClevisHanger inputs");
                }
            }
            endIndex = startIndex;
        }

        /// <summary>
        /// Adds the ClevisHanger outputs.User symbol calls this method during AdditionalOutputs
        /// to define additional outputs for an aspect. The list of outputs returned by this method will be the outputs for the aspect
        /// in addition to the outputs that are already defined as attributes on the aspect.
        /// </summary>
        /// <param name="additionalOutputs">The additional outputs.</param>
        ///<code>
        ///public override IEnumerable<OutputDefinition> AdditionalOutputs(string aspectName)
        ///{
        ///    List<OutputDefinition> additionalOutputs = new List<OutputDefinition>();
        ///    if (aspectName == "Symbolic")
        ///    {
        ///        AddClevisHangerOutputs(additionalOutputs);
        ///    }
        ///    return additionalOutputs;
        ///}
        ///</code> 
        public void AddClevisHangerOutputs(List<OutputDefinition> additionalOutputs)
        {
            try
            {
                additionalOutputs.Add(new OutputDefinition("ClevisHanger" + "TopShp", "ClevisHanger" + "TopShp"));
                additionalOutputs.Add(new OutputDefinition("ClevisHanger" + "BOLT", "ClevisHanger" + "BOLT"));
                additionalOutputs.Add(new OutputDefinition("ClevisHanger" + "BotShp", "ClevisHanger" + "BotShp"));
                additionalOutputs.Add(new OutputDefinition("ClevisHanger" + "WRAP", "ClevisHanger" + "WRAP"));
                additionalOutputs.Add(new OutputDefinition("ClevisHanger" + "LINER", "ClevisHanger" + "LINER"));
                additionalOutputs.Add(new OutputDefinition("ClevisHanger" + "SPACER", "ClevisHanger" + "SPACER"));
                additionalOutputs.Add(new OutputDefinition("ClevisHanger" + "R_ROLL", "ClevisHanger" + "R_ROLL"));
                additionalOutputs.Add(new OutputDefinition("ClevisHanger" + "L_ROLL", "ClevisHanger" + "L_ROLL"));
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddClevisHangerOutputs, "Error in adding ClevisHanger outputs");
            }
        }
        /// <summary>
        /// This method will be called by user symbol to get value of an input(in this case, ClevisHanger input structure)during construction of outputs. 
        /// Given the start index, this method will return the value of the NutInputs struct object.
        /// </summary>
        /// <param name="startIndex">The start index.</param>
        /// <returns></returns>
        ///<code>
        /// ClevisHangerInputs cHanger = LoadClevisHangerData(3);
        ///</code>
        public ClevisHangerInputs LoadClevisHangerData(int startIndex)
        {
            ClevisHangerInputs cHanger = new ClevisHangerInputs();
            try
            {
                cHanger.Angle1 = GetDoubleInputValue(startIndex);
                cHanger.ClevisTopShp = Convert.ToInt32(GetDoubleInputValue(++startIndex));
                cHanger.ClevisBotShp = Convert.ToInt32(GetDoubleInputValue(++startIndex));
                cHanger.RodTakeOut = GetDoubleInputValue(++startIndex);
                cHanger.Height1 = GetDoubleInputValue(++startIndex);
                cHanger.Diameter1 = GetDoubleInputValue(++startIndex);
                cHanger.Width1 = GetDoubleInputValue(++startIndex);
                cHanger.Thickness1 = GetDoubleInputValue(++startIndex);
                cHanger.Width2 = GetDoubleInputValue(++startIndex);
                cHanger.Thickness2 = GetDoubleInputValue(++startIndex);
                cHanger.Pin1Diameter = GetDoubleInputValue(++startIndex);
                cHanger.Pin1Length = GetDoubleInputValue(++startIndex);
                cHanger.Height2 = GetDoubleInputValue(++startIndex);
                cHanger.Height3 = GetDoubleInputValue(++startIndex);
                cHanger.Height4 = GetDoubleInputValue(++startIndex);
                cHanger.Length1 = GetDoubleInputValue(++startIndex);
                cHanger.Length2 = GetDoubleInputValue(++startIndex);
                cHanger.Length3 = GetDoubleInputValue(++startIndex);
                cHanger.Height5 = GetDoubleInputValue(++startIndex);
                cHanger.Height6 = GetDoubleInputValue(++startIndex);
                cHanger.Height7 = GetDoubleInputValue(++startIndex);
                cHanger.Thickness3 = GetDoubleInputValue(++startIndex);
                cHanger.Height8 = GetDoubleInputValue(++startIndex);
                cHanger.Thickness4 = GetDoubleInputValue(++startIndex);
                cHanger.Pin2Diameter = GetDoubleInputValue(++startIndex);
                cHanger.Pin2Length = GetDoubleInputValue(++startIndex);
                cHanger.Diameter2 = GetDoubleInputValue(++startIndex);
                if (cHanger.Width1 == 0 && cHanger.Width2 == 0)
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidWidth1Width2NZero, "Width1 and Width2 value should not be zero");
                else if (cHanger.Width1 == 0)
                    cHanger.Width1 = cHanger.Width2;
                else if (cHanger.Width2 == 0)
                    cHanger.Width2 = cHanger.Width1;
            }
            catch (SmartPartSymbolException hgrEx)
            {
                throw hgrEx;
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadClevisData, "Error in LoadClevisHangerData");
                }
            }
            return cHanger;
        }
        /// <summary>
        ///Create the graphical representation of a ClevisHanger.  Specify the inputs and StringMatrix.
        /// </summary>
        ///<param name="ClevisHanger">Structure for specifying the inputs for the ClevisHanger -ClevisHangerInputs </param>
        ///<param name="matrix">matrix to specify the position and oreintation the graphics - matrix.</param>
        /// <param name="outputs">Collection of declared outputs, which is indexed by the name of the outputs declared as defining SymbolOutputs on the AspectDefinition field- OutputDictionary</param>
        /// <param name="outputName">Output that this graphic is being placed on-String</param>
        ///<code>
        /// AddClevisHanger(cHanger, pipeOd, rodDiameter, matrix, m_PhysicalAspect.Outputs, "ClevisHanger");
        ///</code>
        public void AddClevisHanger(ClevisHangerInputs clevisHgr, Double pipeOD, Double rodDiameter, Matrix4X4 matrix, OutputDictionary outputs, String outputName)
        {
            try
            {
                StringBuilder error = new StringBuilder();
                Double topCrossAngle, topCrossDistance1, topCrossDistance2;
                SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();
                Collection<Position> pointCollection = new Collection<Position>();
                Collection<ICurve> curveCollection = new Collection<ICurve>();
                Vector projectionVector;
                Projection3d projectionBody;
                Line3d line;
                Matrix4X4 arcMatrix = new Matrix4X4();
                Arc3d arc;
                //Initialisations
                if (clevisHgr.Height1 <= clevisHgr.RodTakeOut)
                    error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidHeight1LTRodTakeout, "The distance from the pipe centerline to the top of the clevis must be longer than rod takeout"));

                //Check the Value of Diameter1
                if ((clevisHgr.ClevisBotShp >= (3 - Math3d.DistanceTolerance)) && (clevisHgr.ClevisBotShp <= (3 + Math3d.DistanceTolerance)))
                    clevisHgr.Diameter1 = pipeOD;

                if (clevisHgr.Diameter1 < 0)
                    error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidDiameter1Value, "Enter Positive value for Diameter1"));
                else if ((clevisHgr.Diameter1 >= (0 - Math3d.DistanceTolerance)) && (clevisHgr.Diameter1 <= (0 + Math3d.DistanceTolerance)))
                    clevisHgr.Diameter1 = pipeOD;

                //For Width1 and Width2, one of them should be greater than Pin1 Diameter and RodDiameter
                if (clevisHgr.Pin1Diameter <= 0)
                    clevisHgr.Pin1Diameter = rodDiameter;

                if (clevisHgr.Width1 <= rodDiameter)
                    clevisHgr.Width1 = 2 * rodDiameter;

                if (clevisHgr.Width2 <= clevisHgr.Pin1Diameter)
                    clevisHgr.Width2 = 2 * clevisHgr.Pin1Diameter;

                //Check the value of RodTakeOut
                if (clevisHgr.RodTakeOut <= 0.5 * clevisHgr.Diameter1 + clevisHgr.Pin1Diameter)
                    error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidRodTakeoutGTDiameter, "Rod Take Out should greater than 0.5 * Diameter1 plus dPin1Diameter"));

                //Thickness1 and Thickness2, Both of them should be greater than 0
                if (clevisHgr.Thickness1 < 0)
                    error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidThickness1GTZero, "Enter Positive value for Thickness1"));

                if (clevisHgr.Thickness2 < 0)
                    error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidThickness2GTZero, "Enter Positive value for Thickness2"));

                if (((clevisHgr.Thickness1 >= (0 - Math3d.DistanceTolerance)) && (clevisHgr.Thickness1 <= (0 + Math3d.DistanceTolerance))) && ((clevisHgr.Thickness2 >= (0 - Math3d.DistanceTolerance)) && (clevisHgr.Thickness2 <= (0 + Math3d.DistanceTolerance))))
                {
                    clevisHgr.Thickness1 = 0.5 * rodDiameter;
                    clevisHgr.Thickness2 = 0.5 * rodDiameter;
                }
                else if (clevisHgr.Thickness1 > clevisHgr.Thickness2)
                    clevisHgr.Thickness2 = clevisHgr.Thickness1;
                else
                    clevisHgr.Thickness1 = clevisHgr.Thickness2;

                //Check the Value of PinLength
                if (clevisHgr.Pin1Length <= 0)
                    clevisHgr.Pin1Length = 1.25 * (clevisHgr.Diameter1 + 2 * clevisHgr.Thickness1 + 2 * clevisHgr.Thickness2);

                //Check the Value of dHeight2
                if (clevisHgr.Height2 <= 0)
                {
                    if (!((clevisHgr.ClevisBotShp >= (3 - Math3d.DistanceTolerance)) && (clevisHgr.ClevisBotShp <= (3 + Math3d.DistanceTolerance))))
                        clevisHgr.Height2 = clevisHgr.RodTakeOut - 1.5 * clevisHgr.Pin1Diameter;
                    else if ((clevisHgr.ClevisBotShp >= (3 - Math3d.DistanceTolerance)) && (clevisHgr.ClevisBotShp <= (3 + Math3d.DistanceTolerance)))
                        clevisHgr.Height2 = 0.75 * clevisHgr.Diameter1;
                }
                //Check the value of Height3
                if (!((clevisHgr.ClevisBotShp >= (3 - Math3d.DistanceTolerance)) && (clevisHgr.ClevisBotShp <= (3 + Math3d.DistanceTolerance))))
                {
                    if (clevisHgr.Height3 < clevisHgr.RodTakeOut - (clevisHgr.Height2 - clevisHgr.Pin1Diameter / 2))
                        clevisHgr.Height3 = clevisHgr.Height1 - (clevisHgr.Height2 - 1.5 * clevisHgr.Pin1Diameter);
                }
                else
                {
                    if (clevisHgr.Height3 < clevisHgr.Height1 + clevisHgr.Height2)
                        clevisHgr.Height3 = clevisHgr.Height1 + 2 * clevisHgr.Height2;
                }

                //Check the Value of Height4
                if (!((clevisHgr.ClevisTopShp >= (3 - Math3d.DistanceTolerance)) && (clevisHgr.ClevisTopShp <= (3 + Math3d.DistanceTolerance))))
                {
                    if (!((clevisHgr.ClevisBotShp >= (3 - Math3d.DistanceTolerance)) && (clevisHgr.ClevisBotShp <= (3 + Math3d.DistanceTolerance))))
                    {
                        if ((clevisHgr.Height4 > clevisHgr.Height3) || (clevisHgr.Height4 < clevisHgr.RodTakeOut - (clevisHgr.Height2 - clevisHgr.Pin1Diameter / 2)))
                            clevisHgr.Height4 = 3 * clevisHgr.Pin1Diameter;
                    }
                    else
                    {
                        if ((clevisHgr.Height4 > clevisHgr.Height3) || (clevisHgr.Height4 < clevisHgr.Height1 + clevisHgr.Height2))
                            clevisHgr.Height4 = clevisHgr.Height3 - 3 * clevisHgr.Pin1Diameter;
                    }
                }


                //Check the Value of Length1
                if (clevisHgr.Length1 < rodDiameter + Math3d.DistanceTolerance)
                    clevisHgr.Length1 = 3 * rodDiameter;

                //Check the Value of Length2
                if (!((clevisHgr.ClevisBotShp >= (3 - Math3d.DistanceTolerance)) && (clevisHgr.ClevisBotShp <= (3 + Math3d.DistanceTolerance))))
                {
                    if ((clevisHgr.ClevisTopShp >= (3 - Math3d.DistanceTolerance)) && (clevisHgr.ClevisBotShp <= (3 + Math3d.DistanceTolerance)))
                    {
                        if (((clevisHgr.Length2 >= (clevisHgr.Length1 - Math3d.DistanceTolerance)) && (clevisHgr.Length2 <= (clevisHgr.Length1 + Math3d.DistanceTolerance))) == false)
                            clevisHgr.Length2 = clevisHgr.Length1;
                    }
                    else
                    {
                        if (clevisHgr.Length2 < clevisHgr.Length1)
                            clevisHgr.Length2 = clevisHgr.Diameter1 + 2 * clevisHgr.Thickness2;
                    }
                    if (clevisHgr.Length2 > clevisHgr.Pin1Length - 2 * clevisHgr.Thickness1)
                        error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidLength2LTPin1Length, "Length2 should less than or equal to Pin1Length - 2 * Thickness1"));
                }
                else
                {
                    if (clevisHgr.Length2 < clevisHgr.Diameter1)
                        error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidLength2EDiameter1, "Length2 should greater than or equal to Diameter1"));
                }

                //Check the value of Length3

                if (((clevisHgr.ClevisTopShp >= (2 - Math3d.DistanceTolerance)) && (clevisHgr.ClevisTopShp <= (2 + Math3d.DistanceTolerance))) && (clevisHgr.Length3 <= 0))
                    clevisHgr.Length3 = 0.125 * clevisHgr.Length1;

                //Bot Detail
                if (!((clevisHgr.ClevisBotShp >= (3 - Math3d.DistanceTolerance)) && (clevisHgr.ClevisBotShp <= (3 + Math3d.DistanceTolerance))))
                {
                    //Check the value of Height5
                    if (clevisHgr.Height5 < 0.5 * clevisHgr.Diameter1 + clevisHgr.Pin1Diameter)
                        clevisHgr.Height5 = clevisHgr.RodTakeOut - 0.5 * clevisHgr.Pin1Diameter;

                    //Check the value of Height7
                    if (((clevisHgr.ClevisBotShp >= (2 - Math3d.DistanceTolerance)) && (clevisHgr.ClevisTopShp <= (2 + Math3d.DistanceTolerance))) && (clevisHgr.Height7 <= 0))
                        clevisHgr.Height6 = 0.5 * clevisHgr.Diameter1 / Math.Sin(4 * Math.Atan(1) / 4);

                    //Check the value of Height6
                    if (((clevisHgr.ClevisBotShp >= (2 - Math3d.DistanceTolerance)) && (clevisHgr.ClevisTopShp <= (2 + Math3d.DistanceTolerance))) && (clevisHgr.Height6 <= 0))
                        clevisHgr.Height6 = clevisHgr.Height7 - 0.5 * clevisHgr.Diameter1;

                    if (clevisHgr.Height8 > clevisHgr.Height5)
                        error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidHeight8LTHeight5, "Height8 must be less than Height5"));
                }
                //Spacer or Rollor
                //Check the value of dPin2Diameter
                if (((clevisHgr.ClevisBotShp >= (3 - Math3d.DistanceTolerance)) && (clevisHgr.ClevisTopShp <= (3 + Math3d.DistanceTolerance))) && (clevisHgr.Pin2Diameter <= clevisHgr.Pin1Diameter))
                    clevisHgr.Pin2Diameter = 0.5 * clevisHgr.Diameter1;

                //Check the value of dPin2Length
                if ((clevisHgr.Pin2Length >= (0 - Math3d.DistanceTolerance)) && (clevisHgr.Pin2Length <= (0 + Math3d.DistanceTolerance)))
                    clevisHgr.Pin2Length = clevisHgr.Diameter1;

                if ((clevisHgr.ClevisBotShp >= (3 - Math3d.DistanceTolerance)) && (clevisHgr.ClevisBotShp <= (3 + Math3d.DistanceTolerance)))
                {
                    if (clevisHgr.Pin2Length > clevisHgr.Length2)
                        error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidPin2LengthLTELength2, "Pin2 Length must be less than or equal to Length2"));
                }
                else
                {
                    if ((clevisHgr.Pin2Length > clevisHgr.Diameter1) || (clevisHgr.Pin2Length > clevisHgr.Length2))
                        error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidPin2LengthLTELength2AndDiameter1, "Pin2 Length must be less than or equal to Length2 and Diameter1"));
                }

                //Check the value of Diameter2
                if (((clevisHgr.ClevisBotShp >= (3 - Math3d.DistanceTolerance)) && (clevisHgr.ClevisBotShp <= (3 + Math3d.DistanceTolerance))) && (clevisHgr.Diameter2 <= 0))
                    clevisHgr.Diameter2 = 2 * clevisHgr.Pin2Diameter;

                //Top Shape
                if (clevisHgr.ClevisTopShp == 1)
                {
                    topCrossAngle = Math.Atan((clevisHgr.Height3 - clevisHgr.Height4) / (clevisHgr.Length2 / 2 + clevisHgr.Thickness1 - clevisHgr.Length1 / 2));
                    topCrossDistance1 = clevisHgr.Thickness1 * Math.Tan((4 * Math.Atan(1) / 2 - topCrossAngle) / 2);
                    topCrossDistance2 = clevisHgr.Thickness1 * Math.Tan(topCrossAngle / 2);

                    pointCollection = new Collection<Position>();
                    pointCollection.Add(new Position(-clevisHgr.Width1 / 2, -clevisHgr.Length1 / 2, clevisHgr.Height1));
                    pointCollection.Add(new Position(-clevisHgr.Width1 / 2, -(clevisHgr.Length2 / 2 + clevisHgr.Thickness1), clevisHgr.Height1 - clevisHgr.Height3 + clevisHgr.Height4));
                    pointCollection.Add(new Position(-clevisHgr.Width1 / 2, -(clevisHgr.Length2 / 2 + clevisHgr.Thickness1), clevisHgr.Height1 - clevisHgr.Height3));
                    pointCollection.Add(new Position(-clevisHgr.Width1 / 2, -clevisHgr.Length2 / 2, clevisHgr.Height1 - clevisHgr.Height3));
                    pointCollection.Add(new Position(-clevisHgr.Width1 / 2, -clevisHgr.Length2 / 2, clevisHgr.Height1 - clevisHgr.Height3 + clevisHgr.Height4 - topCrossDistance1));
                    pointCollection.Add(new Position(-clevisHgr.Width1 / 2, -clevisHgr.Length1 / 2 + topCrossDistance2, clevisHgr.Height1 - clevisHgr.Thickness1));
                    pointCollection.Add(new Position(-clevisHgr.Width1 / 2, clevisHgr.Length1 / 2 - topCrossDistance2, clevisHgr.Height1 - clevisHgr.Thickness1));
                    pointCollection.Add(new Position(-clevisHgr.Width1 / 2, clevisHgr.Length2 / 2, clevisHgr.Height1 - clevisHgr.Height3 + clevisHgr.Height4 - topCrossDistance1));
                    pointCollection.Add(new Position(-clevisHgr.Width1 / 2, clevisHgr.Length2 / 2, clevisHgr.Height1 - clevisHgr.Height3));
                    pointCollection.Add(new Position(-clevisHgr.Width1 / 2, (clevisHgr.Length2 / 2 + clevisHgr.Thickness1), clevisHgr.Height1 - clevisHgr.Height3));
                    pointCollection.Add(new Position(-clevisHgr.Width1 / 2, (clevisHgr.Length2 / 2 + clevisHgr.Thickness1), clevisHgr.Height1 - clevisHgr.Height3 + clevisHgr.Height4));
                    pointCollection.Add(new Position(-clevisHgr.Width1 / 2, clevisHgr.Length1 / 2, clevisHgr.Height1));
                    pointCollection.Add(new Position(-clevisHgr.Width1 / 2, -clevisHgr.Length1 / 2, clevisHgr.Height1));

                    curveCollection = new Collection<ICurve>();
                    curveCollection.Add(new LineString3d(pointCollection));

                    projectionVector = new Vector(clevisHgr.Width1, 0, 0);
                    projectionBody = new Projection3d((ICurve)(new ComplexString3d(curveCollection)), projectionVector, projectionVector.Length, true);
                    projectionBody.Transform(matrix);
                    outputs.Add(outputName + "TopShp", projectionBody);
                }
                else if (clevisHgr.ClevisTopShp == 2)
                {
                    pointCollection = new Collection<Position>();
                    pointCollection.Add(new Position(-clevisHgr.Width1 / 2, -clevisHgr.Length1 / 2, clevisHgr.Height1));
                    pointCollection.Add(new Position(-clevisHgr.Width1 / 2, -(clevisHgr.Length2 - clevisHgr.Length3) / 2, clevisHgr.Height1 - clevisHgr.Height3 + clevisHgr.Height4));
                    pointCollection.Add(new Position(-clevisHgr.Width1 / 2, -(clevisHgr.Length2 / 2 + clevisHgr.Thickness1), clevisHgr.Height1 - clevisHgr.Height3 + clevisHgr.Height4));
                    pointCollection.Add(new Position(-clevisHgr.Width1 / 2, -(clevisHgr.Length2 / 2 + clevisHgr.Thickness1), clevisHgr.Height1 - clevisHgr.Height3));
                    pointCollection.Add(new Position(-clevisHgr.Width1 / 2, -clevisHgr.Length2 / 2, clevisHgr.Height1 - clevisHgr.Height3));
                    pointCollection.Add(new Position(-clevisHgr.Width1 / 2, -clevisHgr.Length2 / 2, clevisHgr.Height1 - clevisHgr.Height3 + clevisHgr.Height4 - clevisHgr.Thickness1));
                    pointCollection.Add(new Position(-clevisHgr.Width1 / 2, -(clevisHgr.Length2 - clevisHgr.Length3) / 2, clevisHgr.Height1 - clevisHgr.Height3 + clevisHgr.Height4 - clevisHgr.Thickness1));
                    pointCollection.Add(new Position(-clevisHgr.Width1 / 2, -clevisHgr.Length1 / 2, clevisHgr.Height1 - clevisHgr.Thickness1 / Math.Sin(4 * Math.Atan(1) / 4)));
                    pointCollection.Add(new Position(-clevisHgr.Width1 / 2, clevisHgr.Length1 / 2, clevisHgr.Height1 - clevisHgr.Thickness1 / Math.Sin(4 * Math.Atan(1) / 4)));
                    pointCollection.Add(new Position(-clevisHgr.Width1 / 2, (clevisHgr.Length2 - clevisHgr.Length3) / 2, clevisHgr.Height1 - clevisHgr.Height3 + clevisHgr.Height4 - clevisHgr.Thickness1));
                    pointCollection.Add(new Position(-clevisHgr.Width1 / 2, clevisHgr.Length2 / 2, clevisHgr.Height1 - clevisHgr.Height3 + clevisHgr.Height4 - clevisHgr.Thickness1));
                    pointCollection.Add(new Position(-clevisHgr.Width1 / 2, clevisHgr.Length2 / 2, clevisHgr.Height1 - clevisHgr.Height3));
                    pointCollection.Add(new Position(-clevisHgr.Width1 / 2, (clevisHgr.Length2 / 2 + clevisHgr.Thickness1), clevisHgr.Height1 - clevisHgr.Height3));
                    pointCollection.Add(new Position(-clevisHgr.Width1 / 2, (clevisHgr.Length2 / 2 + clevisHgr.Thickness1), clevisHgr.Height1 - clevisHgr.Height3 + clevisHgr.Height4));
                    pointCollection.Add(new Position(-clevisHgr.Width1 / 2, (clevisHgr.Length2 - clevisHgr.Length3) / 2, clevisHgr.Height1 - clevisHgr.Height3 + clevisHgr.Height4));
                    pointCollection.Add(new Position(-clevisHgr.Width1 / 2, clevisHgr.Length1 / 2, clevisHgr.Height1));
                    pointCollection.Add(new Position(-clevisHgr.Width1 / 2, -clevisHgr.Length1 / 2, clevisHgr.Height1));

                    curveCollection = new Collection<ICurve>();
                    curveCollection.Add(new LineString3d(pointCollection));

                    projectionVector = new Vector(clevisHgr.Width1, 0, 0);
                    projectionBody = new Projection3d((ICurve)(new ComplexString3d(curveCollection)), projectionVector, projectionVector.Length, true);
                    projectionBody.Transform(matrix);
                    outputs.Add(outputName + "TopShp", projectionBody);
                }
                else if (clevisHgr.ClevisTopShp == 3)
                {
                    pointCollection = new Collection<Position>();
                    pointCollection.Add(new Position(-clevisHgr.Width1 / 2, -(clevisHgr.Length2 / 2 + clevisHgr.Thickness1), clevisHgr.Height1));
                    pointCollection.Add(new Position(-clevisHgr.Width1 / 2, -(clevisHgr.Length2 / 2 + clevisHgr.Thickness1), clevisHgr.Height1 - clevisHgr.Height3));
                    pointCollection.Add(new Position(-clevisHgr.Width1 / 2, -clevisHgr.Length2 / 2, clevisHgr.Height1 - clevisHgr.Height3));
                    pointCollection.Add(new Position(-clevisHgr.Width1 / 2, -clevisHgr.Length2 / 2, clevisHgr.Height1 - clevisHgr.Thickness1));
                    pointCollection.Add(new Position(-clevisHgr.Width1 / 2, clevisHgr.Length2 / 2, clevisHgr.Height1 - clevisHgr.Thickness1));
                    pointCollection.Add(new Position(-clevisHgr.Width1 / 2, clevisHgr.Length2 / 2, clevisHgr.Height1 - clevisHgr.Height3));
                    pointCollection.Add(new Position(-clevisHgr.Width1 / 2, clevisHgr.Length2 / 2 + clevisHgr.Thickness1, clevisHgr.Height1 - clevisHgr.Height3));
                    pointCollection.Add(new Position(-clevisHgr.Width1 / 2, clevisHgr.Length2 / 2 + clevisHgr.Thickness1, clevisHgr.Height1));
                    pointCollection.Add(new Position(-clevisHgr.Width1 / 2, -(clevisHgr.Length2 / 2 + clevisHgr.Thickness1), clevisHgr.Height1));

                    curveCollection = new Collection<ICurve>();
                    curveCollection.Add(new LineString3d(pointCollection));

                    projectionVector = new Vector(clevisHgr.Width1, 0, 0);
                    projectionBody = new Projection3d((ICurve)(new ComplexString3d(curveCollection)), projectionVector, projectionVector.Length, true);
                    projectionBody.Transform(matrix);
                    outputs.Add(outputName + "TopShp", projectionBody);
                }

                //Bolt
                if (clevisHgr.ClevisBotShp == 3)
                {
                    if (clevisHgr.Height2 != 0)
                    {
                        symbolGeometryHelper = new SymbolGeometryHelper();
                        Vector normal = new Position(0, clevisHgr.Pin1Length / 2, -clevisHgr.Height2).Subtract(new Position(0, -clevisHgr.Pin1Length / 2, -clevisHgr.Height2));
                        Vector orthogonal = normal.GetOrthogonalVector();
                        symbolGeometryHelper.ActivePosition = new Position(0, -clevisHgr.Pin1Length / 2, -clevisHgr.Height2);
                        symbolGeometryHelper.SetOrientation(normal, orthogonal);
                        Projection3d boltCylinder = symbolGeometryHelper.CreateCylinder(null, clevisHgr.Pin1Diameter / 2, normal.Length);
                        boltCylinder.Transform(matrix);
                        outputs.Add(outputName + "BOLT", boltCylinder);
                    }
                }
                else
                {
                    if (clevisHgr.Height2 != 0)
                    {
                        symbolGeometryHelper = new SymbolGeometryHelper();
                        Vector normal = new Position(0, clevisHgr.Pin1Length / 2, clevisHgr.Height2).Subtract(new Position(0, -clevisHgr.Pin1Length / 2, clevisHgr.Height2));
                        Vector orthogonal = normal.GetOrthogonalVector();
                        symbolGeometryHelper.ActivePosition = new Position(0, -clevisHgr.Pin1Length / 2, clevisHgr.Height2);
                        symbolGeometryHelper.SetOrientation(normal, orthogonal);
                        Projection3d boltCylinder = symbolGeometryHelper.CreateCylinder(null, clevisHgr.Pin1Diameter / 2, normal.Length);
                        boltCylinder.Transform(matrix);
                        outputs.Add(outputName + "BOLT", boltCylinder);
                    }
                }

                //Bottom Shape
                if (clevisHgr.ClevisBotShp == 1)
                {
                    curveCollection = new Collection<ICurve>();
                    line = new Line3d(new Position(-clevisHgr.Width2 / 2, -(clevisHgr.Diameter1 / 2 + clevisHgr.Thickness2), clevisHgr.Height5), new Position(-clevisHgr.Width2 / 2, -(clevisHgr.Diameter1 / 2 + clevisHgr.Thickness2), 0));
                    curveCollection.Add(line);

                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    arcMatrix = new Matrix4X4();
                    arcMatrix.Rotate(Math.PI, new Vector(0, 0, 1));

                    arc = new Arc3d(symbolGeometryHelper.CreateArc(null, clevisHgr.Diameter1 / 2 + clevisHgr.Thickness2, (Math.PI)));
                    arc.Transform(arcMatrix);

                    arcMatrix = new Matrix4X4();
                    arcMatrix.SetIdentity();
                    arcMatrix.Rotate(Math.PI / 2, new Vector(1, 0, 0));
                    arc.Transform(arcMatrix);

                    arcMatrix = new Matrix4X4();
                    arcMatrix.SetIdentity();
                    arcMatrix.Translate(new Vector(0, -clevisHgr.Width2 / 2, 0));
                    arc.Transform(arcMatrix);

                    arcMatrix = new Matrix4X4();
                    arcMatrix.SetIdentity();
                    arcMatrix.Rotate(3 * Math.PI / 2, new Vector(0, 0, 1));
                    arc.Transform(arcMatrix);
                    curveCollection.Add(arc);

                    line = new Line3d(new Position(-clevisHgr.Width2 / 2, (clevisHgr.Diameter1 / 2 + clevisHgr.Thickness2), 0), new Position(-clevisHgr.Width2 / 2, (clevisHgr.Diameter1 / 2 + clevisHgr.Thickness2), clevisHgr.Height5));
                    curveCollection.Add(line);
                    line = new Line3d(new Position(-clevisHgr.Width2 / 2, (clevisHgr.Diameter1 / 2 + clevisHgr.Thickness2), clevisHgr.Height5), new Position(-clevisHgr.Width2 / 2, clevisHgr.Diameter1 / 2, clevisHgr.Height5));
                    curveCollection.Add(line);
                    line = new Line3d(new Position(-clevisHgr.Width2 / 2, clevisHgr.Diameter1 / 2, clevisHgr.Height5), new Position(-clevisHgr.Width2 / 2, clevisHgr.Diameter1 / 2, 0));
                    curveCollection.Add(line);

                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    arcMatrix = new Matrix4X4();
                    arcMatrix.Rotate(Math.PI, new Vector(0, 0, 1));

                    arc = new Arc3d(symbolGeometryHelper.CreateArc(null, clevisHgr.Diameter1 / 2, (Math.PI)));
                    arc.Transform(arcMatrix);

                    arcMatrix = new Matrix4X4();
                    arcMatrix.SetIdentity();
                    arcMatrix.Rotate(Math.PI / 2, new Vector(1, 0, 0));
                    arc.Transform(arcMatrix);

                    arcMatrix = new Matrix4X4();
                    arcMatrix.SetIdentity();
                    arcMatrix.Translate(new Vector(0, -clevisHgr.Width2 / 2, 0));
                    arc.Transform(arcMatrix);

                    arcMatrix = new Matrix4X4();
                    arcMatrix.SetIdentity();
                    arcMatrix.Rotate(3 * Math.PI / 2, new Vector(0, 0, 1));
                    arc.Transform(arcMatrix);
                    curveCollection.Add(arc);

                    line = new Line3d(new Position(-clevisHgr.Width2 / 2, -clevisHgr.Diameter1 / 2, 0), new Position(-clevisHgr.Width2 / 2, -clevisHgr.Diameter1 / 2, clevisHgr.Height5));
                    curveCollection.Add(line);
                    line = new Line3d(new Position(-clevisHgr.Width2 / 2, -clevisHgr.Diameter1 / 2, clevisHgr.Height5), new Position(-clevisHgr.Width2 / 2, -(clevisHgr.Diameter1 / 2 + clevisHgr.Thickness2), clevisHgr.Height5));
                    curveCollection.Add(line);

                    ComplexString3d side1Collection = new ComplexString3d(curveCollection);
                    projectionVector = new Vector(1, 0, 0);
                    projectionBody = new Projection3d(side1Collection, projectionVector, clevisHgr.Width2, true);
                    projectionBody.Transform(matrix);
                    outputs.Add(outputName + "BotShp", projectionBody);
                }
                else if (clevisHgr.ClevisBotShp == 2)
                {
                    pointCollection = new Collection<Position>();
                    pointCollection.Add(new Position(-clevisHgr.Width2 / 2, -(clevisHgr.Diameter1 / 2 + clevisHgr.Thickness2), clevisHgr.Height5));
                    pointCollection.Add(new Position(-clevisHgr.Width2 / 2, -(clevisHgr.Diameter1 / 2 + clevisHgr.Thickness2), -clevisHgr.Height6));
                    pointCollection.Add(new Position(-clevisHgr.Width2 / 2, 0, -clevisHgr.Height7));
                    pointCollection.Add(new Position(-clevisHgr.Width2 / 2, clevisHgr.Diameter1 / 2 + clevisHgr.Thickness2, -clevisHgr.Height6));
                    pointCollection.Add(new Position(-clevisHgr.Width2 / 2, clevisHgr.Diameter1 / 2 + clevisHgr.Thickness2, clevisHgr.Height5));
                    pointCollection.Add(new Position(-clevisHgr.Width2 / 2, clevisHgr.Diameter1 / 2, clevisHgr.Height5));
                    pointCollection.Add(new Position(-clevisHgr.Width2 / 2, clevisHgr.Diameter1 / 2, -clevisHgr.Height6 + clevisHgr.Thickness2 * Math.Sin(4 * Math.Atan(1) / 4)));
                    pointCollection.Add(new Position(-clevisHgr.Width2 / 2, 0, -clevisHgr.Height7 + clevisHgr.Thickness2 / Math.Sin(4 * Math.Atan(1) / 4)));
                    pointCollection.Add(new Position(-clevisHgr.Width2 / 2, -clevisHgr.Diameter1 / 2, -clevisHgr.Height6 + clevisHgr.Thickness2 * Math.Sin(4 * Math.Atan(1) / 4)));
                    pointCollection.Add(new Position(-clevisHgr.Width2 / 2, -clevisHgr.Diameter1 / 2, clevisHgr.Height5));
                    pointCollection.Add(new Position(-clevisHgr.Width2 / 2, -(clevisHgr.Diameter1 / 2 + clevisHgr.Thickness2), clevisHgr.Height5));

                    curveCollection = new Collection<ICurve>();
                    curveCollection.Add(new LineString3d(pointCollection));

                    projectionVector = new Vector(clevisHgr.Width2, 0, 0);
                    projectionBody = new Projection3d((ICurve)(new ComplexString3d(curveCollection)), projectionVector, projectionVector.Length, true);
                    projectionBody.Transform(matrix);
                    outputs.Add(outputName + "BotShp", projectionBody);
                }

                //Liner or Wrap
                if ((clevisHgr.ClevisBotShp == 1) || (clevisHgr.ClevisBotShp == 2))
                {
                    if (((clevisHgr.Thickness3 > 0) || (clevisHgr.Thickness4 > 0)) && (clevisHgr.Height8 > 0))
                    {
                        if (clevisHgr.Thickness4 > clevisHgr.Thickness3 - Math3d.DistanceTolerance)
                        {
                            curveCollection = new Collection<ICurve>();

                            line = new Line3d(new Position(-clevisHgr.Width2 / 2, -(clevisHgr.Diameter1 / 2 + clevisHgr.Thickness2 / 2) - clevisHgr.Thickness4 / 2, clevisHgr.Height5), new Position(-clevisHgr.Width2 / 2, -(clevisHgr.Diameter1 / 2 + clevisHgr.Thickness2 / 2) - clevisHgr.Thickness4 / 2, 0));
                            curveCollection.Add(line);

                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                            symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                            arcMatrix = new Matrix4X4();
                            arcMatrix.Rotate(Math.PI, new Vector(0, 0, 1));

                            arc = new Arc3d(symbolGeometryHelper.CreateArc(null, clevisHgr.Diameter1 / 2 + clevisHgr.Thickness2 / 2 + clevisHgr.Thickness4 / 2, (Math.PI)));
                            arc.Transform(arcMatrix);

                            arcMatrix = new Matrix4X4();
                            arcMatrix.SetIdentity();
                            arcMatrix.Rotate(Math.PI / 2, new Vector(1, 0, 0));
                            arc.Transform(arcMatrix);

                            arcMatrix = new Matrix4X4();
                            arcMatrix.SetIdentity();
                            arcMatrix.Translate(new Vector(0, -clevisHgr.Width2 / 2, 0));
                            arc.Transform(arcMatrix);

                            arcMatrix = new Matrix4X4();
                            arcMatrix.SetIdentity();
                            arcMatrix.Rotate(3 * Math.PI / 2, new Vector(0, 0, 1));
                            arc.Transform(arcMatrix);
                            curveCollection.Add(arc);

                            line = new Line3d(new Position(-clevisHgr.Width2 / 2, (clevisHgr.Diameter1 / 2 + clevisHgr.Thickness2 / 2 + clevisHgr.Thickness4 / 2), 0), new Position(-clevisHgr.Width2 / 2, (clevisHgr.Diameter1 / 2 + clevisHgr.Thickness2 / 2 + clevisHgr.Thickness4 / 2), clevisHgr.Height8));
                            curveCollection.Add(line);

                            line = new Line3d(new Position(-clevisHgr.Width2 / 2, (clevisHgr.Diameter1 / 2 + clevisHgr.Thickness2 / 2 + clevisHgr.Thickness4 / 2), clevisHgr.Height8), new Position(-clevisHgr.Width2 / 2, clevisHgr.Diameter1 / 2 + clevisHgr.Thickness2 / 2 - clevisHgr.Thickness4 / 2, clevisHgr.Height8));
                            curveCollection.Add(line);

                            line = new Line3d(new Position(-clevisHgr.Width2 / 2, clevisHgr.Diameter1 / 2 + clevisHgr.Thickness2 / 2 - clevisHgr.Thickness4 / 2, clevisHgr.Height8), new Position(-clevisHgr.Width2 / 2, clevisHgr.Diameter1 / 2 + clevisHgr.Thickness2 / 2 - clevisHgr.Thickness4 / 2, 0));
                            curveCollection.Add(line);

                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                            symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                            arcMatrix = new Matrix4X4();
                            arcMatrix.Rotate(Math.PI, new Vector(0, 0, 1));

                            arc = new Arc3d(symbolGeometryHelper.CreateArc(null, clevisHgr.Diameter1 / 2 + clevisHgr.Thickness2 / 2 - clevisHgr.Thickness4 / 2, (Math.PI)));
                            arc.Transform(arcMatrix);

                            arcMatrix = new Matrix4X4();
                            arcMatrix.SetIdentity();
                            arcMatrix.Rotate(Math.PI / 2, new Vector(1, 0, 0));
                            arc.Transform(arcMatrix);

                            arcMatrix = new Matrix4X4();
                            arcMatrix.SetIdentity();
                            arcMatrix.Translate(new Vector(0, -clevisHgr.Width2 / 2, 0));
                            arc.Transform(arcMatrix);

                            arcMatrix = new Matrix4X4();
                            arcMatrix.SetIdentity();
                            arcMatrix.Rotate(3 * Math.PI / 2, new Vector(0, 0, 1));
                            arc.Transform(arcMatrix);
                            curveCollection.Add(arc);

                            line = new Line3d(new Position(-clevisHgr.Width2 / 2, -(clevisHgr.Diameter1 / 2 + clevisHgr.Thickness2 / 2) + clevisHgr.Thickness4 / 2, 0), new Position(-clevisHgr.Width2 / 2, -(clevisHgr.Diameter1 / 2 + clevisHgr.Thickness2 / 2) + clevisHgr.Thickness4 / 2, clevisHgr.Height8));
                            curveCollection.Add(line);

                            line = new Line3d(new Position(-clevisHgr.Width2 / 2, -(clevisHgr.Diameter1 / 2 + clevisHgr.Thickness2 / 2) + clevisHgr.Thickness4 / 2, clevisHgr.Height8), new Position(-clevisHgr.Width2 / 2, -(clevisHgr.Diameter1 / 2 + clevisHgr.Thickness2 / 2) - clevisHgr.Thickness4 / 2, clevisHgr.Height8));
                            curveCollection.Add(line);

                            ComplexString3d side1Collection = new ComplexString3d(curveCollection);
                            projectionVector = new Vector(clevisHgr.Width2, 0, 0);
                            projectionBody = new Projection3d(side1Collection, projectionVector, projectionVector.Length, true);
                            projectionBody.Transform(matrix);
                            outputs.Add(outputName + "WRAP", projectionBody);
                        }
                        else
                        {
                            curveCollection = new Collection<ICurve>();
                            line = new Line3d(new Position(-clevisHgr.Width2 / 2, -clevisHgr.Diameter1 / 2, clevisHgr.Height8), new Position(-clevisHgr.Width2 / 2, -clevisHgr.Diameter1 / 2, 0));
                            curveCollection.Add(line);

                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                            symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                            arcMatrix = new Matrix4X4();
                            arcMatrix.Rotate(Math.PI, new Vector(0, 0, 1));

                            arc = new Arc3d(symbolGeometryHelper.CreateArc(null, clevisHgr.Diameter1 / 2, (Math.PI)));
                            arc.Transform(arcMatrix);

                            arcMatrix = new Matrix4X4();
                            arcMatrix.SetIdentity();
                            arcMatrix.Rotate(Math.PI / 2, new Vector(1, 0, 0));
                            arc.Transform(arcMatrix);

                            arcMatrix = new Matrix4X4();
                            arcMatrix.SetIdentity();
                            arcMatrix.Translate(new Vector(0, -clevisHgr.Width2 / 2, 0));
                            arc.Transform(arcMatrix);

                            arcMatrix = new Matrix4X4();
                            arcMatrix.SetIdentity();
                            arcMatrix.Rotate(3 * Math.PI / 2, new Vector(0, 0, 1));
                            arc.Transform(arcMatrix);
                            curveCollection.Add(arc);

                            line = new Line3d(new Position(-clevisHgr.Width2 / 2, clevisHgr.Diameter1 / 2, 0), new Position(-clevisHgr.Width2 / 2, clevisHgr.Diameter1 / 2, clevisHgr.Height8));
                            curveCollection.Add(line);
                            line = new Line3d(new Position(-clevisHgr.Width2 / 2, clevisHgr.Diameter1 / 2, clevisHgr.Height8), new Position(-clevisHgr.Width2 / 2, clevisHgr.Diameter1 / 2 - clevisHgr.Thickness3, clevisHgr.Height8));
                            curveCollection.Add(line);
                            line = new Line3d(new Position(-clevisHgr.Width2 / 2, clevisHgr.Diameter1 / 2 - clevisHgr.Thickness3, clevisHgr.Height8), new Position(-clevisHgr.Width2 / 2, clevisHgr.Diameter1 / 2 - clevisHgr.Thickness3, 0));
                            curveCollection.Add(line);

                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                            symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                            arcMatrix = new Matrix4X4();
                            arcMatrix.Rotate(Math.PI, new Vector(0, 0, 1));

                            arc = new Arc3d(symbolGeometryHelper.CreateArc(null, clevisHgr.Diameter1 / 2 - clevisHgr.Thickness3, (Math.PI)));
                            arc.Transform(arcMatrix);

                            arcMatrix = new Matrix4X4();
                            arcMatrix.SetIdentity();
                            arcMatrix.Rotate(Math.PI / 2, new Vector(1, 0, 0));
                            arc.Transform(arcMatrix);

                            arcMatrix = new Matrix4X4();
                            arcMatrix.SetIdentity();
                            arcMatrix.Translate(new Vector(0, -clevisHgr.Width2 / 2, 0));
                            arc.Transform(arcMatrix);

                            arcMatrix = new Matrix4X4();
                            arcMatrix.SetIdentity();
                            arcMatrix.Rotate(3 * Math.PI / 2, new Vector(0, 0, 1));
                            arc.Transform(arcMatrix);
                            curveCollection.Add(arc);

                            line = new Line3d(new Position(-clevisHgr.Width2 / 2, -(clevisHgr.Diameter1 / 2 - clevisHgr.Thickness3), 0), new Position(-clevisHgr.Width2 / 2, -(clevisHgr.Diameter1 / 2 - clevisHgr.Thickness3), clevisHgr.Height8));
                            curveCollection.Add(line);
                            line = new Line3d(new Position(-clevisHgr.Width2 / 2, -(clevisHgr.Diameter1 / 2 - clevisHgr.Thickness3), clevisHgr.Height8), new Position(-clevisHgr.Width2 / 2, -clevisHgr.Diameter1 / 2, clevisHgr.Height8));
                            curveCollection.Add(line);

                            ComplexString3d side1Collection = new ComplexString3d(curveCollection);
                            projectionVector = new Vector(1, 0, 0);
                            projectionBody = new Projection3d(side1Collection, projectionVector, clevisHgr.Width2, true);
                            projectionBody.Transform(matrix);
                            outputs.Add(outputName + "LINER", projectionBody);
                        }
                    }
                }

                //Spacer or Roller
                if ((clevisHgr.ClevisBotShp == 1) || (clevisHgr.ClevisBotShp == 2))
                {
                    if (clevisHgr.Pin2Diameter > clevisHgr.Pin1Diameter - Math3d.DistanceTolerance)
                    {
                        symbolGeometryHelper = new SymbolGeometryHelper();
                        Vector normal = new Position(0, clevisHgr.Pin2Length / 2, clevisHgr.Height2).Subtract(new Position(0, -clevisHgr.Pin2Length / 2, clevisHgr.Height2));
                        Vector orthogonal = normal.GetOrthogonalVector();
                        symbolGeometryHelper.ActivePosition = new Position(0, -clevisHgr.Pin2Length / 2, clevisHgr.Height2);
                        symbolGeometryHelper.SetOrientation(normal, orthogonal);
                        Projection3d boltCylinder = symbolGeometryHelper.CreateCylinder(null, clevisHgr.Pin2Diameter / 2, normal.Length);
                        boltCylinder.Transform(matrix);
                        outputs.Add(outputName + "SPACER", boltCylinder);
                    }
                }
                else if (clevisHgr.ClevisBotShp == 3)
                {
                    if (clevisHgr.Diameter2 != 0)
                    {
                        symbolGeometryHelper = new SymbolGeometryHelper();
                        symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                        symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(0, 1, 0));

                        Cone3d rightCone = symbolGeometryHelper.CreateCone(null, clevisHgr.Pin2Diameter / 2, clevisHgr.Diameter2 / 2, clevisHgr.Pin2Length / 2);

                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                        rightCone.Transform(arcMatrix);

                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Translate(new Vector(0, 0, clevisHgr.Height2));
                        rightCone.Transform(arcMatrix);

                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(3 * Math.PI / 2, new Vector(0, 0, 1));
                        rightCone.Transform(arcMatrix);

                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(Math.PI, new Vector(1, 0, 0));
                        rightCone.Transform(arcMatrix);

                        rightCone.Transform(matrix);
                        outputs.Add(outputName + "R_ROLL", rightCone);

                        symbolGeometryHelper = new SymbolGeometryHelper();
                        symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                        symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(0, 1, 0));

                        Cone3d leftCone = symbolGeometryHelper.CreateCone(null, clevisHgr.Pin2Diameter / 2, clevisHgr.Diameter2 / 2, clevisHgr.Pin2Length / 2);

                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(-Math.PI / 2, new Vector(0, 1, 0));
                        leftCone.Transform(arcMatrix);

                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Translate(new Vector(0, 0, clevisHgr.Height2));
                        leftCone.Transform(arcMatrix);

                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(3 * Math.PI / 2, new Vector(0, 0, 1));
                        leftCone.Transform(arcMatrix);

                        arcMatrix = new Matrix4X4();
                        arcMatrix.SetIdentity();
                        arcMatrix.Rotate(Math.PI, new Vector(1, 0, 0));
                        leftCone.Transform(arcMatrix);

                        leftCone.Transform(matrix);
                        outputs.Add(outputName + "L_ROLL", leftCone);
                    }
                }
                if (error.Length != 0)
                {
                    ToDoListMessage = new ToDoListMessage(ToDoMessageTypes.ToDoMessageWarning, error.ToString());
                }
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddClevisHanger, "Error in AddClevisHanger");
                }
            }
        }
        /// <summary>
        /// Create the graphical representation of a Guide.
        /// </summary>
        /// <param name="guideData">Structure for specifying the inputs for the Guide -GuideProperties.</param>
        /// <param name="matrix">Matrix to specify the position and oreintation the graphics - Matrix4X4.</param>
        /// <param name="outputs">Collection of declared outputs, which is indexed by the name of the outputs declared as defining SymbolOutputs on the AspectDefinition field- OutputDictionary.</param>
        /// <param name="outputName">OutputName that this graphic is being placed on-String.</param>
        ///<code>
        ///Matrix4X4 matrix = new Matrix4X4();
        ///matrix.Origin = new Position(0,0,0);
        ///AddGuideShape(guide, matrix, m_PhysicalAspect.Outputs, "Guide");
        ///</code>
        public void AddGuide(GuideInputs guideData, Matrix4X4 matrix, OutputDictionary outputs, String outputName)
        {
            try
            {
                StringBuilder error = new StringBuilder();
                double inNotchWidth = 0.0, basePlateThickness = 0;
                Boolean mirror1;
                Boolean mirror2;
                CatalogStructHelper catalogStructHelper = new CatalogStructHelper();
                CrossSectionServices crossSectionServices = new CrossSectionServices();
                Line3d projectionLeftHor = null, projectionRightHor = null;

                PlateInputs basePlate = new PlateInputs();
                PlateInputs vertPlate1 = new PlateInputs();
                PlateInputs vertPlate2 = new PlateInputs();
                PlateInputs horizPlate1 = new PlateInputs();
                PlateInputs horizPlate2 = new PlateInputs();
                Matrix4X4 plateMatrix = new Matrix4X4();

                //Base Plate
                basePlate.thickness1 = guideData.Thickness1;
                basePlate.width1 = guideData.Length1;
                basePlate.length1 = guideData.Width1;

                if (HgrCompareDoubleService.cmpdbl(guideData.Width3, 0) == false && HgrCompareDoubleService.cmpdbl(guideData.GuideHeight, 0) == false)
                {
                    if (guideData.GuideHeight > guideData.Thickness2)
                    {
                        guideData.Thickness3 = guideData.GuideHeight - guideData.Thickness2;
                    }
                }

                //Vertical Plates
                vertPlate1.thickness1 = guideData.Length2;
                vertPlate1.width1 = guideData.Width2;
                vertPlate1.length1 = guideData.Thickness2;

                vertPlate2.thickness1 = guideData.Length2;
                vertPlate2.width1 = guideData.Width2;
                vertPlate2.length1 = guideData.Thickness2;

                //Horz Plates
                horizPlate1.thickness1 = guideData.Length3;
                horizPlate1.width1 = guideData.Width3;
                horizPlate1.length1 = guideData.Thickness3;

                horizPlate2.thickness1 = guideData.Length3;
                horizPlate2.width1 = guideData.Width3;
                horizPlate2.length1 = guideData.Thickness3;

                Boolean noVSteel = false, plateYes = false, VPlateYes = false, HPlateYes = false;

                double offset1 = guideData.Offset1;
                double gap1 = guideData.Gap1;
                double topPlInnerOffset = (guideData.Gap1 / 2) - guideData.Offset1;
                double topPlOuterOffset = (guideData.Gap1 / 2) - guideData.Offset1 + guideData.Width3;
                double lengthOffset = guideData.Length1 / 2;
                double horizontalSpanDiff = guideData.Width1 - (guideData.Gap1 + guideData.Width2 + guideData.Width2);
                double topOuterOH = guideData.Width3 - (guideData.Offset1 + guideData.Width2);

                //rules
                if (guideData.VerPlSecStand == "" || guideData.VerPlSecSize == "" || guideData.VerPlSecType == "" || guideData.VerPlSecStand == "No Value" || guideData.VerPlSecSize == "No Value" || guideData.VerPlSecType == "No Value")
                    noVSteel = true;

                if (noVSteel && guideData.Thickness1 > 0.00000001)
                    plateYes = true;

                if (noVSteel && guideData.Thickness2 > 0.00000001)
                    VPlateYes = true;

                if (noVSteel && guideData.Thickness3 > 0.00000001)
                    HPlateYes = true;

                //Error messages
                if (!(guideData.Thickness2 > 0))
                    error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidThickness2Value, "Thickness2 is required"));
                //error = error.Append(error + "Thickness2 is required");
                if (!((horizontalSpanDiff < 0.0000001 && horizontalSpanDiff > -0.0000001) || horizontalSpanDiff > 0.0000001))
                {
                    if (guideData.Thickness1 > 0.0000001)
                        error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidWidth1, "The Specified Width1 is too small. The symbol may not place correctly"));
                    // error = error.Append(error + Environment.NewLine + "The Specified Width1 is too small. The symbol may not place correctly");
                }
                //if (guideData.Thickness3 > 0)  // TR 298998
                //{
                //    if (guideData.Width3 <= guideData.Width2)
                //        error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidWidth3, "The Specified Width3 is too small. The symbol may not place properly"));
                //    //error = error.Append(error + Environment.NewLine + "The Specified Width3 is too small. The symbol may not place properly");
                //    if (!(((topOuterOH < 0.0000001 && topOuterOH > -0.0000001) || topOuterOH > 0.0000001)) && guideData.SolidBaseVerPl == 1 && guideData.SolidVerHorPl == 1)
                //        error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidWidth3, "The Specified Width3 is too small. The symbol may not place properly"));
                //    // error = error.Append(error + Environment.NewLine + "The Specified Width3 is too small. The symbol may not place properly");
                //}

                //check for gap
                if (guideData.SolidVerHorPl == 2 && guideData.Offset1 > guideData.Width3)
                    error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidOffset, "The top most horizontal plate has an invalid offset relative to the plate below"));
                //error = error.Append(error + Environment.NewLine + "The top most horizontal plate has an invalid offset relative to the plate below.");

                if (VPlateYes == true && plateYes == false && guideData.SolidBaseVerPl == 1)
                    error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidSolidBaseVerPl, "SolidBaseVerPl must be set to 2. The guide may not place properly"));
                // error = error.Append(error + Environment.NewLine + " lSolidBaseVerPl must be set to 2. The guide may not place properly");

                if (VPlateYes = true && HPlateYes == false && guideData.SolidVerHorPl == 1)
                    error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidSolidVerHorPl, "SolidVerHorPl must be set to 2. The guide may not place properly"));
                // error = error.Append(error + Environment.NewLine + " lSolidVerHorPl must be set to 2. The guide may not place properly");
                if (guideData.SecConfig == 1 && noVSteel == false)
                {
                    if (guideData.Thickness2 < 0.0000001)
                        error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidThickness2, " Thickness2 must be specified. The guide may not place properly"));
                    //error = error.Append(error + Environment.NewLine + " Thickness2 must be specified. The guide may not place properly");
                }
                if (guideData.SecConfig == 2 && noVSteel == false)
                {
                    if (guideData.Length2 < 0.0000001)
                        error.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidLength2, "Length2 must be specified. The guide may not place properly"));
                    //error = error.Append(error + Environment.NewLine + " Length2 must be specified. The guide may not place properly");
                }
                if (error.Length != 0)
                    ToDoListMessage = new ToDoListMessage(ToDoMessageTypes.ToDoMessageWarning, error.ToString());

                if (noVSteel)
                {
                    //Add base plate
                    if (basePlate.thickness1 > 0 && guideData.SolidBaseVerPl != 1)
                    {
                        plateMatrix = new Matrix4X4();
                        plateMatrix.SetIdentity();
                        plateMatrix.Translate(new Vector(-basePlate.width1 / 2, -basePlate.length1 / 2, 0));

                        AddPlate(basePlate, plateMatrix, outputs, outputName + "Bplate");

                        Projection3d projection = (Projection3d)outputs[outputName + "Bplate"];
                        projection.Transform(matrix);

                        basePlateThickness = basePlate.thickness1;
                    }

                    //Add Horizontal Plates
                    if (horizPlate1.thickness1 > 0 && guideData.SolidVerHorPl != 1)
                    {
                        plateMatrix = new Matrix4X4();
                        plateMatrix.SetIdentity();
                        plateMatrix.Rotate((Math.PI / 2), new Vector(1, 0, 0));

                        plateMatrix.Rotate((Math.PI / 2), new Vector(0, 0, 1));

                        plateMatrix.Translate(new Vector(-horizPlate1.thickness1 / 2, -gap1 / 2 + offset1 - guideData.Width3, guideData.Thickness1 + vertPlate1.length1));

                        AddPlate(horizPlate1, plateMatrix, outputs, outputName + "Hplate1");

                        Projection3d projection = (Projection3d)outputs[outputName + "Hplate1"];
                        projection.Transform(matrix);

                        plateMatrix = new Matrix4X4();
                        plateMatrix.SetIdentity();
                        plateMatrix.Rotate((Math.PI / 2), new Vector(1, 0, 0));

                        plateMatrix.Rotate((Math.PI / 2), new Vector(0, 0, 1));

                        plateMatrix.Translate(new Vector(-horizPlate2.thickness1 / 2, gap1 / 2 - offset1, guideData.Thickness1 + vertPlate2.length1));

                        AddPlate(horizPlate2, plateMatrix, outputs, outputName + "Hplate2");

                        Projection3d projection1 = (Projection3d)outputs[outputName + "Hplate2"];
                        projection1.Transform(matrix);
                    }

                    //Add Vertical Plates
                    if (vertPlate1.thickness1 > 0 && guideData.SolidBaseVerPl != 1)
                    {
                        if (guideData.SolidVerHorPl == 1)
                        {
                            vertPlate1.width1 = guideData.Width3;
                            vertPlate1.length1 = guideData.Thickness2 + guideData.Thickness3;
                            vertPlate1.blCornerType = 1;
                            vertPlate1.blCornerX = guideData.Offset1;
                            vertPlate1.blCornerY = guideData.Thickness2;

                            vertPlate1.brCornerType = 1;
                            vertPlate1.brCornerX = guideData.Width3 - guideData.Width2 - guideData.Offset1;
                            vertPlate1.brCornerY = guideData.Thickness2;

                            vertPlate2.width1 = guideData.Width3;
                            vertPlate2.length1 = guideData.Thickness2 + guideData.Thickness3;
                            vertPlate2.blCornerType = 1;
                            vertPlate2.blCornerX = guideData.Width3 - guideData.Width2 - guideData.Offset1;
                            vertPlate2.blCornerY = guideData.Thickness2;

                            vertPlate2.brCornerType = 1;
                            vertPlate2.brCornerX = guideData.Offset1;
                            vertPlate2.brCornerY = guideData.Thickness2;
                            inNotchWidth = guideData.Offset1;
                        }

                        plateMatrix = new Matrix4X4();
                        plateMatrix.SetIdentity();
                        plateMatrix.Rotate((Math.PI / 2), new Vector(1, 0, 0));

                        plateMatrix.Rotate((Math.PI / 2), new Vector(0, 0, 1));

                        plateMatrix.Translate(new Vector(-vertPlate1.thickness1 / 2, gap1 / 2 - inNotchWidth, basePlateThickness));

                        AddPlate(vertPlate1, plateMatrix, outputs, outputName + "Vplate1");

                        Projection3d projection = (Projection3d)outputs[outputName + "Vplate1"];
                        projection.Transform(matrix);

                        plateMatrix = new Matrix4X4();
                        plateMatrix.SetIdentity();
                        plateMatrix.Rotate((Math.PI / 2), new Vector(1, 0, 0));

                        plateMatrix.Rotate((Math.PI / 2), new Vector(0, 0, 1));

                        plateMatrix.Translate(new Vector(-vertPlate2.thickness1 / 2, -gap1 / 2 + inNotchWidth - vertPlate2.width1, basePlateThickness));

                        AddPlate(vertPlate2, plateMatrix, outputs, outputName + "Vplate2");

                        Projection3d projection1 = (Projection3d)outputs[outputName + "Vplate2"];
                        projection1.Transform(matrix);
                    }

                    Collection<ICurve> lineCollection = new Collection<ICurve>();
                    if (guideData.SolidBaseVerPl == 1 && guideData.SolidVerHorPl == 1 && guideData.Thickness3 > 0)
                    {
                        if (topOuterOH > 0.000000001)
                        {
                            horizontalSpanDiff = guideData.Width1 - (guideData.Gap1 + guideData.Width2 + guideData.Width2);
                            if (horizontalSpanDiff < 0.0000001 && horizontalSpanDiff > -0.0000001)
                            {
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, guideData.Width1 / 2, 0), new Position(-lengthOffset, -guideData.Width1 / 2, 0)));

                                lineCollection.Add(new Line3d(new Position(-lengthOffset, guideData.Width1 / 2, 0), new Position(-lengthOffset, guideData.Width1 / 2, guideData.Thickness1)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, -guideData.Width1 / 2, 0), new Position(-lengthOffset, -guideData.Width1 / 2, guideData.Thickness1)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, guideData.Gap1 / 2, guideData.Thickness1), new Position(-lengthOffset, -guideData.Gap1 / 2, guideData.Thickness1)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, (-guideData.Gap1 / 2) - guideData.Width2, guideData.Thickness1), new Position(-lengthOffset, (-guideData.Gap1 / 2) - guideData.Width2, guideData.Thickness1 + guideData.Thickness2)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, (guideData.Gap1 / 2) + guideData.Width2, guideData.Thickness1), new Position(-lengthOffset, (guideData.Gap1 / 2) + guideData.Width2, guideData.Thickness1 + guideData.Thickness2)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, (-guideData.Gap1 / 2), guideData.Thickness1), new Position(-lengthOffset, (-guideData.Gap1 / 2), guideData.Thickness1 + guideData.Thickness2)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, (guideData.Gap1 / 2), guideData.Thickness1), new Position(-lengthOffset, (guideData.Gap1 / 2), guideData.Thickness1 + guideData.Thickness2)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, (-guideData.Gap1 / 2) - guideData.Width2 - topOuterOH, guideData.Thickness1 + guideData.Thickness2), new Position(-lengthOffset, (-guideData.Gap1 / 2) - guideData.Width2 - topOuterOH, guideData.Thickness1 + guideData.Thickness2 + guideData.Thickness3)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, (guideData.Gap1 / 2) + guideData.Width2 + topOuterOH, guideData.Thickness1 + guideData.Thickness2), new Position(-lengthOffset, (guideData.Gap1 / 2) + guideData.Width2 + topOuterOH, guideData.Thickness1 + guideData.Thickness2 + guideData.Thickness3)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, (-guideData.Gap1 / 2) - guideData.Width2 - topOuterOH, guideData.Thickness1 + guideData.Thickness2), new Position(-lengthOffset, (-guideData.Gap1 / 2) - guideData.Width2, guideData.Thickness1 + guideData.Thickness2)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, (guideData.Gap1 / 2) + guideData.Width2 + topOuterOH, guideData.Thickness1 + guideData.Thickness2), new Position(-lengthOffset, (guideData.Gap1 / 2) + guideData.Width2, guideData.Thickness1 + guideData.Thickness2)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, (-guideData.Gap1 / 2), guideData.Thickness1 + guideData.Thickness2), new Position(-lengthOffset, -topPlInnerOffset, guideData.Thickness1 + guideData.Thickness2)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, (guideData.Gap1 / 2), guideData.Thickness1 + guideData.Thickness2), new Position(-lengthOffset, topPlInnerOffset, guideData.Thickness1 + guideData.Thickness2)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, -topPlOuterOffset, guideData.Thickness1 + guideData.Thickness2 + guideData.Thickness3), new Position(-lengthOffset, -topPlInnerOffset, guideData.Thickness1 + guideData.Thickness2 + guideData.Thickness3)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, topPlOuterOffset, guideData.Thickness1 + guideData.Thickness2 + guideData.Thickness3), new Position(-lengthOffset, topPlInnerOffset, guideData.Thickness1 + guideData.Thickness2 + guideData.Thickness3)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, -topPlInnerOffset, guideData.Thickness1 + guideData.Thickness2), new Position(-lengthOffset, -topPlInnerOffset, guideData.Thickness1 + guideData.Thickness2 + guideData.Thickness3)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, topPlInnerOffset, guideData.Thickness1 + guideData.Thickness2), new Position(-lengthOffset, topPlInnerOffset, guideData.Thickness1 + guideData.Thickness2 + guideData.Thickness3)));

                                Vector guideVector = new Vector(guideData.Length1, 0, 0);
                                Projection3d guide = new Projection3d(new ComplexString3d(lineCollection), guideVector, guideVector.Length, true);
                                guide.Transform(matrix);
                                outputs.Add(outputName + "guide", guide);
                            }
                            else
                            {
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, guideData.Width1 / 2, 0), new Position(-lengthOffset, -guideData.Width1 / 2, 0)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, guideData.Width1 / 2, 0), new Position(-lengthOffset, guideData.Width1 / 2, guideData.Thickness1)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, -guideData.Width1 / 2, 0), new Position(-lengthOffset, -guideData.Width1 / 2, guideData.Thickness1)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, -guideData.Width1 / 2, guideData.Thickness1), new Position(-lengthOffset, (-guideData.Gap1 / 2) - guideData.Width2, guideData.Thickness1)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, guideData.Width1 / 2, guideData.Thickness1), new Position(-lengthOffset, (guideData.Gap1 / 2) + guideData.Width2, guideData.Thickness1)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, guideData.Gap1 / 2, guideData.Thickness1), new Position(-lengthOffset, -guideData.Gap1 / 2, guideData.Thickness1)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, (-guideData.Gap1 / 2) - guideData.Width2, guideData.Thickness1), new Position(-lengthOffset, (-guideData.Gap1 / 2) - guideData.Width2, guideData.Thickness1 + guideData.Thickness2)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, (guideData.Gap1 / 2) + guideData.Width2, guideData.Thickness1), new Position(-lengthOffset, (guideData.Gap1 / 2) + guideData.Width2, guideData.Thickness1 + guideData.Thickness2)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, (-guideData.Gap1 / 2), guideData.Thickness1), new Position(-lengthOffset, (-guideData.Gap1 / 2), guideData.Thickness1 + guideData.Thickness2)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, (guideData.Gap1 / 2), guideData.Thickness1), new Position(-lengthOffset, (guideData.Gap1 / 2), guideData.Thickness1 + guideData.Thickness2)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, (-guideData.Gap1 / 2) - guideData.Width2 - topOuterOH, guideData.Thickness1 + guideData.Thickness2), new Position(-lengthOffset, (-guideData.Gap1 / 2) - guideData.Width2 - topOuterOH, guideData.Thickness1 + guideData.Thickness2 + guideData.Thickness3)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, (guideData.Gap1 / 2) + guideData.Width2 + topOuterOH, guideData.Thickness1 + guideData.Thickness2), new Position(-lengthOffset, (guideData.Gap1 / 2) + guideData.Width2 + topOuterOH, guideData.Thickness1 + guideData.Thickness2 + guideData.Thickness3)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, (-guideData.Gap1 / 2) - guideData.Width2 - topOuterOH, guideData.Thickness1 + guideData.Thickness2), new Position(-lengthOffset, (-guideData.Gap1 / 2) - guideData.Width2, guideData.Thickness1 + guideData.Thickness2)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, (guideData.Gap1 / 2) + guideData.Width2 + topOuterOH, guideData.Thickness1 + guideData.Thickness2), new Position(-lengthOffset, (guideData.Gap1 / 2) + guideData.Width2, guideData.Thickness1 + guideData.Thickness2)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, (-guideData.Gap1 / 2), guideData.Thickness1 + guideData.Thickness2), new Position(-lengthOffset, -topPlInnerOffset, guideData.Thickness1 + guideData.Thickness2)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, (guideData.Gap1 / 2), guideData.Thickness1 + guideData.Thickness2), new Position(-lengthOffset, topPlInnerOffset, guideData.Thickness1 + guideData.Thickness2)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, -topPlOuterOffset, guideData.Thickness1 + guideData.Thickness2 + guideData.Thickness3), new Position(-lengthOffset, -topPlInnerOffset, guideData.Thickness1 + guideData.Thickness2 + guideData.Thickness3)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, topPlOuterOffset, guideData.Thickness1 + guideData.Thickness2 + guideData.Thickness3), new Position(-lengthOffset, topPlInnerOffset, guideData.Thickness1 + guideData.Thickness2 + guideData.Thickness3)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, -topPlInnerOffset, guideData.Thickness1 + guideData.Thickness2), new Position(-lengthOffset, -topPlInnerOffset, guideData.Thickness1 + guideData.Thickness2 + guideData.Thickness3)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, topPlInnerOffset, guideData.Thickness1 + guideData.Thickness2), new Position(-lengthOffset, topPlInnerOffset, guideData.Thickness1 + guideData.Thickness2 + guideData.Thickness3)));

                                Vector guideVector = new Vector(guideData.Length1, 0, 0);
                                Projection3d guide = new Projection3d(new ComplexString3d(lineCollection), guideVector, guideVector.Length, true);
                                guide.Transform(matrix);
                                outputs.Add(outputName + "guide", guide);
                            }
                        }
                        else
                        {
                            horizontalSpanDiff = guideData.Width1 - (guideData.Gap1 + guideData.Width2 + guideData.Width2);
                            if (horizontalSpanDiff < 0.0000001 && horizontalSpanDiff > -0.0000001)
                            {
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, guideData.Width1 / 2, 0), new Position(-lengthOffset, -guideData.Width1 / 2, 0)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, guideData.Width1 / 2, 0), new Position(-lengthOffset, guideData.Width1 / 2, guideData.Thickness1)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, -guideData.Width1 / 2, 0), new Position(-lengthOffset, -guideData.Width1 / 2, guideData.Thickness1)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, guideData.Gap1 / 2, guideData.Thickness1), new Position(-lengthOffset, -guideData.Gap1 / 2, guideData.Thickness1)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, (-guideData.Gap1 / 2) - guideData.Width2, guideData.Thickness1), new Position(-lengthOffset, (-guideData.Gap1 / 2) - guideData.Width2, guideData.Thickness1 + guideData.Thickness2)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, (guideData.Gap1 / 2) + guideData.Width2, guideData.Thickness1), new Position(-lengthOffset, (guideData.Gap1 / 2) + guideData.Width2, guideData.Thickness1 + guideData.Thickness2)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, (-guideData.Gap1 / 2), guideData.Thickness1), new Position(-lengthOffset, (-guideData.Gap1 / 2), guideData.Thickness1 + guideData.Thickness2)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, (guideData.Gap1 / 2), guideData.Thickness1), new Position(-lengthOffset, (guideData.Gap1 / 2), guideData.Thickness1 + guideData.Thickness2)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, (-guideData.Gap1 / 2) - guideData.Width2, guideData.Thickness1 + guideData.Thickness2), new Position(-lengthOffset, (-guideData.Gap1 / 2) + guideData.Offset1 - guideData.Width3, guideData.Thickness1 + guideData.Thickness2 + guideData.Thickness3)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, (guideData.Gap1 / 2) + guideData.Width2, guideData.Thickness1 + guideData.Thickness2), new Position(-lengthOffset, (guideData.Gap1 / 2) - guideData.Offset1 + guideData.Width3, guideData.Thickness1 + guideData.Thickness2 + guideData.Thickness3)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, (-guideData.Gap1 / 2), guideData.Thickness1 + guideData.Thickness2), new Position(-lengthOffset, -topPlInnerOffset, guideData.Thickness1 + guideData.Thickness2)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, (guideData.Gap1 / 2), guideData.Thickness1 + guideData.Thickness2), new Position(-lengthOffset, topPlInnerOffset, guideData.Thickness1 + guideData.Thickness2)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, -topPlOuterOffset, guideData.Thickness1 + guideData.Thickness2 + guideData.Thickness3), new Position(-lengthOffset, -topPlInnerOffset, guideData.Thickness1 + guideData.Thickness2 + guideData.Thickness3)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, topPlOuterOffset, guideData.Thickness1 + guideData.Thickness2 + guideData.Thickness3), new Position(-lengthOffset, topPlInnerOffset, guideData.Thickness1 + guideData.Thickness2 + guideData.Thickness3)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, -topPlInnerOffset, guideData.Thickness1 + guideData.Thickness2), new Position(-lengthOffset, -topPlInnerOffset, guideData.Thickness1 + guideData.Thickness2 + guideData.Thickness3)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, topPlInnerOffset, guideData.Thickness1 + guideData.Thickness2), new Position(-lengthOffset, topPlInnerOffset, guideData.Thickness1 + guideData.Thickness2 + guideData.Thickness3)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, (-guideData.Gap1 / 2) - guideData.Width2 - guideData.Offset1, guideData.Thickness1 + guideData.Thickness2), new Position(-lengthOffset, (-guideData.Gap1 / 2) - guideData.Width2 - guideData.Offset1, guideData.Thickness1 + guideData.Thickness2 + guideData.Thickness3)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, (guideData.Gap1 / 2) + guideData.Width2 + guideData.Offset1, guideData.Thickness1 + guideData.Thickness2), new Position(-lengthOffset, (guideData.Gap1 / 2) + guideData.Width2 + guideData.Offset1, guideData.Thickness1 + guideData.Thickness2 + guideData.Thickness3)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, (-guideData.Gap1 / 2), guideData.Thickness1 + guideData.Thickness2), new Position(-lengthOffset, -topPlInnerOffset, guideData.Thickness1 + guideData.Thickness2)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, (guideData.Gap1 / 2), guideData.Thickness1 + guideData.Thickness2), new Position(-lengthOffset, topPlInnerOffset, guideData.Thickness1 + guideData.Thickness2)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, -topPlOuterOffset, guideData.Thickness1 + guideData.Thickness2 + guideData.Thickness3), new Position(-lengthOffset, -topPlInnerOffset, guideData.Thickness1 + guideData.Thickness2 + guideData.Thickness3)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, topPlOuterOffset, guideData.Thickness1 + guideData.Thickness2 + guideData.Thickness3), new Position(-lengthOffset, topPlInnerOffset, guideData.Thickness1 + guideData.Thickness2 + guideData.Thickness3)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, -topPlInnerOffset, guideData.Thickness1 + guideData.Thickness2), new Position(-lengthOffset, -topPlInnerOffset, guideData.Thickness1 + guideData.Thickness2 + guideData.Thickness3)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, topPlInnerOffset, guideData.Thickness1 + guideData.Thickness2), new Position(-lengthOffset, topPlInnerOffset, guideData.Thickness1 + guideData.Thickness2 + guideData.Thickness3)));

                                Vector guideVector = new Vector(guideData.Length1, 0, 0);
                                Projection3d guide = new Projection3d(new ComplexString3d(lineCollection), guideVector, guideVector.Length, true);
                                guide.Transform(matrix);
                                outputs.Add(outputName + "guide", guide);
                            }
                            else
                            {
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, guideData.Width1 / 2, 0), new Position(-lengthOffset, -guideData.Width1 / 2, 0)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, guideData.Width1 / 2, 0), new Position(-lengthOffset, guideData.Width1 / 2, guideData.Thickness1)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, -guideData.Width1 / 2, 0), new Position(-lengthOffset, -guideData.Width1 / 2, guideData.Thickness1)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, -guideData.Width1 / 2, guideData.Thickness1), new Position(-lengthOffset, (-guideData.Gap1 / 2) - guideData.Width2, guideData.Thickness1)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, guideData.Width1 / 2, guideData.Thickness1), new Position(-lengthOffset, (guideData.Gap1 / 2) + guideData.Width2, guideData.Thickness1)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, guideData.Gap1 / 2, guideData.Thickness1), new Position(-lengthOffset, -guideData.Gap1 / 2, guideData.Thickness1)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, (-guideData.Gap1 / 2) - guideData.Width2, guideData.Thickness1), new Position(-lengthOffset, (-guideData.Gap1 / 2) - guideData.Width2, guideData.Thickness1 + guideData.Thickness2)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, (guideData.Gap1 / 2) + guideData.Width2, guideData.Thickness1), new Position(-lengthOffset, (guideData.Gap1 / 2) + guideData.Width2, guideData.Thickness1 + guideData.Thickness2)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, (-guideData.Gap1 / 2), guideData.Thickness1), new Position(-lengthOffset, (-guideData.Gap1 / 2), guideData.Thickness1 + guideData.Thickness2)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, (guideData.Gap1 / 2), guideData.Thickness1), new Position(-lengthOffset, (guideData.Gap1 / 2), guideData.Thickness1 + guideData.Thickness2)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, (-guideData.Gap1 / 2) - guideData.Width2 - topOuterOH, guideData.Thickness1 + guideData.Thickness2), new Position(-lengthOffset, (-guideData.Gap1 / 2) - guideData.Width2 - topOuterOH, guideData.Thickness1 + guideData.Thickness2 + guideData.Thickness3)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, (guideData.Gap1 / 2) + guideData.Width2 + topOuterOH, guideData.Thickness1 + guideData.Thickness2), new Position(-lengthOffset, (guideData.Gap1 / 2) + guideData.Width2 + topOuterOH, guideData.Thickness1 + guideData.Thickness2 + guideData.Thickness3)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, (-guideData.Gap1 / 2), guideData.Thickness1 + guideData.Thickness2), new Position(-lengthOffset, -topPlInnerOffset, guideData.Thickness1 + guideData.Thickness2)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, (guideData.Gap1 / 2), guideData.Thickness1 + guideData.Thickness2), new Position(-lengthOffset, topPlInnerOffset, guideData.Thickness1 + guideData.Thickness2)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, -topPlOuterOffset, guideData.Thickness1 + guideData.Thickness2 + guideData.Thickness3), new Position(-lengthOffset, -topPlInnerOffset, guideData.Thickness1 + guideData.Thickness2 + guideData.Thickness3)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, topPlOuterOffset, guideData.Thickness1 + guideData.Thickness2 + guideData.Thickness3), new Position(-lengthOffset, topPlInnerOffset, guideData.Thickness1 + guideData.Thickness2 + guideData.Thickness3)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, -topPlInnerOffset, guideData.Thickness1 + guideData.Thickness2), new Position(-lengthOffset, -topPlInnerOffset, guideData.Thickness1 + guideData.Thickness2 + guideData.Thickness3)));
                                lineCollection.Add(new Line3d(new Position(-lengthOffset, topPlInnerOffset, guideData.Thickness1 + guideData.Thickness2), new Position(-lengthOffset, topPlInnerOffset, guideData.Thickness1 + guideData.Thickness2 + guideData.Thickness3)));

                                Vector guideVector = new Vector(guideData.Length1, 0, 0);
                                Projection3d guide = new Projection3d(new ComplexString3d(lineCollection), guideVector, guideVector.Length, true);
                                guide.Transform(matrix);
                                outputs.Add(outputName + "guide", guide);
                            }
                        }
                    }
                    else if (guideData.SolidBaseVerPl == 1)
                    {
                        horizontalSpanDiff = guideData.Width1 - (guideData.Gap1 + guideData.Width2 + guideData.Width2);
                        if (horizontalSpanDiff < 0.0000001 && horizontalSpanDiff > -0.0000001)
                        {
                            lineCollection.Add(new Line3d(new Position(-lengthOffset, guideData.Width1 / 2, 0), new Position(-lengthOffset, -guideData.Width1 / 2, 0)));
                            lineCollection.Add(new Line3d(new Position(-lengthOffset, guideData.Width1 / 2, 0), new Position(-lengthOffset, guideData.Width1 / 2, guideData.Thickness1)));
                            lineCollection.Add(new Line3d(new Position(-lengthOffset, -guideData.Width1 / 2, 0), new Position(-lengthOffset, -guideData.Width1 / 2, guideData.Thickness1)));
                            lineCollection.Add(new Line3d(new Position(-lengthOffset, guideData.Gap1 / 2, guideData.Thickness1), new Position(-lengthOffset, -guideData.Gap1 / 2, guideData.Thickness1)));
                            lineCollection.Add(new Line3d(new Position(-lengthOffset, (-guideData.Gap1 / 2) - guideData.Width2, guideData.Thickness1), new Position(-lengthOffset, (-guideData.Gap1 / 2) - guideData.Width2, guideData.Thickness1 + guideData.Thickness2)));
                            lineCollection.Add(new Line3d(new Position(-lengthOffset, (guideData.Gap1 / 2) + guideData.Width2, guideData.Thickness1), new Position(-lengthOffset, (guideData.Gap1 / 2) + guideData.Width2, guideData.Thickness1 + guideData.Thickness2)));
                            lineCollection.Add(new Line3d(new Position(-lengthOffset, (-guideData.Gap1 / 2), guideData.Thickness1), new Position(-lengthOffset, (-guideData.Gap1 / 2), guideData.Thickness1 + guideData.Thickness2)));
                            lineCollection.Add(new Line3d(new Position(-lengthOffset, (guideData.Gap1 / 2), guideData.Thickness1), new Position(-lengthOffset, (guideData.Gap1 / 2), guideData.Thickness1 + guideData.Thickness2)));
                            lineCollection.Add(new Line3d(new Position(-lengthOffset, -guideData.Gap1 / 2, guideData.Thickness1 + guideData.Thickness2), new Position(-lengthOffset, (-guideData.Gap1 / 2) - guideData.Width2, guideData.Thickness1 + guideData.Thickness2)));
                            lineCollection.Add(new Line3d(new Position(-lengthOffset, guideData.Gap1 / 2, guideData.Thickness1 + guideData.Thickness2), new Position(-lengthOffset, (guideData.Gap1 / 2) + guideData.Width2, guideData.Thickness1 + guideData.Thickness2)));

                            Vector guideVector = new Vector(guideData.Length1, 0, 0);
                            Projection3d guide = new Projection3d(new ComplexString3d(lineCollection), guideVector, guideVector.Length, true);
                            guide.Transform(matrix);
                            outputs.Add(outputName + "guide", guide);
                        }
                        else
                        {
                            lineCollection.Add(new Line3d(new Position(-lengthOffset, guideData.Width1 / 2, 0), new Position(-lengthOffset, -guideData.Width1 / 2, 0)));
                            lineCollection.Add(new Line3d(new Position(-lengthOffset, guideData.Width1 / 2, 0), new Position(-lengthOffset, guideData.Width1 / 2, guideData.Thickness1)));
                            lineCollection.Add(new Line3d(new Position(-lengthOffset, -guideData.Width1 / 2, 0), new Position(-lengthOffset, -guideData.Width1 / 2, guideData.Thickness1)));
                            lineCollection.Add(new Line3d(new Position(-lengthOffset, -guideData.Width1 / 2, guideData.Thickness1), new Position(-lengthOffset, (-guideData.Gap1 / 2) - guideData.Width2, guideData.Thickness1)));
                            lineCollection.Add(new Line3d(new Position(-lengthOffset, guideData.Width1 / 2, guideData.Thickness1), new Position(-lengthOffset, (guideData.Gap1 / 2) + guideData.Width2, guideData.Thickness1)));
                            lineCollection.Add(new Line3d(new Position(-lengthOffset, guideData.Gap1 / 2, guideData.Thickness1), new Position(-lengthOffset, -guideData.Gap1 / 2, guideData.Thickness1)));
                            lineCollection.Add(new Line3d(new Position(-lengthOffset, (-guideData.Gap1 / 2) - guideData.Width2, guideData.Thickness1), new Position(-lengthOffset, (-guideData.Gap1 / 2) - guideData.Width2, guideData.Thickness1 + guideData.Thickness2)));
                            lineCollection.Add(new Line3d(new Position(-lengthOffset, (guideData.Gap1 / 2) + guideData.Width2, guideData.Thickness1), new Position(-lengthOffset, (guideData.Gap1 / 2) + guideData.Width2, guideData.Thickness1 + guideData.Thickness2)));
                            lineCollection.Add(new Line3d(new Position(-lengthOffset, (-guideData.Gap1 / 2), guideData.Thickness1), new Position(-lengthOffset, (-guideData.Gap1 / 2), guideData.Thickness1 + guideData.Thickness2)));
                            lineCollection.Add(new Line3d(new Position(-lengthOffset, (guideData.Gap1 / 2), guideData.Thickness1), new Position(-lengthOffset, (guideData.Gap1 / 2), guideData.Thickness1 + guideData.Thickness2)));
                            lineCollection.Add(new Line3d(new Position(-lengthOffset, -guideData.Gap1 / 2, guideData.Thickness1 + guideData.Thickness2), new Position(-lengthOffset, -(guideData.Gap1 / 2) - guideData.Width2, guideData.Thickness1 + guideData.Thickness2)));
                            lineCollection.Add(new Line3d(new Position(-lengthOffset, guideData.Gap1 / 2, guideData.Thickness1 + guideData.Thickness2), new Position(-lengthOffset, (guideData.Gap1 / 2) + guideData.Width2, guideData.Thickness1 + guideData.Thickness2)));

                            Vector guideVector = new Vector(guideData.Length1, 0, 0);
                            Projection3d guide = new Projection3d(new ComplexString3d(lineCollection), guideVector, guideVector.Length, true);
                            guide.Transform(matrix);
                            outputs.Add(outputName + "guide", guide);
                        }
                    }
                } //noVsteel
                SweepOptions sweepOptions = (SweepOptions)1;
                CrossSection crossSection, crossSection1;
                if (!(noVSteel))
                {
                    if (guideData.Mirrored1 == 1)
                        mirror1 = true;
                    else
                        mirror1 = false;

                    if (guideData.Mirrored2 == 1)
                        mirror2 = true;
                    else
                        mirror2 = false;

                    //Add base plate
                    if (basePlate.thickness1 > 0.000000001)
                    {
                        plateMatrix = new Matrix4X4();
                        plateMatrix.SetIdentity();

                        plateMatrix.Translate(new Vector(-basePlate.width1 / 2, -basePlate.length1 / 2, 0));

                        AddPlate(basePlate, plateMatrix, outputs, outputName + "Bplate");

                        Projection3d projection = (Projection3d)outputs[outputName + "Bplate"];
                        projection.Transform(matrix);

                        basePlateThickness = basePlate.thickness1;
                    }
                    //LEFT SECTION
                    Line3d projectionRight = null, projectionLeft = null;
                    Collection<ISurface> crossSecSurfaces1, crossSecSurfaces2;

                    try
                    {
                        crossSection = catalogStructHelper.GetCrossSection(guideData.VerPlSecStand, guideData.VerPlSecType, guideData.VerPlSecSize);
                    }
                    catch
                    {
                        base.ToDoListMessage = new ToDoListMessage(ToDoMessageTypes.ToDoMessageError, guideData.VerPlSecSize + " " + SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrSectionNotFound, "section not found in catalog"));
                        return;
                    }


                    //set up projection line
                    if (guideData.SecConfig == 1)
                    {
                        projectionLeft = new Line3d(new Position(0, -guideData.Gap1 / 2 - (guideData.CPXoffset), basePlateThickness + (guideData.CPYoffset)), new Position(0, -guideData.Gap1 / 2 - (guideData.CPXoffset), basePlateThickness + guideData.Thickness2 + (guideData.CPYoffset)));
                    }
                    else
                    {
                        projectionLeft = new Line3d(new Position(-guideData.Length2 / 2, -guideData.Gap1 / 2 - (guideData.CPXoffset), basePlateThickness + guideData.CPYoffset), new Position(guideData.Length2 / 2, -guideData.Gap1 / 2 - (guideData.CPXoffset), basePlateThickness + guideData.CPYoffset));
                    }
                    crossSecSurfaces1 = crossSectionServices.GetProjectionSurfacesFromCrossSection(crossSection, projectionLeft, guideData.Connection1, mirror1, guideData.Angle1, sweepOptions);

                    Geometry3d csSurface1 = (Geometry3d)crossSecSurfaces1[0];
                    csSurface1.Transform(matrix);
                    outputs.Add(outputName + "Section1", csSurface1);
                    //RIGHT SECTION
                    //set up projection line

                    if (guideData.SecConfig == 1)
                    {
                        projectionRight = new Line3d(new Position(0, guideData.Gap1 / 2 + (guideData.CPXoffset), basePlateThickness + (guideData.CPYoffset)), new Position(0, guideData.Gap1 / 2 + (guideData.CPXoffset), basePlateThickness + guideData.Thickness2 + (guideData.CPYoffset)));
                    }
                    else
                    {
                        projectionRight = new Line3d(new Position(-guideData.Length2 / 2, guideData.Gap1 / 2 + (guideData.CPXoffset), basePlateThickness + (guideData.CPYoffset)), new Position(guideData.Length2 / 2, guideData.Gap1 / 2 + (guideData.CPXoffset), basePlateThickness + (guideData.CPYoffset)));
                    }
                    crossSecSurfaces2 = crossSectionServices.GetProjectionSurfacesFromCrossSection(crossSection, projectionRight, guideData.Connection2, mirror2, guideData.Angle2, sweepOptions);

                    Geometry3d csSurface2 = (Geometry3d)crossSecSurfaces2[0];
                    csSurface2.Transform(matrix);
                    outputs.Add(outputName + "Section2", csSurface2);
                }
                //HORIZONTAL steels
                Collection<ISurface> surfaces1Hor = null, surfaces2Hor = null;
                if ((guideData.HorPlSecSize) != "" && guideData.HorPlSecStand != "" && guideData.HorPlSecType != "" && guideData.HorPlSecSize != "No Value" && guideData.HorPlSecStand != "No Value" && guideData.HorPlSecType != "No Value")
                {
                    //HORIZ SECTION 1
                    try
                    {
                        crossSection1 = catalogStructHelper.GetCrossSection(guideData.HorPlSecStand, guideData.HorPlSecType, guideData.HorPlSecSize);
                    }
                    catch
                    {
                        base.ToDoListMessage = new ToDoListMessage(ToDoMessageTypes.ToDoMessageError, guideData.HorPlSecSize + " " + SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrSectionNotFound, "section not found in catalog"));
                        return;
                    }

                    projectionLeftHor = new Line3d(new Position(guideData.Offset2, -guideData.Gap1 / 2 + guideData.Offset1, basePlateThickness + guideData.Thickness2), new Position(guideData.Offset2, -guideData.Gap1 / 2 + guideData.Offset1 - guideData.Width3, basePlateThickness + guideData.Thickness2));
                    surfaces1Hor = crossSectionServices.GetProjectionSurfacesFromCrossSection(crossSection1, projectionLeftHor, guideData.Connection3, true, guideData.Angle3, sweepOptions);

                    Geometry3d csSurfacehor1 = (Geometry3d)surfaces1Hor[0];
                    csSurfacehor1.Transform(matrix);
                    outputs.Add(outputName + "Section1Hor", csSurfacehor1);

                    projectionRightHor = new Line3d(new Position(guideData.Offset2, guideData.Gap1 / 2 - guideData.Offset1 + guideData.Width3, basePlateThickness + guideData.Thickness2), new Position(guideData.Offset2, guideData.Gap1 / 2 - guideData.Offset1, basePlateThickness + guideData.Thickness2));
                    surfaces2Hor = crossSectionServices.GetProjectionSurfacesFromCrossSection(crossSection1, projectionRightHor, guideData.Connection4, true, guideData.Angle4, sweepOptions);

                    Geometry3d csSurfacehor2 = (Geometry3d)surfaces2Hor[0];
                    csSurfacehor2.Transform(matrix);
                    outputs.Add(outputName + "Section2Hor", csSurfacehor2);
                }
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddGuideMethod, "Error in AddGuide");
                }
            }
        }
        /// <summary>
        /// Create the graphical representation of multiple plates in a row.
        /// </summary>
        /// <param name="width">Width of item that we want position on-Double</param>
        /// <param name="Qty">Quantity of plates to be placed-Double</param>
        /// <param name="LocateBy">Can be 0 - Nothing, 1 - Center or 2 - Edge-Double</param>
        /// <param name="Location">distance from Locate by to position the plate-Double</param>
        /// <param name="PlateWidth">Width of the Gusset Plate-Double</param>
        /// <param name="PlateHeight">Height of the Gusset Plate-Double</param>
        /// <param name="PlateThickness">Thickness of the Gusset-Double</param>
        /// <param name="ChamferWidth">Width of the chamfer-Double</param>
        /// <param name="ChamferHeight">Height of the chamfer-Double</param>
        /// <param name="matrix">Transformation matrix for the row. (ie: rotation and translation)-Matrix4X4</param> 
        /// <param name="outputcoll">Collection of declared outputs, which is indexed by the name of the outputs declared as defining SymbolOutputs on the AspectDefinition field- OutputDictionary.</param>
        /// <param name="Output">Specifies the distance between the structure port and the RodEnd port-Double.</param>
        ///<code>
        ///Matrix4X4 matrix = new Matrix4X4();
        ///matrix.Origin = new Position(0,0,0);
        ///AddGussetsWithChamferByRow(guide.Length2, multi1Qty, multi1LocateBy, multi1Location, width5, length5, thickness5, width6, length6, matrix, m_PhysicalAspect.Outputs, "Gussets", 2);
        ///</code>
        public void AddGussetsWithChamferByRow(Double width, Double qty, Double locateBy, Double location, Double plateWidth, Double plateHeight, Double plateThickness, Double chamferWidth, Double chamferHeight, Matrix4X4 matrix, OutputDictionary outputs, String outputName, int row)
        {
            try
            {
                SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();

                double[] XLocation = new double[(int)(qty)];
                int i;

                for (i = 0; i <= qty - 1; i++)
                {
                    XLocation[i] = MultiPosition(width, qty, locateBy, location, plateThickness)[i];
                }

                PlateInputs plateShape = new PlateInputs();
                plateShape.width1 = plateWidth;
                plateShape.length1 = plateHeight;
                plateShape.thickness1 = plateThickness;
                plateShape.trCornerType = 3;
                plateShape.trCornerX = chamferWidth;
                plateShape.trCornerY = chamferHeight;
                Matrix4X4 plateMatrix = new Matrix4X4();

                for (i = 0; i <= qty - 1; i++)
                {
                    if (row % 2 == 0)
                    {
                        plateMatrix.SetIdentity();
                        plateMatrix.Rotate((Math.PI / 2), new Vector(1, 0, 0));

                        plateMatrix.Rotate(3 * (Math.PI / 2), new Vector(0, 0, 1));

                        plateMatrix.Translate(new Vector(-(-width / 2 + XLocation[i] - plateThickness / 2), 0, 0));

                        AddPlate(plateShape, plateMatrix, outputs, outputName + i + row);
                        Projection3d pro = (Projection3d)outputs[outputName + i + row];
                        pro.Transform(matrix);
                    }
                    else
                    {
                        plateMatrix.SetIdentity();
                        plateMatrix.Rotate((Math.PI / 2), new Vector(1, 0, 0));

                        plateMatrix.Rotate(3 * (Math.PI / 2), new Vector(0, 0, 1));

                        plateMatrix.Translate(new Vector(-width / 2 + XLocation[i] + plateThickness / 2, 0, 0));

                        AddPlate(plateShape, plateMatrix, outputs, outputName + i + row);
                        Projection3d pro = (Projection3d)outputs[outputName + i + row];
                        pro.Transform(matrix);
                    }

                }
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddGussetsWithChamferByRowMethod, "Error in AddGussetsWithChamferByRow");
                }
            }
        }

        /// <summary>
        ///Create the graphical representation of a Slide Plate.
        /// </summary>
        ///<param name="myShape">Structure for specifying the inputs for the Slide Plate -SlidePlateInputs </param>
        ///<param name="matrix">string to specify the position and oreintation the graphics - String.</param>
        /// <param name="outputcoll">Collection of declared outputs, which is indexed by the name of the outputs declared as defining SymbolOutputs on the AspectDefinition field- OutputDictionary</param>
        /// <param name="output">Output that this graphic is being placed on-String</param>
        ///<code>
        ///AddSlidePlate(SlidePlate, new Matrix4X4(), m_PhysicalAspect.Outputs, "SlidePlate");
        ///</code>
        public void AddSlidePlate(SlidePlateInputs myShape, Matrix4X4 matrix, OutputDictionary outputcoll, string output)
        {
            try
            {
                SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();
                symbolGeometryHelper.ActivePosition = new Position(-myShape.Width1 / 2 + myShape.XPl1, -myShape.Height1 / 2 + myShape.YPl1, myShape.ZPl1);
                symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                Projection3d slidePlate1 = (Projection3d)symbolGeometryHelper.CreateBox(null, myShape.Width1, myShape.Height1, myShape.Thickness1, 9);
                slidePlate1.Transform(matrix);
                outputcoll.Add(output + "SlidePlate1", slidePlate1);

                if (HgrCompareDoubleService.cmpdbl(myShape.Width2, 0) == false || HgrCompareDoubleService.cmpdbl(myShape.Height2, 0) == false || HgrCompareDoubleService.cmpdbl(myShape.Thickness2, 0) == false)
                {
                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(-myShape.Width2 / 2 + myShape.XPl2, -myShape.Height2 / 2 + myShape.YPl2, myShape.ZPl2);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    Projection3d slidePlate2 = (Projection3d)symbolGeometryHelper.CreateBox(null, myShape.Width2, myShape.Height2, myShape.Thickness2, 9);
                    slidePlate2.Transform(matrix);
                    outputcoll.Add(output + "SlidePlate2", slidePlate2);
                }

                if (HgrCompareDoubleService.cmpdbl(myShape.Width3, 0) == false || HgrCompareDoubleService.cmpdbl(myShape.Height3, 0) == false || HgrCompareDoubleService.cmpdbl(myShape.Thickness3, 0) == false)
                {
                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(-myShape.Width3 / 2 + myShape.XPl3, -myShape.Height3 / 2 + myShape.YPl3, myShape.ZPl3);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    Projection3d slidePlate3 = (Projection3d)symbolGeometryHelper.CreateBox(null, myShape.Width3, myShape.Height3, myShape.Thickness3, 9);
                    slidePlate3.Transform(matrix);
                    outputcoll.Add(output + "SlidePlate3", slidePlate3);
                }
                if (HgrCompareDoubleService.cmpdbl(myShape.Width4, 0) == false || HgrCompareDoubleService.cmpdbl(myShape.Height4, 0) == false || HgrCompareDoubleService.cmpdbl(myShape.Thickness4, 0) == false)
                {
                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(-myShape.Width4 / 2 + myShape.XPl4, -myShape.Height4 / 2 + myShape.YPl4, myShape.ZPl4);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    Projection3d slidePlate4 = (Projection3d)symbolGeometryHelper.CreateBox(null, myShape.Width4, myShape.Height4, myShape.Thickness4, 9);
                    slidePlate4.Transform(matrix);
                    outputcoll.Add(output + "SlidePlate4", slidePlate4);
                }
                if (HgrCompareDoubleService.cmpdbl(myShape.Width5, 0) == false || HgrCompareDoubleService.cmpdbl(myShape.Height5, 0) == false || HgrCompareDoubleService.cmpdbl(myShape.Thickness5, 0) == false)
                {
                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(-myShape.Width5 / 2 + myShape.XPl5, -myShape.Height5 / 2 + myShape.YPl5, myShape.ZPl5);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    Projection3d slidePlate5 = (Projection3d)symbolGeometryHelper.CreateBox(null, myShape.Width5, myShape.Height5, myShape.Thickness5, 9);
                    slidePlate5.Transform(matrix);
                    outputcoll.Add(output + "SlidePlate5", slidePlate5);
                }
                if (HgrCompareDoubleService.cmpdbl(myShape.Width6, 0) == false || HgrCompareDoubleService.cmpdbl(myShape.Height6, 0) == false || HgrCompareDoubleService.cmpdbl(myShape.Thickness6, 0) == false)
                {
                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(-myShape.Width6 / 2 + myShape.XPl6, -myShape.Height6 / 2 + myShape.YPl6, myShape.ZPl6);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    Projection3d slidePlate6 = (Projection3d)symbolGeometryHelper.CreateBox(null, myShape.Width6, myShape.Height6, myShape.Thickness6, 9);
                    slidePlate6.Transform(matrix);
                    outputcoll.Add(output + "SlidePlate6", slidePlate6);
                }
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddSlidePlateMethod, "Error in AddSlidePlate");
                }
            }
        }

        /// <summary>
        /// Loads the values associated to the given shape into the Guide UDT. This is done by querying the database for the given name.
        /// </summary>
        /// <param name="guideName">Name of the guide-String.</param>
        /// <returns></returns>
        ///<code>
        ///GuideInputs Guide  = LoadGuideDataByQuery(Guide.guideName);
        ///</code>
        public GuideInputs LoadGuideDataByQuery(string guideName)
        {
            GuideInputs guide = new GuideInputs() { VerPlSecSize = "No Value", VerPlSecStand = "No Value", VerPlSecType = "No Value", HorPlSecSize = "No Value", HorPlSecStand = "No Value", HorPlSecType = "No Value" };
            try
            {
                if (!(guideName == "" || guideName == "No Value"))
                {
                    Catalog plantCatalog = MiddleServiceProvider.SiteMgr.ActiveSite.ActivePlant.PlantCatalog;
                    BusinessObject guideAuxilaryTable = plantCatalog.GetNamedObject(guideName);
                    try
                    {
                        guide.Width1 = (double)((PropertyValueDouble)guideAuxilaryTable.GetPropertyValue("IJUAhsWidth1", "Width1")).PropValue;
                    }
                    catch
                    {
                        guide.Width1 = 0;
                    }
                    try
                    {
                        guide.Length1 = (double)((PropertyValueDouble)guideAuxilaryTable.GetPropertyValue("IJUAhsLength1", "Length1")).PropValue;
                    }
                    catch
                    {
                        guide.Length1 = 0;
                    }
                    if (guide.Length1 == 0)
                    {
                        RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidLength1NZero, "Length1 value can not be zero");
                        return guide;
                    }
                    try
                    {
                        guide.Thickness1 = (double)((PropertyValueDouble)guideAuxilaryTable.GetPropertyValue("IJUAhsThickness1", "Thickness1")).PropValue;
                    }
                    catch
                    {
                        guide.Thickness1 = 0;
                    }
                    try
                    {
                        guide.Width2 = (double)((PropertyValueDouble)guideAuxilaryTable.GetPropertyValue("IJUAhsWidth2", "Width2")).PropValue;
                    }
                    catch
                    {
                        guide.Width2 = 0;
                    }
                    try
                    {
                        guide.Length2 = (double)((PropertyValueDouble)guideAuxilaryTable.GetPropertyValue("IJUAhsLength2", "Length2")).PropValue;
                    }
                    catch
                    {
                        guide.Length2 = 0;
                    }

                    try
                    {
                        guide.Thickness2 = (double)((PropertyValueDouble)guideAuxilaryTable.GetPropertyValue("IJUAhsThickness2", "Thickness2")).PropValue;
                    }
                    catch
                    {
                        guide.Thickness2 = 0;
                    }
                    try
                    {

                        guide.Gap1 = (double)((PropertyValueDouble)guideAuxilaryTable.GetPropertyValue("IJUAhsGap1", "Gap1")).PropValue;
                    }
                    catch
                    {
                        guide.Gap1 = 0;
                    }
                    try
                    {
                        guide.VerPlSecStand = (string)((PropertyValueString)guideAuxilaryTable.GetPropertyValue("IJUAhsVerPlSecStand", "VerPlSecStand")).PropValue;
                    }
                    catch { guide.VerPlSecStand = "No Value"; }
                    if (guide.VerPlSecStand == null)
                    {
                        guide.VerPlSecStand = "No Value";
                    }
                    guide.VerPlSecSize = (string)((PropertyValueString)guideAuxilaryTable.GetPropertyValue("IJUAhsVerPlSecSize", "VerPlSecSize")).PropValue;
                    if (guide.VerPlSecSize == null)
                    {
                        guide.VerPlSecSize = "No Value";
                    }
                    guide.VerPlSecType = (string)((PropertyValueString)guideAuxilaryTable.GetPropertyValue("IJUAhsVerPlSecType", "VerPlSecType")).PropValue;
                    if (guide.VerPlSecType == null)
                    {
                        guide.VerPlSecType = "No Value";
                    }
                    try
                    {
                        guide.Angle1 = (double)((PropertyValueDouble)guideAuxilaryTable.GetPropertyValue("IJUAhsAngle1", "Angle1")).PropValue;
                    }
                    catch { guide.Angle1 = 0; }
                    try
                    {
                        guide.Angle2 = (double)((PropertyValueDouble)guideAuxilaryTable.GetPropertyValue("IJUAhsAngle2", "Angle2")).PropValue;
                    }
                    catch { guide.Angle2 = 0; }
                    try
                    {
                        guide.Connection1 = (int)((PropertyValueCodelist)guideAuxilaryTable.GetPropertyValue("IJUAhsConnection1", "Connection1")).PropValue;
                        if (guide.Connection1 < 1 || guide.Connection1 > 15)
                        {
                            guide.Connection1 = 1;
                        }
                    }
                    catch { guide.Connection1 = 1; } //setting the default cardinalpoint value as 5
                    try
                    {
                        guide.Connection2 = (int)((PropertyValueCodelist)guideAuxilaryTable.GetPropertyValue("IJUAhsConnection2", "Connection2")).PropValue;
                        if (guide.Connection2 < 1 || guide.Connection2 > 15)
                        {
                            guide.Connection2 = 1;
                        }
                    }
                    catch { guide.Connection2 = 1; } //setting the default cardinalpoint value as 5
                    try
                    {
                        guide.Mirrored1 = (int)((PropertyValueCodelist)guideAuxilaryTable.GetPropertyValue("IJUAhsMirrored1", "Mirrored1")).PropValue;
                        if (guide.Mirrored1 == -1)
                            guide.Mirrored1 = 1;
                        if (guide.Mirrored1 < 1 || guide.Mirrored1 > 2)
                        {
                            RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidMirrored, "Mirrored code list value should be between 1 and 2");
                        }
                    }
                    catch { guide.Mirrored1 = 0; }
                    try
                    {
                        guide.Mirrored2 = (int)((PropertyValueCodelist)guideAuxilaryTable.GetPropertyValue("IJUAhsMirrored2", "Mirrored2")).PropValue;
                        if (guide.Mirrored2 == -1)
                            guide.Mirrored2 = 1;
                        if (guide.Mirrored2 < 1 || guide.Mirrored2 > 2)
                        {
                            RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidMirrored, "Mirrored code list value should be between 1 and 2");
                        }
                    }
                    catch { guide.Mirrored2 = 0; }
                    try
                    {
                        guide.SecConfig = (int)((PropertyValueCodelist)guideAuxilaryTable.GetPropertyValue("IJUAhsSecConfig", "SecConfig")).PropValue;
                        if (guide.SecConfig < 1 || guide.SecConfig > 2)
                        {
                            RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidSecConfigCodeListValue, "SecConfig code list value should be between 1 and 2");
                        }
                    }
                    catch { guide.SecConfig = 0; }
                    try
                    {
                        guide.Width3 = (double)((PropertyValueDouble)guideAuxilaryTable.GetPropertyValue("IJUAhsWidth3", "Width3")).PropValue;
                    }
                    catch { guide.Width3 = 0; }
                    try
                    {
                        guide.Length3 = (double)((PropertyValueDouble)guideAuxilaryTable.GetPropertyValue("IJUAhsLength3", "Length3")).PropValue;
                    }
                    catch { guide.Length3 = 0; }
                    try
                    {
                        guide.Thickness3 = (double)((PropertyValueDouble)guideAuxilaryTable.GetPropertyValue("IJUAhsThickness3", "Thickness3")).PropValue;
                    }
                    catch { guide.Thickness3 = 0; }
                    try
                    {
                        guide.Offset1 = (double)((PropertyValueDouble)guideAuxilaryTable.GetPropertyValue("IJUAhsOffset1", "Offset1")).PropValue;
                    }
                    catch { guide.Offset1 = 0; }
                    try
                    {
                        guide.HorPlSecStand = (string)((PropertyValueString)guideAuxilaryTable.GetPropertyValue("IJUAhsHorPlSecStand", "HorPlSecStand")).PropValue;
                        if (guide.HorPlSecStand == null)
                        {
                            guide.HorPlSecStand = "No Value";
                        }
                    }
                    catch { guide.HorPlSecStand = "No Value"; }
                    try
                    {
                        guide.HorPlSecSize = (string)((PropertyValueString)guideAuxilaryTable.GetPropertyValue("IJUAhsHorPlSecSize", "HorPlSecSize")).PropValue;
                        if (guide.HorPlSecSize == null)
                        {
                            guide.HorPlSecSize = "No Value";
                        }
                    }
                    catch { guide.HorPlSecSize = "No Value"; }
                    try
                    {
                        guide.HorPlSecType = (string)((PropertyValueString)guideAuxilaryTable.GetPropertyValue("IJUAhsHorPlSecType", "HorPlSecType")).PropValue;

                        if (guide.HorPlSecType == null)
                        {
                            guide.HorPlSecType = "No Value";
                        }
                    }
                    catch { guide.HorPlSecType = "No Value"; }
                    try
                    {
                        guide.Angle3 = (double)((PropertyValueDouble)guideAuxilaryTable.GetPropertyValue("IJUAhsAngle3", "Angle3")).PropValue;
                    }
                    catch
                    {
                        guide.Angle3 = 0;
                    }
                    try
                    {
                        guide.Angle4 = (double)((PropertyValueDouble)guideAuxilaryTable.GetPropertyValue("IJUAhsAngle4", "Angle4")).PropValue;
                    }
                    catch
                    {
                        guide.Angle4 = 0;
                    }
                    try
                    {
                        guide.Connection3 = (int)((PropertyValueCodelist)guideAuxilaryTable.GetPropertyValue("IJUAhsConnection3", "Connection3")).PropValue;
                        if (guide.Connection3 == -1)
                            guide.Connection3 = 1;
                        if (guide.Connection3 < 1 || guide.Connection3 > 15)
                        {
                            RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidConnection, "Connection code list value should be between 1 and 15");
                        }
                    }
                    catch { guide.Connection3 = 0; }
                    try
                    {
                        guide.Connection4 = (int)((PropertyValueCodelist)guideAuxilaryTable.GetPropertyValue("IJUAhsConnection4", "Connection4")).PropValue;
                        if (guide.Connection4 == -1)
                            guide.Connection4 = 1;
                        if (guide.Connection4 < 1 || guide.Connection4 > 15)
                        {
                            RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidConnection, "Connection code list value should be between 1 and 15");
                        }
                    }
                    catch { guide.Connection4 = 0; }
                    try
                    {
                        guide.Offset2 = (int)((PropertyValueDouble)guideAuxilaryTable.GetPropertyValue("IJUAhsOffset2", "Offset2")).PropValue;
                    }
                    catch
                    {
                        guide.Offset2 = 0;
                    }
                    try
                    {
                        guide.SolidBaseVerPl = (int)((PropertyValueCodelist)guideAuxilaryTable.GetPropertyValue("IJUAhsSolidBaseVerPl", "SolidBaseVerPl")).PropValue;
                        if (guide.SolidBaseVerPl == -1)
                            guide.SolidBaseVerPl = 1;
                        if (guide.SolidBaseVerPl < 1 || guide.SolidBaseVerPl > 2)
                        {
                            RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidSolidBaseVerPl, "SolidBaseVerPl code list value should be between 1 and 2");
                        }
                    }
                    catch { return guide; }
                    try
                    {
                        guide.SolidVerHorPl = (int)((PropertyValueCodelist)guideAuxilaryTable.GetPropertyValue("IJUAhsSolidVerHorPl", "SolidVerHorPl")).PropValue;
                        if (guide.SolidVerHorPl == -1)
                            guide.SolidVerHorPl = 1;
                        if (guide.SolidVerHorPl < 1 || guide.SolidVerHorPl > 2)
                        {
                            RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidSolidVerHorPl, "SolidVerHorPl code list value should be between 1 and 2");
                        }
                    }
                    catch { return guide; }
                    try
                    {
                        guide.CPXoffset = (double)((PropertyValueDouble)guideAuxilaryTable.GetPropertyValue("IJUAhsCPXOffset", "CPXoffset")).PropValue;
                    }
                    catch
                    {
                        guide.CPXoffset = 0;
                    }
                    try
                    {
                        guide.CPYoffset = (double)((PropertyValueDouble)guideAuxilaryTable.GetPropertyValue("IJUAhsCPYOffset", "CPYoffset")).PropValue;
                    }
                    catch
                    {
                        guide.CPYoffset = 0;
                    }
                    try
                    {
                        guide.GuideHeight = (double)((PropertyValueDouble)guideAuxilaryTable.GetPropertyValue("IJUAhsGuideHeight", "GuideHeight")).PropValue;
                    }
                    catch
                    {
                        guide.GuideHeight = 0;
                    }
                }
            }
            catch (SmartPartSymbolException hgrEx)
            {
                throw hgrEx;
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadGuideDataByQuery, "Error in LoadGuideDataByQuery");
                }
            }
            return guide;
        }


        /// <summary>
        /// Create the graphical representation of the Swivel Ring shape
        /// </summary>
        /// <param name="swivel">Collection of all the values for the Swivel Ring inputs -SwivelInputs </param>
        /// <param name="matrix">string to specify the position and oreintation the graphics - String.</param>
        /// <param name="outputcoll">Collection of declared outputs, which is indexed by the name of the outputs declared as defining SymbolOutputs on the AspectDefinition field- OutputDictionary</param>
        /// <param name="output">Output that this graphic is being placed on-String</param>
        /// <code>
        /// AddSwivelRing(Swivel, rotateAngle, new Matrix4X4(), m_PhysicalAspect.Outputs, "SwivelRing");
        /// </code>
        public void AddSwivelRing(SwivelInputs swivel, Double rotationAngle, Matrix4X4 matrix, OutputDictionary outputcoll, string output)
        {
            try
            {
                //Create attributest that will be used to calculate the dimensions used to build the shape
                // The following four attributes are for angles that are needed in the calculations of the left side of the shape
                double angle1 = 0, angle2 = 0, angle3 = 0, angle4 = 0;

                //The following 5 attributes are used for the left side of the symbol
                double lowerRightY, lowerRightZ, lowerLeftY, lowerLeftZ, upperRightY;

                //The following are used on the left side of the symbol. These are used to help in figuring out Angle3
                double x, x2, tempUpperRightY;

                //The following four attibutes are for angles that are needed in the calculation of the right side of the shape
                double angleR1, angleR2 = 0, angleR3, angleR4;

                //The following will help determin the dimensions for the botom ear of the J shape swivel.
                double angleE1, angleE2, lowerEarTopY, lowerEarTopZ, lowerEarTopFarY, lowerEarTopFarZ, lowerEarBotFarY, lowerEarBotFarZ, earHypot;

                //The following will help determin the dimensions for the top ear of the J shape swivel.
                double angleTopE1, topEarBottomY, topEarBottomZ, topEarBotFarY, topEarBotFarZ, topEarTopFarY, topEarTopFarZ, topEarTopY, topEarTopZ;

                //The following 5 attributes are used for the right side of the symbol
                double lowerRightRY, lowerRightRZ, lowerLeftRY, lowerLeftRZ, upperRightY2;

                //The follwing are used on the right side of the symbol.  These are used to help in figuring out AngleR3
                double RX, RX2, tempUpperRightY2;

                //The following are used for the bolt
                double rotBoltAngle, boltBeginY, boltBeginZ, boltTempLength, boltoverhang, earHalfY, earHalfZ, boltEndY, boltEndZ, calcDia;

                //The following is to determin the cut off if the Swivel shape is an adjustable ring.
                double cutOffset = 0, zeroAngle;
                int objectCount = 0;
                String[] objectCollection = new String[objectCount];

                //Check to see if there is a value set for needed attributes
                // if there are values passed in values then continue to use these values
                // if there are not values passed in then set values to default values determined in the hs_SwivelRing.doc specification
                if (swivel.RodDiameter > -0.000001 && swivel.RodDiameter < 0.000001)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidRodDiameter, "Rod Diameter must have a value greater than zero");
                    return;
                }
                if (swivel.Width1 > -0.000001 && swivel.Width1 < 0.000001)
                    swivel.Width1 = swivel.RodDiameter * 1.5;
                if (swivel.Width2 > -0.000001 && swivel.Width2 < 0.000001)
                    swivel.Width2 = swivel.RodDiameter * 1.5;
                if (swivel.Width3 > -0.000001 && swivel.Width3 < 0.000001)
                    swivel.Width3 = swivel.RodDiameter * 2;
                if (swivel.Thickness1 > -0.000001 && swivel.Thickness1 < 0.000001)
                    swivel.Thickness1 = swivel.RodDiameter * 0.5;
                if (swivel.Height1 > -0.000001 && swivel.Height1 < 0.000001)
                    swivel.Height1 = swivel.PipeOD * 0.5;
                if (swivel.Thickness2 > 0.000001)
                {
                    if (swivel.PipeOD > swivel.Diameter1 - 0.000001)
                        calcDia = swivel.PipeOD + swivel.Thickness2 * 2;
                    else
                        calcDia = swivel.Diameter1 + swivel.Thickness2 * 2;
                }
                else
                {
                    if (swivel.PipeOD > swivel.Diameter1 - 0.000001)
                        calcDia = swivel.PipeOD;
                    else
                        calcDia = swivel.Diameter1;
                }
                if (swivel.Width4 < -0.000001)
                    swivel.Width4 = 3 * swivel.Pin1Diameter + swivel.Thickness1;
                if (swivel.Pin1Length <= 0 && swivel.Gap1 > 0)
                    swivel.Pin1Length = swivel.Gap1 + (2 * swivel.Pin1Diameter);
                if (swivel.Pin1Diameter > -0.000001 && swivel.Pin1Diameter < 0.000001 && swivel.Gap1 > 0)
                    swivel.Pin1Diameter = swivel.RodDiameter;

                x = Math.Sqrt((swivel.Width2 * swivel.Width2) + ((swivel.Height1 + (swivel.Thickness1 * 2)) * (swivel.Height1 + (swivel.Thickness1 * 2))));
                RX = Math.Sqrt((swivel.Width1 * swivel.Width1) + ((swivel.Height1 + (swivel.Thickness1)) * (swivel.Height1 + (swivel.Thickness1))));

                //Calculations for the left side of the symbol
                angle1 = Math.Asin(swivel.Width2 / x) * 180 / Math.PI;

                if ((((calcDia / 2) + swivel.Thickness1) / x) > 1 - 0.01 || (((calcDia / 2) + swivel.Thickness1) / x) < -1 + 0.01)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidWidth1AndWidht2, "Please check values for Width1 and Width2");
                    return;
                }
                else
                {
                    angle2 = Math.Acos(((calcDia / 2) + swivel.Thickness1) / x) * 180 / Math.PI;
                }
                angle3 = 90 - angle1 - angle2;

                //Set the values for the dimensions of the left side
                lowerRightZ = Math.Sin(angle3 * Math.PI / 180) * (calcDia / 2);
                lowerRightY = Math.Cos(angle3 * Math.PI / 180) * (calcDia / 2);
                lowerLeftZ = Math.Sin(angle3 * Math.PI / 180) * ((calcDia / 2) + swivel.Thickness1);
                lowerLeftY = Math.Cos(angle3 * Math.PI / 180) * ((calcDia / 2) + swivel.Thickness1);

                //Calculations for the Right side of the symbol
                angleR1 = Math.Asin(swivel.Width1 / RX) * 180 / Math.PI;

                if ((((calcDia / 2) + swivel.Thickness1) / RX) > 1 - 0.01 || (((calcDia / 2) + swivel.Thickness1) / RX) < -1 + 0.01)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidWidth1AndWidht2, "Please check values for Width1 and Width2");
                    return;
                }
                else
                {
                    angleR2 = Math.Acos(((calcDia / 2) + swivel.Thickness1) / RX) * 180 / Math.PI;
                }

                angleR3 = 90 - angleR1 - angleR2;

                //Set the values for the dimensions of the right side
                lowerRightRZ = Math.Sin(angleR3 * Math.PI / 180) * (calcDia / 2);
                lowerRightRY = Math.Cos(angleR3 * Math.PI / 180) * (calcDia / 2);
                lowerLeftRZ = Math.Sin(angleR3 * Math.PI / 180) * ((calcDia / 2) + swivel.Thickness1);
                lowerLeftRY = Math.Cos(angleR3 * Math.PI / 180) * ((calcDia / 2) + swivel.Thickness1);

                x2 = lowerLeftY - swivel.Width2;
                RX2 = lowerLeftRY - swivel.Width1;

                angle4 = Math.Atan((x2 / (swivel.Height1 + (swivel.Thickness1 * 2)))) * 180 / Math.PI;
                tempUpperRightY = Math.Tan(angle4 * Math.PI / 180) * (swivel.Height1 + swivel.Thickness1);

                angleR4 = Math.Atan((RX2 / (swivel.Height1 + (swivel.Thickness1)))) * 180 / Math.PI;
                tempUpperRightY2 = Math.Tan(angleR4 * Math.PI / 180) * (swivel.Height1);

                upperRightY = (lowerRightY - tempUpperRightY);
                upperRightY2 = (lowerRightRY - tempUpperRightY2);

                //The following will determin the points for the lower ear on a J shape swivel.
                angleE1 = Math.Atan(swivel.Thickness1 / (calcDia / 2)) * 180 / Math.PI;
                angleE2 = angleR3 + angleE1;

                earHypot = swivel.Thickness1 / Math.Sin(angleE1 * Math.PI / 180);

                lowerEarTopZ = Math.Sin(angleE2 * Math.PI / 180) * earHypot;
                lowerEarTopY = Math.Cos(angleE2 * Math.PI / 180) * earHypot;

                lowerEarTopFarY = Math.Cos(angleR3 * Math.PI / 180) * (swivel.Width4 * 1.5);
                lowerEarTopFarZ = Math.Sin(angleR3 * Math.PI / 180) * (swivel.Width4 * 1.5);

                lowerEarBotFarY = lowerLeftRY + (Math.Cos(angleR3 * Math.PI / 180) * ((swivel.Width4 * 1.5) - swivel.Thickness1));
                lowerEarBotFarZ = lowerLeftRZ + (Math.Sin(angleR3 * Math.PI / 180) * ((swivel.Width4 * 1.5) - swivel.Thickness1));

                //The following will determin the points for the top ear on the J shape swivel.
                angleTopE1 = Math.Atan((swivel.Height1 - lowerRightRZ) / (lowerRightRY - upperRightY2)) * 180 / Math.PI;
                topEarBottomZ = Math.Sin(angleTopE1 * Math.PI / 180) * swivel.Gap1;
                topEarBottomY = Math.Cos(angleTopE1 * Math.PI / 180) * swivel.Gap1;

                topEarBotFarY = lowerEarTopY - topEarBottomY + (Math.Cos(angleR3 * Math.PI / 180) * swivel.Width4);
                topEarBotFarZ = lowerEarTopZ + topEarBottomZ + (Math.Sin(angleR3 * Math.PI / 180) * swivel.Width4);

                topEarTopFarY = topEarBotFarY - (Math.Cos(angleTopE1 * Math.PI / 180) * swivel.Thickness1);
                topEarTopFarZ = topEarBotFarZ + (Math.Sin(angleTopE1 * Math.PI / 180) * swivel.Thickness1);

                topEarTopY = topEarTopFarY - ((swivel.Width4 - swivel.Thickness1) * Math.Cos(angleR3 * Math.PI / 180));
                topEarTopZ = topEarTopFarZ - ((swivel.Width4 - swivel.Thickness1) * Math.Sin(angleR3 * Math.PI / 180));

                if (swivel.Width1 < (0.5 * swivel.RodDiameter) && swivel.Width2 < (0.5 * swivel.RodDiameter))
                {
                    zeroAngle = Math.Acos((((calcDia / 2) - (0.5 * swivel.RodDiameter)) + swivel.Thickness1) / swivel.Height1) * 180 / Math.PI;
                    cutOffset = swivel.Thickness1 / (Math.Sin(Math.PI / 2 - zeroAngle * Math.PI / 180));
                }

                Collection<ICurve> curveCollection = new Collection<ICurve>();
                SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();
                Matrix4X4 Matrix = new Matrix4X4();

                if (swivel.Gap1 > 0.000001)
                {
                    // Build left side of shape
                    swivel.Height1 = swivel.Height1 - swivel.Thickness1;
                    curveCollection.Add(new Line3d(new Position(-swivel.Width3 / 2, -lowerRightY, lowerRightZ), new Position(-swivel.Width3 / 2, -upperRightY, swivel.Height1 + swivel.Thickness1)));
                    curveCollection.Add(new Line3d(new Position(-swivel.Width3 / 2, -upperRightY, swivel.Height1 + swivel.Thickness1), new Position(-swivel.Width3 / 2, upperRightY2, swivel.Height1 + swivel.Thickness1)));
                    curveCollection.Add(new Line3d(new Position(-swivel.Width3 / 2, upperRightY2, swivel.Height1 + swivel.Thickness1), new Position(-swivel.Width3 / 2, lowerEarTopY - topEarBottomY, lowerEarTopZ + topEarBottomZ)));
                    curveCollection.Add(new Line3d(new Position(-swivel.Width3 / 2, lowerEarTopY - topEarBottomY, lowerEarTopZ + topEarBottomZ), new Position(-swivel.Width3 / 2, topEarBotFarY, topEarBotFarZ)));
                    curveCollection.Add(new Line3d(new Position(-swivel.Width3 / 2, topEarBotFarY, topEarBotFarZ), new Position(-swivel.Width3 / 2, topEarTopFarY, topEarTopFarZ)));
                    curveCollection.Add(new Line3d(new Position(-swivel.Width3 / 2, topEarTopFarY, topEarTopFarZ), new Position(-swivel.Width3 / 2, topEarTopY, topEarTopZ)));
                    curveCollection.Add(new Line3d(new Position(-swivel.Width3 / 2, topEarTopY, topEarTopZ), new Position(-swivel.Width3 / 2, swivel.Width1, swivel.Height1 + (swivel.Thickness1 * 2))));
                    curveCollection.Add(new Line3d(new Position(-swivel.Width3 / 2, swivel.Width1, swivel.Height1 + (swivel.Thickness1 * 2)), new Position(-swivel.Width3 / 2, -swivel.Width2, swivel.Height1 + (swivel.Thickness1 * 2))));
                    curveCollection.Add(new Line3d(new Position(-swivel.Width3 / 2, -swivel.Width2, swivel.Height1 + (swivel.Thickness1 * 2)), new Position(-swivel.Width3 / 2, -lowerLeftY, lowerLeftZ)));

                    //Arc to get to the right side of the shape
                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    Matrix.SetIdentity();
                    Matrix.Rotate(-Math.PI / 2 - angleR3 * Math.PI / 180, new Vector(0, 0, 1));
                    Arc3d arc = symbolGeometryHelper.CreateArc(null, calcDia / 2, Math.PI + (angle3 + angleR3) * Math.PI / 180);
                    arc.Transform(Matrix);

                    Matrix = new Matrix4X4();
                    Matrix.SetIdentity();
                    Matrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                    arc.Transform(Matrix);

                    Matrix = new Matrix4X4();
                    Matrix.SetIdentity();
                    Matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                    arc.Transform(Matrix);

                    Matrix = new Matrix4X4();
                    Matrix.SetIdentity();
                    Matrix.Translate(new Vector(-swivel.Width3 / 2, 0, 0));
                    arc.Transform(Matrix);
                    curveCollection.Add(arc);

                    //Build right side of shape
                    curveCollection.Add(new Line3d(new Position(-swivel.Width3 / 2, lowerRightRY, lowerRightRZ), new Position(-swivel.Width3 / 2, lowerEarTopY, lowerEarTopZ)));
                    curveCollection.Add(new Line3d(new Position(-swivel.Width3 / 2, lowerEarTopY, lowerEarTopZ), new Position(-swivel.Width3 / 2, lowerEarTopY + lowerEarTopFarY, lowerEarTopZ + lowerEarTopFarZ)));
                    curveCollection.Add(new Line3d(new Position(-swivel.Width3 / 2, lowerEarTopY + lowerEarTopFarY, lowerEarTopZ + lowerEarTopFarZ), new Position(-swivel.Width3 / 2, lowerEarBotFarY, lowerEarBotFarZ)));
                    curveCollection.Add(new Line3d(new Position(-swivel.Width3 / 2, lowerEarBotFarY, lowerEarBotFarZ), new Position(-swivel.Width3 / 2, lowerLeftRY, lowerLeftRZ)));
                    //arc
                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    Matrix.SetIdentity();
                    Matrix.Rotate(-Math.PI / 2 - angleR3 * Math.PI / 180, new Vector(0, 0, 1));
                    Arc3d arc1 = symbolGeometryHelper.CreateArc(null, calcDia / 2 + swivel.Thickness1, Math.PI + (angle3 + angleR3) * Math.PI / 180);
                    arc1.Transform(Matrix);

                    Matrix = new Matrix4X4();
                    Matrix.SetIdentity();
                    Matrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                    arc1.Transform(Matrix);

                    Matrix = new Matrix4X4();
                    Matrix.SetIdentity();
                    Matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                    arc1.Transform(Matrix);

                    Matrix = new Matrix4X4();
                    Matrix.SetIdentity();
                    Matrix.Translate(new Vector(-swivel.Width3 / 2, 0, 0));
                    arc1.Transform(Matrix);
                    curveCollection.Add(arc1);

                    Vector lineVector = new Vector(swivel.Width3, 0, 0);
                    Projection3d swivelRing = new Projection3d(new ComplexString3d(curveCollection), lineVector, lineVector.Length, true);
                    swivelRing.Transform(matrix);
                    outputcoll.Add(output + "Swivel", swivelRing);
                    objectCount = objectCount + 1;
                    Array.Resize(ref objectCollection, objectCount);
                    objectCollection[objectCount - 1] = output + "Swivel";
                }
                else
                {
                    if (swivel.Width1 < (0.5 * swivel.RodDiameter) && swivel.Width2 < (0.5 * swivel.RodDiameter))
                    {
                        curveCollection = new Collection<ICurve>();
                        //Build left side of shape
                        curveCollection.Add(new Line3d(new Position(-swivel.Width3 / 2, -lowerLeftY, lowerLeftZ), new Position(-swivel.Width3 / 2, -swivel.RodDiameter / 2, swivel.Height1 + cutOffset)));
                        curveCollection.Add(new Line3d(new Position(-swivel.Width3 / 2, -swivel.RodDiameter / 2, swivel.Height1 + cutOffset), new Position(-swivel.Width3 / 2, -swivel.RodDiameter / 2, swivel.Height1)));
                        curveCollection.Add(new Line3d(new Position(-swivel.Width3 / 2, -swivel.RodDiameter / 2, swivel.Height1), new Position(-swivel.Width3 / 2, -lowerRightY, lowerRightZ)));

                        //Arc to get to the right side of the shape
                        symbolGeometryHelper = new SymbolGeometryHelper();
                        symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                        symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        Matrix.SetIdentity();
                        Matrix.Rotate(-Math.PI / 2 - angleR3 * Math.PI / 180, new Vector(0, 0, 1));
                        Arc3d arc = symbolGeometryHelper.CreateArc(null, calcDia / 2, Math.PI + (angle3 + angleR3) * Math.PI / 180);
                        arc.Transform(Matrix);

                        Matrix = new Matrix4X4();
                        Matrix.SetIdentity();
                        Matrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                        arc.Transform(Matrix);

                        Matrix = new Matrix4X4();
                        Matrix.SetIdentity();
                        Matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                        arc.Transform(Matrix);

                        Matrix = new Matrix4X4();
                        Matrix.SetIdentity();
                        Matrix.Translate(new Vector(-swivel.Width3 / 2, 0, 0));
                        arc.Transform(Matrix);
                        curveCollection.Add(arc);

                        //Build right side of shape
                        curveCollection.Add(new Line3d(new Position(-swivel.Width3 / 2, lowerRightRY, lowerRightRZ), new Position(-swivel.Width3 / 2, swivel.RodDiameter / 2, swivel.Height1)));
                        curveCollection.Add(new Line3d(new Position(-swivel.Width3 / 2, swivel.RodDiameter / 2, swivel.Height1), new Position(-swivel.Width3 / 2, swivel.RodDiameter / 2, swivel.Height1 + cutOffset)));
                        curveCollection.Add(new Line3d(new Position(-swivel.Width3 / 2, swivel.RodDiameter / 2, swivel.Height1 + cutOffset), new Position(-swivel.Width3 / 2, lowerLeftRY, lowerLeftRZ)));

                        //arc
                        symbolGeometryHelper = new SymbolGeometryHelper();
                        symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                        symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        Matrix.SetIdentity();
                        Matrix.Rotate(-Math.PI / 2 - angleR3 * Math.PI / 180, new Vector(0, 0, 1));
                        Arc3d arc1 = symbolGeometryHelper.CreateArc(null, calcDia / 2 + swivel.Thickness1, Math.PI + (angle3 + angleR3) * Math.PI / 180);
                        arc1.Transform(Matrix);

                        Matrix = new Matrix4X4();
                        Matrix.SetIdentity();
                        Matrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                        arc1.Transform(Matrix);

                        Matrix = new Matrix4X4();
                        Matrix.SetIdentity();
                        Matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                        arc1.Transform(Matrix);

                        Matrix = new Matrix4X4();
                        Matrix.SetIdentity();
                        Matrix.Translate(new Vector(-swivel.Width3 / 2, 0, 0));
                        arc1.Transform(Matrix);
                        curveCollection.Add(arc1);

                        Vector lineVector = new Vector(swivel.Width3, 0, 0);
                        Projection3d swivelRing = new Projection3d(new ComplexString3d(curveCollection), lineVector, lineVector.Length, true);
                        swivelRing.Transform(matrix);
                        outputcoll.Add(output + "Swivel", swivelRing);
                        objectCount = objectCount + 1;
                        Array.Resize(ref objectCollection, objectCount);
                        objectCollection[objectCount - 1] = output + "Swivel";
                    }
                    else
                    {
                        Double dWidth1Extra = Math.Abs(swivel.Width2 - ((swivel.Width2 - swivel.Thickness1) / 2));
                        Double dWidth2Extra = Math.Abs(swivel.Width1 - ((swivel.Width1 - swivel.Thickness1) / 2));

                        //Build left side of shape
                        curveCollection.Add(new Line3d(new Position(-swivel.Width3 / 2, -lowerRightY, lowerRightZ), new Position(-swivel.Width3 / 2, -upperRightY, swivel.Height1 + swivel.Thickness1)));
                        curveCollection.Add(new Line3d(new Position(-swivel.Width3 / 2, -upperRightY, swivel.Height1 + swivel.Thickness1), new Position(-swivel.Width3 / 2, dWidth2Extra, swivel.Height1 + swivel.Thickness1)));
                        curveCollection.Add(new Line3d(new Position(-swivel.Width3 / 2, dWidth2Extra, swivel.Height1 + swivel.Thickness1), new Position(-swivel.Width3 / 2, dWidth2Extra, swivel.Height1 + (swivel.Thickness1 * 2))));
                        curveCollection.Add(new Line3d(new Position(-swivel.Width3 / 2, dWidth2Extra, swivel.Height1 + (swivel.Thickness1 * 2)), new Position(-swivel.Width3 / 2, -swivel.Width2, swivel.Height1 + (swivel.Thickness1 * 2))));
                        curveCollection.Add(new Line3d(new Position(-swivel.Width3 / 2, -swivel.Width2, swivel.Height1 + (swivel.Thickness1 * 2)), new Position(-swivel.Width3 / 2, -lowerLeftY, lowerLeftZ)));
                        //Arc to get to the right side of the shape
                        symbolGeometryHelper = new SymbolGeometryHelper();
                        symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                        symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        Matrix.SetIdentity();
                        Matrix.Rotate(-Math.PI / 2 - angleR3 * Math.PI / 180, new Vector(0, 0, 1));
                        Arc3d arc = symbolGeometryHelper.CreateArc(null, calcDia / 2, Math.PI + (angle3 + angleR3) * Math.PI / 180);
                        arc.Transform(Matrix);

                        Matrix = new Matrix4X4();
                        Matrix.SetIdentity();
                        Matrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                        arc.Transform(Matrix);

                        Matrix = new Matrix4X4();
                        Matrix.SetIdentity();
                        Matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                        arc.Transform(Matrix);

                        Matrix = new Matrix4X4();
                        Matrix.SetIdentity();
                        Matrix.Translate(new Vector(-swivel.Width3 / 2, 0, 0));
                        arc.Transform(Matrix);
                        curveCollection.Add(arc);
                        //Build right side of shape
                        curveCollection.Add(new Line3d(new Position(-swivel.Width3 / 2, lowerRightRY, lowerRightRZ), new Position(-swivel.Width3 / 2, upperRightY2, swivel.Height1)));
                        curveCollection.Add(new Line3d(new Position(-swivel.Width3 / 2, upperRightY2, swivel.Height1), new Position(-swivel.Width3 / 2, -dWidth1Extra, swivel.Height1)));
                        curveCollection.Add(new Line3d(new Position(-swivel.Width3 / 2, -dWidth1Extra, swivel.Height1), new Position(-swivel.Width3 / 2, -dWidth1Extra, swivel.Height1 + swivel.Thickness1 - 0.000001)));
                        curveCollection.Add(new Line3d(new Position(-swivel.Width3 / 2, -dWidth1Extra, swivel.Height1 + swivel.Thickness1 - 0.000001), new Position(-swivel.Width3 / 2, swivel.Width1, swivel.Height1 + swivel.Thickness1 - 0.000001)));
                        curveCollection.Add(new Line3d(new Position(-swivel.Width3 / 2, swivel.Width1, swivel.Height1 + swivel.Thickness1 - 0.000001), new Position(-swivel.Width3 / 2, lowerLeftRY, lowerLeftRZ)));
                        //arc
                        symbolGeometryHelper = new SymbolGeometryHelper();
                        symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                        symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        Matrix.SetIdentity();
                        Matrix.Rotate(-Math.PI / 2 - angleR3 * Math.PI / 180, new Vector(0, 0, 1));
                        Arc3d arc1 = symbolGeometryHelper.CreateArc(null, calcDia / 2 + swivel.Thickness1, Math.PI + (angle3 + angleR3) * Math.PI / 180);
                        arc1.Transform(Matrix);

                        Matrix = new Matrix4X4();
                        Matrix.SetIdentity();
                        Matrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                        arc1.Transform(Matrix);

                        Matrix = new Matrix4X4();
                        Matrix.SetIdentity();
                        Matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                        arc1.Transform(Matrix);

                        Matrix = new Matrix4X4();
                        Matrix.SetIdentity();
                        Matrix.Translate(new Vector(-swivel.Width3 / 2, 0, 0));
                        arc1.Transform(Matrix);
                        curveCollection.Add(arc1);

                        Vector lineVector = new Vector(swivel.Width3, 0, 0);
                        Projection3d swivelRing = new Projection3d(new ComplexString3d(curveCollection), lineVector, lineVector.Length, true);
                        swivelRing.Transform(matrix);
                        outputcoll.Add(output + "Swivel", swivelRing);
                        objectCount = objectCount + 1;
                        Array.Resize(ref objectCollection, objectCount);
                        objectCollection[objectCount - 1] = output + "Swivel";
                    }
                }

                //If this is a J shape swivel ring then add the bolt.
                if (swivel.Gap1 > 0.000001)    // 0.9999999 instead of 0 for some tolerance
                {
                    if (swivel.Thickness2 > 0)
                    {
                        RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidWrapOnJHangers, "You cannot place wrap on J Hangers");
                    }
                    rotBoltAngle = 90 - angleTopE1;
                    earHalfY = Math.Cos(angleR3 * Math.PI / 180) * ((swivel.Width4 * 1.5) / 2);
                    earHalfZ = Math.Sin(angleR3 * Math.PI / 180) * ((swivel.Width4 * 1.5) / 2);

                    boltTempLength = swivel.Pin1Length - swivel.Gap1;
                    boltoverhang = (boltTempLength / 2);

                    boltBeginY = lowerEarTopY + earHalfY + (Math.Cos(angleTopE1 * Math.PI / 180) * boltoverhang);
                    boltBeginZ = lowerEarTopZ + earHalfZ - (Math.Sin(angleTopE1 * Math.PI / 180) * boltoverhang);

                    boltEndY = boltBeginY - (Math.Cos(angleTopE1 * Math.PI / 180) * swivel.Pin1Length);
                    boltEndZ = boltBeginZ + (Math.Sin(angleTopE1 * Math.PI / 180) * swivel.Pin1Length);

                    Vector normal = new Position(0, boltEndY, boltEndZ).Subtract(new Position(0, boltBeginY, boltBeginZ));
                    Vector orthogonal = normal.GetOrthogonalVector();
                    symbolGeometryHelper.ActivePosition = new Position(0, boltBeginY, boltBeginZ);
                    symbolGeometryHelper.SetOrientation(normal, orthogonal);
                    Projection3d cylinder = symbolGeometryHelper.CreateCylinder(null, swivel.Pin1Diameter / 2, normal.Length);
                    cylinder.Transform(matrix);
                    outputcoll.Add(output + "Rod", cylinder);
                    objectCount = objectCount + 1;
                    Array.Resize(ref objectCollection, objectCount);
                    objectCollection[objectCount - 1] = output + "Rod";
                }
                //Check to see if we need to add the Liner
                if (swivel.Thickness2 > 0.000001)
                {
                    //If there is a value entered into Thickness two then we will have to add liner.
                    // The following line of code will add the liner to any swivel but the JHanger
                    AddSwivelLiner(swivel, outputcoll, output + "Liner");
                    Projection3d projection = (Projection3d)outputcoll[output + "Liner"];
                    projection.Transform(matrix);
                    objectCount = objectCount + 1;
                    Array.Resize(ref objectCollection, objectCount);
                    objectCollection[objectCount - 1] = output + "Liner";
                }

                if (swivel.Height2 > -0.000001 && swivel.Height2 < 0.000001 && swivel.Diameter2 < -0.000001 && swivel.Diameter2 > 0.000001)
                {
                    swivel.Height2 = 2 * swivel.RodDiameter;
                }

                if (swivel.Height2 > 0.000001)
                {
                    if (swivel.Diameter2 < 0.000001)
                    {
                        swivel.Diameter2 = swivel.RodDiameter * 1.25;
                    }

                    //This will add the top shape to the swivel ring if it is needed (Height2 greater then 0)
                    NutInputs nut = new NutInputs();
                    nut.ShapeType = 1;
                    nut.ShapeWidth1 = swivel.Diameter2;
                    nut.ShapeWidth2 = swivel.Diameter2;
                    nut.ShapeLength = swivel.Height2;

                    Matrix = new Matrix4X4();
                    Matrix.SetIdentity();
                    Matrix.Translate(new Vector(0, 0, swivel.RodTakeOut));
                    AddNut(nut, Matrix, outputcoll, output + "TopShape");
                    Projection3d projection = (Projection3d)outputcoll[output + "TopShape"];
                    projection.Transform(matrix);
                    objectCount = objectCount + 1;
                    Array.Resize(ref objectCollection, objectCount);
                    objectCollection[objectCount - 1] = output + "TopShape";
                }

                //If there is a rotation angle then we will want to rotate the shape.
                if (HgrCompareDoubleService.cmpdbl(rotationAngle, 0) == false)
                {
                    rotationAngle = Math.Atan(((swivel.Height1 + (swivel.Thickness1 * 2)) - lowerLeftZ) / (swivel.Width2 - lowerLeftY)) * 180 / Math.PI;
                    Matrix4X4 rotateMatrix = new Matrix4X4();
                    rotateMatrix.Rotate((90 + rotationAngle) * Math.PI / 180, new Vector(1, 0, 0));
                    for (int i = 0; i < objectCollection.Length; i++)
                    {
                        if (objectCollection[i] != null)
                        {
                            Geometry3d transformObject = (Geometry3d)outputcoll[objectCollection[i]];
                            transformObject.Transform(rotateMatrix);
                        }
                    }
                }
            }
            catch (SmartPartSymbolException hgrEx)
            {
                throw hgrEx;
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddSwivelRingMethod, "Error in AddSwivelRing");
                }

            }
        }

        /// <summary>
        /// Create the graphical representation of the Swivel Ring Liner shape
        /// </summary>
        /// <param name="swivel">Collection of all the values for the Swivel Ring inputs -SwivelInputs </param>
        /// <param name="outputcoll">Collection of declared outputs, which is indexed by the name of the outputs declared as defining SymbolOutputs on the AspectDefinition field- OutputDictionary</param>
        /// <param name="output">Output that this graphic is being placed on-String</param>
        /// <code>
        /// AddSwivelLiner(swivel, outputcoll, output + "Liner");
        /// </code>
        public void AddSwivelLiner(SwivelInputs swivel, OutputDictionary outputcoll, string output)
        {
            try
            {
                double lineX, lineXRight, angle1, angle2, angle3, angle4, angle1Right, angle2Right, angle3Right, middleBotY, middleBotZ, middleBotYRight, middleBotZRight;
                double radiusY, radiusZ, farRingY, farRingZ, outerBotY, outerBotZ, radiusYRight, radiusZRight;
                double farRingYRight, farRingZRight, outerBotYRight, outerBotZRight, calcHeight, calcDia, calcWidth1, calcWidth2, zeroAngle, cutOffset = 0;

                SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();
                if (swivel.PipeOD > swivel.Diameter1 - 0.000001)
                {
                    calcDia = swivel.PipeOD;
                }
                else
                {
                    calcDia = swivel.Diameter1;
                }

                if (swivel.Width1 < (0.5 * swivel.RodDiameter) && swivel.Width2 < (0.5 * swivel.RodDiameter))
                {
                    zeroAngle = Math.Acos((((calcDia / 2) - (0.5 * swivel.RodDiameter)) + swivel.Thickness1) / swivel.Height1) * 180 / Math.PI;
                    cutOffset = swivel.Thickness1 / (Math.Sin(Math.PI / 2 - zeroAngle * Math.PI / 180));
                }

                if (swivel.Gap1 > 0.000001)
                    calcHeight = swivel.Height1 + swivel.Thickness1;
                else if (swivel.Width1 < (0.5 * swivel.RodDiameter) && swivel.Width2 < (0.5 * swivel.RodDiameter))
                    calcHeight = swivel.Height1 + cutOffset;    // + Swivel.Thickness1;
                else
                    calcHeight = swivel.Height1 + (2 * swivel.Thickness1);

                if (swivel.Width1 < (0.5 * swivel.RodDiameter) && swivel.Width2 < (0.5 * swivel.RodDiameter))
                {
                    calcWidth1 = swivel.RodDiameter / 2;
                    calcWidth2 = swivel.RodDiameter / 2;
                }
                else
                {
                    calcWidth1 = swivel.Width1;
                    calcWidth2 = swivel.Width2;
                }

                // Calculations for the left side
                lineX = Math.Sqrt((calcWidth1 * calcWidth1) + (calcHeight * calcHeight));
                angle1 = Math.Asin(calcWidth1 / lineX) * 180 / Math.PI;
                angle2 = Math.Acos((calcDia / 2 + swivel.Thickness1 + swivel.Thickness2) / lineX) * 180 / Math.PI;
                angle3 = 90 - angle1 - angle2;
                angle4 = 90 - angle3;

                radiusY = Math.Cos(angle3 * Math.PI / 180) * (calcDia / 2);
                radiusZ = Math.Sin(angle3 * Math.PI / 180) * (calcDia / 2);

                middleBotY = Math.Cos(angle3 * Math.PI / 180) * ((calcDia / 2) + swivel.Thickness2 + swivel.Thickness1 / 2);
                middleBotZ = Math.Sin(angle3 * Math.PI / 180) * ((calcDia / 2) + swivel.Thickness2 + swivel.Thickness1 / 2);

                outerBotY = Math.Cos(angle3 * Math.PI / 180) * ((calcDia / 2) + (2 * swivel.Thickness2) + swivel.Thickness1);
                outerBotZ = Math.Sin(angle3 * Math.PI / 180) * ((calcDia / 2) + (2 * swivel.Thickness2) + swivel.Thickness1);

                farRingY = Math.Cos(angle3 * Math.PI / 180) * ((calcDia / 2) + swivel.Thickness2 + swivel.Thickness1);
                farRingZ = Math.Sin(angle3 * Math.PI / 180) * ((calcDia / 2) + swivel.Thickness2 + swivel.Thickness1);

                //Calculations for the right side
                lineXRight = Math.Sqrt((calcWidth2 * calcWidth2) + (calcHeight * calcHeight));
                angle1Right = Math.Asin(calcWidth2 / lineXRight) * 180 / Math.PI;
                angle2Right = Math.Acos((calcDia / 2 + swivel.Thickness1 + swivel.Thickness2) / lineXRight) * 180 / Math.PI;
                angle3Right = 90 - angle1Right - angle2Right;

                radiusYRight = Math.Cos(angle3Right * Math.PI / 180) * (calcDia / 2);
                radiusZRight = Math.Sin(angle3Right * Math.PI / 180) * (calcDia / 2);

                middleBotYRight = Math.Cos(angle3Right * Math.PI / 180) * ((calcDia / 2) + swivel.Thickness2 + swivel.Thickness1 / 2);
                middleBotZRight = Math.Sin(angle3Right * Math.PI / 180) * ((calcDia / 2) + swivel.Thickness2 + swivel.Thickness1 / 2);

                outerBotYRight = Math.Cos(angle3Right * Math.PI / 180) * ((calcDia / 2) + (2 * swivel.Thickness2) + swivel.Thickness1);
                outerBotZRight = Math.Sin(angle3Right * Math.PI / 180) * ((calcDia / 2) + (2 * swivel.Thickness2) + swivel.Thickness1);

                farRingYRight = Math.Cos(angle3Right * Math.PI / 180) * ((calcDia / 2) + swivel.Thickness2 * 1.25 + swivel.Thickness1);
                farRingZRight = Math.Sin(angle3Right * Math.PI / 180) * ((calcDia / 2) + swivel.Thickness2 * 1.25 + swivel.Thickness1);

                double dVertAngle, dTopVertOffset = 0, dTopHorzOffset = 0, dVertAngleRight, dTopVertOffsetRight = 0, dTopHorzOffsetRight = 0;

                if (middleBotZ < calcDia / 2)
                {
                    // Calculations for the right side
                    dVertAngle = Math.Atan((calcHeight - farRingZ) / (farRingY - calcWidth1)) * 180 / Math.PI;
                    dTopVertOffset = calcDia / 2 - middleBotZ;

                    dTopHorzOffset = dTopVertOffset / Math.Tan(dVertAngle * Math.PI / 180);

                    // Calculations for the left side
                    dVertAngleRight = Math.Atan((calcHeight - farRingZRight) / (farRingYRight - calcWidth2)) * 180 / Math.PI;
                    dTopVertOffsetRight = calcDia / 2 - middleBotZRight;
                    dTopHorzOffsetRight = (dTopVertOffsetRight / Math.Tan(dVertAngleRight * Math.PI / 180));
                }
                Matrix4X4 Matrix = new Matrix4X4();
                Collection<ICurve> curveCollection = new Collection<ICurve>();

                //Create liner shape
                if (middleBotZ > calcDia / 2)
                {
                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    Matrix.SetIdentity();
                    Matrix.Rotate(-Math.PI / 2 - angle3 * Math.PI / 180, new Vector(0, 0, 1));
                    Arc3d arc = symbolGeometryHelper.CreateArc(null, calcDia / 2, Math.PI + 2 * angle3 * Math.PI / 180);
                    arc.Transform(Matrix);

                    Matrix = new Matrix4X4();
                    Matrix.SetIdentity();
                    Matrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                    arc.Transform(Matrix);

                    Matrix = new Matrix4X4();
                    Matrix.SetIdentity();
                    Matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                    arc.Transform(Matrix);

                    Matrix = new Matrix4X4();
                    Matrix.SetIdentity();
                    Matrix.Translate(new Vector(-swivel.Width3 / 2 - swivel.Thickness2, 0, 0));
                    arc.Transform(Matrix);
                    curveCollection.Add(arc);

                    curveCollection.Add(new Line3d(new Position(-swivel.Width3 / 2 - swivel.Thickness2, -radiusY, radiusZ), new Position(-swivel.Width3 / 2 - swivel.Thickness2, -outerBotY, outerBotZ)));

                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    Matrix.SetIdentity();
                    Matrix.Rotate(-Math.PI / 2 - angle3 * Math.PI / 180, new Vector(0, 0, 1));
                    Arc3d arc1 = symbolGeometryHelper.CreateArc(null, calcDia / 2 + swivel.Thickness1 + (2 * swivel.Thickness2), Math.PI + 2 * angle3 * Math.PI / 180);
                    arc1.Transform(Matrix);

                    Matrix = new Matrix4X4();
                    Matrix.SetIdentity();
                    Matrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                    arc1.Transform(Matrix);

                    Matrix = new Matrix4X4();
                    Matrix.SetIdentity();
                    Matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                    arc1.Transform(Matrix);

                    Matrix = new Matrix4X4();
                    Matrix.SetIdentity();
                    Matrix.Translate(new Vector(-swivel.Width3 / 2 - swivel.Thickness2, 0, 0));
                    arc1.Transform(Matrix);
                    curveCollection.Add(arc1);

                    curveCollection.Add(new Line3d(new Position(-swivel.Width3 / 2 - swivel.Thickness2, outerBotYRight, outerBotZRight), new Position(-swivel.Width3 / 2 - swivel.Thickness2, radiusYRight, radiusZRight)));

                    Vector lineVector = new Vector(swivel.Width3 + (swivel.Thickness2 * 2), 0, 0);
                    Projection3d swivelRing = new Projection3d(new ComplexString3d(curveCollection), lineVector, lineVector.Length, true);
                    outputcoll.Add(output, swivelRing);
                }
                else
                {
                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    Matrix.SetIdentity();
                    Matrix.Rotate(-Math.PI / 2 - angle3 * Math.PI / 180, new Vector(0, 0, 1));
                    Arc3d arc = symbolGeometryHelper.CreateArc(null, calcDia / 2, Math.PI + 2 * angle3 * Math.PI / 180);
                    arc.Transform(Matrix);

                    Matrix = new Matrix4X4();
                    Matrix.SetIdentity();
                    Matrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                    arc.Transform(Matrix);

                    Matrix = new Matrix4X4();
                    Matrix.SetIdentity();
                    Matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                    arc.Transform(Matrix);

                    Matrix = new Matrix4X4();
                    Matrix.SetIdentity();
                    Matrix.Translate(new Vector(-swivel.Width3 / 2 - swivel.Thickness2, 0, 0));
                    arc.Transform(Matrix);
                    curveCollection.Add(arc);

                    curveCollection.Add(new Line3d(new Position(-swivel.Width3 / 2 - swivel.Thickness2, -radiusY, radiusZ), new Position(-swivel.Width3 / 2 - swivel.Thickness2, -radiusY + dTopHorzOffset, radiusZ + dTopVertOffset)));
                    curveCollection.Add(new Line3d(new Position(-swivel.Width3 / 2 - swivel.Thickness2, -radiusY + dTopHorzOffset, radiusZ + dTopVertOffset), new Position(-swivel.Width3 / 2 - swivel.Thickness2, -outerBotY + dTopHorzOffset, outerBotZ + dTopVertOffset)));
                    curveCollection.Add(new Line3d(new Position(-swivel.Width3 / 2 - swivel.Thickness2, -outerBotY + dTopHorzOffset, outerBotZ + dTopVertOffset), new Position(-swivel.Width3 / 2 - swivel.Thickness2, -outerBotY, outerBotZ)));

                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    Matrix.SetIdentity();
                    Matrix.Rotate(-Math.PI / 2 - angle3 * Math.PI / 180, new Vector(0, 0, 1));
                    Arc3d arc1 = symbolGeometryHelper.CreateArc(null, calcDia / 2 + swivel.Thickness1 + (2 * swivel.Thickness2), Math.PI + 2 * angle3 * Math.PI / 180);
                    arc1.Transform(Matrix);

                    Matrix = new Matrix4X4();
                    Matrix.SetIdentity();
                    Matrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                    arc1.Transform(Matrix);

                    Matrix = new Matrix4X4();
                    Matrix.SetIdentity();
                    Matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                    arc1.Transform(Matrix);

                    Matrix = new Matrix4X4();
                    Matrix.SetIdentity();
                    Matrix.Translate(new Vector(-swivel.Width3 / 2 - swivel.Thickness2, 0, 0));
                    arc1.Transform(Matrix);
                    curveCollection.Add(arc1);

                    curveCollection.Add(new Line3d(new Position(-swivel.Width3 / 2 - swivel.Thickness2, outerBotYRight, outerBotZRight), new Position(-swivel.Width3 / 2 - swivel.Thickness2, outerBotYRight - dTopHorzOffsetRight, outerBotZRight + dTopVertOffsetRight)));
                    curveCollection.Add(new Line3d(new Position(-swivel.Width3 / 2 - swivel.Thickness2, outerBotYRight - dTopHorzOffsetRight, outerBotZRight + dTopVertOffsetRight), new Position(-swivel.Width3 / 2 - swivel.Thickness2, radiusYRight - dTopHorzOffsetRight, radiusZRight + dTopVertOffsetRight)));
                    curveCollection.Add(new Line3d(new Position(-swivel.Width3 / 2 - swivel.Thickness2, radiusYRight - dTopHorzOffsetRight, radiusZ + dTopVertOffsetRight), new Position(-swivel.Width3 / 2 - swivel.Thickness2, radiusYRight, radiusZRight)));

                    Vector lineVector = new Vector(swivel.Width3 + (swivel.Thickness2 * 2), 0, 0);
                    Projection3d swivelRing = new Projection3d(new ComplexString3d(curveCollection), lineVector, lineVector.Length, true);
                    outputcoll.Add(output, swivelRing);
                }
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddSwivelLinerMethod, "Error in AddSwivelLiner");
                }
            }
        }


        /// <summary>
        /// Defines the inputs for the Bolt shape.
        /// </summary>
        public struct BoltInputs
        {
            /// <summary>
            /// Inside distance between the legs of the strap. Must be greater than PipeOD. 
            /// Determines the spacing of the vertical legs of the strap as well as the bend radius for the curved part of the strap. 
            /// The nominal bend radius equals half the StrapWidthInside dimension.
            /// </summary>
            public double BoltLength;
            /// <summary>
            /// Inside height from the base of the strap to the top.
            /// </summary>
            public double BoltDiameter;
            /// <summary>
            /// Thickness of the rectangular stock used to make the strap. If zero, none of the strap shape is drawn.
            /// </summary>
            public int HeadType;
            /// <summary>
            /// Width of the rectangular stock used to make the strap. If zero, none of the strap shape is drawn.
            /// </summary>
            public double HeadThickness;
            /// <summary>
            /// Adds a flat spot in the curved part of the strap. Must be less than or equal to StrapWidthInside.
            /// </summary>
            public double HeadWidth;
        }

        /// <summary>
        /// Defines the inputs for the BeamClip shape.
        /// </summary>
        public struct BeamClipInputs
        {
            /// <summary>
            /// Inside distance between the legs of the strap. Must be greater than PipeOD. 
            /// Determines the spacing of the vertical legs of the strap as well as the bend radius for the curved part of the strap. 
            /// The nominal bend radius equals half the StrapWidthInside dimension.
            /// </summary>
            public int ShapeType;
            /// <summary>
            /// Inside height from the base of the strap to the top.
            /// </summary>
            public double ClipWidth1;
            /// <summary>
            /// Thickness of the rectangular stock used to make the strap. If zero, none of the strap shape is drawn.
            /// </summary>
            public double ClipWidth2;
            /// <summary>
            /// Width of the rectangular stock used to make the strap. If zero, none of the strap shape is drawn.
            /// </summary>
            public double ClipWidth3;
            /// <summary>
            /// Adds a flat spot in the curved part of the strap. Must be less than or equal to StrapWidthInside.
            /// </summary>
            public double ClipDepth;
            /// <summary>
            /// Inside height from the base of the strap to the top.
            /// </summary>
            public double ClipThickness;
            /// <summary>
            /// Top gap, between outside of pipe and inside of strap. 
            /// Affects the vertical position of the center of the bend radius for the curved part of the strap.
            /// </summary>
            public double ClipThickness1;
            /// <summary>
            /// Width to the outside of the wings, if any. If zero, or less than StrapWidthInside plus twice the StrapThickness, then wings are not drawn. 
            /// Also affects position of gussets.
            /// </summary>
            public double ClipThickness2;
            /// <summary>
            /// Inside height from the base of the strap to the top.
            /// </summary>
            public double ClipHeight1;
            /// <summary>
            /// Thickness of the rectangular stock used to make the strap. If zero, none of the strap shape is drawn.
            /// </summary>
            public double ClipHeight2;
            /// <summary>
            /// For split clamp-type tubing straps, creates a gap at the top and splits the strap into two graphics.
            /// Can be zero or positive. If both this and StrapSplitExtension are zero, the strap is one-piece.
            /// </summary>
            public double BoltOffset;
            /// <summary>
            ///The Nut input parameter type.
            /// </summary>
            public NutInputs Nut;
            /// <summary>
            ///The Bolt input parameter type.
            /// </summary>
            public BoltInputs Bolt;
        }

        /// <summary>
        /// Defines the inputs for the BeamClamp shape.
        /// </summary>
        public struct BeamClampInputs
        {
            /// <summary>
            /// Inside distance between the legs of the strap. Must be greater than PipeOD. 
            /// Determines the spacing of the vertical legs of the strap as well as the bend radius for the curved part of the strap. 
            /// The nominal bend radius equals half the StrapWidthInside dimension.
            /// </summary>
            public string LeftClipShape;
            /// <summary>
            /// Inside height from the base of the strap to the top.
            /// </summary>
            public double LeftClipGap;
            /// <summary>
            /// Thickness of the rectangular stock used to make the strap. If zero, none of the strap shape is drawn.
            /// </summary>
            public double LeftOffsetV;
            /// <summary>
            /// Width of the rectangular stock used to make the strap. If zero, none of the strap shape is drawn.
            /// </summary>
            public double LeftOffsetH;
            /// <summary>
            /// Adds a flat spot in the curved part of the strap. Must be less than or equal to StrapWidthInside.
            /// </summary>
            public string RightClipShape;
            /// <summary>
            /// Inside height from the base of the strap to the top.
            /// </summary>
            public double RightClipGap;
            /// <summary>
            /// Top gap, between outside of pipe and inside of strap. 
            /// Affects the vertical position of the center of the bend radius for the curved part of the strap.
            /// </summary>
            public double RightOffsetV;
            /// <summary>
            /// Width to the outside of the wings, if any. If zero, or less than StrapWidthInside plus twice the StrapThickness, then wings are not drawn. 
            /// Also affects position of gussets.
            /// </summary>
            public double RightOffsetH;
            /// <summary>
            /// The effects this has are:
            /// 1. Strap graphic stops at the tangent point on the right side, as shown.
            /// 2. Wing, bolts and gussets are only included on the left side
            /// </summary>
            public int BottomShape;
            /// <summary>
            /// For split clamp-type tubing straps, creates a gap at the top and splits the strap into two graphics.
            /// Can be zero or positive. If both this and StrapSplitExtension are zero, the strap is one-piece.
            /// </summary>
            public double Gap1;
        }

        /// <summary>
        /// Adds the BeamClamp inputs.
        /// </summary>
        /// <param name="startIndex">The start index.</param>
        /// <param name="endIndex">The end index.</param>
        /// <param name="additionalInputs">The additional inputs.</param>
        /// <code>
        /// AddBeamClampInputs(2, out endIndex, additionalInputs);
        /// </code>
        public void AddBeamClampInputs(int startIndex, out int endIndex, List<Input> additionalInputs)
        {
            try
            {
                additionalInputs.Add(new InputString(startIndex, "LeftClipShape", "LeftClipShape", "No Value", false));
                additionalInputs.Add(new InputDouble(++startIndex, "LeftClipGap", "LeftClipGap", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "LeftOffsetV", "LeftOffsetV", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "LeftOffsetH", "LeftOffsetH", 0, false));
                additionalInputs.Add(new InputString(++startIndex, "RightClipShape", "RightClipShape", "No Value", false));
                additionalInputs.Add(new InputDouble(++startIndex, "RightClipGap", "RightClipGap", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "RightOffsetV", "RightOffsetV", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "RightOffsetH", "RightOffsetH", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "BottomShape", "BottomShape", 1, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Gap1", "Gap1", 0, false));
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddBeamClampInputs, "Error in adding BeamClamp Inputs");
            }
            endIndex = startIndex;
        }

        /// <summary>
        /// This property adds inputs for Bolt.User symbol calls this property AdditionalInputs
        /// to define additional inputs. The list of inputs returned by this method will be the inputs for the user symbol in addition
        /// to the inputs that are already defined as member variables.
        /// </summary>
        ///<code>
        /// //Example: Here 2 is the Number of Bolts needed.
        ///AddBoltInputs(endIndex, 2, out endIndex, additionalInputs);
        ///</code>
        public void AddBoltInputs(int startIndex, int numberOfBolts, out int endIndex, List<Input> additionalInputs)
        {
            try
            {
                for (int i = 1; i <= numberOfBolts; i++)
                {
                    ++startIndex;
                    additionalInputs.Add((Input)new InputDouble(startIndex, "BoltLength" + i, "BoltLength" + i, 0, false));
                    additionalInputs.Add((Input)new InputDouble(++startIndex, "BoltDiameter" + i, "BoltDiameter" + i, 0, false));
                    additionalInputs.Add((Input)new InputDouble(++startIndex, "HeadType" + i, "HeadType" + i, 1, false));
                    additionalInputs.Add((Input)new InputDouble(++startIndex, "HeadThickness" + i, "HeadThickness" + i, 0, false));
                    additionalInputs.Add((Input)new InputDouble(++startIndex, "HeadWidth" + i, "HeadWidth" + i, 0, false));
                }
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddBoltInputs, "Error in adding Bolt Inputs");
            }
            endIndex = startIndex;
        }

        /// <summary>
        /// Adds the BeamClamp outputs.
        /// </summary>
        /// <param name="numberOfBolts">Number of Bolts.</param>
        /// <param name="aspectName">Name of the aspect.</param>
        /// <param name="additionalOutputs">The additional outputs.</param>
        /// <code>
        /// AddBeamClampOutputs(2, additionalOutputs);
        /// </code>
        public void AddBeamClampOutputs(int numberOfBolts, List<OutputDefinition> additionalOutputs)
        {
            try
            {
                additionalOutputs.Add(new OutputDefinition("BeamClamp" + "LeftClip", "BeamClamp" + "LeftClip"));
                additionalOutputs.Add(new OutputDefinition("BeamClamp" + "RightClip", "BeamClamp" + "RightClip"));
                additionalOutputs.Add(new OutputDefinition("BeamClamp" + "Bottom", "BeamClamp" + "Bottom"));
                additionalOutputs.Add(new OutputDefinition("BeamClamp" + "Pin", "BeamClamp" + "Pin"));

                for (int i = 1; i <= numberOfBolts; i++)
                {
                    additionalOutputs.Add(new OutputDefinition("BeamClamp" + "Bolt" + i, "BeamClamp" + "Bolt" + i));
                }
                additionalOutputs.Add(new OutputDefinition("BeamClamp" + "JBolt", "BeamClamp" + "JBolt"));
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddBeamClampOutputs, "Error in adding BeamClamp Outputs");
            }
        }

        /// <summary>
        /// This method will be called by user symbol to get value of an input(in this case, Nut input structure)during construction of outputs. 
        /// Given the start index, this method will return the value of the NutInputs struct object.
        /// </summary>
        /// <param name="startIndex">The start index.</param>
        /// <param name="endIndex">The end index.</param>
        /// <returns></returns>
        ///<code>
        ///BoltInputs leftBolt = LoadBoltData(++startIndex, out endIndex);
        ///startIndex = endIndex;
        ///</code>
        public BoltInputs LoadBoltData(int startIndex, out int endIndex)
        {
            BoltInputs bolt = new BoltInputs();
            try
            {
                bolt.BoltLength = GetDoubleInputValue(startIndex);
                bolt.BoltDiameter = GetDoubleInputValue(++startIndex);
                bolt.HeadType = (int)GetDoubleInputValue(++startIndex);
                bolt.HeadThickness = GetDoubleInputValue(++startIndex);
                bolt.HeadWidth = GetDoubleInputValue(++startIndex);
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadBoltData, "Error in LoadBoltData");
                }
            }
            endIndex = startIndex;
            return bolt;
        }

        /// <summary>
        /// This method will be called by user symbol to get value of an input(in this case, BeamClip input structure)during construction of outputs. 
        /// This method will return the value of the BeamClipInputs struct object.
        /// </summary>
        /// <param name="refShapeName">part name of the auxiliary table.</param>
        /// <returns></returns>
        ///<code>
        ///      leftBeamClip = LoadBeamClipDataByQuery(beamClamp.LeftClipShape);
        ///</code>
        public BeamClipInputs LoadBeamClipDataByQuery(string refShapeName)
        {
            BeamClipInputs beamClip = new BeamClipInputs();
            try
            {
                if (!(refShapeName == "" || refShapeName == "No Value"))
                {
                    Catalog m_oPlantCatalog = MiddleServiceProvider.SiteMgr.ActiveSite.ActivePlant.PlantCatalog;
                    BusinessObject BeamClipAuxTable = m_oPlantCatalog.GetNamedObject(refShapeName);

                    beamClip.ShapeType = (int)((PropertyValueCodelist)BeamClipAuxTable.GetPropertyValue("IJUAhsClip", "ShapeType")).PropValue;
                    try
                    {
                        beamClip.ClipWidth1 = (double)((PropertyValueDouble)BeamClipAuxTable.GetPropertyValue("IJUAhsClip", "ClipWidth1")).PropValue;
                    }
                    catch
                    {
                        beamClip.ClipWidth1 = 0;
                    }
                    try
                    {
                        beamClip.ClipWidth2 = (double)((PropertyValueDouble)BeamClipAuxTable.GetPropertyValue("IJUAhsClip", "ClipWidth2")).PropValue;
                    }
                    catch
                    {
                        beamClip.ClipWidth2 = 0;
                    }
                    try
                    {
                        beamClip.ClipWidth3 = (double)((PropertyValueDouble)BeamClipAuxTable.GetPropertyValue("IJUAhsClip", "ClipWidth3")).PropValue;
                    }
                    catch
                    {
                        beamClip.ClipWidth3 = 0;
                    }
                    try
                    {
                        beamClip.ClipDepth = (double)((PropertyValueDouble)BeamClipAuxTable.GetPropertyValue("IJUAhsClip", "ClipDepth")).PropValue;
                    }
                    catch
                    {
                        beamClip.ClipDepth = 0;
                    }
                    try
                    {
                        beamClip.ClipThickness = (double)((PropertyValueDouble)BeamClipAuxTable.GetPropertyValue("IJUAhsClip", "ClipThickness")).PropValue;
                    }
                    catch
                    {
                        beamClip.ClipThickness = 0;
                    }
                    try
                    {
                        beamClip.ClipThickness1 = (double)((PropertyValueDouble)BeamClipAuxTable.GetPropertyValue("IJUAhsClip", "ClipThickness1")).PropValue;
                    }
                    catch
                    {
                        beamClip.ClipThickness1 = 0;
                    }
                    try
                    {
                        beamClip.ClipThickness2 = (double)((PropertyValueDouble)BeamClipAuxTable.GetPropertyValue("IJUAhsClip", "ClipThickness2")).PropValue;
                    }
                    catch
                    {
                        beamClip.ClipThickness2 = 0;
                    }
                    try
                    {
                        beamClip.ClipHeight1 = (double)((PropertyValueDouble)BeamClipAuxTable.GetPropertyValue("IJUAhsClip", "ClipHeight1")).PropValue;
                    }
                    catch
                    {
                        beamClip.ClipHeight1 = 0;
                    }
                    try
                    {
                        beamClip.ClipHeight2 = (double)((PropertyValueDouble)BeamClipAuxTable.GetPropertyValue("IJUAhsClip", "ClipHeight2")).PropValue;
                    }
                    catch
                    {
                        beamClip.ClipHeight2 = 0;
                    }
                    try
                    {
                        beamClip.Bolt.BoltLength = (double)((PropertyValueDouble)BeamClipAuxTable.GetPropertyValue("IJUAhsClipBolt", "BoltLength")).PropValue;
                    }
                    catch
                    {
                        beamClip.Bolt.BoltLength = 0;
                    }
                    try
                    {
                        beamClip.Bolt.BoltDiameter = (double)((PropertyValueDouble)BeamClipAuxTable.GetPropertyValue("IJUAhsClipBolt", "BoltDiameter")).PropValue;
                    }
                    catch
                    {
                        beamClip.Bolt.BoltDiameter = 0;
                    }
                    beamClip.Bolt.HeadType = (int)((PropertyValueCodelist)BeamClipAuxTable.GetPropertyValue("IJUAhsClipBolt", "HeadType")).PropValue;
                    try
                    {
                        beamClip.Bolt.HeadThickness = (double)((PropertyValueDouble)BeamClipAuxTable.GetPropertyValue("IJUAhsClipBolt", "HeadThickness")).PropValue;
                    }
                    catch
                    {
                        beamClip.Bolt.HeadThickness = 0;
                    }
                    try
                    {
                        beamClip.Bolt.HeadWidth = (double)((PropertyValueDouble)BeamClipAuxTable.GetPropertyValue("IJUAhsClipBolt", "HeadWidth")).PropValue;
                    }
                    catch
                    {
                        beamClip.Bolt.HeadWidth = 0;
                    }
                    try
                    {
                        beamClip.BoltOffset = (double)((PropertyValueDouble)BeamClipAuxTable.GetPropertyValue("IJUAhsClipBolt", "BoltOffset")).PropValue;
                    }
                    catch
                    {
                        beamClip.BoltOffset = 0;
                    }
                }
                beamClip.Nut = LoadNutDataByQuery(refShapeName, 1);
                return beamClip;
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadBeamClipDataByQuery, "Error in LoadBeamClipDataByQuery");
                }
                return beamClip;
            }
        }

        /// <summary>
        /// This method will be called by user symbol to get value of an input(in this case, Nut input structure)during construction of outputs. 
        /// This method will return the value of the NutInputs struct object.
        /// </summary>
        /// <param name="refShapeName">part name of the auxiliary table.</param>
        /// <param name="numberOfNuts">Get Number of Nuts</param>
        /// <returns></returns>
        ///<code>
        ///beamClip.Nut = LoadNutDataByQuery(refShapeName, 1);
        ///</code>
        public NutInputs LoadNutDataByQuery(string refShapeName, int numberOfNuts)
        {
            NutInputs nut = new NutInputs();
            try
            {
                if (!(refShapeName == "" || refShapeName == "No Value"))
                {
                    Catalog plantCatalog = MiddleServiceProvider.SiteMgr.ActiveSite.ActivePlant.PlantCatalog;
                    BusinessObject nutAuxTable = plantCatalog.GetNamedObject(refShapeName);
                    for (int i = 1; i <= numberOfNuts; i++)
                    {
                        nut.ShapeType = (int)((PropertyValueCodelist)nutAuxTable.GetPropertyValue("IJUAhsShape" + i, "Shape" + i + "Type")).PropValue;
                        try
                        {
                            nut.ShapeWidth1 = (double)((PropertyValueDouble)nutAuxTable.GetPropertyValue("IJUAhsShape" + i, "Shape" + i + "Width1")).PropValue;
                        }
                        catch
                        {
                            nut.ShapeWidth1 = 0;
                        }
                        try
                        {
                            nut.ShapeWidth2 = (double)((PropertyValueDouble)nutAuxTable.GetPropertyValue("IJUAhsShape" + i, "Shape" + i + "Width2")).PropValue;
                        }
                        catch
                        {
                            nut.ShapeWidth2 = 0;
                        }
                        try
                        {
                            nut.ShapeLength = (double)((PropertyValueDouble)nutAuxTable.GetPropertyValue("IJUAhsShape" + i, "Shape" + i + "Length")).PropValue;
                        }
                        catch
                        {
                            nut.ShapeLength = 0;
                        }
                    }
                }
                return nut;
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadNutDataByQuery, "Error in LoadNutDataByQuery");
                }
                return nut;
            }
        }

        /// <summary>
        /// This method will be called by user symbol to get value of an input(in this case, Nut input structure)during construction of outputs. 
        /// Given the start index, this method will return the value of the NutInputs struct object.
        /// </summary>
        /// <param name="startIndex">The start index.</param>
        /// <param name="endIndex">The end index.</param>
        /// <returns></returns>
        ///<code>
        ///BeamClampInputs beamClamp = LoadBeamClampData(2, out endIndex);
        ///startIndex = endIndex;
        ///</code>
        public BeamClampInputs LoadBeamClampData(int startIndex, out int endIndex)
        {
            BeamClampInputs beamClamp = new BeamClampInputs();
            try
            {
                beamClamp.LeftClipShape = (string)GetStringInputValue(startIndex);
                beamClamp.LeftClipGap = GetDoubleInputValue(++startIndex);
                beamClamp.LeftOffsetV = GetDoubleInputValue(++startIndex);
                beamClamp.LeftOffsetH = GetDoubleInputValue(++startIndex);
                beamClamp.RightClipShape = (string)GetStringInputValue(++startIndex);
                beamClamp.RightClipGap = GetDoubleInputValue(++startIndex);
                beamClamp.RightOffsetV = GetDoubleInputValue(++startIndex);
                beamClamp.RightOffsetH = GetDoubleInputValue(++startIndex);
                beamClamp.BottomShape = (int)GetDoubleInputValue(++startIndex);
                beamClamp.Gap1 = GetDoubleInputValue(++startIndex);
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadBeamClampData, "Error in LoadBeamClampData");
                }
            }
            endIndex = startIndex;
            return beamClamp;
        }

        /// <summary>
        /// Add Bolt With Head
        /// </summary>        
        /// <param name="bolt">Structure for specifying the inputs for the BoltInputs.</param>
        /// <param name="matrix">Matrix to specify the position and oreintation the graphics - Matrix4X4.</param>
        /// <param name="outputs">Collection of declared outputs, which is indexed by the name of the outputs declared as defining SymbolOutputs on the AspectDefinition field- OutputDictionary.</param>
        /// <param name="outputName">OutputName that this graphic is being placed on-String.</param>
        ///<code>
        /// Matrix4X4 matrix = new Matrix4X4();
        /// matrix.Origin = new Position(0, -flangeWidth / 2 - beamClamp.RightClipGap - beamClamp.RightOffsetH, -rightBolt.BoltLength + beamClamp.RightOffsetV);
        /// AddBoltWithHead(rightBolt, matrix, m_PhysicalAspect.Outputs, "BeamClampBolt2");
        ///</code>
        public void AddBoltWithHead(BoltInputs bolt, Matrix4X4 matrix, OutputDictionary outputs, String outputName)
        {
            try
            {
                NutInputs headNut = new NutInputs();
                SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();
                if ((bolt.BoltLength > 0) && (bolt.BoltDiameter > 0))
                {
                    //Bolt Shape
                    symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                    symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(1, 0, 0));
                    Projection3d boltCylinder = symbolGeometryHelper.CreateCylinder(null, bolt.BoltDiameter / 2, bolt.BoltLength - bolt.HeadThickness);
                    boltCylinder.Transform(matrix);
                    outputs.Add(outputName + "Bolt", boltCylinder);

                    //Nut Shape
                    if ((bolt.HeadWidth > 0) && (bolt.HeadThickness > 0))
                    //Mapping to Nut attribute for Head Nut
                    {
                        headNut.ShapeLength = bolt.HeadThickness;
                        headNut.ShapeWidth1 = bolt.HeadWidth;
                        headNut.ShapeType = bolt.HeadType;

                        //Head Nut
                        Matrix4X4 nutMatrix = new Matrix4X4();
                        nutMatrix.Origin = new Position(0, 0, bolt.BoltLength - bolt.HeadThickness);
                        AddNut(headNut, nutMatrix, outputs, outputName + "Nut");
                        Projection3d nutOutput = (Projection3d)outputs[outputName + "Nut"];
                        nutOutput.Transform(matrix);
                    }
                }
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddBoltWithHead, "Error in AddBoltWithHead");
                }
            }
        }

        /// <summary>
        /// Adds the Beam Clamp.
        /// </summary>
        /// <param name="beamClamp">BeamClamp shape.</param>
        /// <param name="flangeThickness">FlangeThickness.</param>
        /// <param name="flangeWidth">FlangeWidthe.</param>
        /// <param name="height3">Height.</param>
        /// <param name="matrix">The matrix.</param>
        /// <param name="outputs">The outputs.</param>
        /// <param name="outputName">Name of the output.</param>
        /// <param name="objectColl">collection for holding outputs.</param>
        /// <param name="beamClampXLocation">offset beamclamp in X Axis.</param>
        /// <code>
        ///   Matrix4X4 matrix = new Matrix4X4();
        ///   matrix.Origin = new Position(0, 0, 0);
        ///   AddBeamClamp(part, beamClamp, flangeThickness, flangeWidth, height3, matrix, m_PhysicalAspect.Outputs, "BeamClamp");
        /// </code>
        public void AddBeamClamp(BeamClampInputs beamClamp, Double flangeThickness, Double flangeWidth, Double height3, Matrix4X4 matrix, OutputDictionary outputs, String outputName, List<string> objectColl = null, Double beamClampXLocation = 0)
        {
            try
            {
                BeamClipInputs leftBeamClip = new BeamClipInputs();
                BeamClipInputs rightBeamClip = new BeamClipInputs();
                Double vertOffset = 0;
                Matrix4X4 beamClipMatrix = new Matrix4X4();
                StringBuilder error = new StringBuilder();
                //Left beamClip
                if (beamClamp.LeftClipShape != "")
                {
                    //Load Data
                    leftBeamClip = LoadBeamClipDataByQuery(beamClamp.LeftClipShape);
                    //Set the attributes for Beam Clip
                    if (leftBeamClip.ShapeType >= 7)        //For I and 2I Shape
                        leftBeamClip.BoltOffset = beamClamp.LeftOffsetH;        //Set the Bolt Offset
                    else if ((leftBeamClip.ShapeType == 5) || (leftBeamClip.ShapeType == 6))        //For P and Q
                    {
                        if (HgrCompareDoubleService.cmpdbl(leftBeamClip.ClipWidth1 , 0) == true)
                            leftBeamClip.ClipWidth1 = ((flangeWidth / 2 - beamClamp.Gap1 / 2) + beamClamp.LeftClipGap);
                        if (HgrCompareDoubleService.cmpdbl(leftBeamClip.ClipWidth2 , 0) == true)
                        {
                            if (leftBeamClip.ShapeType == 6)        //For Q
                                leftBeamClip.ClipWidth2 = leftBeamClip.ClipWidth1;
                            else                                    //For P
                                leftBeamClip.ClipWidth2 = ((flangeWidth / 2 - beamClamp.Gap1 / 2) + beamClamp.LeftClipGap + leftBeamClip.ClipThickness);
                        }
                        else
                        {
                            if (leftBeamClip.ShapeType == 6)        //For Q
                            {
                                if ((leftBeamClip.ClipWidth2 + leftBeamClip.ClipWidth3) < (flangeWidth / 2 + beamClamp.LeftClipGap + leftBeamClip.ClipThickness))
                                {
                                    //Throw Warning When Width 2 is not sufficient
                                    ToDoListMessage = new ToDoListMessage(ToDoMessageTypes.ToDoMessageWarning, SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrOverlapBeamClip, "Width1 and Width 2 value are not enough to create the Overlap with Other Beam clip"));
                                    leftBeamClip.ClipWidth2 = flangeWidth / 2 + beamClamp.LeftClipGap + leftBeamClip.ClipThickness - leftBeamClip.ClipWidth3;
                                }
                            }
                        }
                        if ((HgrCompareDoubleService.cmpdbl(leftBeamClip.ClipWidth3 , 0) ==true) && (leftBeamClip.ShapeType == 6))        //Width 3 for Q Shape
                            leftBeamClip.ClipWidth3 = beamClamp.Gap1 + leftBeamClip.ClipThickness;
                        if (HgrCompareDoubleService.cmpdbl(leftBeamClip.ClipHeight1 , 0) == true)
                            leftBeamClip.ClipHeight1 = flangeThickness + 2 * leftBeamClip.ClipThickness;

                        if (leftBeamClip.ShapeType == 5)        //For P
                        {
                            if (HgrCompareDoubleService.cmpdbl(leftBeamClip.ClipHeight2 , 0) == true)
                                leftBeamClip.ClipHeight2 = height3 + 2 * leftBeamClip.ClipThickness;
                        }
                    }

                    //Check Bolt offset to Move the Beam clip
                    if ((HgrCompareDoubleService.cmpdbl(leftBeamClip.Bolt.BoltLength , 0) == false) && (leftBeamClip.ShapeType != 7))
                    {
                        if (leftBeamClip.ShapeType == 1)
                            vertOffset = leftBeamClip.ClipHeight1 - leftBeamClip.ClipThickness1 - leftBeamClip.ClipThickness2 - flangeThickness;
                        else if ((leftBeamClip.ShapeType == 2) || (leftBeamClip.ShapeType == 3))
                            vertOffset = leftBeamClip.ClipHeight1 - leftBeamClip.ClipThickness1 - flangeThickness;
                        else if (leftBeamClip.ShapeType == 4)
                            vertOffset = leftBeamClip.ClipHeight1 - leftBeamClip.ClipThickness - leftBeamClip.ClipHeight2 - flangeThickness;
                        else if (leftBeamClip.ShapeType == 5)
                            vertOffset = leftBeamClip.ClipHeight1 - 2 * leftBeamClip.ClipThickness - flangeThickness;
                        else if (leftBeamClip.ShapeType == 6)
                            vertOffset = leftBeamClip.ClipHeight1 - 2 * leftBeamClip.ClipThickness - flangeThickness;
                    }
                    else
                        vertOffset = 0;

                    //Add Beam Clip Shape
                    beamClipMatrix = new Matrix4X4();
                    beamClipMatrix.Origin = new Position(beamClampXLocation, flangeWidth / 2 + beamClamp.LeftClipGap, vertOffset + flangeThickness);
                    AddBeamClip(leftBeamClip, flangeThickness, beamClipMatrix, outputs, outputName + "LeftClip", objectColl);
                }

                //Right Beam Clip
                if (beamClamp.RightClipShape != "")
                {
                    //Load Data
                    rightBeamClip = LoadBeamClipDataByQuery(beamClamp.RightClipShape);

                    //Set the attributes for Bema Clip
                    if (rightBeamClip.ShapeType >= 7)       //For I and 2I Shape
                        rightBeamClip.BoltOffset = beamClamp.RightOffsetH;      //Set the Bolt Offset
                    else if ((rightBeamClip.ShapeType == 5) || (rightBeamClip.ShapeType == 6))      //For P and Q
                    {
                        if (HgrCompareDoubleService.cmpdbl(rightBeamClip.ClipWidth1 , 0) == true)
                            rightBeamClip.ClipWidth1 = ((flangeWidth / 2 - beamClamp.Gap1 / 2) + beamClamp.RightClipGap);

                        if (HgrCompareDoubleService.cmpdbl(rightBeamClip.ClipWidth2 , 0) == true)
                        {
                            if (rightBeamClip.ShapeType == 6)        //For Q
                                rightBeamClip.ClipWidth2 = rightBeamClip.ClipWidth1;
                            else
                                rightBeamClip.ClipWidth2 = ((flangeWidth / 2 - beamClamp.Gap1 / 2) + beamClamp.RightClipGap + rightBeamClip.ClipThickness);
                        }
                        else
                        {
                            if (rightBeamClip.ShapeType == 6)       //For Q
                            {
                                if ((rightBeamClip.ClipWidth2 + rightBeamClip.ClipWidth3) < (flangeWidth / 2 + beamClamp.RightClipGap + rightBeamClip.ClipThickness))
                                {
                                    //Throw Warning When Width 2 is not sufficient
                                    ToDoListMessage = new ToDoListMessage(ToDoMessageTypes.ToDoMessageWarning, SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrOverlapBeamClip, "Width1 and Width 2 value are not enough to create the Overlap with Other Beam clip"));
                                    rightBeamClip.ClipWidth2 = flangeWidth / 2 + beamClamp.RightClipGap + rightBeamClip.ClipThickness - rightBeamClip.ClipWidth3;
                                }
                            }
                        }

                        if ((HgrCompareDoubleService.cmpdbl(rightBeamClip.ClipWidth3 , 0) == true) && (rightBeamClip.ShapeType == 6))      //Width 3 for Q Shape
                            rightBeamClip.ClipWidth3 = beamClamp.Gap1 + rightBeamClip.ClipThickness;
                        if (HgrCompareDoubleService.cmpdbl(rightBeamClip.ClipHeight1, 0) == true)
                            rightBeamClip.ClipHeight1 = flangeThickness + 2 * rightBeamClip.ClipThickness;

                        if (rightBeamClip.ShapeType == 5)       //For P
                        {
                            if (HgrCompareDoubleService.cmpdbl(rightBeamClip.ClipHeight2 , 0) ==true)
                                rightBeamClip.ClipHeight2 = height3 + 2 * rightBeamClip.ClipThickness;
                        }
                    }

                    //Check Bolt offset to Move the Beam clip
                    if ((HgrCompareDoubleService.cmpdbl(rightBeamClip.Bolt.BoltLength , 0) == false) && (rightBeamClip.ShapeType != 7))     //There is Bolt on Beam Clip and Not 2I shape
                    {
                        if (rightBeamClip.ShapeType == 1)       //C
                            vertOffset = rightBeamClip.ClipHeight1 - rightBeamClip.ClipThickness1 - rightBeamClip.ClipThickness2 - flangeThickness;
                        else if ((rightBeamClip.ShapeType == 2) || (rightBeamClip.ShapeType == 3))      //L or S
                            vertOffset = rightBeamClip.ClipHeight1 - rightBeamClip.ClipThickness1 - flangeThickness;
                        else if (rightBeamClip.ShapeType == 4)      //G
                            vertOffset = rightBeamClip.ClipHeight1 - rightBeamClip.ClipThickness - rightBeamClip.ClipHeight2 - flangeThickness;
                        else if (rightBeamClip.ShapeType == 5)      //P
                            vertOffset = rightBeamClip.ClipHeight1 - 2 * rightBeamClip.ClipThickness - flangeThickness;
                        else if (rightBeamClip.ShapeType == 6)      //Q
                            vertOffset = rightBeamClip.ClipHeight1 - 2 * rightBeamClip.ClipThickness - flangeThickness;
                    }
                    else
                        vertOffset = 0;

                    //Add Beam Clip Shape
                    beamClipMatrix = new Matrix4X4();
                    beamClipMatrix.Rotate(Math.PI, new Vector(0, 0, 1));
                    beamClipMatrix.Translate(beamClipMatrix.Transform(new Vector(-beamClampXLocation, flangeWidth / 2 + beamClamp.RightClipGap, vertOffset + flangeThickness)));
                    AddBeamClip(rightBeamClip, flangeThickness, beamClipMatrix, outputs, outputName + "RightClip", objectColl);
                }
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddBeamClamp, "Error in AddBeamClamp");
                }
            }
        }

        /// <summary>
        /// Add Beam Clip
        /// </summary>        
        /// <param name="beamClip">Structure for specifying the inputs for the BeamClip -BeamClipInputs.</param>
        /// <param name="clampThickness">Get The Value of ClampThickness</param>
        /// <param name="matrix">Matrix to specify the position and oreintation the graphics - Matrix4X4.</param>
        /// <param name="outputs">Collection of declared outputs, which is indexed by the name of the outputs declared as defining SymbolOutputs on the AspectDefinition field- OutputDictionary.</param>
        /// <param name="outputName">OutputName that this graphic is being placed on-String.</param>
        /// <param name="objectColl">collection for holding outputs.</param>
        ///<code>
        /// Matrix4X4 beamClipMatrix = new Matrix4X4();
        /// beamClipMatrix.Origin = new Position(0, flangeWidth / 2 + beamClamp.LeftClipGap, vertOffset + flangeThickness);
        /// AddBeamClip(leftBeamClip, flangeThickness, beamClipMatrix, outputs, outputName + "LeftClip");
        ///</code>
        public void AddBeamClip(BeamClipInputs beamClip, Double clampThickness, Matrix4X4 matrix, OutputDictionary outputs, String outputName, List<string> objectColl = null)
        {
            try
            {
                SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();
                NutInputs nut = new NutInputs();
                Collection<Position> pointCollection = new Collection<Position>();
                Projection3d projectionBody;
                Matrix4X4 nutMatrix = new Matrix4X4();
                switch (beamClip.ShapeType)
                {
                    case 1:     //C Shape
                        pointCollection = new Collection<Position>();

                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, 0, 0));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, 0, -(beamClip.ClipHeight1 - beamClip.ClipThickness1 - beamClip.ClipThickness2)));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, -(beamClip.ClipWidth2 - beamClip.ClipThickness), -(beamClip.ClipHeight1 - beamClip.ClipThickness1 - beamClip.ClipThickness2)));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, -(beamClip.ClipWidth2 - beamClip.ClipThickness), -(beamClip.ClipHeight1 - beamClip.ClipThickness1)));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, beamClip.ClipThickness, -(beamClip.ClipHeight1 - beamClip.ClipThickness1)));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, beamClip.ClipThickness, beamClip.ClipThickness1));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, -(beamClip.ClipWidth1 - beamClip.ClipThickness), beamClip.ClipThickness1));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, -(beamClip.ClipWidth1 - beamClip.ClipThickness), 0));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, 0, 0));

                        projectionBody = new Projection3d(new LineString3d(pointCollection), new Vector(beamClip.ClipDepth, 0, 0), beamClip.ClipDepth, true);
                        projectionBody.Transform(matrix);
                        outputs.Add(outputName + "Clip", projectionBody);
                        if (objectColl != null)
                            objectColl.Add(outputName + "Clip");

                        //Bolts and Nuts
                        if ((beamClip.Bolt.BoltLength > 0) && (beamClip.Bolt.BoltDiameter > 0))
                        {
                            //Bolt Shape
                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(0, -beamClip.BoltOffset, -beamClip.ClipHeight1 + beamClip.ClipThickness1 + beamClip.ClipThickness2 + clampThickness);
                            symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(1, 0, 0));
                            Projection3d boltCylinder = symbolGeometryHelper.CreateCylinder(null, beamClip.Bolt.BoltDiameter / 2, beamClip.Bolt.BoltLength - beamClip.Bolt.HeadThickness);
                            boltCylinder.Transform(matrix);
                            outputs.Add(outputName + "Bolt", boltCylinder);
                            if (objectColl != null)
                                objectColl.Add(outputName + "Bolt");

                            //Nut Shape
                            if ((beamClip.Bolt.HeadWidth > 0) && (beamClip.Bolt.HeadThickness > 0))
                            {
                                //Mapping to Nut attribute for Top Nut
                                nut.ShapeLength = beamClip.Bolt.HeadThickness;
                                nut.ShapeWidth1 = beamClip.Bolt.HeadWidth;
                                nut.ShapeType = beamClip.Bolt.HeadType;

                                //Top Nut
                                nutMatrix = new Matrix4X4();
                                nutMatrix.Origin = new Position(0, -beamClip.BoltOffset, beamClip.Bolt.BoltLength - beamClip.ClipHeight1 + beamClip.ClipThickness1 + beamClip.ClipThickness2 + clampThickness - beamClip.Bolt.HeadThickness);
                                AddNut(nut, nutMatrix, outputs, outputName + "Nut1");
                                Projection3d nut1Ouput = (Projection3d)outputs[outputName + "Nut1"];
                                nut1Ouput.Transform(matrix);
                                if (objectColl != null)
                                    objectColl.Add(outputName + "Nut1");

                                //Bottom nut
                                nutMatrix = new Matrix4X4();
                                nutMatrix.Origin = new Position(0, -beamClip.BoltOffset, beamClip.ClipThickness1);
                                AddNut(beamClip.Nut, nutMatrix, outputs, outputName + "Nut2");
                                Projection3d nut2Ouput = (Projection3d)outputs[outputName + "Nut2"];
                                nut2Ouput.Transform(matrix);
                                if (objectColl != null)
                                    objectColl.Add(outputName + "Nut2");
                            }
                        }
                        break;
                    case 2:     //L Shape
                        pointCollection = new Collection<Position>();
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, 0, 0));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, 0, -(beamClip.ClipHeight1 - beamClip.ClipThickness1)));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, beamClip.ClipThickness, -(beamClip.ClipHeight1 - beamClip.ClipThickness1)));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, beamClip.ClipThickness, beamClip.ClipThickness1));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, -(beamClip.ClipWidth1 - beamClip.ClipThickness), beamClip.ClipThickness1));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, -(beamClip.ClipWidth1 - beamClip.ClipThickness), 0));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, 0, 0));

                        projectionBody = new Projection3d(new LineString3d(pointCollection), new Vector(beamClip.ClipDepth, 0, 0), beamClip.ClipDepth, true);
                        projectionBody.Transform(matrix);
                        outputs.Add(outputName + "Clip", projectionBody);
                        if (objectColl != null)
                            objectColl.Add(outputName + "Clip");

                        //Bolts and Nuts
                        if ((beamClip.Bolt.BoltLength > 0) && (beamClip.Bolt.BoltDiameter > 0))
                        {
                            //Bolt Shape
                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(0, -beamClip.BoltOffset, -beamClip.ClipHeight1 + beamClip.ClipThickness1 + clampThickness);
                            symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(1, 0, 0));
                            Projection3d boltCylinder = symbolGeometryHelper.CreateCylinder(null, beamClip.Bolt.BoltDiameter / 2, beamClip.Bolt.BoltLength - beamClip.Bolt.HeadThickness);
                            boltCylinder.Transform(matrix);
                            outputs.Add(outputName + "Bolt", boltCylinder);
                            if (objectColl != null)
                                objectColl.Add(outputName + "Bolt");

                            //Nut Shape
                            if ((beamClip.Bolt.HeadWidth > 0) && (beamClip.Bolt.HeadThickness > 0))
                            {
                                //Mapping to Nut attribute for Top Nut
                                nut.ShapeLength = beamClip.Bolt.HeadThickness;
                                nut.ShapeWidth1 = beamClip.Bolt.HeadWidth;
                                nut.ShapeType = beamClip.Bolt.HeadType;

                                //Top Nut
                                nutMatrix = new Matrix4X4();
                                nutMatrix.Origin = new Position(0, -beamClip.BoltOffset, beamClip.Bolt.BoltLength - beamClip.ClipHeight1 + beamClip.ClipThickness1 + clampThickness - beamClip.Bolt.HeadThickness);
                                AddNut(nut, nutMatrix, outputs, outputName + "Nut1");
                                Projection3d nut1Ouput = (Projection3d)outputs[outputName + "Nut1"];
                                nut1Ouput.Transform(matrix);
                                if (objectColl != null)
                                    objectColl.Add(outputName + "Nut1");

                                //Bottom nut
                                nutMatrix = new Matrix4X4();
                                nutMatrix.Origin = new Position(0, -beamClip.BoltOffset, beamClip.ClipThickness1);
                                AddNut(beamClip.Nut, nutMatrix, outputs, outputName + "Nut2");
                                Projection3d nut2Ouput = (Projection3d)outputs[outputName + "Nut2"];
                                nut2Ouput.Transform(matrix);
                                if (objectColl != null)
                                    objectColl.Add(outputName + "Nut2");
                            }
                        }
                        break;
                    case 3:     //S Shape
                        pointCollection = new Collection<Position>();
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, 0, 0));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, 0, -(beamClip.ClipHeight1 - beamClip.ClipThickness1)));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, beamClip.ClipWidth2, -(beamClip.ClipHeight1 - beamClip.ClipThickness1)));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, beamClip.ClipWidth2, -(beamClip.ClipHeight1 - beamClip.ClipThickness1 - beamClip.ClipThickness2)));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, beamClip.ClipThickness, -(beamClip.ClipHeight1 - beamClip.ClipThickness1 - beamClip.ClipThickness2)));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, beamClip.ClipThickness, beamClip.ClipThickness1));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, -(beamClip.ClipWidth1 - beamClip.ClipThickness), beamClip.ClipThickness1));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, -(beamClip.ClipWidth1 - beamClip.ClipThickness), 0));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, 0, 0));

                        projectionBody = new Projection3d(new LineString3d(pointCollection), new Vector(beamClip.ClipDepth, 0, 0), beamClip.ClipDepth, true);
                        projectionBody.Transform(matrix);
                        outputs.Add(outputName + "Clip", projectionBody);
                        if (objectColl != null)
                            objectColl.Add(outputName + "Clip");

                        //Bolts and Nuts
                        if ((beamClip.Bolt.BoltLength > 0) && (beamClip.Bolt.BoltDiameter > 0))
                        {
                            //Bolt Shape
                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(0, -beamClip.BoltOffset, -beamClip.ClipHeight1 + beamClip.ClipThickness1 + clampThickness);
                            symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(1, 0, 0));
                            Projection3d boltCylinder = symbolGeometryHelper.CreateCylinder(null, beamClip.Bolt.BoltDiameter / 2, beamClip.Bolt.BoltLength - beamClip.Bolt.HeadThickness);
                            boltCylinder.Transform(matrix);
                            outputs.Add(outputName + "Bolt", boltCylinder);
                            if (objectColl != null)
                                objectColl.Add(outputName + "Bolt");

                            //Nut Shape
                            if ((beamClip.Bolt.HeadWidth > 0) && (beamClip.Bolt.HeadThickness > 0))
                            {
                                //Mapping to Nut attribute for Top Nut
                                nut.ShapeLength = beamClip.Bolt.HeadThickness;
                                nut.ShapeWidth1 = beamClip.Bolt.HeadWidth;
                                nut.ShapeType = beamClip.Bolt.HeadType;

                                //Top Nut
                                nutMatrix = new Matrix4X4();
                                nutMatrix.Origin = new Position(0, -beamClip.BoltOffset, beamClip.Bolt.BoltLength - beamClip.ClipHeight1 + beamClip.ClipThickness1 + clampThickness - beamClip.Bolt.HeadThickness);
                                AddNut(nut, nutMatrix, outputs, outputName + "Nut1");
                                Projection3d nut1Ouput = (Projection3d)outputs[outputName + "Nut1"];
                                nut1Ouput.Transform(matrix);
                                if (objectColl != null)
                                    objectColl.Add(outputName + "Nut1");

                                //Bottom nut
                                nutMatrix = new Matrix4X4();
                                nutMatrix.Origin = new Position(0, -beamClip.BoltOffset, beamClip.ClipThickness1);
                                AddNut(beamClip.Nut, nutMatrix, outputs, outputName + "Nut2");
                                Projection3d nut2Ouput = (Projection3d)outputs[outputName + "Nut2"];
                                nut2Ouput.Transform(matrix);
                                if (objectColl != null)
                                    objectColl.Add(outputName + "Nut2");
                            }
                        }
                        break;
                    case 4:     //G Shape
                        pointCollection = new Collection<Position>();
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, 0, 0));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, 0, -(beamClip.ClipHeight1 - 2 * beamClip.ClipThickness)));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, -(beamClip.ClipWidth2 - 2 * beamClip.ClipThickness), -(beamClip.ClipHeight1 - 2 * beamClip.ClipThickness)));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, -(beamClip.ClipWidth2 - 2 * beamClip.ClipThickness), -(beamClip.ClipHeight1 - beamClip.ClipHeight2 - beamClip.ClipThickness)));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, -(beamClip.ClipWidth2 - beamClip.ClipThickness), -(beamClip.ClipHeight1 - beamClip.ClipHeight2 - beamClip.ClipThickness)));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, -(beamClip.ClipWidth2 - beamClip.ClipThickness), -(beamClip.ClipHeight1 - beamClip.ClipThickness)));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, beamClip.ClipThickness, -(beamClip.ClipHeight1 - beamClip.ClipThickness)));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, beamClip.ClipThickness, beamClip.ClipThickness));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, -(beamClip.ClipWidth1 - beamClip.ClipThickness), beamClip.ClipThickness));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, -(beamClip.ClipWidth1 - beamClip.ClipThickness), 0));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, 0, 0));

                        projectionBody = new Projection3d(new LineString3d(pointCollection), new Vector(beamClip.ClipDepth, 0, 0), beamClip.ClipDepth, true);
                        projectionBody.Transform(matrix);
                        outputs.Add(outputName + "Clip", projectionBody);
                        if (objectColl != null)
                            objectColl.Add(outputName + "Clip");

                        //Bolts and Nuts
                        if ((beamClip.Bolt.BoltLength > 0) && (beamClip.Bolt.BoltDiameter > 0))
                        {
                            //Bolt Shape
                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(0, -beamClip.BoltOffset, -beamClip.ClipHeight1 + beamClip.ClipThickness + beamClip.ClipHeight2 + clampThickness);
                            symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(1, 0, 0));
                            Projection3d boltCylinder = symbolGeometryHelper.CreateCylinder(null, beamClip.Bolt.BoltDiameter / 2, beamClip.Bolt.BoltLength - beamClip.Bolt.HeadThickness);
                            boltCylinder.Transform(matrix);
                            outputs.Add(outputName + "Bolt", boltCylinder);
                            if (objectColl != null)
                                objectColl.Add(outputName + "Bolt");

                            //Nut Shape
                            if ((beamClip.Bolt.HeadWidth > 0) && (beamClip.Bolt.HeadThickness > 0))
                            {
                                //Mapping to Nut attribute for Top Nut
                                nut.ShapeLength = beamClip.Bolt.HeadThickness;
                                nut.ShapeWidth1 = beamClip.Bolt.HeadWidth;
                                nut.ShapeType = beamClip.Bolt.HeadType;

                                //Top Nut
                                nutMatrix = new Matrix4X4();
                                nutMatrix.Origin = new Position(0, -beamClip.BoltOffset, beamClip.Bolt.BoltLength - beamClip.ClipHeight1 + beamClip.ClipHeight2 + clampThickness - beamClip.Bolt.HeadThickness);
                                AddNut(nut, nutMatrix, outputs, outputName + "Nut1");
                                Projection3d nut1Ouput = (Projection3d)outputs[outputName + "Nut1"];
                                nut1Ouput.Transform(matrix);
                                if (objectColl != null)
                                    objectColl.Add(outputName + "Nut1");

                                //Bottom nut
                                nutMatrix = new Matrix4X4();
                                nutMatrix.Origin = new Position(0, -beamClip.BoltOffset, beamClip.ClipThickness);
                                AddNut(beamClip.Nut, nutMatrix, outputs, outputName + "Nut2");
                                Projection3d nut2Ouput = (Projection3d)outputs[outputName + "Nut2"];
                                nut2Ouput.Transform(matrix);
                                if (objectColl != null)
                                    objectColl.Add(outputName + "Nut2");
                            }
                        }
                        break;
                    case 5:     //P Shape
                        pointCollection = new Collection<Position>();
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, 0, 0));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, 0, -(beamClip.ClipHeight1 - 2 * beamClip.ClipThickness)));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, -(beamClip.ClipWidth2 - beamClip.ClipThickness), -(beamClip.ClipHeight1 - 2 * beamClip.ClipThickness)));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, -(beamClip.ClipWidth2 - beamClip.ClipThickness), -(beamClip.ClipHeight1 + beamClip.ClipHeight2 - beamClip.ClipThickness)));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, -(beamClip.ClipWidth2 - 2 * beamClip.ClipThickness), -(beamClip.ClipHeight1 + beamClip.ClipHeight2 - beamClip.ClipThickness)));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, -(beamClip.ClipWidth2 - 2 * beamClip.ClipThickness), -(beamClip.ClipHeight1 - beamClip.ClipThickness)));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, beamClip.ClipThickness, -(beamClip.ClipHeight1 - beamClip.ClipThickness)));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, beamClip.ClipThickness, beamClip.ClipThickness));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, -(beamClip.ClipWidth1 - beamClip.ClipThickness), beamClip.ClipThickness));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, -(beamClip.ClipWidth1 - beamClip.ClipThickness), 0));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, 0, 0));

                        projectionBody = new Projection3d(new LineString3d(pointCollection), new Vector(beamClip.ClipDepth, 0, 0), beamClip.ClipDepth, true);
                        projectionBody.Transform(matrix);
                        outputs.Add(outputName + "Clip", projectionBody);
                        if (objectColl != null)
                            objectColl.Add(outputName + "Clip");

                        //Bolts and Nuts
                        if ((beamClip.Bolt.BoltLength > 0) && (beamClip.Bolt.BoltDiameter > 0))
                        {
                            //Bolt Shape
                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(0, -beamClip.BoltOffset, -beamClip.ClipHeight1 + 2 * beamClip.ClipThickness + clampThickness);
                            symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(1, 0, 0));
                            Projection3d boltCylinder = symbolGeometryHelper.CreateCylinder(null, beamClip.Bolt.BoltDiameter / 2, beamClip.Bolt.BoltLength - beamClip.Bolt.HeadThickness);
                            boltCylinder.Transform(matrix);
                            outputs.Add(outputName + "Bolt", boltCylinder);
                            if (objectColl != null)
                                objectColl.Add(outputName + "Bolt");

                            //Nut Shape
                            if ((beamClip.Bolt.HeadWidth > 0) && (beamClip.Bolt.HeadThickness > 0))
                            {
                                //Mapping to Nut attribute for Top Nut
                                nut.ShapeLength = beamClip.Bolt.HeadThickness;
                                nut.ShapeWidth1 = beamClip.Bolt.HeadWidth;
                                nut.ShapeType = beamClip.Bolt.HeadType;

                                //Top Nut
                                nutMatrix = new Matrix4X4();
                                nutMatrix.Origin = new Position(0, -beamClip.BoltOffset, beamClip.Bolt.BoltLength - beamClip.ClipHeight1 + 2 * beamClip.ClipThickness + clampThickness - beamClip.Bolt.HeadThickness);
                                AddNut(nut, nutMatrix, outputs, outputName + "Nut1");
                                Projection3d nut1Ouput = (Projection3d)outputs[outputName + "Nut1"];
                                nut1Ouput.Transform(matrix);
                                if (objectColl != null)
                                    objectColl.Add(outputName + "Nut1");

                                //Bottom nut
                                nutMatrix = new Matrix4X4();
                                nutMatrix.Origin = new Position(0, -beamClip.BoltOffset, beamClip.ClipThickness);
                                AddNut(beamClip.Nut, nutMatrix, outputs, outputName + "Nut2");
                                Projection3d nut2Ouput = (Projection3d)outputs[outputName + "Nut2"];
                                nut2Ouput.Transform(matrix);
                                if (objectColl != null)
                                    objectColl.Add(outputName + "Nut2");
                            }
                        }
                        break;
                    case 6:     //Q Shape
                        pointCollection = new Collection<Position>();
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, 0, 0));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, 0, -(beamClip.ClipHeight1 - 2 * beamClip.ClipThickness)));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, -beamClip.ClipWidth2, -(beamClip.ClipHeight1 - 2 * beamClip.ClipThickness)));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, -beamClip.ClipWidth2, -(beamClip.ClipHeight1 + beamClip.ClipHeight2 - 2 * beamClip.ClipThickness)));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, -(beamClip.ClipWidth2 + beamClip.ClipWidth3 - beamClip.ClipThickness), -(beamClip.ClipHeight1 + beamClip.ClipHeight2 - 2 * beamClip.ClipThickness)));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, -(beamClip.ClipWidth2 + beamClip.ClipWidth3 - beamClip.ClipThickness), -(beamClip.ClipHeight1 + beamClip.ClipHeight2 - beamClip.ClipThickness)));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, -(beamClip.ClipWidth2 - beamClip.ClipThickness), -(beamClip.ClipHeight1 + beamClip.ClipHeight2 - beamClip.ClipThickness)));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, -(beamClip.ClipWidth2 - beamClip.ClipThickness), -(beamClip.ClipHeight1 - beamClip.ClipThickness)));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, beamClip.ClipThickness, -(beamClip.ClipHeight1 - beamClip.ClipThickness)));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, beamClip.ClipThickness, beamClip.ClipThickness));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, -(beamClip.ClipWidth1 - beamClip.ClipThickness), beamClip.ClipThickness));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, -(beamClip.ClipWidth1 - beamClip.ClipThickness), 0));
                        pointCollection.Add(new Position(-beamClip.ClipDepth / 2, 0, 0));

                        projectionBody = new Projection3d(new LineString3d(pointCollection), new Vector(beamClip.ClipDepth, 0, 0), beamClip.ClipDepth, true);
                        projectionBody.Transform(matrix);
                        outputs.Add(outputName + "Clip", projectionBody);
                        if (objectColl != null)
                            objectColl.Add(outputName + "Clip");

                        //Bolts and Nuts
                        if ((beamClip.Bolt.BoltLength > 0) && (beamClip.Bolt.BoltDiameter > 0))
                        {
                            //Bolt Shape
                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(0, -beamClip.BoltOffset, -beamClip.ClipHeight1 + 2 * beamClip.ClipThickness + clampThickness);
                            symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(1, 0, 0));
                            Projection3d boltCylinder = symbolGeometryHelper.CreateCylinder(null, beamClip.Bolt.BoltDiameter / 2, beamClip.Bolt.BoltLength - beamClip.Bolt.HeadThickness);
                            boltCylinder.Transform(matrix);
                            outputs.Add(outputName + "Bolt", boltCylinder);
                            if (objectColl != null)
                                objectColl.Add(outputName + "Bolt");

                            //Nut Shape
                            if ((beamClip.Bolt.HeadWidth > 0) && (beamClip.Bolt.HeadThickness > 0))
                            {
                                //Mapping to Nut attribute for Top Nut
                                nut.ShapeLength = beamClip.Bolt.HeadThickness;
                                nut.ShapeWidth1 = beamClip.Bolt.HeadWidth;
                                nut.ShapeType = beamClip.Bolt.HeadType;

                                //Top Nut
                                nutMatrix = new Matrix4X4();
                                nutMatrix.Origin = new Position(0, -beamClip.BoltOffset, beamClip.Bolt.BoltLength - beamClip.ClipHeight1 + 2 * beamClip.ClipThickness + clampThickness - beamClip.Bolt.HeadThickness);
                                AddNut(nut, nutMatrix, outputs, outputName + "Nut1");
                                Projection3d nut1Ouput = (Projection3d)outputs[outputName + "Nut1"];
                                nut1Ouput.Transform(matrix);
                                if (objectColl != null)
                                    objectColl.Add(outputName + "Nut1");

                                //Bottom nut
                                nutMatrix = new Matrix4X4();
                                nutMatrix.Origin = new Position(0, -beamClip.BoltOffset, beamClip.ClipThickness);
                                AddNut(beamClip.Nut, nutMatrix, outputs, outputName + "Nut2");
                                Projection3d nut2Ouput = (Projection3d)outputs[outputName + "Nut2"];
                                nut2Ouput.Transform(matrix);
                                if (objectColl != null)
                                    objectColl.Add(outputName + "Nut2");
                            }
                        }
                        break;
                    case 7:     //2I Shape
                        //Top Box
                        symbolGeometryHelper = new SymbolGeometryHelper();
                        symbolGeometryHelper.ActivePosition = new Position(-beamClip.ClipDepth / 2, -beamClip.ClipWidth1, 0);
                        symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        Projection3d topBox2IShape = symbolGeometryHelper.CreateBox(null, beamClip.ClipDepth, beamClip.ClipWidth1, beamClip.ClipThickness, 9);
                        topBox2IShape.Transform(matrix);
                        outputs.Add(outputName + "TopBox", topBox2IShape);
                        if (objectColl != null)
                            objectColl.Add(outputName + "TopBox");

                        //Bot Box
                        symbolGeometryHelper = new SymbolGeometryHelper();
                        symbolGeometryHelper.ActivePosition = new Position(-beamClip.ClipDepth / 2, -beamClip.ClipWidth1, -clampThickness - beamClip.ClipThickness);
                        symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        Projection3d botBox2IShape = symbolGeometryHelper.CreateBox(null, beamClip.ClipDepth, beamClip.ClipWidth1, beamClip.ClipThickness, 9);
                        botBox2IShape.Transform(matrix);
                        outputs.Add(outputName + "BotBox", botBox2IShape);
                        if (objectColl != null)
                            objectColl.Add(outputName + "BotBox");

                        //Bolt
                        if ((beamClip.Bolt.BoltLength > 0) && (beamClip.Bolt.BoltDiameter > 0))
                        {
                            //Bolt Shape
                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(0, -beamClip.BoltOffset, -(clampThickness / 2 + beamClip.Bolt.BoltLength / 2));
                            symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(1, 0, 0));
                            Projection3d boltCylinder = symbolGeometryHelper.CreateCylinder(null, beamClip.Bolt.BoltDiameter / 2, beamClip.Bolt.BoltLength - beamClip.Bolt.HeadThickness);
                            boltCylinder.Transform(matrix);
                            outputs.Add(outputName + "Bolt", boltCylinder);
                            if (objectColl != null)
                                objectColl.Add(outputName + "Bolt");

                            //Nut Shape
                            if ((beamClip.Bolt.HeadWidth > 0) && (beamClip.Bolt.HeadThickness > 0))
                            {
                                //Mapping to Nut attribute for Top Nut
                                nut.ShapeLength = beamClip.Bolt.HeadThickness;
                                nut.ShapeWidth1 = beamClip.Bolt.HeadWidth;
                                nut.ShapeType = beamClip.Bolt.HeadType;

                                //Top Nut
                                nutMatrix = new Matrix4X4();
                                nutMatrix.Origin = new Position(0, -beamClip.BoltOffset, beamClip.ClipThickness);
                                AddNut(nut, nutMatrix, outputs, outputName + "Nut1");
                                Projection3d nut1Ouput = (Projection3d)outputs[outputName + "Nut1"];
                                nut1Ouput.Transform(matrix);
                                if (objectColl != null)
                                    objectColl.Add(outputName + "Nut1");

                                //Bottom nut
                                nutMatrix = new Matrix4X4();
                                nutMatrix.Origin = new Position(0, -beamClip.BoltOffset, -clampThickness - beamClip.ClipThickness - beamClip.Bolt.HeadThickness);
                                AddNut(beamClip.Nut, nutMatrix, outputs, outputName + "Nut2");
                                Projection3d nut2Ouput = (Projection3d)outputs[outputName + "Nut2"];
                                nut2Ouput.Transform(matrix);
                                if (objectColl != null)
                                    objectColl.Add(outputName + "Nut2");
                            }
                        }
                        break;
                    case 8:     //I shape
                        //Top Box
                        symbolGeometryHelper = new SymbolGeometryHelper();
                        symbolGeometryHelper.ActivePosition = new Position(-beamClip.ClipDepth / 2, -beamClip.ClipWidth1, 0);
                        symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        Projection3d topBoxIshape = symbolGeometryHelper.CreateBox(null, beamClip.ClipDepth, beamClip.ClipWidth1, beamClip.ClipThickness, 9);
                        topBoxIshape.Transform(matrix);
                        outputs.Add(outputName + "TopBox", topBoxIshape);
                        if (objectColl != null)
                            objectColl.Add(outputName + "TopBox");

                        //Bolt
                        if ((beamClip.Bolt.BoltLength > 0) && (beamClip.Bolt.BoltDiameter > 0))
                        {
                            //Bolt Shape
                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(0, -beamClip.BoltOffset, -(clampThickness / 2 + beamClip.Bolt.BoltLength / 2));
                            symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(1, 0, 0));
                            Projection3d boltCylinder = symbolGeometryHelper.CreateCylinder(null, beamClip.Bolt.BoltDiameter / 2, beamClip.Bolt.BoltLength - beamClip.Bolt.HeadThickness);
                            boltCylinder.Transform(matrix);
                            outputs.Add(outputName + "Bolt", boltCylinder);
                            if (objectColl != null)
                                objectColl.Add(outputName + "Bolt");

                            //Nut Shape
                            if ((beamClip.Bolt.HeadWidth > 0) && (beamClip.Bolt.HeadThickness > 0))
                            {
                                //Mapping to Nut attribute for Top Nut
                                nut.ShapeLength = beamClip.Bolt.HeadThickness;
                                nut.ShapeWidth1 = beamClip.Bolt.HeadWidth;
                                nut.ShapeType = beamClip.Bolt.HeadType;

                                //Top Nut
                                nutMatrix = new Matrix4X4();
                                nutMatrix.Origin = new Position(0, -beamClip.BoltOffset, beamClip.ClipThickness);
                                AddNut(nut, nutMatrix, outputs, outputName + "Nut1");
                                Projection3d nut1Ouput = (Projection3d)outputs[outputName + "Nut1"];
                                nut1Ouput.Transform(matrix);
                                if (objectColl != null)
                                    objectColl.Add(outputName + "Nut1");

                                //Bottom nut
                                nutMatrix = new Matrix4X4();
                                nutMatrix.Origin = new Position(0, -beamClip.BoltOffset, -clampThickness - beamClip.Bolt.HeadThickness);
                                AddNut(beamClip.Nut, nutMatrix, outputs, outputName + "Nut2");
                                Projection3d nut2Ouput = (Projection3d)outputs[outputName + "Nut2"];
                                nut2Ouput.Transform(matrix);
                                if (objectColl != null)
                                    objectColl.Add(outputName + "Nut2");
                            }
                        }
                        break;
                }
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddBeamClip, "Error in AddBeamClip");
                }
            }
        }

        /// <summary>
        /// Defines the inputs for the MalleableBeamClampInputs shape.
        /// </summary>
        public struct MalleableBeamClampInputs
        {
            /// <summary>
            /// Inside distance between the legs of the strap. Must be greater than PipeOD. 
            /// Determines the spacing of the vertical legs of the strap as well as the bend radius for the curved part of the strap. 
            /// The nominal bend radius equals half the StrapWidthInside dimension.
            /// </summary>
            public int MalleableConfig;
            /// <summary>
            /// Inside height from the base of the strap to the top.
            /// </summary>
            public double TopWidth;
            /// <summary>
            /// Thickness of the rectangular stock used to make the strap. If zero, none of the strap shape is drawn.
            /// </summary>
            public double Depth;
            /// <summary>
            /// Width of the rectangular stock used to make the strap. If zero, none of the strap shape is drawn.
            /// </summary>
            public double Thickness;
            /// <summary>
            /// Adds a flat spot in the curved part of the strap. Must be less than or equal to StrapWidthInside.
            /// </summary>
            public string NutShape;
            /// <summary>
            /// Inside height from the base of the strap to the top.
            /// </summary>
            public string EyeNutShape;
            /// <summary>
            /// Top gap, between outside of pipe and inside of strap. 
            /// Affects the vertical position of the center of the bend radius for the curved part of the strap.
            /// </summary>
            public double RodTakeOut;
            /// <summary>
            /// Width to the outside of the wings, if any. If zero, or less than StrapWidthInside plus twice the StrapThickness, then wings are not drawn. 
            /// Also affects position of gussets.
            /// </summary>
            public double Angle;
            /// <summary>
            /// The effects this has are:
            /// 1. Strap graphic stops at the tangent point on the right side, as shown.
            /// 2. Wing, bolts and gussets are only included on the left side
            /// </summary>
            public double OverLength;
            /// <summary>
            /// Top gap, between outside of pipe and inside of strap. 
            /// Affects the vertical position of the center of the bend radius for the curved part of the strap.
            /// </summary>
            public double Pin1Diameter;
            /// <summary>
            /// Width to the outside of the wings, if any. If zero, or less than StrapWidthInside plus twice the StrapThickness, then wings are not drawn. 
            /// Also affects position of gussets.
            /// </summary>
            public double Pin1Length;
            /// <summary>
            /// The effects this has are:
            /// 1. Strap graphic stops at the tangent point on the right side, as shown.
            /// 2. Wing, bolts and gussets are only included on the left side
            /// </summary>
            public double Pin2Diameter;
            /// <summary>
            /// For split clamp-type tubing straps, creates a gap at the top and splits the strap into two graphics.
            /// Can be zero or positive. If both this and StrapSplitExtension are zero, the strap is one-piece.
            /// </summary>
            public double Pin2Length;
        }

        /// <summary>
        /// Adds the Malleable Beam Clamp inputs.
        /// </summary>
        /// <param name="startIndex">The start index.</param>
        /// <param name="endIndex">The end index.</param>
        /// <param name="additionalInputs">The additional inputs.</param>
        /// <code>
        /// AddMalleableBCInputs(4, out endIndex, additionalInputs);
        /// </code>
        public void AddMalleableBeamClampInputs(int startIndex, out int endIndex, List<Input> additionalInputs)
        {
            try
            {
                additionalInputs.Add(new InputDouble(startIndex, "MalleableConfig", "MalleableConfig", 1, false));
                additionalInputs.Add(new InputDouble(++startIndex, "TopWidth", "TopWidth", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Depth", "Depth", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Thickness", "Thickness", 0, false));
                additionalInputs.Add(new InputString(++startIndex, "NutShape", "NutShape", "", false));
                additionalInputs.Add(new InputString(++startIndex, "EyeNutShape", "EyeNutShape", "", false));
                additionalInputs.Add(new InputDouble(++startIndex, "RodTakeOut", "RodTakeOut", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Angle1", "Angle1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "OverLength1", "OverLength1", 0, false));

                //Pin Inputs
                additionalInputs.Add(new InputDouble(++startIndex, "Pin1Diameter", "Pin1Diameter", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Pin1Length", "Pin1Length", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Pin2Diameter", "Pin2Diameter", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Pin2Length", "Pin2Length", 0, false));
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddMalleableBeamClampInputs, "Error in AddMalleableBeamClampInputs");
                }
            }
            endIndex = startIndex;
        }

        /// <summary>
        /// Adds the BeamClamp outputs.
        /// </summary>
        /// <param name="additionalOutputs">The additional outputs.</param>
        /// <code>
        /// AddMalleableBCOutputs(additionalOutputs);
        /// </code>
        public void AddMalleableBeamClampOutputs(List<OutputDefinition> additionalOutputs)
        {
            try
            {
                //These are the outputs for the Malleable Beam Clamp
                additionalOutputs.Add(new OutputDefinition("MalleableBC" + "Clip", "MalleableBC" + "Clip"));
                additionalOutputs.Add(new OutputDefinition("MalleableBC" + "Pin1", "MalleableBC" + "Pin1"));
                additionalOutputs.Add(new OutputDefinition("MalleableBC" + "Pin2", "MalleableBC" + "Pin2"));

                //Add Nut outputs
                additionalOutputs.Add(new OutputDefinition("MalleableBC" + "Nut", "MalleableBC" + "Nut"));

                //Add Eyenut outputs
                additionalOutputs.Add(new OutputDefinition("MalleableBC" + "EyeNut" + "TOP_CYL_1", "MalleableBC" + "EyeNut" + "TOP_CYL_1"));
                additionalOutputs.Add(new OutputDefinition("MalleableBC" + "EyeNut" + "TOP_CYL_2", "MalleableBC" + "EyeNut" + "TOP_CYL_2"));
                additionalOutputs.Add(new OutputDefinition("MalleableBC" + "EyeNut" + "BOT_CYL_1", "MalleableBC" + "EyeNut" + "BOT_CYL_1"));
                additionalOutputs.Add(new OutputDefinition("MalleableBC" + "EyeNut" + "BOT_CYL_2", "MalleableBC" + "EyeNut" + "BOT_CYL_2"));
                additionalOutputs.Add(new OutputDefinition("MalleableBC" + "EyeNut" + "BOTTOM", "MalleableBC" + "EyeNut" + "BOTTOM"));
                additionalOutputs.Add(new OutputDefinition("MalleableBC" + "EyeNut" + "Nut1", "MalleableBC" + "EyeNut" + "Nut1"));
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddMalleableBeamClampOutputs, "Error in AddMalleableBeamClampOutputs");
                }
            }
        }

        /// <summary>
        /// This method will be called by user symbol to get value of an input(in this case, MalleableBeamClamp input structure)during construction of outputs. 
        /// This method will return the value of the MalleableBeamClampInputs struct object.
        /// </summary>
        /// <param name="startIndex">The start index.</param>
        /// <param name="endIndex">The end index.</param>
        /// <returns></returns>
        ///<code>
        ///MalleableBeamClampInputs malleableBeamClampInputs = LoadMaleableBCData(4, out endIndex);
        ///startIndex = endIndex;
        ///</code>
        public MalleableBeamClampInputs LoadMaleableBCData(int startIndex, out int endIndex)
        {
            MalleableBeamClampInputs malleableBeamClampInputs = new MalleableBeamClampInputs();
            try
            {
                malleableBeamClampInputs.MalleableConfig = (int)GetDoubleInputValue(startIndex);
                malleableBeamClampInputs.TopWidth = GetDoubleInputValue(++startIndex);
                malleableBeamClampInputs.Depth = GetDoubleInputValue(++startIndex);
                malleableBeamClampInputs.Thickness = GetDoubleInputValue(++startIndex);
                malleableBeamClampInputs.NutShape = (string)GetStringInputValue(++startIndex);
                malleableBeamClampInputs.EyeNutShape = (string)GetStringInputValue(++startIndex);
                malleableBeamClampInputs.RodTakeOut = GetDoubleInputValue(++startIndex);
                malleableBeamClampInputs.Angle = GetDoubleInputValue(++startIndex);
                malleableBeamClampInputs.OverLength = GetDoubleInputValue(++startIndex);
                malleableBeamClampInputs.Pin1Diameter = GetDoubleInputValue(++startIndex);
                malleableBeamClampInputs.Pin1Length = GetDoubleInputValue(++startIndex);
                malleableBeamClampInputs.Pin2Diameter = GetDoubleInputValue(++startIndex);
                malleableBeamClampInputs.Pin2Length = GetDoubleInputValue(++startIndex);
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadMaleableBCData, "Error in LoadMaleableBCData");
                }
            }
            endIndex = startIndex;
            return malleableBeamClampInputs;
        }

        /// <summary>
        /// This method will be called by user symbol to get value of an input(in this case, EyeNut input structure)during construction of outputs. 
        /// This method will return the value of the EyeNutInputs struct object.
        /// </summary>
        /// <param name="refShapeName">part name of the auxiliary table.</param>
        /// <returns></returns>
        ///<code>
        ///eyeNut = LoadEyeNutDataByQuery(refShapeName);
        ///</code>
        public EyeNutInputs LoadEyeNutDataByQuery(string refShapeName)
        {
            EyeNutInputs eyeNut = new EyeNutInputs();
            try
            {
                if (!(refShapeName == "" || refShapeName == "No Value"))
                {
                    Catalog plantCatalog = MiddleServiceProvider.SiteMgr.ActiveSite.ActivePlant.PlantCatalog;
                    BusinessObject eyeNutAuxTable = plantCatalog.GetNamedObject(refShapeName);
                    try
                    {
                        eyeNut.InnerWidth1 = (double)((PropertyValueDouble)eyeNutAuxTable.GetPropertyValue("IJUAhsElongatedEye", "InnerWidth1")).PropValue;
                    }
                    catch
                    {
                        eyeNut.InnerWidth1 = 0;
                    }
                    try
                    {
                        eyeNut.InnerWidth2 = (double)((PropertyValueDouble)eyeNutAuxTable.GetPropertyValue("IJUAhsElongatedEye", "InnerWidth2")).PropValue;
                    }
                    catch
                    {
                        eyeNut.InnerWidth2 = 0;
                    }

                    try
                    {
                        eyeNut.InnerLength1 = (double)((PropertyValueDouble)eyeNutAuxTable.GetPropertyValue("IJUAhsElongatedEye", "InnerLength1")).PropValue;
                    }
                    catch
                    {
                        eyeNut.InnerLength1 = 0;
                    }
                    try
                    {
                        eyeNut.InnerLength2 = (double)((PropertyValueDouble)eyeNutAuxTable.GetPropertyValue("IJUAhsElongatedEye", "InnerLength2")).PropValue;
                    }
                    catch
                    {
                        eyeNut.InnerLength2 = 0;
                    }
                    try
                    {
                        eyeNut.Thickness1 = (double)((PropertyValueDouble)eyeNutAuxTable.GetPropertyValue("IJUAhsThickness1", "Thickness1")).PropValue;
                    }
                    catch
                    {
                        eyeNut.Thickness1 = 0;
                    }
                    try
                    {
                        eyeNut.OverLength1 = (double)((PropertyValueDouble)eyeNutAuxTable.GetPropertyValue("IJUAhsOverLength1", "OverLength1")).PropValue;
                    }
                    catch
                    {
                        eyeNut.OverLength1 = 0;
                    }

                }
                eyeNut.Nut = LoadNutDataByQuery(refShapeName, 1);
                return eyeNut;
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadEyeNutDataByQuery, "Error in LoadEyeNutDataByQuery");
                }
                return eyeNut;
            }
        }

        /// <summary>
        /// Adds the MalleablBC.
        /// </summary>
        /// <param name="malleableBeamClampInputs">My MalleableBeamClamp shape.</param>
        /// <param name="flangeThickness">My FlangeThickness.</param>
        /// <param name="flangeWidth">My FlangeWidthe.</param>
        /// <param name="matrix">The matrix.</param>
        /// <param name="outputs">The outputs.</param>
        /// <param name="outputName">Name of the output.</param>
        /// <code>
        ///   Matrix4X4 matrix = new Matrix4X4();
        ///   matrix.Origin = new Position(0, 0, 0);
        ///   AddMalleablBC(malleableBeamClampInputs, flangeThickness, flangeWidth, matrix, m_PhysicalAspect.Outputs, "MalleableBC");
        /// </code>
        public void AddMalleablBeamClamp(MalleableBeamClampInputs malleableBeamClampInputs, Double flangeThickness, Double flangeWidth, Matrix4X4 matrix, OutputDictionary outputs, String outputName)
        {
            try
            {
                Double diagLength, angle, rotAngle, zOffset;
                NutInputs nut = new NutInputs();
                EyeNutInputs eyeNut = new EyeNutInputs();
                Line3d line;
                SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();
                Matrix4X4 tempMatrix = new Matrix4X4();
                Arc3d arc;
                //Load Nut Attributes from Query
                if (malleableBeamClampInputs.NutShape != "")
                    nut = LoadNutDataByQuery(malleableBeamClampInputs.NutShape, 1);

                //Load EyeNut Attributes from Query
                if (malleableBeamClampInputs.EyeNutShape != "")
                    eyeNut = LoadEyeNutDataByQuery(malleableBeamClampInputs.EyeNutShape);

                diagLength = Math.Sqrt(Math.Pow(flangeThickness, 2) + Math.Pow(malleableBeamClampInputs.TopWidth, 2));
                angle = (Math.PI / 2 - Math.Atan(malleableBeamClampInputs.TopWidth / flangeThickness));

                if ((malleableBeamClampInputs.MalleableConfig == 3) && (malleableBeamClampInputs.EyeNutShape != ""))    //For Eyenut attachement
                    zOffset = -malleableBeamClampInputs.RodTakeOut - malleableBeamClampInputs.Pin2Diameter / 2 + eyeNut.InnerLength2;
                else
                    zOffset = -malleableBeamClampInputs.RodTakeOut - malleableBeamClampInputs.Pin2Diameter / 2;

                //Add Clip
                Collection<ICurve> curveCollection = new Collection<ICurve>();

                symbolGeometryHelper = new SymbolGeometryHelper();
                symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                tempMatrix = new Matrix4X4();
                tempMatrix.SetIdentity();
                tempMatrix.Rotate(angle, new Vector(0, 0, 1));

                arc = new Arc3d(symbolGeometryHelper.CreateArc(null, diagLength / 2, (Math.PI)));
                arc.Transform(tempMatrix);

                tempMatrix = new Matrix4X4();
                tempMatrix.SetIdentity();
                tempMatrix.Translate(new Vector(-flangeWidth / 2 + (diagLength / 2) * Math.Cos(angle), (diagLength / 2) * Math.Sin(angle), malleableBeamClampInputs.Depth / 2));
                arc.Transform(tempMatrix);

                tempMatrix = new Matrix4X4();
                tempMatrix.SetIdentity();
                tempMatrix.Rotate(Math.PI / 2, new Vector(1, 0, 0));
                arc.Transform(tempMatrix);

                tempMatrix = new Matrix4X4();
                tempMatrix.SetIdentity();
                tempMatrix.Rotate(3 * Math.PI / 2, new Vector(0, 0, 1));
                arc.Transform(tempMatrix);
                curveCollection.Add(arc);

                line = new Line3d(new Position(-malleableBeamClampInputs.Depth / 2, flangeWidth / 2 - malleableBeamClampInputs.TopWidth, flangeThickness), new Position(-malleableBeamClampInputs.Depth / 2, flangeWidth / 2 - malleableBeamClampInputs.TopWidth - malleableBeamClampInputs.Thickness * Math.Cos(angle), flangeThickness + malleableBeamClampInputs.Thickness * Math.Sin(angle)));
                curveCollection.Add(line);

                symbolGeometryHelper = new SymbolGeometryHelper();
                symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                tempMatrix = new Matrix4X4();
                tempMatrix.Rotate(angle, new Vector(0, 0, 1));

                arc = new Arc3d(symbolGeometryHelper.CreateArc(null, (diagLength / 2) + malleableBeamClampInputs.Thickness, (Math.PI)));
                arc.Transform(tempMatrix);

                tempMatrix = new Matrix4X4();
                tempMatrix.SetIdentity();
                tempMatrix.Translate(new Vector(-flangeWidth / 2 + (diagLength / 2) * Math.Cos(angle), (diagLength / 2) * Math.Sin(angle), malleableBeamClampInputs.Depth / 2));
                arc.Transform(tempMatrix);

                tempMatrix = new Matrix4X4();
                tempMatrix.SetIdentity();
                tempMatrix.Rotate(Math.PI / 2, new Vector(1, 0, 0));
                arc.Transform(tempMatrix);

                tempMatrix = new Matrix4X4();
                tempMatrix.SetIdentity();
                tempMatrix.Rotate(3 * Math.PI / 2, new Vector(0, 0, 1));
                arc.Transform(tempMatrix);

                curveCollection.Add(arc);

                line = new Line3d(new Position(-malleableBeamClampInputs.Depth / 2, flangeWidth / 2 + malleableBeamClampInputs.Thickness * Math.Cos(angle), -malleableBeamClampInputs.Thickness * Math.Sin(angle)), new Position(-malleableBeamClampInputs.Depth / 2, 0, zOffset - malleableBeamClampInputs.Thickness / 2));
                curveCollection.Add(line);
                line = new Line3d(new Position(-malleableBeamClampInputs.Depth / 2, 0, zOffset - malleableBeamClampInputs.Thickness / 2), new Position(-malleableBeamClampInputs.Depth / 2, -(flangeWidth / 2 + malleableBeamClampInputs.Thickness * Math.Cos(angle)), -malleableBeamClampInputs.Thickness * Math.Sin(angle)));
                curveCollection.Add(line);

                symbolGeometryHelper = new SymbolGeometryHelper();
                symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                tempMatrix = new Matrix4X4();
                tempMatrix.Rotate(-angle, new Vector(0, 0, 1));

                arc = new Arc3d(symbolGeometryHelper.CreateArc(null, (diagLength / 2) + malleableBeamClampInputs.Thickness, -(Math.PI)));
                arc.Transform(tempMatrix);

                tempMatrix = new Matrix4X4();
                tempMatrix.SetIdentity();
                tempMatrix.Translate(new Vector(flangeWidth / 2 - (diagLength / 2) * Math.Cos(angle), (diagLength / 2) * Math.Sin(angle), malleableBeamClampInputs.Depth / 2));
                arc.Transform(tempMatrix);

                tempMatrix = new Matrix4X4();
                tempMatrix.SetIdentity();
                tempMatrix.Rotate(Math.PI / 2, new Vector(1, 0, 0));
                arc.Transform(tempMatrix);

                tempMatrix = new Matrix4X4();
                tempMatrix.SetIdentity();
                tempMatrix.Rotate(3 * Math.PI / 2, new Vector(0, 0, 1));
                arc.Transform(tempMatrix);

                curveCollection.Add(arc);

                line = new Line3d(new Position(-malleableBeamClampInputs.Depth / 2, -flangeWidth / 2 + malleableBeamClampInputs.TopWidth + malleableBeamClampInputs.Thickness * Math.Cos(angle), flangeThickness + malleableBeamClampInputs.Thickness * Math.Sin(angle)), new Position(-malleableBeamClampInputs.Depth / 2, -flangeWidth / 2 + malleableBeamClampInputs.TopWidth, flangeThickness));
                curveCollection.Add(line);

                symbolGeometryHelper = new SymbolGeometryHelper();
                symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                tempMatrix = new Matrix4X4();
                tempMatrix.Rotate(-angle, new Vector(0, 0, 1));

                arc = new Arc3d(symbolGeometryHelper.CreateArc(null, diagLength / 2, -(Math.PI)));
                arc.Transform(tempMatrix);

                tempMatrix = new Matrix4X4();
                tempMatrix.SetIdentity();
                tempMatrix.Translate(new Vector(flangeWidth / 2 - (diagLength / 2) * Math.Cos(angle), (diagLength / 2) * Math.Sin(angle), malleableBeamClampInputs.Depth / 2));
                arc.Transform(tempMatrix);

                tempMatrix = new Matrix4X4();
                tempMatrix.SetIdentity();
                tempMatrix.Rotate(Math.PI / 2, new Vector(1, 0, 0));
                arc.Transform(tempMatrix);

                tempMatrix = new Matrix4X4();
                tempMatrix.SetIdentity();
                tempMatrix.Rotate(3 * Math.PI / 2, new Vector(0, 0, 1));
                arc.Transform(tempMatrix);

                curveCollection.Add(arc);

                line = new Line3d(new Position(-malleableBeamClampInputs.Depth / 2, -flangeWidth / 2, 0), new Position(-malleableBeamClampInputs.Depth / 2, 0, zOffset + malleableBeamClampInputs.Thickness / 2));
                curveCollection.Add(line);

                line = new Line3d(new Position(-malleableBeamClampInputs.Depth / 2, 0, zOffset + malleableBeamClampInputs.Thickness / 2), new Position(-malleableBeamClampInputs.Depth / 2, flangeWidth / 2, 0));
                curveCollection.Add(line);

                ComplexString3d side1Collection = new ComplexString3d(curveCollection);
                Vector projectionVector = new Vector(1, 0, 0);
                Projection3d projectionBody = new Projection3d(side1Collection, projectionVector, malleableBeamClampInputs.Depth, true);
                projectionBody.Transform(matrix);
                outputs.Add(outputName + "Clip", projectionBody);

                //Add Top Pin
                if ((malleableBeamClampInputs.Pin1Diameter != 0) && (malleableBeamClampInputs.Pin1Length != 0))
                {
                    tempMatrix = new Matrix4X4();
                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(0, 1, 0));
                    tempMatrix.Rotate(Math.PI / 2, new Vector(1, 0, 0));
                    tempMatrix.Translate(tempMatrix.Transform(new Vector(0, -malleableBeamClampInputs.Pin1Diameter / 2, -malleableBeamClampInputs.Pin1Length / 2)));
                    Projection3d pinCylinder = symbolGeometryHelper.CreateCylinder(null, malleableBeamClampInputs.Pin1Diameter / 2, malleableBeamClampInputs.Pin1Length);
                    pinCylinder.Transform(tempMatrix);
                    pinCylinder.Transform(matrix);
                    outputs.Add(outputName + "Pin1", pinCylinder);
                }

                //Add Botoom Pin
                if ((malleableBeamClampInputs.Pin2Diameter != 0) && (malleableBeamClampInputs.Pin2Length != 0))
                {
                    tempMatrix = new Matrix4X4();
                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(0, 1, 0));
                    tempMatrix.Rotate(Math.PI / 2, new Vector(1, 0, 0));
                    tempMatrix.Rotate(Math.PI / 2, new Vector(0, 0, 1));
                    if (malleableBeamClampInputs.MalleableConfig == 3)
                    {
                        tempMatrix.Translate(tempMatrix.Transform(new Vector(0, -malleableBeamClampInputs.RodTakeOut - malleableBeamClampInputs.Pin2Diameter / 2 + eyeNut.InnerLength2, -malleableBeamClampInputs.Pin2Length / 2)));
                        Projection3d pinCylinder1 = symbolGeometryHelper.CreateCylinder(null, malleableBeamClampInputs.Pin2Diameter / 2, malleableBeamClampInputs.Pin2Length);
                        pinCylinder1.Transform(tempMatrix);
                        pinCylinder1.Transform(matrix);
                        outputs.Add(outputName + "Pin2", pinCylinder1);
                    }
                    else
                    {
                        tempMatrix.Translate(tempMatrix.Transform(new Vector(0, -malleableBeamClampInputs.RodTakeOut - malleableBeamClampInputs.Pin2Diameter / 2, -malleableBeamClampInputs.Pin2Length / 2)));
                        Projection3d pinCylinder1 = symbolGeometryHelper.CreateCylinder(null, malleableBeamClampInputs.Pin2Diameter / 2, malleableBeamClampInputs.Pin2Length);
                        pinCylinder1.Transform(tempMatrix);
                        pinCylinder1.Transform(matrix);
                        outputs.Add(outputName + "Pin2", pinCylinder1);
                    }
                }

                //Add Side Nut
                if ((malleableBeamClampInputs.MalleableConfig == 2) && (malleableBeamClampInputs.NutShape != ""))
                {
                    tempMatrix = new Matrix4X4();
                    tempMatrix.Origin = new Position(0, 0, -malleableBeamClampInputs.RodTakeOut - nut.ShapeLength);
                    AddNut(nut, tempMatrix, outputs, outputName + "Nut");
                }

                //Add EyeNut
                rotAngle = malleableBeamClampInputs.Angle;
                Double temp;
                temp = (eyeNut.InnerLength2 - eyeNut.OverLength1 - malleableBeamClampInputs.Pin2Diameter / 2) + (malleableBeamClampInputs.RodTakeOut - eyeNut.InnerLength2 + malleableBeamClampInputs.Pin2Diameter / 2) * Math.Cos(rotAngle);
                if ((malleableBeamClampInputs.MalleableConfig == 3) && (malleableBeamClampInputs.EyeNutShape != ""))
                {
                    tempMatrix = new Matrix4X4();

                    ArrayList eyeNutObjectCollection;
                    AddEyeNut(eyeNut, outputs, outputName + "EyeNut", out eyeNutObjectCollection);
                    tempMatrix.SetIdentity();
                    tempMatrix.Translate(new Vector((malleableBeamClampInputs.RodTakeOut - eyeNut.InnerLength2 + malleableBeamClampInputs.Pin2Diameter / 2.0) * (Math.Sin(rotAngle)), 0, temp));
                    Geometry3d geometry3d;
                    foreach (string item in eyeNutObjectCollection)
                    {
                        geometry3d = (Geometry3d)outputs[item];
                        geometry3d.Transform(tempMatrix);
                    }
                    tempMatrix.SetIdentity();
                    tempMatrix.Rotate(Math.PI, new Vector(0, 1, 0), new Position(0, 0, 0));
                    foreach (string item in eyeNutObjectCollection)
                    {
                        geometry3d = (Geometry3d)outputs[item];
                        geometry3d.Transform(tempMatrix);
                    }
                    tempMatrix.SetIdentity();
                    tempMatrix.Rotate(Math.PI / 2, new Vector(0, 0, 1));
                    foreach (string item in eyeNutObjectCollection)
                    {
                        geometry3d = (Geometry3d)outputs[item];
                        geometry3d.Transform(tempMatrix);
                    }
                    tempMatrix.SetIdentity();
                    tempMatrix.Rotate(rotAngle, new Vector(1, 0, 0));
                    foreach (string item in eyeNutObjectCollection)
                    {
                        geometry3d = (Geometry3d)outputs[item];
                        geometry3d.Transform(tempMatrix);
                    }
                }
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddMalleablBeamClamp, "Error in AddMalleablBeamClamp");
                }
            }
        }
        /// <summary>
        /// Returns the sectiondata.
        /// </summary>
        /// <param name="sectionStandard">Specifies the section Standard- String.</param>
        /// <param name="sectionType">Specifies the section Type- String.</param>
        /// <param name="sectionName">Specifies the section Name - String.</param>
        ///<code>
        ///GetSectionDataFromSection(string sectionStandard, string sectionType, string sectionName)
        ///</code>
        public SteelMember GetSectionDataFromSection(string sectionStandard, string sectionType, string sectionName)
        {

            SteelMember resultMember = new SteelMember();
            resultMember.partNumber = "";
            resultMember.sectionStandard = sectionStandard;
            resultMember.sectionName = sectionName;
            resultMember.sectionType = sectionType;
            CatalogStructHelper catalogStructHelper = new CatalogStructHelper();
            CrossSection crossSection = catalogStructHelper.GetCrossSection(resultMember.sectionStandard, resultMember.sectionName);
            try
            {
                resultMember.depth = (Double)((PropertyValueDouble)crossSection.GetPropertyValue("IStructCrossSectionDimensions", "Depth")).PropValue;
            }
            catch { resultMember.depth = 0; }
            try
            {
                resultMember.width = (Double)((PropertyValueDouble)crossSection.GetPropertyValue("IStructCrossSectionDimensions", "Width")).PropValue;
            }
            catch { resultMember.width = 0; }
            try
            {
                resultMember.webThickness = (Double)((PropertyValueDouble)crossSection.GetPropertyValue("IStructFlangedSectionDimensions", "tw")).PropValue;
            }
            catch { resultMember.webThickness = 0; }
            try
            {
                resultMember.flangeThickness = (Double)((PropertyValueDouble)crossSection.GetPropertyValue("IStructFlangedSectionDimensions", "tf")).PropValue;
            }
            catch { resultMember.flangeThickness = 0; }
            try
            {
                resultMember.unitWeight = (Double)((PropertyValueDouble)crossSection.GetPropertyValue("IStructCrossSectionUnitWeight", "UnitWeight")).PropValue;
            }
            catch { resultMember.unitWeight = 0; }
            try
            {
                resultMember.webDepth = (Double)((PropertyValueDouble)crossSection.GetPropertyValue("IStructFlangedSectionDimensions", "d")).PropValue;
            }
            catch { resultMember.webDepth = 0; }
            try
            {
                resultMember.flangeWidth = (Double)((PropertyValueDouble)crossSection.GetPropertyValue("IStructFlangedSectionDimensions", "bf")).PropValue;
            }
            catch { resultMember.flangeWidth = 0; }
            try
            {
                resultMember.centroidX = (Double)((PropertyValueDouble)crossSection.GetPropertyValue("IStructCrossSectionDesignProperties", "CentroidX")).PropValue;
            }
            catch { resultMember.centroidX = 0; }
            try
            {
                resultMember.centroidY = (Double)((PropertyValueDouble)crossSection.GetPropertyValue("IStructCrossSectionDesignProperties", "CentroidY")).PropValue;
            }
            catch { resultMember.centroidY = 0; }
            try
            {
                resultMember.B2B_Config = (int)((PropertyValueCodelist)crossSection.GetPropertyValue("IJUA2L", "bbConfiguration")).PropValue;
            }
            catch
            {
                resultMember.B2B_Config = 0;
            }
            try
            {
                resultMember.B2B_Spacing = (Double)((PropertyValueDouble)crossSection.GetPropertyValue("IJUA2L", "bb")).PropValue;
            }
            catch
            {
                resultMember.B2B_Spacing = 0;
            }
            if (crossSection.SupportsInterface("IJUA2L"))
            {
                try
                {
                    resultMember.B2B_SingleFlangeWidth = (Double)((PropertyValueDouble)crossSection.GetPropertyValue("IJUA2L", "b")).PropValue;
                }
                catch { resultMember.B2B_SingleFlangeWidth = 0; }
            }
            try
            {
                resultMember.HSS_NominalWallThickness = (Double)((PropertyValueDouble)crossSection.GetPropertyValue("IJUAHSS", "tnom")).PropValue;
            }
            catch
            {
                resultMember.HSS_NominalWallThickness = 0;
            }
            try
            {
                resultMember.HSS_DesignWallThickness = (Double)((PropertyValueDouble)crossSection.GetPropertyValue("IJUAHSS", "tdes")).PropValue;
            }
            catch
            {
                resultMember.HSS_DesignWallThickness = 0;
            }
            try
            {
                resultMember.HSSR_RatioWidthperThickness = (Double)((PropertyValueDouble)crossSection.GetPropertyValue("IJUAHSSR", "b_t")).PropValue;
            }
            catch
            {
                resultMember.HSSR_RatioWidthperThickness = 0;
            }
            try
            {
                resultMember.HSSR_RatioHeightperThickness = (Double)((PropertyValueDouble)crossSection.GetPropertyValue("IJUAHSSR", "h_t")).PropValue;
            }
            catch
            {
                resultMember.HSSR_RatioHeightperThickness = 0;
            }
            try
            {
                resultMember.HSSC_OuterDiameter = (Double)((PropertyValueDouble)crossSection.GetPropertyValue("IJUAHSSC", "OD")).PropValue;
            }
            catch
            {
                resultMember.HSSC_OuterDiameter = 0;
            }
            try
            {
                resultMember.HSSC_RatioDepthPerThickness = (Double)((PropertyValueDouble)crossSection.GetPropertyValue("IJUAHSSC", "D_t")).PropValue;
            }
            catch
            {
                resultMember.HSSC_RatioDepthPerThickness = 0;
            }
            try
            {
                resultMember.FB_FlangeGage = (Double)((PropertyValueDouble)crossSection.GetPropertyValue("IStructFlangedBoltGage", "gf")).PropValue;
            }
            catch
            {
                resultMember.FB_FlangeGage = 0;
            }
            try
            {
                resultMember.FB_WebGage = (Double)((PropertyValueDouble)crossSection.GetPropertyValue("IStructFlangedBoltGage", "gw")).PropValue;
            }
            catch
            {
                resultMember.FB_WebGage = 0;
            }
            try
            {
                resultMember.AB_LongSideGage = (Double)((PropertyValueDouble)crossSection.GetPropertyValue("IStructAngleBoltGage", "lsg")).PropValue;
            }
            catch
            {
                resultMember.AB_LongSideGage = 0;
            }
            try
            {
                resultMember.AB_LongSideGage1 = (Double)((PropertyValueDouble)crossSection.GetPropertyValue("IStructAngleBoltGage", "lsg1")).PropValue;
            }
            catch
            {
                resultMember.AB_LongSideGage1 = 0;
            }
            try
            {
                resultMember.AB_LongSideGage2 = (Double)((PropertyValueDouble)crossSection.GetPropertyValue("IStructAngleBoltGage", "lsg2")).PropValue;
            }
            catch
            {
                resultMember.AB_LongSideGage2 = 0;
            }
            try
            {
                resultMember.AB_ShortSideGage = (Double)((PropertyValueDouble)crossSection.GetPropertyValue("IStructAngleBoltGage", "ssg")).PropValue;
            }
            catch
            {
                resultMember.AB_ShortSideGage = 0;
            }
            try
            {
                resultMember.AB_ShortSideGage1 = (Double)((PropertyValueDouble)crossSection.GetPropertyValue("IStructAngleBoltGage", "ssg1")).PropValue;
            }
            catch
            {
                resultMember.AB_ShortSideGage1 = 0;
            }
            try
            {
                resultMember.AB_ShortSideGage2 = (Double)((PropertyValueDouble)crossSection.GetPropertyValue("IStructAngleBoltGage", "ssg2")).PropValue;
            }
            catch
            {
                resultMember.AB_ShortSideGage2 = 0;
            }

            return resultMember;

        }
        /// <summary>
        /// Returns the ShoeshapetopWidth.
        /// </summary>
        /// <param name="shoe">Structure for specifying the inputs for the shoe -ShoeInputs.</param>
        ///<code>
        ///GetLegWidthOnTop(ShoeInputs shoe)
        ///</code>
        public Double GetLegWidthOnTop(ShoeInputs shoe)
        {
            Double shoespacing;
            if (shoe.ShoeSpacingFrm == 1)
                shoespacing = (shoe.ShoeSpacing) * 2;
            else if (shoe.ShoeSpacingFrm == 2)
                shoespacing = (shoe.ShoeWidth) - (shoe.ShoeSpacing + shoe.ShoeThickness1) * 2;
            else
                shoespacing = shoe.ShoeSpacing;

            if (shoe.ShoeType == 1)
            {
                if (shoe.HasExtension == true)
                    return shoe.TopPlateThickness;
                else
                    return shoe.ShoeThickness1;

            }
            else if (shoe.ShoeType == 5 || shoe.ShoeType == 6)
            {
                if (shoe.HasExtension == true)
                {
                    if (shoe.ExtensionType == 0)
                        return shoe.ShoeWidth - (shoe.ShoeThickness1 * 2);
                    else
                        return shoe.ShoeWidth + (shoe.ShoeThickness1 * 2);
                }
                else
                {
                    return shoe.ShoeWidth;
                }
            }
            else if (shoe.ShoeType == 8 || shoe.ShoeType == 9)
            {
                return shoe.ShoeWidth;
            }
            else if (shoe.ShoeType == 4)
            {
                if (shoe.HasExtension == true)
                {
                    if (shoe.ExtensionType == 0)
                        return shoe.ShoeWidth - (shoe.ShoeThickness1 * 2);
                    else
                        return shoe.ShoeWidth + (shoe.TopPlateThickness * 2);
                }
                else
                {
                    return shoe.ShoeWidth;
                }
            }
            else
            {
                if (shoe.HasExtension == true)
                {
                    if (shoe.ExtensionType == 0)
                        return shoespacing;
                    else
                        return shoespacing + (shoe.ShoeThickness1 * 2) + (shoe.TopPlateThickness * 2);
                }
                else
                {
                    return shoespacing + (shoe.ShoeThickness1 * 2);
                }
            }
        }
        /// <summary>
        /// Returns the ShoeShapeLegHieght.
        /// </summary>
        /// <param name="width">Width of the Leg -Double.</param>
        /// <param name="pipeDiaameter">Diameter of the pipe -Double. </param>
        /// <param name="shoeHeight">Height of the shoe-Double.</param>
        /// <param name="legHeight">Height of the Leg-Double.</param>
        /// <param name="gap">Gap-Double.</param>
        ///<code>
        ///LegHeightToPipe(Double width,Double pipeDiaameter,Double shoeHeight,Double legHeight,Double gap)
        ///</code>
        public Double LegHeightToPipe(Double width, Double pipeDiaameter, Double shoeHeight, Double legHeight, Double gap)
        {
            Double angle = 0, adj = 0, difference = 0;
            if (gap > 0)
            {
                return shoeHeight - gap;
            }
            if (legHeight > 0)
            {
                return legHeight;
            }
            else
            {
                if (width >= pipeDiaameter)
                    difference = pipeDiaameter / 2;
                else
                {
                    angle = Math.Asin((width / 2) / (pipeDiaameter / 2)) * 180 / Math.PI;
                    adj = (Math.Cos(angle * (Math.PI / 180))) * (pipeDiaameter / 2);//* Math.PI / 180
                    difference = (pipeDiaameter / 2) - adj;
                }
                return shoeHeight + difference;
            }


        }
        /// <summary>
        /// Create the graphical representation of a T - Section Hanger Beam
        /// </summary>
        /// <param name="steelWidth">Double [The width of the cross section]</param>
        /// <param name="steelHeight">Double [The height of the cross section] </param>
        /// <param name="steelLength">Double [The width of the cross section]</param>
        /// <param name="flangeThickness">Double [The flange thickness of the cross section]</param>
        /// <param name="webThickness">Double [The web thickness of the cross section]</param>
        /// <param name="drawAsPlates">Boolean [Signifies whether the beam will be drawn as plates or continues]</param>
        /// <param name="outputs">IJDOutputCollection [Output Collection] </param>
        /// <param name="matrix">Matrix 4*4 [ Matrix that will be applied to entire resulting shape]</param>
        /// <param name="outputName">Height of the Leg-Double.</param>
        /// <param name="sectionStandard">String [Section Standard to be used to obtain cross section info]</param>
        /// <param name="sectionType">String [Section Type to be used to obtain cross section info]</param>
        /// <param name="sectionName">String [Section Name to be used to obtain cross section info]</param>
        /// <param name="hasExtension">Width of the Leg -Double.</param>
        /// <param name="extensionType">Double [Specifies extension plate type to be either 'Inside' OR 'Outside']</param>
        /// <param name="extensionPlateLength">Double [Extension Plate Length]</param>
        /// <param name="extensionPlateHeight">Double [Extension Plate Height]</param>
        /// <param name="extensionPlateThickness">GDouble [Extension Plate Thickness]</param>
        /// <param name="extensionPlateAxialPosition">Double [Specifies Extension plate's position along the pipe]</param>
        ///<param name="extensionGap">Double [Specifies Extension plate's vetical position]</param>
        /// <param name="extensionPlateAngle">Double [Specifies the angle between the extension plate and rest of beam]</param>
        ///<param name="extensionOffset">Double.</param>
        /// <param name="flangePlateLength">Double [Length for the Horizontalplate. Only used when plates are used]</param>
        ///<param name="flangePlateLength">Double [Length for the vertical plate. Only used when plates are used]</param>          
        ///<code>
        ///DrawBeam_T(double steelWidth, double steelHeight, double steelLength, double flangeThickness, double webThickness, Boolean drawAsPlates, OutputDictionary outputs, Matrix4X4 matrix, string outputName = "BeamShape", string name = "None", string sectionStandard = "No Value", string sectionType = "No Value", string sectionName = "No Value", Boolean hasExtension = false, double extensiontype = 0, double extensionPlateLength = 0, double extensionPlateHeight = 0, double extensionPlateThickness = 0, double extensionPlateAxialPosition = 0, double extensionGap = 0, double extensionPlateAngle = 0, double extensionOffset = 0, double diameter = 0, double flangePlateLength = 0, double webPlateLength = 0)
        ///</code>
        public void DrawBeam_T(double steelWidth, double steelHeight, double steelLength, double flangeThickness, double webThickness, Boolean drawAsPlates, OutputDictionary outputs, Matrix4X4 matrix, string outputName = "BeamShape", string name = "None", string sectionStandard = "No Value", string sectionType = "No Value", string sectionName = "No Value", Boolean hasExtension = false, double extensiontype = 0, double extensionPlateLength = 0, double extensionPlateHeight = 0, double extensionPlateThickness = 0, double extensionPlateAxialPosition = 0, double extensionGap = 0, double extensionPlateAngle = 0, double extensionOffset = 0, double diameter = 0, double flangePlateLength = 0, double webPlateLength = 0)
        {
            try
            {
                double[] vector = new double[3];
                double m_SteelWidth = 0, m_SteelHeight = 0, m_SteelLength = 0, m_FlangeThickness = 0, m_WebThickness = 0, m_TopPlateHorOffset = 0, ExtrusionOff = 0;

                SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();
                //Line3d line;
                Collection<ICurve> curveCollection = new Collection<ICurve>();
                if (sectionStandard != "No Value" && sectionType != "No Value" && sectionName != "No Value" && sectionStandard != "" && sectionType != "" && sectionName != "" && sectionStandard != null && sectionType != null && sectionName != null)
                {
                    SteelMember steel;
                    steel = GetSectionDataFromSection(sectionStandard, sectionType, sectionName);

                    // get dims from steel sectionn
                    m_FlangeThickness = steel.flangeThickness;
                    m_WebThickness = steel.webThickness;
                    m_SteelWidth = steel.width;
                    m_SteelHeight = steel.depth;

                    // Overide steel dims if there are some provided
                    if (steelWidth > 0)
                        m_SteelWidth = steelWidth;

                    if (steelHeight > 0)
                        m_SteelHeight = steelHeight;

                    if (flangeThickness > 0)
                        m_FlangeThickness = flangeThickness;

                    if (webThickness > 0)
                        m_WebThickness = webThickness;

                }
                // Else means user is custom specifying all dimensions
                else
                {
                    m_SteelWidth = steelWidth;
                    m_SteelHeight = steelHeight;
                    m_FlangeThickness = flangeThickness;
                    m_WebThickness = webThickness;
                }
                // Length is always user defined & never from a standard
                m_SteelLength = steelLength;
                // Set Length for base and Vertical Plate
                if (!(flangePlateLength > 0))
                    flangePlateLength = steelLength;

                if (!(webPlateLength > 0))
                    webPlateLength = steelLength;

                // Check for width error
                if (!(m_SteelWidth > 0))
                    ToDoListMessage = new ToDoListMessage(ToDoMessageTypes.ToDoMessageWarning, SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrShoeOtypeTWidth, "Width is required"));

                // Adjust leg len if there is a an extension
                if (hasExtension)
                {
                    m_SteelHeight = m_SteelHeight - extensionGap;
                }

                if (drawAsPlates)
                {

                    // Draw flange plate
                    Vector normal = new Vector(1, 0, 0);
                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(-m_SteelWidth / 2, 0, m_FlangeThickness / 2);//x--m_SteelWidth / 2
                    symbolGeometryHelper.SetOrientation(normal, normal.GetOrthogonalVector());
                    Projection3d flangePlate = (Projection3d)symbolGeometryHelper.CreateBox(null, m_SteelWidth, flangePlateLength, m_FlangeThickness);
                    flangePlate.Transform(matrix);
                    outputs.Add(outputName + "FlangePlate", flangePlate);

                    // Draw web plate
                    normal = new Vector(1, 0, 0);
                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(-m_WebThickness / 2, 0, m_SteelHeight / 2 + m_FlangeThickness / 2);//x--m_WebThickness/2--z--m_FlangeThickness
                    symbolGeometryHelper.SetOrientation(normal, normal.GetOrthogonalVector());
                    //symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    Projection3d webPlate = (Projection3d)symbolGeometryHelper.CreateBox(null, m_WebThickness, webPlateLength, m_SteelHeight - m_FlangeThickness);
                    webPlate.Transform(matrix);
                    outputs.Add(outputName + "WebPlate", webPlate);
                }
                else
                {
                    // Check for error
                    if (!(m_SteelLength > 0))
                        ToDoListMessage = new ToDoListMessage(ToDoMessageTypes.ToDoMessageWarning, SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrShoeOtypeTLength, "Length is required"));
                    ExtrusionOff = -m_SteelLength / 2;

                    // Composite used to create extruded beam
                    curveCollection.Add(new Line3d(new Position(m_SteelWidth / 2, ExtrusionOff, 0), new Position(-m_SteelWidth / 2, ExtrusionOff, 0)));
                    curveCollection.Add(new Line3d(new Position(-m_SteelWidth / 2, ExtrusionOff, 0), new Position(-m_SteelWidth / 2, ExtrusionOff, m_FlangeThickness)));
                    curveCollection.Add(new Line3d(new Position(-m_SteelWidth / 2, ExtrusionOff, m_FlangeThickness), new Position(-m_WebThickness / 2, ExtrusionOff, m_FlangeThickness)));
                    curveCollection.Add(new Line3d(new Position(-m_WebThickness / 2, ExtrusionOff, m_FlangeThickness), new Position(-m_WebThickness / 2, ExtrusionOff, m_SteelHeight)));
                    curveCollection.Add(new Line3d(new Position(-m_WebThickness / 2, ExtrusionOff, m_SteelHeight), new Position(m_WebThickness / 2, ExtrusionOff, m_SteelHeight)));
                    curveCollection.Add(new Line3d(new Position(m_WebThickness / 2, ExtrusionOff, m_SteelHeight), new Position(m_WebThickness / 2, ExtrusionOff, m_FlangeThickness)));
                    curveCollection.Add(new Line3d(new Position(m_WebThickness / 2, ExtrusionOff, m_FlangeThickness), new Position(m_SteelWidth / 2, ExtrusionOff, m_FlangeThickness)));
                    curveCollection.Add(new Line3d(new Position(m_SteelWidth / 2, ExtrusionOff, m_FlangeThickness), new Position(m_SteelWidth / 2, ExtrusionOff, 0)));
                    // Extrusion created from cross section of beam
                    Projection3d lines = new Projection3d(new ComplexString3d(curveCollection), new Vector(0, 1, 0), m_SteelLength, true);
                    lines.Transform(matrix);
                    outputs.Add(outputName, lines);
                }

                if (hasExtension)
                {
                    //Determines lateral position of extension plate.
                    if ((int)extensiontype == 0)
                        m_TopPlateHorOffset = (m_WebThickness / 2) + (extensionPlateThickness / 2);
                    else
                        m_TopPlateHorOffset = -(m_WebThickness / 2) - (extensionPlateThickness / 2);

                    if (HgrCompareDoubleService.cmpdbl(extensionPlateHeight, 0) == true)
                        extensionPlateHeight = (extensionOffset + extensionGap) * Math.Cos(extensionPlateAngle);

                    symbolGeometryHelper = new SymbolGeometryHelper();
                    Matrix4X4 boxMatrix = new Matrix4X4();
                    boxMatrix.Rotate(extensionPlateAngle, new Vector(1, 0, 0));
                    symbolGeometryHelper.ActivePosition = new Position(m_TopPlateHorOffset - extensionPlateThickness / 2, extensionPlateAxialPosition, m_SteelHeight);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    Projection3d extPlate = (Projection3d)symbolGeometryHelper.CreateBox(null, extensionPlateThickness, extensionPlateLength, extensionPlateHeight);
                    extPlate.Transform(boxMatrix);
                    extPlate.Transform(matrix);
                    outputs.Add(outputName + "ExtPlate", extPlate);

                }
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrDrawBeam_T, "Error in DrawBeam_T");
            }
        }
        /// <summary>
        /// Create the graphical representation of a T - Section Hanger Beam
        /// </summary>
        /// <param name="steelWidth">Double [The width of the cross section]</param>
        /// <param name="steelHeight">Double [The height of the cross section] </param>
        /// <param name="steelLength">Double [The width of the cross section]</param>
        /// <param name="flangeThickness">Double [The flange thickness of the cross section]</param>
        /// <param name="webThickness">Double [The web thickness of the cross section]</param>
        /// <param name="drawAsPlates">Boolean [Signifies whether the beam will be drawn as plates or continues]</param>
        /// <param name="outputs">IJDOutputCollection [Output Collection] </param>
        /// <param name="matrix">Matrix 4*4 [ Matrix that will be applied to entire resulting shape]</param>
        /// <param name="outputName">Height of the Leg-Double.</param>
        /// <param name="sectionStandard">String [Section Standard to be used to obtain cross section info]</param>
        /// <param name="sectionType">String [Section Type to be used to obtain cross section info]</param>
        /// <param name="sectionName">String [Section Name to be used to obtain cross section info]</param>
        /// <param name="hasExtension">Width of the Leg -Double.</param>
        /// <param name="extensionType">Double [Specifies extension plate type to be either 'Inside' OR 'Outside']</param>
        /// <param name="extensionPlateLength">Double [Extension Plate Length]</param>
        /// <param name="extensionPlateHeight">Double [Extension Plate Height]</param>
        /// <param name="extensionPlateThickness">GDouble [Extension Plate Thickness]</param>
        /// <param name="extensionPlateAxialPosition">Double [Specifies Extension plate's position along the pipe]</param>
        ///<param name="extensionGap">Double [Specifies Extension plate's vetical position]</param>
        /// <param name="extensionPlateAngle">Double [Specifies the angle between the extension plate and rest of beam]</param>
        ///<param name="extensionOffset">Double.</param>
        /// <param name="flangePlateLength">Double [Length for the Horizontalplate. Only used when plates are used]</param>
        ///<param name="flangePlateLength">Double [Length for the vertical plate. Only used when plates are used]</param>          
        ///<code>
        ///DrawBeam_B2BL(double steelWidth, double steelHeight, double steelLength, double flangeThickness, double webThickness, Boolean drawAsPlates, OutputDictionary outputs, Matrix4X4 matrix, string outputName = "BeamShape", string name = "None", string sectionStandard = "No Value", string sectionType = "No Value", string sectionName = "No Value", Boolean hasExtension = false, double extensiontype = 0, double extensionPlateLength = 0, double extensionPlateHeight = 0, double extensionPlateThickness = 0, double extensionPlateAxialPosition = 0, double extensionGap = 0, double extensionPlateAngle = 0, double extensionOffset = 0, double diameter = 0, double flangePlateLength = 0, double webPlateLength = 0)
        ///</code>
        public void DrawBeam_B2BL(double steelWidth, double steelHeight, double steelLength, double flangeThickness, double webThickness, double B2BSpacing, Boolean drawAsPlates, OutputDictionary outputs, Matrix4X4 matrix, string outputName = "BeamShape", string name = "None", string sectionStandard = "No Value", string sectionType = "No Value", string sectionName = "No Value", Boolean hasExtension = false, double extensiontype = 0, double extensionPlateLength = 0, double extensionPlateHeight = 0, double extensionPlateThickness = 0, double extensionPlateAxialPosition = 0, double extensionGap = 0, double extensionPlateAngle = 0, double extensionOffset = 0, double flangePlateLength = 0, double webPlateLength = 0)
        {
            try
            {
                double[] vector = new double[3];
                double m_SteelWidth = 0, m_SteelHeight = 0, m_SteelLength = 0, m_FlangeThickness = 0, m_WebThickness = 0, m_TopPlateHorOffset = 0, ExtrusionOff = 0;

                SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();
                //Line3d line;
                Collection<ICurve> curveCollection = new Collection<ICurve>();
                // If NO section data is available through a standard
                if (sectionStandard != "No Value" && sectionType != "No Value" && sectionName != "No Value" && sectionStandard != "" && sectionType != "" && sectionName != "" && sectionStandard != null && sectionType != null && sectionName != null)
                {
                    SteelMember steel;
                    steel = GetSectionDataFromSection(sectionStandard, sectionType, sectionName);

                    m_FlangeThickness = steel.flangeThickness;
                    m_WebThickness = steel.webThickness;
                    m_SteelWidth = steel.width;
                    m_SteelHeight = steel.depth;

                    // Overide steel dims if there are some provided
                    if (steelWidth > 0)
                        m_SteelWidth = steelWidth;

                    if (steelHeight > 0)
                        m_SteelHeight = steelHeight;

                    if (flangeThickness > 0)
                        m_FlangeThickness = flangeThickness;

                    if (webThickness > 0)
                        m_WebThickness = webThickness;

                }
                else
                {
                    m_SteelWidth = steelWidth;
                    m_SteelHeight = steelHeight;
                    m_FlangeThickness = flangeThickness;
                    m_WebThickness = webThickness;
                }
                if (hasExtension)
                    m_SteelHeight = m_SteelHeight - extensionGap;

                // Length is always user defined & never from a standard
                m_SteelLength = steelLength;

                if (flangePlateLength > 0)
                {
                }
                else
                    flangePlateLength = steelLength;

                if (webPlateLength > 0)
                {
                }
                else
                    webPlateLength = steelLength;

                if (!(m_SteelWidth > 0))
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrShoeOtypeDrawBeam_B2BLWidth, "Width is required");
                }

                if (drawAsPlates)
                {
                    symbolGeometryHelper.ActivePosition = new Position(-(m_SteelWidth / 2), 0, m_FlangeThickness / 2);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    Projection3d flangePlate1 = (Projection3d)symbolGeometryHelper.CreateBox(OccurrenceConnection, m_SteelWidth / 2 - B2BSpacing / 2, flangePlateLength, m_FlangeThickness);
                    flangePlate1.Transform(matrix);
                    outputs.Add(outputName + "FlangePlate1", flangePlate1);

                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position((B2BSpacing / 2), 0, m_FlangeThickness / 2);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    Projection3d flangePlate2 = (Projection3d)symbolGeometryHelper.CreateBox(OccurrenceConnection, m_SteelWidth / 2 - B2BSpacing / 2, flangePlateLength, m_FlangeThickness);
                    flangePlate2.Transform(matrix);
                    outputs.Add(outputName + "FlangePlate2", flangePlate2);

                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(-(B2BSpacing / 2 + m_WebThickness), 0, m_SteelHeight / 2 + m_FlangeThickness / 2);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    Projection3d webPlate1 = (Projection3d)symbolGeometryHelper.CreateBox(OccurrenceConnection, m_WebThickness, webPlateLength, m_SteelHeight - m_FlangeThickness);
                    webPlate1.Transform(matrix);
                    outputs.Add(outputName + "WebPlate1", webPlate1);

                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position((B2BSpacing / 2), 0, m_SteelHeight / 2 + m_FlangeThickness / 2);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    Projection3d webPlate2 = (Projection3d)symbolGeometryHelper.CreateBox(OccurrenceConnection, m_WebThickness, webPlateLength, m_SteelHeight - m_FlangeThickness);
                    webPlate2.Transform(matrix);
                    outputs.Add(outputName + "WebPlate2", webPlate2);
                }
                else
                {
                    // Check for lentgh error
                    if (!(steelLength > 0))
                    {
                        RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrShoeOtypeDrawBeam_B2BLLength, "Length is required");
                    }
                    ExtrusionOff = -steelLength / 2;

                    // Composite used to create extruded beam
                    // First L
                    curveCollection.Add(new Line3d(new Position(m_SteelWidth / 2, ExtrusionOff, 0), new Position(B2BSpacing / 2, ExtrusionOff, 0)));
                    curveCollection.Add(new Line3d(new Position(m_SteelWidth / 2, ExtrusionOff, 0), new Position(m_SteelWidth / 2, ExtrusionOff, m_FlangeThickness)));
                    curveCollection.Add(new Line3d(new Position(B2BSpacing / 2 + m_WebThickness, ExtrusionOff, m_FlangeThickness), new Position(m_SteelWidth / 2, ExtrusionOff, m_FlangeThickness)));
                    curveCollection.Add(new Line3d(new Position(B2BSpacing / 2 + m_WebThickness, ExtrusionOff, m_FlangeThickness), new Position(B2BSpacing / 2 + m_WebThickness, ExtrusionOff, m_SteelHeight)));
                    curveCollection.Add(new Line3d(new Position(B2BSpacing / 2 + m_WebThickness, ExtrusionOff, m_SteelHeight), new Position(B2BSpacing / 2, ExtrusionOff, m_SteelHeight)));
                    curveCollection.Add(new Line3d(new Position(B2BSpacing / 2, ExtrusionOff, m_SteelHeight), new Position(B2BSpacing / 2, ExtrusionOff, 0)));
                    // Extrusion created from cross section of beam
                    Projection3d lines = new Projection3d(new ComplexString3d(curveCollection), new Vector(0, 1, 0), m_SteelLength, true);
                    lines.Transform(matrix);
                    outputs.Add(outputName + "sec1", lines);

                    // Second continous L
                    curveCollection = new Collection<ICurve>();
                    curveCollection.Add(new Line3d(new Position(-m_SteelWidth / 2, ExtrusionOff, 0), new Position(-B2BSpacing / 2, ExtrusionOff, 0)));
                    curveCollection.Add(new Line3d(new Position(-m_SteelWidth / 2, ExtrusionOff, 0), new Position(-m_SteelWidth / 2, ExtrusionOff, m_FlangeThickness)));
                    curveCollection.Add(new Line3d(new Position(-(B2BSpacing / 2 + m_WebThickness), ExtrusionOff, m_FlangeThickness), new Position(-m_SteelWidth / 2, ExtrusionOff, m_FlangeThickness)));
                    curveCollection.Add(new Line3d(new Position(-(B2BSpacing / 2 + m_WebThickness), ExtrusionOff, m_FlangeThickness), new Position(-(B2BSpacing / 2 + m_WebThickness), ExtrusionOff, m_SteelHeight)));
                    curveCollection.Add(new Line3d(new Position(-(B2BSpacing / 2 + m_WebThickness), ExtrusionOff, m_SteelHeight), new Position(-(B2BSpacing / 2), ExtrusionOff, m_SteelHeight)));
                    curveCollection.Add(new Line3d(new Position(-(B2BSpacing / 2), ExtrusionOff, m_SteelHeight), new Position(-(B2BSpacing / 2), ExtrusionOff, 0)));
                    // Extrusion created from cross section of beam
                    Projection3d lines2 = new Projection3d(new ComplexString3d(curveCollection), new Vector(0, 1, 0), m_SteelLength, true);
                    lines2.Transform(matrix);
                    outputs.Add(outputName + "sec2", lines2);
                }

                // Code that deals with extension plates
                if (hasExtension)
                {
                    // Determines lateral position of extension plate.
                    if ((int)extensiontype == 0)
                        m_TopPlateHorOffset = -(B2BSpacing / 2) + (extensionPlateThickness / 2);
                    else
                        m_TopPlateHorOffset = -(B2BSpacing / 2) - (extensionPlateThickness / 2) - (m_WebThickness);

                    if (HgrCompareDoubleService.cmpdbl(extensionPlateHeight, 0) == true)
                        extensionPlateHeight = (extensionOffset + extensionGap) * Math.Cos(extensionPlateAngle);// * Math.PI / 180);

                    symbolGeometryHelper = new SymbolGeometryHelper();
                    Matrix4X4 boxMatrix = new Matrix4X4();
                    boxMatrix.Rotate(extensionPlateAngle, new Vector(1, 0, 0));
                    symbolGeometryHelper.ActivePosition = new Position(-m_TopPlateHorOffset - extensionPlateThickness / 2, extensionPlateAxialPosition, m_SteelHeight);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    Projection3d extPlate1 = (Projection3d)symbolGeometryHelper.CreateBox(null, extensionPlateThickness, extensionPlateLength, extensionPlateHeight);
                    extPlate1.Transform(boxMatrix);
                    extPlate1.Transform(matrix);
                    outputs.Add(outputName + "ExtPlate 1", extPlate1);

                    symbolGeometryHelper = new SymbolGeometryHelper();
                    boxMatrix = new Matrix4X4();
                    boxMatrix.Rotate(extensionPlateAngle, new Vector(1, 0, 0));
                    symbolGeometryHelper.ActivePosition = new Position(m_TopPlateHorOffset - extensionPlateThickness / 2, extensionPlateAxialPosition, m_SteelHeight);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    Projection3d extPlate2 = (Projection3d)symbolGeometryHelper.CreateBox(null, extensionPlateThickness, extensionPlateLength, extensionPlateHeight);
                    extPlate2.Transform(boxMatrix);
                    extPlate2.Transform(matrix);
                    outputs.Add(outputName + "ExtPlate 2", extPlate2);
                }
            }
            catch (SmartPartSymbolException hgrEx)
            {
                throw hgrEx;
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrDrawBeam_B2BL, "Error in DrawBeam_B2BL");
            }
        }
        /// <summary>
        /// Create the graphical representation of a T - Section Hanger Beam
        /// </summary>
        /// <param name="steelWidth">Double [The width of the cross section]</param>
        /// <param name="steelHeight">Double [The height of the cross section] </param>
        /// <param name="steelLength">Double [The width of the cross section]</param>
        /// <param name="flangeThickness">Double [The flange thickness of the cross section]</param>
        /// <param name="webThickness">Double [The web thickness of the cross section]</param>
        /// <param name="drawAsPlates">Boolean [Signifies whether the beam will be drawn as plates or continues]</param>
        /// <param name="outputs">IJDOutputCollection [Output Collection] </param>
        /// <param name="matrix">Matrix 4*4 [ Matrix that will be applied to entire resulting shape]</param>
        /// <param name="outputName">Height of the Leg-Double.</param>
        /// <param name="sectionStandard">String [Section Standard to be used to obtain cross section info]</param>
        /// <param name="sectionType">String [Section Type to be used to obtain cross section info]</param>
        /// <param name="sectionName">String [Section Name to be used to obtain cross section info]</param>
        /// <param name="hasExtension">Width of the Leg -Double.</param>
        /// <param name="extensionType">Double [Specifies extension plate type to be either 'Inside' OR 'Outside']</param>
        /// <param name="extensionPlateLength">Double [Extension Plate Length]</param>
        /// <param name="extensionPlateHeight">Double [Extension Plate Height]</param>
        /// <param name="extensionPlateThickness">GDouble [Extension Plate Thickness]</param>
        /// <param name="extensionPlateAxialPosition">Double [Specifies Extension plate's position along the pipe]</param>
        ///<param name="extensionGap">Double [Specifies Extension plate's vetical position]</param>
        /// <param name="extensionPlateAngle">Double [Specifies the angle between the extension plate and rest of beam]</param>
        ///<param name="extensionOffset">Double.</param>
        /// <param name="flangePlateLength">Double [Length for the Horizontalplate. Only used when plates are used]</param>
        ///<param name="flangePlateLength">Double [Length for the vertical plate. Only used when plates are used]</param>          
        ///<code>
        ///DrawBeam_Cradle(double steelWidth, double steelHeight, double steelLength, double flangeThickness, double webThickness, Boolean drawAsPlates, OutputDictionary outputs, Matrix4X4 matrix, string outputName = "BeamShape", string name = "None", string sectionStandard = "No Value", string sectionType = "No Value", string sectionName = "No Value", Boolean hasExtension = false, double extensiontype = 0, double extensionPlateLength = 0, double extensionPlateHeight = 0, double extensionPlateThickness = 0, double extensionPlateAxialPosition = 0, double extensionGap = 0, double extensionPlateAngle = 0, double extensionOffset = 0, double diameter = 0, double flangePlateLength = 0, double webPlateLength = 0)
        ///</code>
        public void DrawBeam_Cradle(double steelWidth, double steelHeight, double steelLength, double flangeThickness, double webThickness, double legSpacing, Boolean drawAsPlates, OutputDictionary outputs, Matrix4X4 matrix, string outputName = "BeamShape", string name = "None", string sectionStandard = "No Value", string sectionType = "No Value", string sectionName = "No Value", Boolean hasExtension = false, double extensiontype = 0, double extensionPlateLength = 0, double extensionPlateHeight = 0, double extensionPlateThickness = 0, double extensionPlateAxialPosition = 0, double extensionGap = 0, double extensionPlateAngle = 0, double extensionOffset = 0, double flangePlateLength = 0, double webPlateLength = 0)
        {
            try
            {
                double[] vector = new double[3];
                double m_SteelWidth = 0, m_SteelHeight = 0, m_SteelLength = 0, m_FlangeThickness = 0, m_WebThickness = 0, m_TopPlateHorOffset = 0, ExtrusionOff = 0;

                SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();
                Collection<ICurve> curveCollection = new Collection<ICurve>();
                // If NO section data is available through a standard
                if (sectionStandard != "No Value" && sectionType != "No Value" && sectionName != "No Value" && sectionStandard != "" && sectionType != "" && sectionName != "" && sectionStandard != null && sectionType != null && sectionName != null)
                {
                    SteelMember steel;
                    steel = GetSectionDataFromSection(sectionStandard, sectionType, sectionName);

                    m_FlangeThickness = steel.flangeThickness;
                    m_WebThickness = steel.webThickness;
                    m_SteelWidth = steel.width;
                    m_SteelHeight = steel.depth;

                    // Overide steel dims if there are some provided
                    if (steelWidth > 0)
                        m_SteelWidth = steelWidth;

                    if (steelHeight > 0)
                        m_SteelHeight = steelHeight;

                    if (flangeThickness > 0)
                        m_FlangeThickness = flangeThickness;

                    if (webThickness > 0)
                        m_WebThickness = webThickness;

                }
                else
                {
                    m_SteelWidth = steelWidth;
                    m_SteelHeight = steelHeight;
                    m_FlangeThickness = flangeThickness;
                    m_WebThickness = webThickness;
                }
                // Adjust leg len if there is a an extension
                if (hasExtension)
                    m_SteelHeight = m_SteelHeight - extensionGap;

                // Length is always user defined & never from a standard
                m_SteelLength = steelLength;

                if (flangePlateLength > 0)
                {
                }
                else
                    flangePlateLength = steelLength;

                if (webPlateLength > 0)
                {
                }
                else
                    webPlateLength = steelLength;

                if (drawAsPlates)
                {
                    // Main plates that are used for shoe shape
                    symbolGeometryHelper.ActivePosition = new Position(m_SteelWidth / 2, 0, m_FlangeThickness / 2);
                    symbolGeometryHelper.SetOrientation(new Vector(-1, 0, 0), new Vector(0, 1, 0));
                    Projection3d flangePlate = (Projection3d)symbolGeometryHelper.CreateBox(null, m_SteelWidth, flangePlateLength, m_FlangeThickness);
                    flangePlate.Transform(matrix);
                    outputs.Add(outputName + "FlangePlate", flangePlate);

                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(-(legSpacing / 2) - m_WebThickness, 0, m_SteelHeight / 2 + m_FlangeThickness / 2);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    Projection3d webPlate1 = (Projection3d)symbolGeometryHelper.CreateBox(null, m_WebThickness, webPlateLength, m_SteelHeight - m_FlangeThickness);
                    webPlate1.Transform(matrix);
                    outputs.Add(outputName + "WebPlate 1", webPlate1);

                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position((legSpacing / 2) + m_WebThickness, 0, m_SteelHeight / 2 + m_FlangeThickness / 2);
                    symbolGeometryHelper.SetOrientation(new Vector(-1, 0, 0), new Vector(0, 1, 0));
                    Projection3d webPlate2 = (Projection3d)symbolGeometryHelper.CreateBox(null, m_WebThickness, webPlateLength, m_SteelHeight - m_FlangeThickness);
                    webPlate2.Transform(matrix);
                    outputs.Add(outputName + "WebPlate 2", webPlate2);
                }
                else
                {
                    // Check for lentgh error
                    if (!(steelLength > 0))
                    {
                        RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrShoeOtypeDrawBeam_CradleLength, "Length is required");
                    }
                    ExtrusionOff = -steelLength / 2;

                    // Composite used to create extruded beam
                    // First L
                    curveCollection.Add(new Line3d(new Position(m_SteelWidth / 2, ExtrusionOff, 0), new Position(-m_SteelWidth / 2, ExtrusionOff, 0)));
                    curveCollection.Add(new Line3d(new Position(-m_SteelWidth / 2, ExtrusionOff, 0), new Position(-m_SteelWidth / 2, ExtrusionOff, m_FlangeThickness)));
                    curveCollection.Add(new Line3d(new Position(-m_SteelWidth / 2, ExtrusionOff, m_FlangeThickness), new Position(-legSpacing / 2 - m_WebThickness, ExtrusionOff, m_FlangeThickness)));
                    curveCollection.Add(new Line3d(new Position(-legSpacing / 2 - m_WebThickness, ExtrusionOff, m_FlangeThickness), new Position(-legSpacing / 2 - m_WebThickness, ExtrusionOff, m_SteelHeight)));
                    curveCollection.Add(new Line3d(new Position(-legSpacing / 2 - m_WebThickness, ExtrusionOff, m_SteelHeight), new Position(-legSpacing / 2, ExtrusionOff, m_SteelHeight)));
                    curveCollection.Add(new Line3d(new Position(-legSpacing / 2, ExtrusionOff, m_SteelHeight), new Position(-legSpacing / 2, ExtrusionOff, m_FlangeThickness)));
                    curveCollection.Add(new Line3d(new Position(-legSpacing / 2, ExtrusionOff, m_FlangeThickness), new Position(legSpacing / 2, ExtrusionOff, m_FlangeThickness)));
                    curveCollection.Add(new Line3d(new Position(legSpacing / 2, ExtrusionOff, m_FlangeThickness), new Position(legSpacing / 2, ExtrusionOff, m_SteelHeight)));
                    curveCollection.Add(new Line3d(new Position(legSpacing / 2, ExtrusionOff, m_SteelHeight), new Position(legSpacing / 2 + m_WebThickness, ExtrusionOff, m_SteelHeight)));
                    curveCollection.Add(new Line3d(new Position(legSpacing / 2 + m_WebThickness, ExtrusionOff, m_SteelHeight), new Position(legSpacing / 2 + m_WebThickness, ExtrusionOff, m_FlangeThickness)));
                    curveCollection.Add(new Line3d(new Position(legSpacing / 2 + m_WebThickness, ExtrusionOff, m_FlangeThickness), new Position(m_SteelWidth / 2, ExtrusionOff, m_FlangeThickness)));
                    curveCollection.Add(new Line3d(new Position(m_SteelWidth / 2, ExtrusionOff, m_FlangeThickness), new Position(m_SteelWidth / 2, ExtrusionOff, 0)));
                    // Extrusion created from cross section of beam
                    Projection3d lines = new Projection3d(new ComplexString3d(curveCollection), new Vector(0, 1, 0), m_SteelLength, true);
                    lines.Transform(matrix);
                    outputs.Add(outputName, lines);
                }

                // Code that deals with extension plates
                if (hasExtension)
                {
                    // Determines lateral position of extension plate.
                    if ((int)extensiontype == 0)
                        m_TopPlateHorOffset = -(legSpacing / 2) + (extensionPlateThickness / 2);
                    else
                        m_TopPlateHorOffset = -(legSpacing / 2) - (extensionPlateThickness / 2) - (m_WebThickness);

                    if (HgrCompareDoubleService.cmpdbl(extensionPlateHeight, 0) == true)
                        extensionPlateHeight = (extensionOffset + extensionGap) * Math.Cos(extensionPlateAngle);// *Math.PI / 180;

                    // Draw extension plates
                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(-m_TopPlateHorOffset - extensionPlateThickness / 2, extensionPlateAxialPosition, extensionGap);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    Projection3d extPlate1 = (Projection3d)symbolGeometryHelper.CreateBox(null, extensionPlateThickness, extensionPlateLength, extensionPlateHeight);
                    Matrix4X4 boxMatrix = new Matrix4X4();
                    boxMatrix.Translate(new Vector(0, 0, m_SteelHeight - extensionGap));
                    boxMatrix.Rotate(extensionPlateAngle, new Vector(1, 0, 0));
                    extPlate1.Transform(boxMatrix);
                    extPlate1.Transform(matrix);
                    outputs.Add(outputName + "ExtPlate 1", extPlate1);

                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(m_TopPlateHorOffset - extensionPlateThickness / 2, extensionPlateAxialPosition, extensionGap);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    Projection3d extPlate2 = (Projection3d)symbolGeometryHelper.CreateBox(null, extensionPlateThickness, extensionPlateLength, extensionPlateHeight);
                    boxMatrix = new Matrix4X4();
                    boxMatrix.Translate(new Vector(0, 0, m_SteelHeight - extensionGap));
                    boxMatrix.Rotate(extensionPlateAngle, new Vector(1, 0, 0));
                    extPlate2.Transform(boxMatrix);
                    extPlate2.Transform(matrix);
                    outputs.Add(outputName + "ExtPlate 2", extPlate2);
                }
            }
            catch (SmartPartSymbolException hgrEx)
            {
                throw hgrEx;
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrDrawBeam_Cradle, "Error in DrawBeam_Cradle");
            }
        }
        /// <summary>
        /// Create the graphical representation of a T - Section Hanger Beam
        /// </summary>
        /// <param name="steelWidth">Double [The width of the cross section]</param>
        /// <param name="steelHeight">Double [The height of the cross section] </param>
        /// <param name="steelLength">Double [The width of the cross section]</param>
        /// <param name="flangeThickness">Double [The flange thickness of the cross section]</param>
        /// <param name="webThickness">Double [The web thickness of the cross section]</param>
        /// <param name="drawAsPlates">Boolean [Signifies whether the beam will be drawn as plates or continues]</param>
        /// <param name="outputs">IJDOutputCollection [Output Collection] </param>
        /// <param name="matrix">Matrix 4*4 [ Matrix that will be applied to entire resulting shape]</param>
        /// <param name="outputName">Height of the Leg-Double.</param>
        /// <param name="sectionStandard">String [Section Standard to be used to obtain cross section info]</param>
        /// <param name="sectionType">String [Section Type to be used to obtain cross section info]</param>
        /// <param name="sectionName">String [Section Name to be used to obtain cross section info]</param>
        /// <param name="hasExtension">Width of the Leg -Double.</param>
        /// <param name="extensionType">Double [Specifies extension plate type to be either 'Inside' OR 'Outside']</param>
        /// <param name="extensionPlateLength">Double [Extension Plate Length]</param>
        /// <param name="extensionPlateHeight">Double [Extension Plate Height]</param>
        /// <param name="extensionPlateThickness">GDouble [Extension Plate Thickness]</param>
        /// <param name="extensionPlateAxialPosition">Double [Specifies Extension plate's position along the pipe]</param>
        ///<param name="extensionGap">Double [Specifies Extension plate's vetical position]</param>
        /// <param name="extensionPlateAngle">Double [Specifies the angle between the extension plate and rest of beam]</param>
        ///<param name="extensionOffset">Double.</param>
        /// <param name="flangePlateLength">Double [Length for the Horizontalplate. Only used when plates are used]</param>
        ///<param name="flangePlateLength">Double [Length for the vertical plate. Only used when plates are used]</param>          
        ///<code>
        ///DrawBeam_C(double steelWidth, double steelHeight, double steelLength, double flangeThickness, double webThickness, Boolean drawAsPlates, OutputDictionary outputs, Matrix4X4 matrix, string outputName = "BeamShape", string name = "None", string sectionStandard = "No Value", string sectionType = "No Value", string sectionName = "No Value", Boolean hasExtension = false, double extensiontype = 0, double extensionPlateLength = 0, double extensionPlateHeight = 0, double extensionPlateThickness = 0, double extensionPlateAxialPosition = 0, double extensionGap = 0, double extensionPlateAngle = 0, double extensionOffset = 0, double diameter = 0, double flangePlateLength = 0, double webPlateLength = 0)
        ///</code>
        public void DrawBeam_C(double steelWidth, double steelHeight, double steelLength, double flangeThickness, double webThickness, double legSpacing, Boolean drawAsPlates, OutputDictionary outputs, Matrix4X4 matrix, string outputName = "BeamShape", string name = "None", string sectionStandard = "No Value", string sectionType = "No Value", string sectionName = "No Value", Boolean hasExtension = false, double extensiontype = 0, double extensionPlateLength = 0, double extensionPlateHeight = 0, double extensionPlateThickness = 0, double extensionPlateAxialPosition = 0, double extensionGap = 0, double extensionPlateAngle = 0, double extensionOffset = 0, double flangePlateLength = 0, double webPlateLength = 0)
        {
            try
            {
                double[] vector = new double[3];
                double m_SteelWidth = 0, m_SteelHeight = 0, m_SteelLength = 0, m_FlangeThickness = 0, m_WebThickness = 0, m_TopPlateHorOffset = 0, ExtrusionOff = 0;

                SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();
                Collection<ICurve> curveCollection = new Collection<ICurve>();
                // If NO section data is available through a standard
                if (sectionStandard != "No Value" && sectionType != "No Value" && sectionName != "No Value" && sectionStandard != "" && sectionType != "" && sectionName != "" && sectionStandard != null && sectionType != null && sectionName != null)
                {
                    SteelMember steel;
                    steel = GetSectionDataFromSection(sectionStandard, sectionType, sectionName);

                    m_FlangeThickness = steel.flangeThickness;
                    m_WebThickness = steel.webThickness;
                    m_SteelWidth = steel.width;
                    m_SteelHeight = steel.depth;

                    // Overide steel dims if there are some provided
                    if (steelWidth > 0)
                        m_SteelWidth = steelWidth;

                    if (steelHeight > 0)
                        m_SteelHeight = steelHeight;

                    if (flangeThickness > 0)
                        m_FlangeThickness = flangeThickness;

                    if (webThickness > 0)
                        m_WebThickness = webThickness;

                }
                else
                {
                    m_SteelWidth = steelWidth;
                    m_SteelHeight = steelHeight;
                    m_FlangeThickness = flangeThickness;
                    m_WebThickness = webThickness;
                }
                // Adjust leg len if there is a an extension
                if (hasExtension)
                    m_SteelHeight = m_SteelHeight - extensionGap;

                // Length is always user defined & never from a standard
                m_SteelLength = steelLength;

                if (flangePlateLength <= 0)
                    flangePlateLength = steelLength;

                if (webPlateLength <= 0)
                    webPlateLength = steelLength;

                if (drawAsPlates)
                {

                    ////// Draw web plate
                    // Main plates that are used for shoe shape
                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(-m_SteelWidth / 2, 0, m_FlangeThickness / 2);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    Projection3d flangePlate = (Projection3d)symbolGeometryHelper.CreateBox(null, m_SteelWidth, flangePlateLength, m_FlangeThickness);
                    flangePlate.Transform(matrix);
                    outputs.Add(outputName + "FlangePlate", flangePlate);

                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(-(legSpacing / 2) - m_WebThickness, 0, m_SteelHeight / 2 + m_FlangeThickness / 2);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    Projection3d webPlate1 = (Projection3d)symbolGeometryHelper.CreateBox(null, m_WebThickness, webPlateLength, m_SteelHeight - m_FlangeThickness);
                    webPlate1.Transform(matrix);
                    outputs.Add(outputName + "WebPlate 1", webPlate1);

                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position((legSpacing / 2) + m_WebThickness, 0, m_SteelHeight / 2 + m_FlangeThickness / 2);
                    symbolGeometryHelper.SetOrientation(new Vector(-1, 0, 0), new Vector(0, 1, 0));
                    Projection3d webPlate2 = (Projection3d)symbolGeometryHelper.CreateBox(null, m_WebThickness, webPlateLength, m_SteelHeight - m_FlangeThickness);
                    webPlate2.Transform(matrix);
                    outputs.Add(outputName + "WebPlate 2", webPlate2);
                }
                else
                {
                    // Check for lentgh error
                    if (!(steelLength > 0))
                    {
                        RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrShoeOtypeDrawBeam_CLength, "Length is required");
                    }
                    ExtrusionOff = -steelLength / 2;

                    // Composite used to create extruded beam
                    // First L
                    curveCollection.Add(new Line3d(new Position(m_SteelWidth / 2, ExtrusionOff, 0), new Position(-m_SteelWidth / 2, ExtrusionOff, 0)));
                    curveCollection.Add(new Line3d(new Position(-m_SteelWidth / 2, ExtrusionOff, 0), new Position(-m_SteelWidth / 2, ExtrusionOff, m_FlangeThickness)));
                    curveCollection.Add(new Line3d(new Position(-m_SteelWidth / 2, ExtrusionOff, m_FlangeThickness), new Position(-legSpacing / 2 - m_WebThickness, ExtrusionOff, m_FlangeThickness)));
                    curveCollection.Add(new Line3d(new Position(-legSpacing / 2 - m_WebThickness, ExtrusionOff, m_FlangeThickness), new Position(-legSpacing / 2 - m_WebThickness, ExtrusionOff, m_SteelHeight)));
                    curveCollection.Add(new Line3d(new Position(-legSpacing / 2 - m_WebThickness, ExtrusionOff, m_SteelHeight), new Position(-legSpacing / 2, ExtrusionOff, m_SteelHeight)));
                    curveCollection.Add(new Line3d(new Position(-legSpacing / 2, ExtrusionOff, m_SteelHeight), new Position(-legSpacing / 2, ExtrusionOff, m_FlangeThickness)));
                    curveCollection.Add(new Line3d(new Position(-legSpacing / 2, ExtrusionOff, m_FlangeThickness), new Position(legSpacing / 2, ExtrusionOff, m_FlangeThickness)));
                    curveCollection.Add(new Line3d(new Position(legSpacing / 2, ExtrusionOff, m_FlangeThickness), new Position(legSpacing / 2, ExtrusionOff, m_SteelHeight)));
                    curveCollection.Add(new Line3d(new Position(legSpacing / 2, ExtrusionOff, m_SteelHeight), new Position(legSpacing / 2 + m_WebThickness, ExtrusionOff, m_SteelHeight)));
                    curveCollection.Add(new Line3d(new Position(legSpacing / 2 + m_WebThickness, ExtrusionOff, m_SteelHeight), new Position(legSpacing / 2 + m_WebThickness, ExtrusionOff, m_FlangeThickness)));
                    curveCollection.Add(new Line3d(new Position(legSpacing / 2 + m_WebThickness, ExtrusionOff, m_FlangeThickness), new Position(m_SteelWidth / 2, ExtrusionOff, m_FlangeThickness)));
                    curveCollection.Add(new Line3d(new Position(m_SteelWidth / 2, ExtrusionOff, m_FlangeThickness), new Position(m_SteelWidth / 2, ExtrusionOff, 0)));
                    // Extrusion created from cross section of beam
                    Projection3d lines = new Projection3d(new ComplexString3d(curveCollection), new Vector(0, 1, 0), m_SteelLength, true);
                    lines.Transform(matrix);
                    outputs.Add(outputName, lines);
                }

                // Code that deals with extension plates
                if (hasExtension)
                {
                    // Determines lateral position of extension plate.
                    if ((int)extensiontype == 0)
                        m_TopPlateHorOffset = -(legSpacing / 2) + (extensionPlateThickness / 2);
                    else
                        m_TopPlateHorOffset = -(legSpacing / 2) - (extensionPlateThickness / 2) - (m_WebThickness);

                    if (HgrCompareDoubleService.cmpdbl(extensionPlateHeight, 0) == true)
                        extensionPlateHeight = (extensionOffset + extensionGap) * (Math.Cos(extensionPlateAngle));// * Math.PI / 180));

                    // Draw extension plates
                    symbolGeometryHelper = new SymbolGeometryHelper();
                    Matrix4X4 boxMatrix = new Matrix4X4();
                    symbolGeometryHelper.ActivePosition = new Position(m_TopPlateHorOffset - extensionPlateThickness / 2, extensionPlateAxialPosition, extensionGap);
                    boxMatrix.Translate(new Vector(0, 0, m_SteelHeight - extensionGap));
                    boxMatrix.Rotate(extensionPlateAngle, new Vector(1, 0, 0));
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    Projection3d extPlate1 = (Projection3d)symbolGeometryHelper.CreateBox(null, extensionPlateThickness, extensionPlateLength, extensionPlateHeight);
                    extPlate1.Transform(boxMatrix);
                    extPlate1.Transform(matrix);
                    outputs.Add(outputName + "ExtPlate 1", extPlate1);

                    symbolGeometryHelper = new SymbolGeometryHelper();
                    boxMatrix = new Matrix4X4();
                    symbolGeometryHelper.ActivePosition = new Position(-m_TopPlateHorOffset + extensionPlateThickness / 2, extensionPlateAxialPosition, extensionGap);
                    boxMatrix.Translate(new Vector(0, 0, m_SteelHeight - extensionGap));
                    boxMatrix.Rotate(extensionPlateAngle, new Vector(1, 0, 0));
                    symbolGeometryHelper.SetOrientation(new Vector(-1, 0, 0), new Vector(0, 1, 0));
                    Projection3d extPlate2 = (Projection3d)symbolGeometryHelper.CreateBox(null, extensionPlateThickness, extensionPlateLength, extensionPlateHeight);
                    extPlate2.Transform(boxMatrix);
                    extPlate2.Transform(matrix);
                    outputs.Add(outputName + "ExtPlate 2", extPlate2);
                }
            }
            catch (SmartPartSymbolException hgrEx)
            {
                throw hgrEx;
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrDrawBeam_C, "Error in DrawBeam_C");
            }
        }
        /// <summary>
        /// Create the graphical representation of a T - Section Hanger Beam
        /// </summary>
        /// <param name="steelWidth">Double [The width of the cross section]</param>
        /// <param name="steelHeight">Double [The height of the cross section] </param>
        /// <param name="steelLength">Double [The width of the cross section]</param>
        /// <param name="flangeThickness">Double [The flange thickness of the cross section]</param>
        /// <param name="webThickness">Double [The web thickness of the cross section]</param>
        /// <param name="drawAsPlates">Boolean [Signifies whether the beam will be drawn as plates or continues]</param>
        /// <param name="outputs">IJDOutputCollection [Output Collection] </param>
        /// <param name="matrix">Matrix 4*4 [ Matrix that will be applied to entire resulting shape]</param>
        /// <param name="outputName">Height of the Leg-Double.</param>
        /// <param name="sectionStandard">String [Section Standard to be used to obtain cross section info]</param>
        /// <param name="sectionType">String [Section Type to be used to obtain cross section info]</param>
        /// <param name="sectionName">String [Section Name to be used to obtain cross section info]</param>
        /// <param name="hasExtension">Width of the Leg -Double.</param>
        /// <param name="extensionType">Double [Specifies extension plate type to be either 'Inside' OR 'Outside']</param>
        /// <param name="extensionPlateLength">Double [Extension Plate Length]</param>
        /// <param name="extensionPlateHeight">Double [Extension Plate Height]</param>
        /// <param name="extensionPlateThickness">GDouble [Extension Plate Thickness]</param>
        /// <param name="extensionPlateAxialPosition">Double [Specifies Extension plate's position along the pipe]</param>
        ///<param name="extensionGap">Double [Specifies Extension plate's vetical position]</param>
        /// <param name="extensionPlateAngle">Double [Specifies the angle between the extension plate and rest of beam]</param>
        ///<param name="extensionOffset">Double.</param>
        /// <param name="flangePlateLength">Double [Length for the Horizontalplate. Only used when plates are used]</param>
        ///<param name="flangePlateLength">Double [Length for the vertical plate. Only used when plates are used]</param>          
        ///<code>
        ///DrawBeam_2L(double steelWidth, double steelHeight, double steelLength, double flangeThickness, double webThickness, Boolean drawAsPlates, OutputDictionary outputs, Matrix4X4 matrix, string outputName = "BeamShape", string name = "None", string sectionStandard = "No Value", string sectionType = "No Value", string sectionName = "No Value", Boolean hasExtension = false, double extensiontype = 0, double extensionPlateLength = 0, double extensionPlateHeight = 0, double extensionPlateThickness = 0, double extensionPlateAxialPosition = 0, double extensionGap = 0, double extensionPlateAngle = 0, double extensionOffset = 0, double diameter = 0, double flangePlateLength = 0, double webPlateLength = 0)
        ///</code>
        public void DrawBeam_2L(double steelWidth, double steelHeight, double steelLength, double flangeThickness, double webThickness, double spacing, Boolean drawAsPlates, OutputDictionary outputs, Matrix4X4 matrix, string outputName = "BeamShape", string name = "None", string sectionStandard = "No Value", string sectionType = "No Value", string sectionName = "No Value", Boolean hasExtension = false, double extensiontype = 0, double extensionPlateLength = 0, double extensionPlateHeight = 0, double extensionPlateThickness = 0, double extensionPlateAxialPosition = 0, double extensionGap = 0, double extensionPlateAngle = 0, double extensionOffset = 0, double diameter = 0, double flangePlateLength = 0, double webPlateLength = 0)
        {
            try
            {
                double[] vector = new double[3];
                double m_SteelWidth = 0, m_SteelHeight = 0, m_SteelLength = 0, m_FlangeThickness = 0, m_WebThickness = 0, m_TopPlateHorOffset = 0, ExtrusionOff = 0;

                SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();
                Collection<ICurve> curveCollection = new Collection<ICurve>();
                // If NO section data is available through a standard
                if (sectionStandard != "No Value" && sectionType != "No Value" && sectionName != "No Value" && sectionStandard != "" && sectionType != "" && sectionName != "" && sectionStandard != null && sectionType != null && sectionName != null)
                {
                    SteelMember steel;
                    steel = GetSectionDataFromSection(sectionStandard, sectionType, sectionName);

                    m_FlangeThickness = steel.flangeThickness;
                    m_WebThickness = steel.webThickness;
                    m_SteelWidth = steel.width;
                    m_SteelHeight = steel.depth;

                    // Overide steel dims if there are some provided
                    if (steelWidth > 0)
                        m_SteelWidth = steelWidth;

                    if (steelHeight > 0)
                        m_SteelHeight = steelHeight;

                    if (flangeThickness > 0)
                        m_FlangeThickness = flangeThickness;

                    if (webThickness > 0)
                        m_WebThickness = webThickness;

                }
                else
                {
                    m_SteelWidth = steelWidth;
                    m_SteelHeight = steelHeight;
                    m_FlangeThickness = flangeThickness;
                    m_WebThickness = webThickness;
                }
                // Adjust leg len if there is a an extension
                if (hasExtension)
                    m_SteelHeight = m_SteelHeight - extensionGap;

                // Length is always user defined & never from a standard
                m_SteelLength = steelLength;

                if (flangePlateLength <= 0)
                    flangePlateLength = steelLength;

                if (webPlateLength <= 0)
                    webPlateLength = steelLength;

                if (drawAsPlates)
                {

                    // Main plates that are used for shoe shape
                    symbolGeometryHelper.ActivePosition = new Position(-m_SteelWidth / 2, 0, m_FlangeThickness / 2);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    Projection3d webPlate1 = (Projection3d)symbolGeometryHelper.CreateBox(null, m_SteelWidth / 2 - spacing / 2, webPlateLength, m_FlangeThickness);
                    webPlate1.Transform(matrix);
                    outputs.Add(outputName + "WebPlate1", webPlate1);

                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(spacing / 2, 0, m_FlangeThickness / 2);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    Projection3d webPlate2 = (Projection3d)symbolGeometryHelper.CreateBox(null, m_SteelWidth / 2 - spacing / 2, webPlateLength, m_FlangeThickness);
                    webPlate2.Transform(matrix);
                    outputs.Add(outputName + "WebPlate2", webPlate2);

                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(-(m_SteelWidth / 2), 0, m_SteelHeight / 2 + m_FlangeThickness / 2);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    Projection3d flangePlate1 = (Projection3d)symbolGeometryHelper.CreateBox(null, m_WebThickness, flangePlateLength, m_SteelHeight - m_FlangeThickness);
                    flangePlate1.Transform(matrix);
                    outputs.Add(outputName + "FlangePlate1", flangePlate1);

                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position((m_SteelWidth / 2) - m_WebThickness, 0, m_SteelHeight / 2 + m_FlangeThickness / 2);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    Projection3d flangePlate2 = (Projection3d)symbolGeometryHelper.CreateBox(null, m_WebThickness, flangePlateLength, m_SteelHeight - m_FlangeThickness);
                    flangePlate2.Transform(matrix);
                    outputs.Add(outputName + "FlangePlate2", flangePlate2);


                }
                else
                {
                    // Check for lentgh error
                    if (!(steelLength > 0))
                    {
                        ToDoListMessage = new ToDoListMessage(ToDoMessageTypes.ToDoMessageWarning, SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrShoeOtypeDrawBeam_2LLength, "Length is required"));

                    }
                    ExtrusionOff = -steelLength / 2;

                    // Composite used to create extruded beam
                    // First L
                    curveCollection.Add(new Line3d(new Position(spacing / 2, ExtrusionOff, 0), new Position(-m_SteelWidth / 2, ExtrusionOff, 0)));
                    curveCollection.Add(new Line3d(new Position(-m_SteelWidth / 2, ExtrusionOff, 0), new Position(-m_SteelWidth / 2, ExtrusionOff, m_SteelHeight)));
                    curveCollection.Add(new Line3d(new Position(-m_SteelWidth / 2, ExtrusionOff, m_SteelHeight), new Position(-m_SteelWidth / 2 + m_WebThickness, ExtrusionOff, m_SteelHeight)));
                    curveCollection.Add(new Line3d(new Position(-m_SteelWidth / 2 + m_WebThickness, ExtrusionOff, m_SteelHeight), new Position(-m_SteelWidth / 2 + m_WebThickness, ExtrusionOff, m_FlangeThickness)));
                    curveCollection.Add(new Line3d(new Position(-m_SteelWidth / 2 + m_WebThickness, ExtrusionOff, m_FlangeThickness), new Position(-spacing / 2, ExtrusionOff, m_FlangeThickness)));
                    curveCollection.Add(new Line3d(new Position(-spacing / 2, ExtrusionOff, m_FlangeThickness), new Position(-spacing / 2, ExtrusionOff, 0)));
                    // Extrusion created from cross section of beam
                    Projection3d lines = new Projection3d(new ComplexString3d(curveCollection), new Vector(0, 1, 0), m_SteelLength, true);
                    lines.Transform(matrix);
                    outputs.Add(outputName + "1", lines);

                    // Second continous L
                    curveCollection = new Collection<ICurve>();
                    curveCollection.Add(new Line3d(new Position(spacing / 2, ExtrusionOff, 0), new Position(m_SteelWidth / 2, ExtrusionOff, 0)));
                    curveCollection.Add(new Line3d(new Position(m_SteelWidth / 2, ExtrusionOff, 0), new Position(m_SteelWidth / 2, ExtrusionOff, m_SteelHeight)));
                    curveCollection.Add(new Line3d(new Position(m_SteelWidth / 2, ExtrusionOff, m_SteelHeight), new Position(m_SteelWidth / 2 - m_WebThickness, ExtrusionOff, m_SteelHeight)));
                    curveCollection.Add(new Line3d(new Position(m_SteelWidth / 2 - m_WebThickness, ExtrusionOff, m_SteelHeight), new Position(m_SteelWidth / 2 - m_WebThickness, ExtrusionOff, m_FlangeThickness)));
                    curveCollection.Add(new Line3d(new Position(m_SteelWidth / 2 - m_WebThickness, ExtrusionOff, m_FlangeThickness), new Position(spacing / 2, ExtrusionOff, m_FlangeThickness)));
                    curveCollection.Add(new Line3d(new Position(spacing / 2, ExtrusionOff, m_FlangeThickness), new Position(spacing / 2, ExtrusionOff, 0)));
                    // Extrusion created from cross section of beam
                    Projection3d lines2 = new Projection3d(new ComplexString3d(curveCollection), new Vector(0, 1, 0), m_SteelLength, true);
                    lines2.Transform(matrix);
                    outputs.Add(outputName + "2", lines2);
                }

                // Code that deals with extension plates
                if (hasExtension)
                {
                    // Determines lateral position of extension plate.
                    if ((int)extensiontype == 0)
                        m_TopPlateHorOffset = -(m_SteelWidth / 2) + (extensionPlateThickness / 2) + (m_WebThickness);
                    else
                        m_TopPlateHorOffset = -(m_SteelWidth / 2) - (extensionPlateThickness / 2);

                    if (HgrCompareDoubleService.cmpdbl(extensionPlateHeight, 0) == true)
                        extensionPlateHeight = (extensionOffset + extensionGap) * Math.Cos(extensionPlateAngle);// *Math.PI / 180;

                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(-m_TopPlateHorOffset - extensionPlateThickness / 2, extensionPlateAxialPosition, extensionGap);
                    Projection3d extPlate1 = (Projection3d)symbolGeometryHelper.CreateBox(null, extensionPlateThickness, extensionPlateLength, extensionPlateHeight);
                    Matrix4X4 boxMatrix = new Matrix4X4();
                    boxMatrix.Translate(new Vector(0, 0, m_SteelHeight - extensionGap));
                    boxMatrix.Rotate(extensionPlateAngle, new Vector(1, 0, 0));
                    extPlate1.Transform(boxMatrix);
                    extPlate1.Transform(matrix);
                    outputs.Add(outputName + "ExtPlate 1", extPlate1);

                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(m_TopPlateHorOffset - extensionPlateThickness / 2, extensionPlateAxialPosition, extensionGap);
                    Projection3d extPlate2 = (Projection3d)symbolGeometryHelper.CreateBox(null, extensionPlateThickness, extensionPlateLength, extensionPlateHeight);
                    boxMatrix = new Matrix4X4();
                    boxMatrix.Translate(new Vector(0, 0, m_SteelHeight - extensionGap));
                    boxMatrix.Rotate(extensionPlateAngle, new Vector(1, 0, 0));
                    extPlate2.Transform(boxMatrix);
                    extPlate2.Transform(matrix);
                    outputs.Add(outputName + "ExtPlate 2", extPlate2);
                }
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrDrawBeam_2L, "Error in DrawBeam_2L");
            }
        }
        /// <summary>
        /// Create the graphical representation of a T - Section Hanger Beam
        /// </summary>
        /// <param name="steelWidth">Double [The width of the cross section]</param>
        /// <param name="steelHeight">Double [The height of the cross section] </param>
        /// <param name="steelLength">Double [The width of the cross section]</param>
        /// <param name="flangeThickness">Double [The flange thickness of the cross section]</param>
        /// <param name="webThickness">Double [The web thickness of the cross section]</param>
        /// <param name="drawAsPlates">Boolean [Signifies whether the beam will be drawn as plates or continues]</param>
        /// <param name="outputs">IJDOutputCollection [Output Collection] </param>
        /// <param name="matrix">Matrix 4*4 [ Matrix that will be applied to entire resulting shape]</param>
        /// <param name="outputName">Height of the Leg-Double.</param>
        /// <param name="sectionStandard">String [Section Standard to be used to obtain cross section info]</param>
        /// <param name="sectionType">String [Section Type to be used to obtain cross section info]</param>
        /// <param name="sectionName">String [Section Name to be used to obtain cross section info]</param>
        /// <param name="hasExtension">Width of the Leg -Double.</param>
        /// <param name="extensionType">Double [Specifies extension plate type to be either 'Inside' OR 'Outside']</param>
        /// <param name="extensionPlateLength">Double [Extension Plate Length]</param>
        /// <param name="extensionPlateHeight">Double [Extension Plate Height]</param>
        /// <param name="extensionPlateThickness">GDouble [Extension Plate Thickness]</param>
        /// <param name="extensionPlateAxialPosition">Double [Specifies Extension plate's position along the pipe]</param>
        ///<param name="extensionGap">Double [Specifies Extension plate's vetical position]</param>
        /// <param name="extensionPlateAngle">Double [Specifies the angle between the extension plate and rest of beam]</param>
        ///<param name="extensionOffset">Double.</param>
        /// <param name="flangePlateLength">Double [Length for the Horizontalplate. Only used when plates are used]</param>
        ///<param name="flangePlateLength">Double [Length for the vertical plate. Only used when plates are used]</param>          
        ///<code>
        ///DrawBeam_W(double steelWidth, double steelHeight, double steelLength, double flangeThickness, double webThickness, Boolean drawAsPlates, OutputDictionary outputs, Matrix4X4 matrix, string outputName = "BeamShape", string name = "None", string sectionStandard = "No Value", string sectionType = "No Value", string sectionName = "No Value", Boolean hasExtension = false, double extensiontype = 0, double extensionPlateLength = 0, double extensionPlateHeight = 0, double extensionPlateThickness = 0, double extensionPlateAxialPosition = 0, double extensionGap = 0, double extensionPlateAngle = 0, double extensionOffset = 0, double diameter = 0, double flangePlateLength = 0, double webPlateLength = 0)
        ///</code>
        public void DrawBeam_W(double steelWidth, double steelHeight, double steelLength, double flangeThickness, double webThickness, Boolean drawAsPlates, OutputDictionary outputs, Matrix4X4 matrix, string outputName = "BeamShape", string name = "None", string sectionStandard = "No Value", string sectionType = "No Value", string sectionName = "No Value", Boolean hasExtension = false, double extensiontype = 0, double extensionPlateLength = 0, double extensionPlateHeight = 0, double extensionPlateThickness = 0, double extensionPlateAxialPosition = 0, double extensionGap = 0, double extensionPlateAngle = 0, double extensionOffset = 0, double flangePlateLength = 0, double webPlateLength = 0, double webVerticalOffset = 0)
        {
            try
            {
                double[] vector = new double[3];
                double m_SteelWidth = 0, m_SteelHeight = 0, m_SteelLength = 0, m_FlangeThickness = 0, m_WebThickness = 0, m_TopPlateHorOffset = 0, ExtrusionOff = 0, legSpacing = 0;

                SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();
                Collection<ICurve> curveCollection = new Collection<ICurve>();
                // If NO section data is available through a standard
                if (sectionStandard != "No Value" && sectionType != "No Value" && sectionName != "No Value" && sectionStandard != "" && sectionType != "" && sectionName != "" && sectionStandard != null && sectionType != null && sectionName != null)
                {
                    SteelMember steel;
                    steel = GetSectionDataFromSection(sectionStandard, sectionType, sectionName);

                    m_FlangeThickness = steel.flangeThickness;
                    m_WebThickness = steel.webThickness;
                    m_SteelWidth = steel.width;
                    m_SteelHeight = steel.depth;

                    // Overide steel dims if there are some provided
                    if (steelWidth > 0)
                        m_SteelWidth = steelWidth;

                    if (steelHeight > 0)
                        m_SteelHeight = steelHeight;

                    if (flangeThickness > 0)
                        m_FlangeThickness = flangeThickness;

                    if (webThickness > 0)
                        m_WebThickness = webThickness;

                }
                else
                {
                    m_SteelWidth = steelWidth;
                    m_SteelHeight = steelHeight;
                    m_FlangeThickness = flangeThickness;
                    m_WebThickness = webThickness;
                }
                // Adjust leg len if there is a an extension
                if (hasExtension)
                    m_SteelHeight = m_SteelHeight - extensionGap;

                // Length is always user defined & never from a standard
                m_SteelLength = steelLength;

                if (flangePlateLength <= 0)
                    flangePlateLength = steelLength;

                if (webPlateLength <= 0)
                    webPlateLength = steelLength;

                if (webVerticalOffset <= 0)
                    webVerticalOffset = (m_SteelHeight / 2);

                if (hasExtension)
                {
                    legSpacing = m_SteelWidth - (2 * m_FlangeThickness);
                }

                // Check for length errors
                if (!(m_SteelLength > 0))
                {
                    ToDoListMessage = new ToDoListMessage(ToDoMessageTypes.ToDoMessageWarning, SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrShoeOtypeDrawBeam_2LLength, "Length is required"));
                }

                if (drawAsPlates)
                {

                    // Main plates that are used for shoe shape
                    symbolGeometryHelper.ActivePosition = new Position(-m_FlangeThickness, 0, (webVerticalOffset));
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    Projection3d webPlate = (Projection3d)symbolGeometryHelper.CreateBox(null, m_SteelWidth - (2 * m_WebThickness), flangePlateLength, m_FlangeThickness);
                    webPlate.Transform(matrix);
                    outputs.Add(outputName + "WebPlate", webPlate);

                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(-(m_SteelWidth / 2), 0, m_SteelHeight / 2);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    Projection3d flangePlate1 = (Projection3d)symbolGeometryHelper.CreateBox(null, m_WebThickness, webPlateLength, m_SteelHeight);
                    flangePlate1.Transform(matrix);
                    outputs.Add(outputName + "FlangePlate1", flangePlate1);

                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position((m_SteelWidth / 2) - (m_FlangeThickness), 0, m_SteelHeight / 2);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    Projection3d flangePlate2 = (Projection3d)symbolGeometryHelper.CreateBox(null, m_WebThickness, webPlateLength, m_SteelHeight);
                    flangePlate2.Transform(matrix);
                    outputs.Add(outputName + "FlangePlate2", flangePlate2);
                }
                else
                {
                    // Check for lentgh error
                    if (!(steelLength > 0))
                    {
                        ToDoListMessage = new ToDoListMessage(ToDoMessageTypes.ToDoMessageWarning, SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrShoeOtypeDrawBeam_2LLength, "Length is required"));
                    }
                    ExtrusionOff = -steelLength / 2;

                    // Composite used to create extruded beam
                    // First L
                    curveCollection.Add(new Line3d(new Position(m_SteelWidth / 2, ExtrusionOff, m_SteelHeight), new Position(m_SteelWidth / 2, ExtrusionOff, 0)));
                    curveCollection.Add(new Line3d(new Position(m_SteelWidth / 2, ExtrusionOff, 0), new Position(m_SteelWidth / 2 - m_WebThickness, ExtrusionOff, 0)));
                    curveCollection.Add(new Line3d(new Position(m_SteelWidth / 2 - m_WebThickness, ExtrusionOff, 0), new Position(m_SteelWidth / 2 - m_WebThickness, ExtrusionOff, webVerticalOffset - (m_FlangeThickness / 2))));
                    curveCollection.Add(new Line3d(new Position(-((m_SteelWidth / 2) - m_WebThickness), ExtrusionOff, 0), new Position(-((m_SteelWidth / 2) - m_WebThickness), ExtrusionOff, webVerticalOffset - (m_FlangeThickness / 2))));
                    curveCollection.Add(new Line3d(new Position(m_SteelWidth / 2 - m_WebThickness, ExtrusionOff, m_SteelHeight), new Position(m_SteelWidth / 2 - m_WebThickness, ExtrusionOff, webVerticalOffset + (m_FlangeThickness / 2))));
                    curveCollection.Add(new Line3d(new Position(-((m_SteelWidth / 2) - m_WebThickness), ExtrusionOff, m_SteelHeight), new Position(-((m_SteelWidth / 2) - m_WebThickness), ExtrusionOff, webVerticalOffset + (m_FlangeThickness / 2))));
                    curveCollection.Add(new Line3d(new Position(-((m_SteelWidth / 2) - m_WebThickness), ExtrusionOff, webVerticalOffset + (m_FlangeThickness / 2)), new Position(((m_SteelWidth / 2) - m_WebThickness), ExtrusionOff, webVerticalOffset + (m_FlangeThickness / 2))));
                    curveCollection.Add(new Line3d(new Position(-((m_SteelWidth / 2) - m_WebThickness), ExtrusionOff, webVerticalOffset - (m_FlangeThickness / 2)), new Position(((m_SteelWidth / 2) - m_WebThickness), ExtrusionOff, webVerticalOffset - (m_FlangeThickness / 2))));
                    curveCollection.Add(new Line3d(new Position(-m_SteelWidth / 2 + m_WebThickness, ExtrusionOff, 0), new Position(-m_SteelWidth / 2, ExtrusionOff, 0)));
                    curveCollection.Add(new Line3d(new Position(-m_SteelWidth / 2, ExtrusionOff, 0), new Position(-m_SteelWidth / 2, ExtrusionOff, m_SteelHeight)));
                    curveCollection.Add(new Line3d(new Position(-m_SteelWidth / 2, ExtrusionOff, m_SteelHeight), new Position(-m_SteelWidth / 2 + m_WebThickness, ExtrusionOff, m_SteelHeight)));
                    curveCollection.Add(new Line3d(new Position(m_SteelWidth / 2 - m_WebThickness, ExtrusionOff, m_SteelHeight), new Position(m_SteelWidth / 2, ExtrusionOff, m_SteelHeight)));
                    // Extrusion created from cross section of beam
                    Projection3d lines = new Projection3d(new ComplexString3d(curveCollection), new Vector(0, 1, 0), m_SteelLength, true);
                    lines.Transform(matrix);
                    outputs.Add(outputName, lines);
                }

                // Code that deals with extension plates
                if (hasExtension)
                {
                    // Determines lateral position of extension plate.
                    if ((int)extensiontype == 0)
                        m_TopPlateHorOffset = -(legSpacing / 2) + (extensionPlateThickness / 2);
                    else
                        m_TopPlateHorOffset = -(legSpacing / 2) - (extensionPlateThickness / 2) - (m_WebThickness);

                    if (HgrCompareDoubleService.cmpdbl(extensionPlateHeight, 0) == true)
                        extensionPlateHeight = (extensionOffset + extensionGap) * Math.Cos(extensionPlateAngle);

                    // Draw extension plates
                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(-m_TopPlateHorOffset + extensionPlateThickness / 2, extensionPlateAxialPosition, extensionGap);
                    symbolGeometryHelper.SetOrientation(new Vector(-1, 0, 0), new Vector(0, 1, 0));
                    Projection3d extPlate1 = (Projection3d)symbolGeometryHelper.CreateBox(null, extensionPlateThickness, extensionPlateLength, extensionPlateHeight);
                    Matrix4X4 boxMatrix = new Matrix4X4();
                    boxMatrix.Translate(new Vector(0, 0, m_SteelHeight - extensionGap));
                    boxMatrix.Rotate(extensionPlateAngle, new Vector(1, 0, 0));
                    extPlate1.Transform(boxMatrix);
                    extPlate1.Transform(matrix);
                    outputs.Add(outputName + "ExtPlate 1", extPlate1);

                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(m_TopPlateHorOffset + extensionPlateThickness / 2, extensionPlateAxialPosition, extensionGap);
                    symbolGeometryHelper.SetOrientation(new Vector(-1, 0, 0), new Vector(0, 1, 0));
                    Projection3d extPlate2 = (Projection3d)symbolGeometryHelper.CreateBox(null, extensionPlateThickness, extensionPlateLength, extensionPlateHeight);
                    boxMatrix = new Matrix4X4();
                    boxMatrix.Translate(new Vector(0, 0, m_SteelHeight - extensionGap));
                    boxMatrix.Rotate(extensionPlateAngle, new Vector(1, 0, 0));
                    extPlate2.Transform(boxMatrix);
                    extPlate2.Transform(matrix);
                    outputs.Add(outputName + "ExtPlate 2", extPlate2);
                }
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrDrawBeam_W, "Error in DrawBeam_W");
            }
        }
        /// <summary>
        /// Gets the height between pipe to leg 
        /// </summary>
        /// <param name="shoe">Structure for specifying the inputs for the Shoe</param>
        /// <param name="pipeDiameter">Specifies the pipe diameter</param>
        /// <param name="gap">Gap between Legs</param>
        /// <param name="turnAngle">ANgle with which it turns</param>
        ///<code>VLegHeightToPipe(shoe, pipeDiameter, gap, ref turnAngle);</code>
        public Double VLegHeightToPipe(ShoeInputs shoe, double pipeDiameter, double gap, ref double turnAngle)
        {
            double angle = 0, adj = 0, webSlice = 0, opp = 0, bottomH = 0, calculatedTrangleH = 0, topAngle = 0, sideAngle = 0, extraHieght = 0;
            if (gap > 0)
                return shoe.ShoeHeight - gap;
            if (shoe.LegHeight > 0)
                return shoe.LegHeight;
            else
            {
                // The trig used to figure out angle of the vertical plates at the bottom
                adj = shoe.ShoeHeight - shoe.ShoeThickness2;
                opp = (shoe.ShoeSpacing / 2) - (shoe.LegLowerSpacing / 2);
                angle = Math.Atan(opp / adj) * 180 / Math.PI;

                // thickness of the plates at an angle
                webSlice = (shoe.ShoeThickness1 / Math.Cos(angle * Math.PI / 180));

                // height at the bottom of extrapolated triangle
                bottomH = ((shoe.LegLowerSpacing / 2) + webSlice) / Math.Tan(angle * Math.PI / 180);

                calculatedTrangleH = bottomH + shoe.ShoeHeight - shoe.ShoeThickness2 + pipeDiameter / 2;

                sideAngle = 180 - Math.Asin(Math.Sin(angle * Math.PI / 180) / (pipeDiameter / 2) * calculatedTrangleH) * 180 / Math.PI;

                // Have to subratct 180 because of the rule of sines special case
                topAngle = 180 - (sideAngle + angle);

                if (topAngle >= 90)
                    extraHieght = pipeDiameter / 2;
                else
                    extraHieght = (pipeDiameter / 2) - ((pipeDiameter / 2) * Math.Cos(topAngle * Math.PI / 180));

                return shoe.ShoeHeight + extraHieght;
            }
        }
        /// <summary>
        /// Gets the height between pipe to leg 
        /// </summary>
        /// <param name="shoe">Structure for specifying the inputs for the Shoe</param>
        /// <param name="pipeDiameter">Specifies the pipe diameter</param>
        /// <param name="gap">Gap between Legs</param>
        ///<code>VLegHeightToPipe(shoe, pipeDiameter, gap, ref turnAngle);</code>
        public Double VLegHeightToPipe(ShoeInputs shoe, double pipeDiameter, double gap)
        {
            double turnAngle = 0;
            return VLegHeightToPipe(shoe, pipeDiameter, gap, ref turnAngle);
        }
        /// <summary>
        /// Draws a Beam irregular in Shoe
        /// </summary>
        /// <param name="steelWidth">Specifies the Steelwidth</param>
        /// <param name="steelHeight">Specifies the SteelHeight</param>
        /// <param name="steelLength">Specifies the SteelLength</param>
        /// <param name="flangeThickness">Specifies the FlangeThickness</param>
        /// <param name="webThickness">Specifies the WebThickness</param>
        /// <param name="upperLegSpacing">Specifies the upperLegSpacing</param>
        /// <param name="lowerLegSpacing">Specifies the LowerLegSpacing</param>
        /// <param name="drawAsPlates">Specifies the drawAsPlates</param>
        /// <param name="outputs">Outputs</param>
        /// <param name="matrix">Matrix</param>
        /// <param name="outputName">Shape Name</param>
        /// <param name="name">Name</param>
        /// <param name="sectionStandard">Standard</param>
        /// <param name="sectionType">Section type</param>
        /// <param name="sectionName">Section name</param>
        /// <param name="hasExtension">Has extension</param>
        /// <param name="extensiontype">Extension type</param>
        /// <param name="extensionPlateLength">extensionPlateLength</param>
        /// <param name="extensionPlateHeight">extensionPlateHeight</param>
        /// <param name="extensionPlateThickness">extensionPlateThickness</param>
        /// <param name="extensionPlateAxialPosition">extensionPlateAxialPosition</param>
        /// <param name="extensionGap">extensionGap</param>
        /// <param name="flangePlateLength">flangePlateLength</param>
        /// <param name="webPlateLength">webPlateLength</param>
        /// <param name="turnAngle">turnAngle</param>
        /// <code> DrawBeam_Irregular(dShoeShapeWidth, ShoeShapeLegHieght, shoe.ShoeLength, dBaseThickness, dTopThickness, shoe.ShoeSpacing, shoe.LegLowerSpacing, bDrawAsPlates, outputs, matrix, outputName, name, shoe.SectionStandard, shoe.SectionType, shoe.SectionName, shoe.HasExtension, shoe.ExtensionType, shoe.TopPlateLength, shoe.TopPlateHeight,</code>
        public void DrawBeam_Irregular(double steelWidth, double steelHeight, double steelLength, double flangeThickness, double webThickness, double upperLegSpacing, double lowerLegSpacing, Boolean drawAsPlates, OutputDictionary outputs, Matrix4X4 matrix, string outputName = "BeamShape", string name = "None", string sectionStandard = "No Value", string sectionType = "No Value", string sectionName = "No Value", Boolean hasExtension = false, double extensiontype = 0, double extensionPlateLength = 0, double extensionPlateHeight = 0, double extensionPlateThickness = 0, double extensionPlateAxialPosition = 0, double extensionGap = 0, double flangePlateLength = 0, double webPlateLength = 0, double turnAngle = 0)
        {
            try
            {
                double[] vector = new double[3];
                double m_SteelWidth = 0, m_SteelHeight = 0, m_SteelLength = 0, m_FlangeThickness = 0, m_WebThickness = 0, ExtrusionOffset = 0, extLength = 0, adj = 0, opp = 0, angle = 0, webslice = 0;

                SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();
                //Line3d line;
                Collection<ICurve> curveCollection = new Collection<ICurve>();
                if (sectionStandard != "No Value" && sectionType != "No Value" && sectionName != "No Value" && sectionStandard != "" && sectionType != "" && sectionName != "" && sectionStandard != null && sectionType != null && sectionName != null)
                {
                    SteelMember steel;
                    steel = GetSectionDataFromSection(sectionStandard, sectionType, sectionName);

                    m_FlangeThickness = steel.flangeThickness;
                    m_WebThickness = steel.webThickness;
                    m_SteelWidth = steel.width;
                    m_SteelHeight = steel.depth;

                    // Overide steel dims if there are some provided
                    if (steelWidth > 0)
                        m_SteelWidth = steelWidth;

                    if (steelHeight > 0)
                        m_SteelHeight = steelHeight;

                    if (flangeThickness > 0)
                        m_FlangeThickness = flangeThickness;

                    if (webThickness > 0)
                        m_WebThickness = webThickness;

                }
                // Else means user is custom specifying all dimensions
                else
                {
                    m_SteelWidth = steelWidth;
                    m_SteelHeight = steelHeight;
                    m_FlangeThickness = flangeThickness;
                    m_WebThickness = webThickness;
                }
                // Length is always user defined & never from a standard
                m_SteelLength = steelLength;
                // Set Length for base and Vertical Plate
                if (flangePlateLength > 0)
                {
                }
                else
                {
                    flangePlateLength = steelLength;
                }

                if (webPlateLength > 0)
                {
                }
                else
                {
                    webPlateLength = steelLength;
                }

                // The trig used to figure out  angle of the verival steels
                if (HgrCompareDoubleService.cmpdbl(turnAngle, 0) == true)
                {
                    adj = m_SteelHeight - m_FlangeThickness;
                    opp = (upperLegSpacing / 2) - (lowerLegSpacing / 2);
                    angle = Math.Atan(opp / adj) * 180 / Math.PI;
                }
                else
                {
                    angle = turnAngle;
                }
                webslice = (m_WebThickness / Math.Cos(angle * Math.PI / 180));
                ExtrusionOffset = m_SteelLength / 2;

                // Check for width error
                if (!(m_SteelLength > 0))
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrDrawBeam_IrregularLength, "Length is required");
                }
                if (!(m_SteelWidth > 0))
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrDrawBeam_IrregularWidth, "Width is required");
                }
                if (lowerLegSpacing > upperLegSpacing)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrDrawBeam_IrregularSpacing, "Lower spacing must be less than upper leg spacing");
                }

                if (drawAsPlates)
                {

                    if (HgrCompareDoubleService.cmpdbl(extensionPlateHeight, 0) == true)

                        // Main plates that are used for shoe shape
                        symbolGeometryHelper.ActivePosition = new Position(-m_SteelWidth / 2, 0, m_FlangeThickness / 2);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    Projection3d flangePlate = (Projection3d)symbolGeometryHelper.CreateBox(null, m_SteelWidth, flangePlateLength, m_FlangeThickness, 5);
                    flangePlate.Transform(matrix);
                    outputs.Add(outputName + "FlangePlate", flangePlate);

                    // Right Vertical Plate (Web)
                    curveCollection.Add(new Line3d(new Position((lowerLegSpacing / 2) + webslice, -webPlateLength / 2, m_FlangeThickness), new Position((upperLegSpacing / 2) + webslice, -webPlateLength / 2, m_SteelHeight)));
                    curveCollection.Add(new Line3d(new Position((upperLegSpacing / 2) + webslice, -webPlateLength / 2, m_SteelHeight), new Position((upperLegSpacing / 2), -webPlateLength / 2, m_SteelHeight)));
                    curveCollection.Add(new Line3d(new Position((upperLegSpacing / 2), -webPlateLength / 2, m_SteelHeight), new Position((lowerLegSpacing / 2), -webPlateLength / 2, m_FlangeThickness)));
                    curveCollection.Add(new Line3d(new Position((lowerLegSpacing / 2), -webPlateLength / 2, m_FlangeThickness), new Position((lowerLegSpacing / 2) + webslice, -webPlateLength / 2, m_FlangeThickness)));

                    Projection3d webPlate1 = new Projection3d(new ComplexString3d(curveCollection), new Vector(0, 1, 0), webPlateLength, true);
                    webPlate1.Transform(matrix);
                    outputs.Add(outputName + "WebPlate 1", webPlate1);
                    // Left Vertical Plate (Web)
                    curveCollection = new Collection<ICurve>();
                    curveCollection.Add(new Line3d(new Position(-(lowerLegSpacing / 2) - webslice, -webPlateLength / 2, m_FlangeThickness), new Position(-(upperLegSpacing / 2) - webslice, -webPlateLength / 2, m_SteelHeight)));
                    curveCollection.Add(new Line3d(new Position(-(upperLegSpacing / 2) - webslice, -webPlateLength / 2, m_SteelHeight), new Position(-(upperLegSpacing / 2), -webPlateLength / 2, m_SteelHeight)));
                    curveCollection.Add(new Line3d(new Position(-(upperLegSpacing / 2), -webPlateLength / 2, m_SteelHeight), new Position(-(lowerLegSpacing / 2), -webPlateLength / 2, m_FlangeThickness)));
                    curveCollection.Add(new Line3d(new Position(-(lowerLegSpacing / 2), -webPlateLength / 2, m_FlangeThickness), new Position(-(lowerLegSpacing / 2) - webslice, -webPlateLength / 2, m_FlangeThickness)));

                    Projection3d webPlate2 = new Projection3d(new ComplexString3d(curveCollection), new Vector(0, 1, 0), webPlateLength, true);
                    webPlate2.Transform(matrix);
                    outputs.Add(outputName + "WebPlate 2", webPlate2);
                }
                else
                {
                    // This gets the steel cross section data by querying the database.
                    // Composite used to create extruded beam
                    curveCollection.Add(new Line3d(new Position(-m_SteelWidth / 2, ExtrusionOffset, 0), new Position(m_SteelWidth / 2, ExtrusionOffset, 0)));
                    curveCollection.Add(new Line3d(new Position(m_SteelWidth / 2, ExtrusionOffset, 0), new Position(m_SteelWidth / 2, ExtrusionOffset, m_FlangeThickness)));
                    curveCollection.Add(new Line3d(new Position(m_SteelWidth / 2, ExtrusionOffset, m_FlangeThickness), new Position(lowerLegSpacing / 2 + webslice, ExtrusionOffset, m_FlangeThickness)));
                    curveCollection.Add(new Line3d(new Position(lowerLegSpacing / 2 + webslice, ExtrusionOffset, m_FlangeThickness), new Position(upperLegSpacing / 2 + webslice, ExtrusionOffset, m_SteelHeight)));
                    curveCollection.Add(new Line3d(new Position(upperLegSpacing / 2 + webslice, ExtrusionOffset, m_SteelHeight), new Position(upperLegSpacing / 2, ExtrusionOffset, m_SteelHeight)));
                    curveCollection.Add(new Line3d(new Position(upperLegSpacing / 2, ExtrusionOffset, m_SteelHeight), new Position(lowerLegSpacing / 2, ExtrusionOffset, m_FlangeThickness)));
                    curveCollection.Add(new Line3d(new Position(lowerLegSpacing / 2, ExtrusionOffset, m_FlangeThickness), new Position(-lowerLegSpacing / 2, ExtrusionOffset, m_FlangeThickness)));
                    curveCollection.Add(new Line3d(new Position(-lowerLegSpacing / 2, ExtrusionOffset, m_FlangeThickness), new Position(-upperLegSpacing / 2, ExtrusionOffset, m_SteelHeight)));
                    curveCollection.Add(new Line3d(new Position(-upperLegSpacing / 2, ExtrusionOffset, m_SteelHeight), new Position(-upperLegSpacing / 2 - webslice, ExtrusionOffset, m_SteelHeight)));
                    curveCollection.Add(new Line3d(new Position(-upperLegSpacing / 2 - webslice, ExtrusionOffset, m_SteelHeight), new Position(-lowerLegSpacing / 2 - webslice, ExtrusionOffset, m_FlangeThickness)));
                    curveCollection.Add(new Line3d(new Position(-lowerLegSpacing / 2 - webslice, ExtrusionOffset, m_FlangeThickness), new Position(-m_SteelWidth / 2, ExtrusionOffset, m_FlangeThickness)));
                    curveCollection.Add(new Line3d(new Position(-m_SteelWidth / 2, ExtrusionOffset, m_FlangeThickness), new Position(-m_SteelWidth / 2, ExtrusionOffset, 0)));
                    // Extrusion created from cross section of beam
                    Projection3d lines = new Projection3d(new ComplexString3d(curveCollection), new Vector(0, 1, 0), m_SteelLength, true);
                    lines.Transform(matrix);
                    outputs.Add(outputName, lines);
                }

                extLength = -extensionPlateLength / 2;
                // Code that deals with extension plates
                if (hasExtension)
                {
                    // not supported
                }
            }
            catch (SmartPartSymbolException hgrEx)
            {
                throw hgrEx;
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrDrawBeam_Irregular, "Error in DrawBeam_Irregular");
            }
        }
        /// <summary>
        /// Draws a standard section on given Graphics
        /// </summary>
        /// <param name="sectionStandard">sectionStandard</param>
        /// <param name="sectionType">sectionType</param>
        /// <param name="sectionName">sectionName</param>
        /// <param name="length">length</param>
        /// <param name="angle">angle</param>
        /// <param name="cardinalPoint">cardinalPoint</param>
        /// <param name="outputs">outputs</param>
        /// <param name="matrix">matrix</param>
        /// <param name="outputName">outputName</param>
        /// <param name="name">name</param>
        /// <code>  DrawStandardSection(stanchShape.steelStandard, stanchShape.steelType, stanchShape.steelName, stanchShape.stanHeight, stanchShape.steelAngle, (int)stanchShape.steelCpoint, outputs, plateMatrix, outputName + "Shape");</code>
        public void DrawStandardSection(string sectionStandard, string sectionType, string sectionName, double length, double angle, long cardinalPoint, OutputDictionary outputs, Matrix4X4 matrix, string outputName, string name = "")
        {
            CrossSectionServices crossSectionServices = new CrossSectionServices();
            CatalogStructHelper catalogStructHelper = new CatalogStructHelper();
            CrossSection crossSection = catalogStructHelper.GetCrossSection(sectionStandard, sectionType, sectionName);
            Line3d projectionLeftHorizontal = new Line3d(new Position(0, length / 2, 0), new Position(0, -length / 2, 0));

            // Get cardinal offsets
            SweepOptions sweepOptions = (SweepOptions)1;
            Collection<ISurface> crossSecSurfaces1 = crossSectionServices.GetProjectionSurfacesFromCrossSection(crossSection, projectionLeftHorizontal, (int)cardinalPoint, true, angle, sweepOptions);
            for (int i = 1; i <= crossSecSurfaces1.Count; i++)
            {
                Geometry3d csSurface1 = (Geometry3d)crossSecSurfaces1[i - 1];
                csSurface1.Transform(matrix);
                outputs.Add(outputName + "SecComp" + i, csSurface1);
            }
        }
        /// <summary>
        /// Gives The Plate Shape
        /// </summary>
        /// <param name="plate">Plate Inputs</param>
        /// <param name="outputs">Outputs</param>
        /// <param name="matrix">matrix</param>
        /// <param name="centerDiameter">CenterDiameter</param>
        /// <param name="plateNumber">PlateNumber</param>
        /// <param name="degPlateAngle">Plate Angle in degrees</param>
        /// <param name="outputName">Outputname</param>
        /// <param name="name">name</param>
        /// <code> StarPlateShape(additionalPlateInputs, m_oSymbolic.Outputs, matrix, centerDiameter, int.Parse(plateNumber.ToString()), plateAngle, "shoeAddPlates");</code>
        public void StarPlateShape(PlateInputs plate, OutputDictionary outputs, Matrix4X4 matrix, double centerDiameter, int plateNumber, double degPlateAngle, string outputName, string name = "None")
        {
            try
            {

                double centerRad = centerDiameter / 2;
                Matrix4X4 plateMatrix = new Matrix4X4();

                for (int i = 1; i <= plateNumber; i++)
                {
                    if (i == 1)
                    {
                        plateMatrix.SetIdentity();
                        plateMatrix.Translate(new Vector(-plate.width1 / 2, centerRad, -plate.thickness1 / 2));
                        plateMatrix.Rotate(Math.PI / 2, new Vector(1, 0, 0), new Position(0, 0, 0));
                        AddPlate(plate, plateMatrix, outputs, outputName + "StarPlate" + i);
                        Projection3d starPlate1 = (Projection3d)outputs[outputName + "StarPlate" + i];
                        starPlate1.Transform(matrix);
                    }
                    else
                    {
                        plateMatrix.SetIdentity();
                        plateMatrix.Translate(new Vector(-plate.width1 / 2, centerRad, -plate.thickness1 / 2));
                        plateMatrix.Rotate(Math.PI / 2, new Vector(1, 0, 0), new Position(0, 0, 0));
                        plateMatrix.Rotate((degPlateAngle * (i - 1)), new Vector(0, 1, 0), new Position(0, 0, 0));
                        AddPlate(plate, plateMatrix, outputs, outputName + "StarPlate" + i);
                        Projection3d starPlate1 = (Projection3d)outputs[outputName + "StarPlate" + i];
                        starPlate1.Transform(matrix);
                    }
                }
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrStarPlateShape, "Error in StarPlateShape");
            }
        }
        /// <summary>
        /// Create the graphical representation of a DummyLeg.
        /// </summary>
        /// <param name="dummyLegShape">The dummy leg shape.</param>
        /// <param name="pipeOD">The pipe OD.</param>
        /// <param name="elbowRadius">The elbow radius.</param>
        /// <param name="offset1">The offset1.</param>
        /// <param name="matrix">matrix to specify the position and oreintation the graphics - matrix.</param>
        /// <param name="outputs">Collection of declared outputs, which is indexed by the name of the outputs declared as defining SymbolOutputs on the AspectDefinition field- OutputDictionary</param>
        /// <param name="outputName">Output that this graphic is being placed on-String</param>
        /// <param name="fixedlength">if set to <c>true</c> [fixedlength].</param>
        /// <code>
        /// AddDummyLegShape(botDummyShape, botDummyShape.diameter, dummyLeg.elbowRadius, dummyLeg.offset1, matrix, m_Symbolic.Outputs, "DummyStanchBot", fixedLength);
        ///   </code>
        public void AddDummyLegShape(DummyLegShapeInputs dummyLegShape, double pipeOD, double elbowRadius, double offset1, Matrix4X4 matrix, OutputDictionary outputs, String outputName, bool fixedlength = true)
        {
            try
            {
                PlateInputs plate1 = new PlateInputs();

                double boltDist;
                Matrix4X4 dummyMatrix;
                Surface3d surface;
                Collection<ICurve> iJElements = new Collection<ICurve>();
                GeometryIntersectionType intersection = new GeometryIntersectionType();

                if (Math.Abs(dummyLegShape.dummyHeight) < (pipeOD / 2.0) || Math.Abs(dummyLegShape.dummyHeight) < (elbowRadius + pipeOD / 2.0))
                {
                    dummyLegShape.dummyHeight = -(elbowRadius + pipeOD);
                }
                if (!(dummyLegShape.plateShape == "No Value" || dummyLegShape.plateShape == ""))
                {
                    //Load Baseplate Data by Query
                    plate1 = LoadPlateDataByQuery(dummyLegShape.plateShape);
                    boltDist = (dummyLegShape.pinLen / 2) - plate1.thickness1 - dummyLegShape.pinDia;
                    if (fixedlength == false)
                    {
                        plate1.thickness1 = -plate1.thickness1;
                        boltDist = -boltDist;
                    }

                    if (dummyLegShape.includeBolts == 2)
                    {
                        dummyMatrix = new Matrix4X4();
                        dummyMatrix.SetIdentity();
                        dummyMatrix.Translate(new Vector(-offset1, 0, -dummyLegShape.dummyHeight - plate1.thickness1));
                        AddPlateShapeWithBolts(plate1, dummyMatrix, outputs, outputName, dummyLegShape.BoltRow1.MultiQty, plate1.width1, dummyLegShape.BoltRow1.MultiLocateBy, dummyLegShape.BoltRow1.MultiLocation, dummyLegShape.pinDia, dummyLegShape.pinLen, dummyLegShape.BoltRow1.Offset, 90, 1, 0, false, -boltDist);
                    }
                    else if (dummyLegShape.includeBolts == 3 || dummyLegShape.includeBolts == 4)
                    {
                        dummyMatrix = new Matrix4X4();
                        dummyMatrix.SetIdentity();
                        dummyMatrix.Translate(new Vector(-offset1, -plate1.length1 / 2, -dummyLegShape.dummyHeight - plate1.thickness1));
                        AddPlateShapeWithBolts(plate1, dummyMatrix, outputs, outputName);
                        ToDoListMessage = new ToDoListMessage(ToDoMessageTypes.ToDoMessageWarning, SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrNoTopPlate, "Top plate is not available for Dummy Leg. So bolts cannot be included"));
                    }
                    else
                    {
                        // No Bolts
                        dummyMatrix = new Matrix4X4();
                        dummyMatrix.SetIdentity();
                        dummyMatrix.Translate(new Vector(-offset1 - plate1.width1 / 2, -plate1.length1 / 2, -dummyLegShape.dummyHeight - plate1.thickness1));
                        AddPlate(plate1, dummyMatrix, outputs, outputName);
                    }
                }
                double pi = 4 * Math.Atan(1);
                SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();

                //Transient Pipe Shape
                if (HgrCompareDoubleService.cmpdbl(elbowRadius, 0) == true)    //Straight Pipe
                {
                    //Creating Transient Pipe shape
                    symbolGeometryHelper = new SymbolGeometryHelper();
                    double cylWidth = Math.Max(dummyLegShape.dummyDepth, dummyLegShape.dummyWidth) * 3;

                    Circle3d cir1 = new Circle3d(new Position(-cylWidth / 2 - offset1, 0, 0), new Vector(1, 0, 0), dummyLegShape.diameter / 2);
                    Projection3d pro = new Projection3d(cir1, new Vector(1, 0, 0), cylWidth, false);
                    surface = pro;
                }
                else  //Elbow Pipe
                {
                    Matrix4X4 elbowMatrix = new Matrix4X4();
                    elbowMatrix.SetIdentity();
                    if (fixedlength == true)
                    {
                        elbowMatrix.Rotate(Math.PI, new Vector(1, 0, 0));
                    }

                    if (pipeOD <= dummyLegShape.dummyWidth)
                    {
                        pipeOD = dummyLegShape.dummyWidth + 0.001;
                    }

                    Revolution3d bend = new Revolution3d(new Circle3d(new Position(0, 0, 0), new Vector(0, 0, 1), pipeOD / 2), new Vector(0, -1, 0), new Position(-elbowRadius, 0, 0), Math.PI / 2, true);
                    bend.Transform(elbowMatrix);
                    surface = bend;

                    if (HgrCompareDoubleService.cmpdbl(offset1, 0) == false)          //For Elbow Dummy Leg Throw Warning if Offset is More
                    {
                        if (offset1 < 0)       //Negative Offset
                        {
                            if (Math.Abs(offset1) > (Math.Abs((pipeOD / 2) - (dummyLegShape.dummyWidth / 2)) - 0.001))          //Throw warning and have 1mm Tolerance
                            {
                                ToDoListMessage = new ToDoListMessage(ToDoMessageTypes.ToDoMessageWarning, SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrMoreOffset, "Offset1 is more than (PipeOD - DummyWidth)/2"));
                            }
                        }
                        else                    //Positive Offset
                        {
                            if (Math.Abs(offset1) > Math.Abs((elbowRadius) - dummyLegShape.dummyWidth / 2))                      //Throw warning and have 1mm Tolerance
                            {
                                ToDoListMessage = new ToDoListMessage(ToDoMessageTypes.ToDoMessageWarning, SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrMoreOffset1, "Offset1 is more than ElbowRadius - DummyWidth/2"));
                            }
                        }
                    }
                    else
                    {
                        if ((dummyLegShape.dummyWidth / 2) > pipeOD / 2 - 0.001)                                                     //Throw warning and have 1mm Tolerance
                        {
                            ToDoListMessage = new ToDoListMessage(ToDoMessageTypes.ToDoMessageWarning, SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrMorePipeOD, "DummyWidth is more than PipeOD"));
                        }
                    }
                }

                //DummyLeg
                if (dummyLegShape.dummyShape == 1)           //Cylinder
                {
                    //Creating Transient Dummy shape
                    symbolGeometryHelper = new SymbolGeometryHelper();

                    Circle3d cir1 = new Circle3d(new Position(-offset1, 0, 0), new Vector(0, 0, 1), dummyLegShape.dummyWidth / 2);
                    Projection3d pro1 = new Projection3d(cir1, new Vector(0, 0, -1), dummyLegShape.dummyHeight, false);

                    Circle3d cir = new Circle3d(new Position(-offset1, 0, -dummyLegShape.dummyHeight), new Vector(0, 0, 1), dummyLegShape.dummyWidth / 2.0);  //Creating TransientDummyLeg Bottom curve
                    ICurve curve1 = cir;

                    //Getting bottom curve from the intersection of Stanchion and Pipe Transient shape
                    try
                    {
                        surface.Intersect((ISurface)pro1, out iJElements, out intersection);
                        ICurve curve2;
                        if (iJElements.Count == 1)
                        {   // Only One InterSection Curve
                            curve2 = (ICurve)iJElements.First();
                        }
                        else
                        {   // Multiple Intersection Curves - Get the Bottom One
                            curve2 = (ICurve)iJElements.First();
                            for (int i = 1; i < iJElements.Count; i++)
                            {
                                ICurve tempCurve = (ICurve)iJElements[i];
                                if (tempCurve.Centroid.Z < curve2.Centroid.Z)
                                {
                                    curve2 = tempCurve;
                                }
                            }
                        }
                        //Creating DummyLeg Shape by joining DummyTopCurve and DummyBotCurve
                        Ruled3d rule = new Ruled3d(curve1, curve2, true);
                        rule.Transform(matrix);
                        outputs.Add(outputName + "Shape", rule);
                    }
                    catch
                    {
                        // Unable to Intersect the Curves - Default to a projection with no trim
                        double projectionHeight;
                        double startHeight;
                        if (offset1 >= 0)
                        {
                            projectionHeight = dummyLegShape.dummyHeight - elbowRadius;
                            startHeight = elbowRadius;
                        }
                        else
                        {
                            projectionHeight = dummyLegShape.dummyHeight;
                            startHeight = 0;
                        }

                        Projection3d defaultProj = new Projection3d(new Circle3d(new Position(-offset1, 0, -startHeight), new Vector(0, 0, 1), dummyLegShape.dummyWidth / 2), new Vector(0, 0, -1), projectionHeight, true);
                        defaultProj.Transform(matrix);
                        outputs.Add(outputName + "Shape", defaultProj);
                    }
                }
                else if (dummyLegShape.dummyShape == 2) //Square or Rectangle
                {
                    if (dummyLegShape.dummyDepth <= 0) //Square
                    {
                        dummyLegShape.dummyDepth = dummyLegShape.dummyWidth;
                    }

                    //Getting bottom curve from the intersection of Stanchion and Pipe Transient shape
                    Projection3d pro = new Projection3d(CreChamBoxLine(new Position(-offset1, 0, 0), dummyLegShape.dummyDepth, dummyLegShape.dummyWidth, true), new Vector(0, 0, -1), dummyLegShape.dummyHeight, true);

                    ComplexString3d complexstring1 = CreChamBoxLine(new Position(-offset1, 0, -dummyLegShape.dummyHeight), dummyLegShape.dummyDepth, dummyLegShape.dummyWidth, false);
                    Curve3d curve2 = (Curve3d)complexstring1;

                    //Getting bottom curve from the intersection of Stanchion and Pipe Transient shape
                    try
                    {
                        surface.Intersect((ISurface)pro, out iJElements, out intersection);
                        ICurve curve1;
                        if (iJElements.Count == 1)
                        {   // Only One InterSection Curve
                            curve1 = (ICurve)iJElements.First();
                        }
                        else
                        {   // Multiple Intersection Curves - Get the Bottom One
                            curve1 = (ICurve)iJElements.First();
                            for (int i = 1; i < iJElements.Count; i++)
                            {
                                ICurve tempCurve = (ICurve)iJElements[i];
                                if (tempCurve.Centroid.Z < curve1.Centroid.Z)
                                {
                                    curve1 = tempCurve;
                                }
                            }
                        }
                        //Creating DummyLeg Shape by joining curve1 and curve2
                        Ruled3d rule = new Ruled3d(curve1, curve2, true);
                        rule.Transform(matrix);
                        outputs.Add(outputName + "Shape", rule);
                    }
                    catch
                    {
                        // Unable to Intersect the Curves - Default to a projection with no trim
                        double projectionHeight;
                        double startHeight;
                        if (offset1 >= 0)
                        {
                            projectionHeight = dummyLegShape.dummyHeight - elbowRadius;
                            startHeight = elbowRadius;
                        }
                        else
                        {
                            projectionHeight = dummyLegShape.dummyHeight;
                            startHeight = 0;
                        }

                        Projection3d defaultProj = new Projection3d(CreChamBoxLine(new Position(-offset1, 0, -startHeight), dummyLegShape.dummyDepth, dummyLegShape.dummyWidth, true), new Vector(0, 0, -1), projectionHeight, true);
                        defaultProj.Transform(matrix);
                        outputs.Add(outputName + "Shape", defaultProj);
                    }
                }
                else if (dummyLegShape.dummyShape == 3)               //Steel Standard Shape
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrSteelDummy, "DummyLeg shape cannot be created for standard steel");
                }
            }
            catch (SmartPartSymbolException hgrEx)
            {
                throw hgrEx;
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddDummyLegShape, "Error in AddDummyLegShape");
                }
            }
        }
        /// <summary>
        ///Create the graphical representation of a Stanchion.  
        /// </summary>
        ///<param name="stanchShape">Structure for specifying the inputs for the stanchShape -stanchShapeinputs </param>
        ///<param name="matrix">matrix to specify the position and oreintation the graphics - matrix.</param>
        /// <param name="outputs">Collection of declared outputs, which is indexed by the name of the outputs declared as defining SymbolOutputs on the AspectDefinition field- OutputDictionary</param>
        /// <param name="outputName">Output that this graphic is being placed on-String</param>
        ///<code>
        ///  AddStanchionShape(botStanchionShape, matrix, m_Symbolic.Outputs, "DummyStanchBot", fixedLength);
        ///</code>
        public void AddStanchionShape(StanchionShapeInputs stanchShape, Matrix4X4 matrix, OutputDictionary outputs, String outputName, bool fixedlength = true)
        {
            try
            {
                PlateInputs plate1 = new PlateInputs();
                PlateInputs plate2 = new PlateInputs();
                int m;
                SteelMember steel;
                double boltDistance;
                Matrix4X4 plateMatrix = new Matrix4X4();
                SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();

                if (!(stanchShape.plate1Shape == "" || stanchShape.plate1Shape == "No Value"))
                {
                    //Load Baseplate Data by Query
                    plate1 = LoadPlateDataByQuery(stanchShape.plate1Shape);
                    boltDistance = (stanchShape.pinLen / 2) - stanchShape.pinDia - plate1.thickness1;
                    if (fixedlength == false)
                    {
                        plate1.thickness1 = -plate1.thickness1;
                        boltDistance = -boltDistance;
                    }
                    plateMatrix = new Matrix4X4();
                    plateMatrix.SetIdentity();
                    plateMatrix.Translate(new Vector(-plate1.width1 / 2.0, -plate1.length1 / 2.0, 0));
                    //Base Plate
                    AddPlate(plate1, plateMatrix, outputs, outputName + "Plate1Shape");
                    Projection3d pro = (Projection3d)outputs[outputName + "Plate1Shape"];
                    pro.Transform(matrix);

                    if (stanchShape.includeBolts == 2 || stanchShape.includeBolts == 4)
                    {
                        if ((int)stanchShape.BoltRow1.MultiQty != 0)
                        {
                            AddBoltsByRow(plate1.width1, stanchShape.BoltRow1.MultiQty, stanchShape.BoltRow1.MultiLocateBy, stanchShape.BoltRow1.MultiLocation, stanchShape.pinDia, stanchShape.pinLen, stanchShape.BoltRow1.Offset, 90, 1, outputs, outputName + "LeftBotBolt", "", 0, false, -boltDistance);

                            AddBoltsByRow(plate1.width1, stanchShape.BoltRow1.MultiQty, stanchShape.BoltRow1.MultiLocateBy, stanchShape.BoltRow1.MultiLocation, stanchShape.pinDia, stanchShape.pinLen, -stanchShape.BoltRow1.Offset, 90, 1, outputs, outputName + "RightBotBolt", "", 0, false, -boltDistance);

                            for (m = 1; m <= stanchShape.BoltRow1.MultiQty; m++)
                            {
                                Projection3d pro1 = (Projection3d)outputs[outputName + "LeftBotBolt" + Convert.ToString(1) + Convert.ToString(m - 1)];
                                pro1.Transform(matrix);
                                Projection3d pro2 = (Projection3d)outputs[outputName + "RightBotBolt" + Convert.ToString(1) + Convert.ToString(m - 1)];
                                pro2.Transform(matrix);

                            }
                        }
                    }
                }
                //Stanchion
                if (stanchShape.stanShape == 1) //Cylinder
                {
                    Vector normal = new Vector(0, 0, 1);
                    Vector orthogonal = normal.GetOrthogonalVector();
                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(0, 0, plate1.thickness1);
                    symbolGeometryHelper.SetOrientation(normal, orthogonal);
                    Projection3d cylinder1 = (Projection3d)symbolGeometryHelper.CreateCylinder(null, stanchShape.stanWidth / 2.0, stanchShape.stanHeight);
                    cylinder1.Transform(matrix);
                    outputs.Add(outputName + "Shape", cylinder1);
                }
                else if (stanchShape.stanShape == 2)   //Square or Rectangle
                {
                    if (stanchShape.stanDepth <= 0)
                    {
                        stanchShape.stanDepth = stanchShape.stanWidth;
                    }
                    symbolGeometryHelper = new SymbolGeometryHelper();

                    double height;
                    height = stanchShape.stanHeight;
                    if (height > 0)
                    {
                        symbolGeometryHelper.ActivePosition = new Position(-stanchShape.stanDepth / 2, -stanchShape.stanWidth / 2, plate1.thickness1);
                    }
                    else if (height < 0)
                    {
                        symbolGeometryHelper.ActivePosition = new Position(-stanchShape.stanDepth / 2, -stanchShape.stanWidth / 2, plate1.thickness1 + height);
                        height = Math.Abs(height);
                    }
                    Projection3d box2 = (Projection3d)symbolGeometryHelper.CreateBox(null, stanchShape.stanDepth, stanchShape.stanWidth, height, 9);
                    box2.Transform(matrix);
                    outputs.Add(outputName + "Shape", box2);
                }
                else if (stanchShape.stanShape == 3) //Steel Standard Shape
                {
                    steel = GetSectionDataFromSection(stanchShape.steelStandard, stanchShape.steelType, stanchShape.steelName);
                    if (fixedlength == false)
                    {
                        steel.width = -steel.width;
                        //steel.depth = steel.depth;
                    }
                    plateMatrix = new Matrix4X4();
                    plateMatrix.SetIdentity();
                    plateMatrix.Rotate(Math.PI / 2, new Vector(1, 0, 0));
                    plateMatrix.Translate(new Vector(-steel.width / 2.0, steel.depth / 2, stanchShape.stanHeight / 2 + plate1.thickness1));

                    DrawStandardSection(stanchShape.steelStandard, stanchShape.steelType, stanchShape.steelName, stanchShape.stanHeight, stanchShape.steelAngle, (int)stanchShape.steelCpoint, outputs, plateMatrix, outputName + "Shape");
                    if (stanchShape.steelType == "2L" || stanchShape.steelType == "2C")
                    {
                        Projection3d proDraw = (Projection3d)outputs[outputName + "ShapeSecComp1"];
                        proDraw.Transform(matrix);
                        Projection3d proDraw1 = (Projection3d)outputs[outputName + "ShapeSecComp2"];
                        proDraw1.Transform(matrix);
                    }
                    else
                    {
                        Projection3d proDraw = (Projection3d)outputs[outputName + "ShapeSecComp1"];
                        proDraw.Transform(matrix);
                    }
                }
                if (!(stanchShape.plate2Shape == "No Value" || stanchShape.plate2Shape == ""))
                {
                    //Load Optionalplate Data by Query
                    plate2 = LoadPlateDataByQuery(stanchShape.plate2Shape);
                    boltDistance = (stanchShape.pinLen / 2) - stanchShape.pinDia - plate2.thickness1;
                    if (fixedlength == false)
                    {
                        plate2.thickness1 = -plate2.thickness1;
                        boltDistance = -boltDistance;
                    }
                    plateMatrix = new Matrix4X4();
                    plateMatrix.SetIdentity();
                    plateMatrix.Translate(new Vector(-plate2.width1 / 2.0, -plate2.length1 / 2.0, stanchShape.stanHeight + plate1.thickness1));
                    AddPlate(plate2, plateMatrix, outputs, outputName + "Plate2Shape");  //Optional Plate
                    Projection3d pro3 = (Projection3d)outputs[outputName + "Plate2Shape"];
                    pro3.Transform(matrix);

                    if (stanchShape.includeBolts == 3 || stanchShape.includeBolts == 4)
                    {
                        if ((int)stanchShape.BoltRow1.MultiQty != 0)
                        {
                            AddBoltsByRow(plate2.width1, stanchShape.BoltRow1.MultiQty, stanchShape.BoltRow1.MultiLocateBy, stanchShape.BoltRow1.MultiLocation, stanchShape.pinDia, stanchShape.pinLen, stanchShape.BoltRow1.Offset, 90, 1, outputs, outputName + "LeftTopBolt", outputName + "LeftTopBolt", 0, false, stanchShape.stanHeight + plate1.thickness1 - boltDistance);

                            AddBoltsByRow(plate2.width1, stanchShape.BoltRow1.MultiQty, stanchShape.BoltRow1.MultiLocateBy, stanchShape.BoltRow1.MultiLocation, stanchShape.pinDia, stanchShape.pinLen, -stanchShape.BoltRow1.Offset, 90, 1, outputs, outputName + "RightTopBolt", outputName + "RightTopBolt", 0, false, stanchShape.stanHeight + plate1.thickness1 - boltDistance);

                            for (m = 1; m <= stanchShape.BoltRow1.MultiQty; m++)
                            {
                                Projection3d pro1 = (Projection3d)outputs[outputName + "LeftTopBolt" + Convert.ToString(1) + Convert.ToString(m - 1)];
                                pro1.Transform(matrix);
                                Projection3d pro2 = (Projection3d)outputs[outputName + "RightTopBolt" + Convert.ToString(1) + Convert.ToString(m - 1)];
                                pro2.Transform(matrix);

                            }
                        }
                    }
                }
            }

            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddStanchShape, "Error in AddStanchionShape");
                }
            }
        }
        /// <summary>
        /// This property Used To Query The Data from DataBase based on the Shapetype
        /// </summary>
        /// <param name="refShapeName">RefShapeName</param>
        /// <code>
        /// stanchshape= LoadDummyLegShapeDataByQuery(string refShapeName)
        /// </code>
        public DummyLegShapeInputs LoadDummyLegShapeDataByQuery(string refShapeName)
        {
            DummyLegShapeInputs dummyShape = new DummyLegShapeInputs();
            try
            {
                if (!(refShapeName == "" || refShapeName == "No Value"))
                {
                    Catalog m_oPlantCatalog = MiddleServiceProvider.SiteMgr.ActiveSite.ActivePlant.PlantCatalog;
                    BusinessObject dummylegAuxTable = m_oPlantCatalog.GetNamedObject(refShapeName);

                    dummyShape.dummyShape = (int)((PropertyValueCodelist)dummylegAuxTable.GetPropertyValue("IJUAhsDummyShape", "DummyShape")).PropValue;
                    try
                    {
                        dummyShape.dummyHeight = (double)((PropertyValueDouble)dummylegAuxTable.GetPropertyValue("IJUAhsDummyHeight", "DummyHeight")).PropValue;
                    }
                    catch
                    {
                        dummyShape.dummyHeight = 0;
                    }
                    try
                    {
                        dummyShape.dummyWidth = (double)((PropertyValueDouble)dummylegAuxTable.GetPropertyValue("IJUAhsDummyWidth", "DummyWidth")).PropValue;
                    }
                    catch
                    {
                        dummyShape.dummyWidth = 0;
                    }
                    try
                    {
                        dummyShape.dummyDepth = (double)((PropertyValueDouble)dummylegAuxTable.GetPropertyValue("IJUAhsDummyDepth", "DummyDepth")).PropValue;
                    }
                    catch
                    {
                        dummyShape.dummyDepth = 0;
                    }

                    dummyShape.steelCpoint = (int)((PropertyValueCodelist)dummylegAuxTable.GetPropertyValue("IJUAhsSteelCPoint", "SteelCpoint")).PropValue;
                    if (dummyShape.steelCpoint == -1)
                        dummyShape.steelCpoint = 1; // setting the default value
                    try
                    {
                        dummyShape.steelAngle = (double)((PropertyValueDouble)dummylegAuxTable.GetPropertyValue("IJUAhssteelAngle", "SteelAngle")).PropValue;
                    }
                    catch
                    {
                        dummyShape.steelAngle = 0;
                    }
                    dummyShape.steelStandard = (string)((PropertyValueString)dummylegAuxTable.GetPropertyValue("IJUAhsSteelSection", "SteelStandard")).PropValue;
                    if (dummyShape.steelStandard == null)
                    {
                        dummyShape.steelStandard = "";
                    }
                    dummyShape.steelType = (string)((PropertyValueString)dummylegAuxTable.GetPropertyValue("IJUAhsSteelSection", "SteelType")).PropValue;
                    if (dummyShape.steelType == null)
                        dummyShape.steelType = "";
                    dummyShape.steelName = (string)((PropertyValueString)dummylegAuxTable.GetPropertyValue("IJUAhsSteelSection", "SteelName")).PropValue;
                    if (dummyShape.steelName == null)
                    {
                        dummyShape.steelName = "";
                    }
                    try
                    {
                        dummyShape.diameter = (double)((PropertyValueDouble)dummylegAuxTable.GetPropertyValue("IJUAhsDummyDia", "Diameter")).PropValue;
                    }
                    catch
                    {
                        dummyShape.diameter = 0;
                    }
                    dummyShape.plateShape = (string)((PropertyValueString)dummylegAuxTable.GetPropertyValue("IJUAhsDummyPlate", "PlateShape")).PropValue;
                    if (dummyShape.plateShape == null)
                    {
                        dummyShape.plateShape = "";
                    }
                    dummyShape.includeBolts = (int)((PropertyValueCodelist)dummylegAuxTable.GetPropertyValue("IJUAhsIncludeBolts", "IncludeBolts")).PropValue;
                    try
                    {
                        dummyShape.pinDia = (double)((PropertyValueDouble)dummylegAuxTable.GetPropertyValue("IJUAhsPin1", "Pin1Diameter")).PropValue;
                    }
                    catch
                    {
                        dummyShape.pinDia = 0;
                    }
                    try
                    {
                        dummyShape.pinLen = (double)((PropertyValueDouble)dummylegAuxTable.GetPropertyValue("IJUAhsPin1", "Pin1Length")).PropValue;
                    }
                    catch
                    {
                        dummyShape.pinLen = 0;
                    }
                    try
                    {
                        dummyShape.BoltRow1.Offset = (double)((PropertyValueDouble)dummylegAuxTable.GetPropertyValue("IJUAhsOffset1", "Offset1")).PropValue;
                    }
                    catch
                    {
                        dummyShape.BoltRow1.Offset = 0;
                    }
                    try
                    {
                        dummyShape.BoltRow1.MultiQty = (double)((PropertyValueDouble)dummylegAuxTable.GetPropertyValue("IJUAhsMulti1", "Multi1Qty")).PropValue;

                    }
                    catch
                    {
                        dummyShape.BoltRow1.MultiQty = 0;
                    }
                    dummyShape.BoltRow1.MultiLocateBy = (double)((PropertyValueCodelist)dummylegAuxTable.GetPropertyValue("IJUAhsMulti1", "Multi1LocateBy")).PropValue;
                    try
                    {
                        dummyShape.BoltRow1.MultiLocation = (double)((PropertyValueDouble)dummylegAuxTable.GetPropertyValue("IJUAhsMulti1", "Multi1Location")).PropValue;
                    }
                    catch
                    {
                        dummyShape.BoltRow1.MultiLocation = 0;
                    }
                }


            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadDummyLegShapeDataByQuery, "Error in LoadDummyLegShapeDataByQuery");
                }
            }
            return dummyShape;
        }
        /// <summary>
        /// This property Used To Query The Data from DataBase based on the Shapetype
        /// </summary>
        /// <param name="refShapeName">RefShapeName</param>
        /// <code>
        /// stanchshape=LoadStanchShapeDataByQuery(string refShapeName)
        /// </code>
        public StanchionShapeInputs LoadStanchShapeDataByQuery(string refShapeName)
        {
            StanchionShapeInputs stanShape = new StanchionShapeInputs();
            try
            {
                if (!(refShapeName == "" || refShapeName == "No Value" || refShapeName == null))
                {
                    Catalog m_oPlantCatalog = MiddleServiceProvider.SiteMgr.ActiveSite.ActivePlant.PlantCatalog;
                    BusinessObject BeamClipAuxTable = m_oPlantCatalog.GetNamedObject(refShapeName);

                    stanShape.stanShape = (int)((PropertyValueCodelist)BeamClipAuxTable.GetPropertyValue("IJUAhsStanShape", "StanShape")).PropValue;
                    try
                    {
                        stanShape.stanHeight = (double)((PropertyValueDouble)BeamClipAuxTable.GetPropertyValue("IJUAhsStanHeight", "StanHeight")).PropValue;
                    }
                    catch
                    {
                        stanShape.stanHeight = 0;
                    }
                    try
                    {
                        stanShape.stanWidth = (double)((PropertyValueDouble)BeamClipAuxTable.GetPropertyValue("IJUAhsStanWidth", "StanWidth")).PropValue;
                    }
                    catch
                    {
                        stanShape.stanWidth = 0;
                    }
                    try
                    {
                        stanShape.stanDepth = (double)((PropertyValueDouble)BeamClipAuxTable.GetPropertyValue("IJUAhsStanDepth", "StanDepth")).PropValue;
                    }
                    catch
                    {
                        stanShape.stanDepth = 0;
                    }
                    stanShape.steelCpoint = (int)((PropertyValueCodelist)BeamClipAuxTable.GetPropertyValue("IJUAhsSteelCPoint", "SteelCpoint")).PropValue;
                    if (stanShape.steelCpoint == -1)
                        stanShape.steelCpoint = 1; // setting the default value
                    try
                    {
                        stanShape.steelAngle = (double)((PropertyValueDouble)BeamClipAuxTable.GetPropertyValue("IJUAhssteelAngle", "SteelAngle")).PropValue;
                    }
                    catch
                    {
                        stanShape.steelAngle = 0;
                    }
                    try
                    {
                        stanShape.steelStandard = (string)((PropertyValueString)BeamClipAuxTable.GetPropertyValue("IJUAhsSteelSection", "SteelStandard")).PropValue;
                    }
                    catch
                    {
                        stanShape.steelStandard = "";
                    }
                    try
                    {
                        stanShape.steelName = (string)((PropertyValueString)BeamClipAuxTable.GetPropertyValue("IJUAhsSteelSection", "SteelName")).PropValue;
                        if (stanShape.steelName == null)
                        {
                            stanShape.steelName = "";
                        }
                    }
                    catch
                    {
                        stanShape.steelName = "";
                    }
                    try
                    {
                        stanShape.steelType = (string)((PropertyValueString)BeamClipAuxTable.GetPropertyValue("IJUAhsSteelSection", "SteelType")).PropValue;
                    }
                    catch
                    {
                        stanShape.steelType = "";
                    }
                    stanShape.plate1Shape = (string)((PropertyValueString)BeamClipAuxTable.GetPropertyValue("IJUAhsStanPlate1", "Plate1Shape")).PropValue;
                    if (stanShape.plate1Shape == null)
                    {
                        stanShape.plate1Shape = "";
                    }
                    stanShape.plate2Shape = (string)((PropertyValueString)BeamClipAuxTable.GetPropertyValue("IJUAhsStanPlate2", "Plate2Shape")).PropValue;
                    if (stanShape.plate2Shape == null)
                    {
                        stanShape.plate2Shape = "";
                    }
                    stanShape.includeBolts = (int)((PropertyValueCodelist)BeamClipAuxTable.GetPropertyValue("IJUAhsIncludeBolts", "IncludeBolts")).PropValue;
                    try
                    {
                        stanShape.pinDia = (double)((PropertyValueDouble)BeamClipAuxTable.GetPropertyValue("IJUAhsPin1", "Pin1Diameter")).PropValue;
                    }
                    catch
                    {
                        stanShape.pinDia = 0;
                    }
                    try
                    {
                        stanShape.pinLen = (double)((PropertyValueDouble)BeamClipAuxTable.GetPropertyValue("IJUAhsPin1", "Pin1Length")).PropValue;
                    }
                    catch
                    {
                        stanShape.pinLen = 0;
                    }
                    try
                    {
                        stanShape.BoltRow1.Offset = (double)((PropertyValueDouble)BeamClipAuxTable.GetPropertyValue("IJUAhsOffset1", "Offset1")).PropValue;
                    }
                    catch
                    {
                        stanShape.BoltRow1.Offset = 0;
                    }
                    try
                    {
                        stanShape.BoltRow1.MultiQty = (double)((PropertyValueDouble)BeamClipAuxTable.GetPropertyValue("IJUAhsMulti1", "Multi1Qty")).PropValue;
                    }
                    catch
                    {
                        stanShape.BoltRow1.MultiQty = 0;
                    }
                    stanShape.BoltRow1.MultiLocateBy = (double)((PropertyValueCodelist)BeamClipAuxTable.GetPropertyValue("IJUAhsMulti1", "Multi1LocateBy")).PropValue;
                    try
                    {
                        stanShape.BoltRow1.MultiLocation = (double)((PropertyValueDouble)BeamClipAuxTable.GetPropertyValue("IJUAhsMulti1", "Multi1Location")).PropValue;
                    }
                    catch
                    {
                        stanShape.BoltRow1.MultiLocation = 0;
                    }
                }
                else
                {
                    stanShape.plate1Shape = "";
                    stanShape.plate2Shape = "";
                    stanShape.steelName = "";
                    stanShape.steelType = "";
                    stanShape.steelStandard = "";
                }


            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadStanchShapeDataByQuery, "Error in LoadStanchShapeDataByQuery");
                }
            }
            return stanShape;
        }
        /// <summary>
        ///Create the plates With Bolts
        /// </summary>
        /// <param name="plate"> specifying Measurements for plate </param>

        ///<param name="matrix">matrix to specify the position and oreintation the graphics - matrix.</param>
        /// <param name="outputs">Collection of declared outputs, which is indexed by the name of the outputs declared as defining SymbolOutputs on the AspectDefinition field- OutputDictionary</param>
        /// <param name="outputName">Output that this graphic is being placed on-String</param>
        ///<code>
        /// AddPlateShapeWithBolts(plate1, dummyMatrix, outputs, outputName, dummyLegShape.BoltRow1.MultiQty, plate1.width1, dummyLegShape.BoltRow1.MultiLocateBy, dummyLegShape.BoltRow1.MultiLocation, dummyLegShape.pinDia, dummyLegShape.pinLen, dummyLegShape.BoltRow1.Offset, 90, 1, 0, false, -boltDist);
        ///</code>
        public void AddPlateShapeWithBolts(PlateInputs plate1, Matrix4X4 matrix, OutputDictionary outputs, String outputName, double qty = 0, double width = 0, double locateBy = 1, double distance = 0, double pinDiameter = 0, double pinLength = 0, double offset = 0, double angle1 = 0, double row = 1, double rotAngle = 1, bool isRiser = false, double zOffset = 0)
        {
            try
            {
                int m;
                Matrix4X4 plateMatrix = new Matrix4X4();
                plateMatrix.Translate(new Vector(-plate1.width1 / 2, -plate1.length1 / 2, 0));
                AddPlate(plate1, plateMatrix, outputs, outputName + "Plate1Shape");
                Projection3d pro1 = (Projection3d)outputs[outputName + "Plate1Shape"];
                pro1.Transform(matrix);
                if (qty != 0)
                {
                    AddBoltsByRow(width, qty, locateBy, distance, pinDiameter, pinLength, offset, angle1, row, outputs, outputName + "LeftBotBolt", outputName + "LeftBotBolt", rotAngle, isRiser, zOffset);

                    AddBoltsByRow(width, qty, locateBy, distance, pinDiameter, pinLength, -offset, angle1, row, outputs, outputName + "RightBotBolt", outputName + "RightBotBolt", rotAngle, isRiser, zOffset);


                    for (m = 1; m <= qty; m++)
                    {
                        Projection3d pro2 = (Projection3d)outputs[outputName + "LeftBotBolt" + Convert.ToString(1) + Convert.ToString(m - 1)];
                        pro2.Transform(matrix);
                        Projection3d pro3 = (Projection3d)outputs[outputName + "RightBotBolt" + Convert.ToString(1) + Convert.ToString(m - 1)];
                        pro3.Transform(matrix);

                    }
                }
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadStanchShapeDataByQuery, "Error in AddPlateShapeWithBolts");
                }
            }
        }
        /// <summary>
        ///Create the graphical Projection of topDummy
        /// </summary>
        ///<param name="cp"> specifying the Position to be created </param>
        ///<param name="Width">Specifies The Width</param>
        ///<param name="depth">Specifies The Depth</param>
        ///<param name="Center">Specifies the direction</param>
        ///<code>
        /// ComplexString3d complexString = CreChamBoxLine(new Position(0, 0, 0), dummyLegShape.dummyDepth, dummyLegShape.dummyDepth / 2, true);
        ///</code>
        public ComplexString3d CreChamBoxLine(Position cp, double width, double depth, bool centerAxisUpward)
        {
            Collection<ICurve> curveCollection = new Collection<ICurve>();
            try
            {
                SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();
                Position[] pos = new Position[5];

                pos[1] = new Position(cp.X - width / 2, cp.Y + depth / 2, cp.Z);
                pos[2] = new Position(cp.X + width / 2, cp.Y + depth / 2, cp.Z);
                pos[3] = new Position(cp.X + width / 2, cp.Y - depth / 2, cp.Z);
                pos[4] = new Position(cp.X - width / 2, cp.Y - depth / 2, cp.Z);

                curveCollection.Add(new Line3d(pos[1], pos[2]));
                curveCollection.Add(new Line3d(pos[2], pos[3]));
                curveCollection.Add(new Line3d(pos[3], pos[4]));
                curveCollection.Add(new Line3d(pos[4], pos[1]));
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrCreChamBoxLine, "Error in CreChamBoxLine");
                }
            }
            ComplexString3d complexString3 = new ComplexString3d(curveCollection);
            return complexString3;

        }
        /// <summary>
        ///Create the graphical representation of a SteelStandard
        /// </summary>
        ///<param name="sectionStandard">Specifying the Sectionstandard</param>
        ///<param name="sectionType">Specifying the Sectionstandard.</param>
        ///<param name="sectionName">Specifying the sectionName</param>
        ///<param name="sectionType">Specifying the Sectionstandard.</param>
        ///<param name="length">Specifying the length</param>
        ///<param name="angle">Specifying the angle.</param>
        ///<param name="cardinalPoint">Specifying the cardinalPoint.</param>
        /// <param name="outputs">Collection of declared outputs, which is indexed by the name of the outputs declared as defining SymbolOutputs on the AspectDefinition field- OutputDictionary</param>
        /// <param name="outputName">Output that this graphic is being placed on-String</param>
        ///<code>
        ///DrawStandardSection(stanchShape.steelStandard, stanchShape.steelType, stanchShape.steelName, stanchShape.stanHeight, stanchShape.steelAngle, (int)stanchShape.steelCpoint, outputs, plateMatrix, outputName + "Shape");
        ///</code>
        public void DrawStandardSection(string sectionStandard, string sectionType, string sectionName, double length, double angle, long cardinalPoint, OutputDictionary outputs, Matrix4X4 matrix, string outputName)
        {
            try
            {
                CrossSectionServices crossSectionServices = new CrossSectionServices();
                CatalogStructHelper catalogStructHelper = new CatalogStructHelper();
                CrossSection crossSection = catalogStructHelper.GetCrossSection(sectionStandard, sectionType, sectionName);
                Line3d projectionLeftHorizontal = new Line3d(new Position(0, length / 2, 0), new Position(0, -length / 2, 0));
                // Get cardinal offsets
                SweepOptions sweepOptions = (SweepOptions)1;
                Collection<ISurface> crossSecSurfaces1 = crossSectionServices.GetProjectionSurfacesFromCrossSection(crossSection, projectionLeftHorizontal, (int)cardinalPoint, true, angle, sweepOptions);
                for (int i = 1; i <= crossSecSurfaces1.Count; i++)
                {
                    Geometry3d csSurface1 = (Geometry3d)crossSecSurfaces1[i - 1];
                    csSurface1.Transform(matrix);
                    outputs.Add(outputName + "SecComp" + i, csSurface1);
                }
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrDrawStandardSection, "Error in DrawStandardSection");
            }
        }
        /// <summary>
        /// Adds the Shoe.
        /// </summary>
        /// <param name="ShoeInputs">Structure for specifying the inputs for the Shoe -ShoeInputs.</param>
        /// <param name="matrix">Matrix to specify the position and oreintation the graphics - Matrix4X4.</param>
        /// <param name="outputs">Collection of declared outputs, which is indexed by the name of the outputs declared as defining SymbolOutputs on the AspectDefinition field- OutputDictionary.</param>
        /// <param name="outputName">OutputName that this graphic is being placed on-String.</param>
        ///<code>
        /// matrix = new Matrix4X4();
        /// matrix.Origin = new Position(0, 0, -vertOffset2);
        /// AddWBAHole(Shoe, matrix, m_PhysicalAspect.Outputs, "Shoe");
        public void AddShoe(ShoeInputs shoe, Double gap, Matrix4X4 matrix, OutputDictionary outputs, Double diameter = 0, String outputName = "ShoeShape", String name = "None")
        {
            try
            {
                Boolean bDrawAsPlates, bUseSteelDim;
                SteelMember tSteel = new SteelMember();
                Double dShoeShapeWidth = 0, dShoeShapeHeight = 0, ShoeShapeTopWidth = 0, dExtensionThickness = 0, ExtensionGap = 0, dTopPlateDepthPos = 0, dTopThickness = 0, dBaseThickness = 0, ShoeShapeLegHieght = 0, turnAngle = 0;

                Double[] vector = new Double[3];

                if (shoe.Continous == 1)
                    bDrawAsPlates = false;
                else
                    bDrawAsPlates = true;
                // This checks whether the user has specified steel cross-section details signifying that the shoe shape
                // should be drawn as a piece of steel and NOT as plates assembled/welded together

                if (shoe.SectionStandard != "" && shoe.SectionName != "No Value" && shoe.SectionStandard != "" && shoe.SectionStandard != "No Value" && shoe.SectionType != "" && shoe.SectionType != "No Value" && shoe.SectionStandard != null && shoe.SectionName != null)
                {
                    bUseSteelDim = true;
                    // This gets the steel cross section data by querying the database.
                    // It requires 1-Section Standard, 2-Section Type, 3-Section Name
                    tSteel = GetSectionDataFromSection(shoe.SectionStandard, shoe.SectionType, shoe.SectionName);
                    // If the ShoeType is set to 11 which means match steel exactly to standard
                    if (shoe.ShoeType == 10)
                    {
                        // Shoe Shape Width & Height is that of actual beam
                        dShoeShapeWidth = tSteel.flangeWidth;
                        dShoeShapeHeight = tSteel.webDepth + tSteel.webThickness;
                    }
                    else
                    {
                        // Shoe Shape Width & Height is set to user defined width
                        dShoeShapeWidth = shoe.ShoeWidth;
                        dShoeShapeHeight = shoe.ShoeHeight;
                    }
                }
                else
                {
                    bUseSteelDim = false;
                    // If the ShoeType is set to 11 which means match steel exactly to standard
                    if (shoe.ShoeType == 10)
                    {
                        // Shoe Shape Width is that of actual beam
                        dShoeShapeWidth = tSteel.flangeWidth;
                        dShoeShapeHeight = tSteel.webDepth + tSteel.webThickness;
                    }
                    else
                    {
                        // Shoe Shape Width is set to user defined width
                        dShoeShapeWidth = shoe.ShoeWidth;
                        dShoeShapeHeight = shoe.ShoeHeight;
                    }
                }
                ExtensionGap = shoe.TopPlateGap;
                if (bDrawAsPlates)
                {
                    dTopThickness = shoe.ShoeThickness1;
                    dBaseThickness = shoe.ShoeThickness2;
                }
                else
                {
                    if (bUseSteelDim == true)
                    {
                        dTopThickness = tSteel.webThickness;
                        dBaseThickness = tSteel.flangeThickness;
                    }
                    else
                    {
                        dTopThickness = shoe.ShoeThickness1;
                        dBaseThickness = shoe.ShoeThickness2;
                    }
                }
                if (shoe.HasExtension)
                {
                    if (HgrCompareDoubleService.cmpdbl(shoe.TopPlateThickness, 0) == false)
                        dExtensionThickness = shoe.TopPlateThickness;
                    else
                    {
                        if (!bDrawAsPlates)
                            dExtensionThickness = tSteel.webThickness;
                        else
                            dExtensionThickness = shoe.TopPlateThickness;
                    }
                    dTopPlateDepthPos = shoe.ExtensionPlateAxialOffset;

                }
                if (!(shoe.ShoeHeight > 0))
                {
                    ToDoListMessage = new ToDoListMessage(ToDoMessageTypes.ToDoMessageWarning, SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidHeightValue, "Height is required"));
                }

                Double shoespacing;
                if (shoe.ShoeSpacingFrm == 1)
                    shoespacing = (shoe.ShoeSpacing) * 2;
                else if (shoe.ShoeSpacingFrm == 2)
                    shoespacing = (shoe.ShoeWidth) - (shoe.ShoeSpacing + shoe.ShoeThickness1) * 2;
                else
                    shoespacing = shoe.ShoeSpacing;

                // THIS IS THE MAIN SELECT CASE BLOCK THAT DEALS WITH ALL THE GENERAL SHOE SHAPES
                int i = shoe.ShoeType;
                switch (i)
                {
                    case 0:  // Nothing

                        break;
                    case 1:  // T
                        {
                            ShoeShapeTopWidth = GetLegWidthOnTop(shoe);
                            ShoeShapeLegHieght = LegHeightToPipe(ShoeShapeTopWidth, diameter, shoe.ShoeHeight, shoe.LegHeight, gap);
                            DrawBeam_T(dShoeShapeWidth, ShoeShapeLegHieght, shoe.ShoeLength, dBaseThickness, dTopThickness, bDrawAsPlates, outputs, matrix, outputName, name, shoe.SectionStandard, shoe.SectionType, shoe.SectionName, shoe.HasExtension, shoe.ExtensionType, shoe.TopPlateLength,
                                shoe.TopPlateHeight, dExtensionThickness, dTopPlateDepthPos, ExtensionGap, shoe.SlopeAngle, shoe.TopPlateOffset, diameter, shoe.HorizontalPlateLength, shoe.VerticalPlateLength);
                        }
                        break;
                    case 2:  // Double _| |_
                        {
                            ShoeShapeTopWidth = GetLegWidthOnTop(shoe);
                            ShoeShapeLegHieght = LegHeightToPipe(ShoeShapeTopWidth, diameter, shoe.ShoeHeight, shoe.LegHeight, gap);
                            DrawBeam_B2BL(dShoeShapeWidth, ShoeShapeLegHieght, shoe.ShoeLength, dBaseThickness, dTopThickness, shoe.ShoeSpacing, bDrawAsPlates, outputs, matrix, outputName, name, shoe.SectionStandard, shoe.SectionType, shoe.SectionName, shoe.HasExtension, shoe.ExtensionType, shoe.TopPlateLength,
                                shoe.TopPlateHeight, dExtensionThickness, dTopPlateDepthPos, ExtensionGap, shoe.SlopeAngle, shoe.TopPlateOffset, shoe.HorizontalPlateLength, shoe.VerticalPlateLength);
                        }
                        break;
                    case 3:  // Cradle
                        {
                            ShoeShapeTopWidth = GetLegWidthOnTop(shoe);
                            ShoeShapeLegHieght = LegHeightToPipe(ShoeShapeTopWidth, diameter, shoe.ShoeHeight, shoe.LegHeight, gap);
                            DrawBeam_Cradle(dShoeShapeWidth, ShoeShapeLegHieght, shoe.ShoeLength, dBaseThickness, dTopThickness, shoespacing, bDrawAsPlates, outputs, matrix, outputName, name, shoe.SectionStandard, shoe.SectionType, shoe.SectionName, shoe.HasExtension, shoe.ExtensionType, shoe.TopPlateLength,
                                shoe.TopPlateHeight, dExtensionThickness, dTopPlateDepthPos, ExtensionGap, shoe.SlopeAngle, shoe.TopPlateOffset, shoe.HorizontalPlateLength, shoe.VerticalPlateLength);
                        }
                        break;
                    case 4:  // C
                        {
                            // Check to see if shoe dimensions make sense
                            shoe.ShoeSpacing = dShoeShapeWidth - (2 * dTopThickness);
                            ShoeShapeTopWidth = GetLegWidthOnTop(shoe);
                            ShoeShapeLegHieght = LegHeightToPipe(ShoeShapeTopWidth, diameter, shoe.ShoeHeight, shoe.LegHeight, gap);
                            DrawBeam_C(dShoeShapeWidth, ShoeShapeLegHieght, shoe.ShoeLength, dBaseThickness, dTopThickness, shoe.ShoeSpacing, bDrawAsPlates, outputs, matrix, outputName, name, shoe.SectionStandard, shoe.SectionType, shoe.SectionName, shoe.HasExtension, shoe.ExtensionType, shoe.TopPlateLength,
                                shoe.TopPlateHeight, dExtensionThickness, dTopPlateDepthPos, ExtensionGap, shoe.SlopeAngle, shoe.TopPlateOffset, shoe.HorizontalPlateLength, shoe.VerticalPlateLength);
                        }
                        break;
                    case 5:  // W
                        {
                            ShoeShapeTopWidth = GetLegWidthOnTop(shoe);
                            ShoeShapeLegHieght = LegHeightToPipe(ShoeShapeTopWidth, diameter, shoe.ShoeHeight, shoe.LegHeight, gap);
                            DrawBeam_W(dShoeShapeWidth, ShoeShapeLegHieght, shoe.ShoeLength, dBaseThickness, dTopThickness, bDrawAsPlates, outputs, matrix, outputName, name, shoe.SectionStandard, shoe.SectionType, shoe.SectionName, shoe.HasExtension, shoe.ExtensionType, shoe.TopPlateLength, shoe.TopPlateHeight, dExtensionThickness,
                                dTopPlateDepthPos, ExtensionGap, shoe.SlopeAngle, shoe.TopPlateOffset, shoe.HorizontalPlateLength, shoe.VerticalPlateLength);
                        }
                        break;
                    case 6:  // Double |_  _|
                        {
                            ShoeShapeTopWidth = GetLegWidthOnTop(shoe);
                            ShoeShapeLegHieght = LegHeightToPipe(ShoeShapeTopWidth, diameter, shoe.ShoeHeight, shoe.LegHeight, gap);
                            DrawBeam_2L(dShoeShapeWidth, ShoeShapeLegHieght, shoe.ShoeLength, dBaseThickness, dTopThickness, shoe.ShoeSpacing, bDrawAsPlates, outputs, matrix, outputName, name, shoe.SectionStandard, shoe.SectionType, shoe.SectionName, shoe.HasExtension, shoe.ExtensionType, shoe.TopPlateLength, shoe.TopPlateHeight,
                               dExtensionThickness, dTopPlateDepthPos, ExtensionGap, shoe.SlopeAngle, shoe.TopPlateOffset, shoe.HorizontalPlateLength, shoe.VerticalPlateLength);
                        }
                        break;
                    case 7:  // V
                        {
                            ShoeShapeLegHieght = VLegHeightToPipe(shoe, diameter, gap, ref turnAngle);
                            DrawBeam_Irregular(dShoeShapeWidth, ShoeShapeLegHieght, shoe.ShoeLength, dBaseThickness, dTopThickness, shoe.ShoeSpacing, shoe.LegLowerSpacing, bDrawAsPlates, outputs, matrix, outputName, name, shoe.SectionStandard, shoe.SectionType, shoe.SectionName, shoe.HasExtension, shoe.ExtensionType, shoe.TopPlateLength, shoe.TopPlateHeight,
                                dExtensionThickness, dTopPlateDepthPos, ExtensionGap, shoe.HorizontalPlateLength, shoe.VerticalPlateLength, turnAngle);
                        }
                        break;
                    case 8:  // Rotated C
                        {
                            // Check to see if shoe dimensions make sense
                            if (HgrCompareDoubleService.cmpdbl(shoe.ShoeSpacing, shoe.ShoeLength - (2 * dTopThickness)) == false)
                            {
                                MiddleServiceProvider.ErrorLogger.Log(0, "", "", "USERWARNINGMESSAGE", "AddShoe()" + ": " + "WARNING: " + "You have entered an invalid value for Vetical Leg Spacing" + "vbCrLf" + "It will now be updated to a valid value", "", "SmartPartComponentDefinition.cs", 1);

                                shoe.ShoeSpacing = shoe.ShoeLength - (2 * dTopThickness);
                            }
                            ShoeShapeTopWidth = GetLegWidthOnTop(shoe);
                            ShoeShapeLegHieght = LegHeightToPipe(ShoeShapeTopWidth, diameter, shoe.ShoeHeight, shoe.LegHeight, gap);
                            matrix = new Matrix4X4();
                            matrix.Rotate(Math.PI / 2, new Vector(0, 0, 1));
                            DrawBeam_C(shoe.ShoeLength, ShoeShapeLegHieght, dShoeShapeWidth, dBaseThickness, dTopThickness, shoe.ShoeSpacing, bDrawAsPlates, outputs, matrix, outputName, name, shoe.SectionStandard, shoe.SectionType, shoe.SectionName, false, shoe.ExtensionType, 0, 0, dExtensionThickness, 0, 0, 0, 0, dShoeShapeWidth, dShoeShapeWidth);
                        }
                        break;
                    case 9:  // Rotated Craddle
                        {
                            ShoeShapeTopWidth = GetLegWidthOnTop(shoe);
                            ShoeShapeLegHieght = LegHeightToPipe(ShoeShapeTopWidth, diameter, shoe.ShoeHeight, shoe.LegHeight, gap);
                            matrix = new Matrix4X4();
                            matrix.Rotate(Math.PI / 2, new Vector(0, 0, 1));
                            DrawBeam_Cradle(shoe.ShoeLength, ShoeShapeLegHieght, dShoeShapeWidth, dBaseThickness, dTopThickness, shoespacing, bDrawAsPlates, outputs, matrix, outputName, name, shoe.SectionStandard, shoe.SectionType, shoe.SectionName, false, shoe.ExtensionType, 0, 0, 0, 0, 0, 0, 0, dShoeShapeWidth, dShoeShapeWidth);
                        }
                        break;
                    case 10:  // Section Standard
                        {
                            DrawStandardSection(shoe.SectionStandard, shoe.SectionType, shoe.SectionName, shoe.ShoeLength, shoe.SteelAngle, (int)(shoe.SteelCpoint), outputs, matrix, outputName);
                        }
                        break;
                }
            }

            catch
            {
                ToDoListMessage = new ToDoListMessage(ToDoMessageTypes.ToDoMessageWarning, SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrShoe, "Error in Shoe"));
            }
        }
        public double GetDoubleorDefaultValueonPart(Part part, string interfaceName, string propertyName, int index)
        {
            double propertyvalue;

            if (part.SupportsInterface(interfaceName))
            {
                try
                {
                    propertyvalue = GetDoubleorDefaultValue(index);
                }
                catch (System.InvalidOperationException)
                {
                    propertyvalue = 0;
                }
            }
            else
                propertyvalue = 0.0;

            return propertyvalue;

        }
        public string GetstringorDefaultValueonPart(Part part, string interfaceName, string propertyName, int index)
        {
            string propertyvalue;

            if (part.SupportsInterface(interfaceName))
            {
                try
                {
                    propertyvalue = GetStringInputValue(index);
                }
                catch (System.InvalidOperationException)
                {
                    propertyvalue = "No Value";
                }
            }
            else
                propertyvalue = "No Value";

            return propertyvalue;

        }
        public double GetDoubleorDefaultValue(int index)
        {
            double value = 0;

            try
            {
                value = GetDoubleInputValue(index);
            }
            catch
            {
                value = 0;
            }

            return value;

        }
        public string GetStringeorDefaultValue(int index)
        {
            string value = string.Empty;

            try
            {
                value = GetStringInputValue(index);
            }
            catch
            {
                value = "No Value";
            }

            return value;

        }
        /// <summary>
        /// Finds the Greater Value
        /// </summary>
        /// <param name="Val1">First Value.</param>
        /// <param name="Val2">second Value</param>
        /// Optional values
        /// <param name="Val1">Third Value.</param>
        /// <param name="Val1">Fourth Value.</param>
        /// <param name="Val1">Fifth Value.</param>
        public double GetGreaterValue(double Val1, double Val2, double Val3 = 0, double Val4 = 0, double Val5 = 0)
        {
            double temp;
            temp = Val1;
            if (Val2 > temp)
            {
                temp = Val2;
            }
            if (Val3 > temp)
            {
                temp = Val3;
            }
            if (Val4 > temp)
            {
                temp = Val4;
            }
            if (Val5 > temp)
            {
                temp = Val5;
            }
            return temp;
        }
        /// <summary>
        /// This method will be called by user symbol to get value of an input(in this case, DummyLeg input structure)during construction of outputs. 
        /// Given the start index, this method will return the value of the DummyLegData struct object.
        /// </summary>
        /// <param name="startIndex">The start index.</param>
        /// <returns></returns>
        ///<code>
        ///DummyLegInputs dummyLeg = LoadDummyLegData(2, out startIndex);
        ///</code>
        public DummyLegInputs LoadDummyLegData(int startIndex, out int endIndex)
        {
            DummyLegInputs dummyLeg = new DummyLegInputs();
            try
            {
                dummyLeg.botShape = GetStringInputValue(startIndex);
                dummyLeg.topShape = GetStringInputValue(++startIndex);
                dummyLeg.length = GetDoubleInputValue(++startIndex);
                dummyLeg.stanGap = GetDoubleInputValue(++startIndex);
                dummyLeg.diameter1 = GetDoubleInputValue(++startIndex);
                dummyLeg.offset1 = GetDoubleInputValue(++startIndex);
                dummyLeg.offset2 = GetDoubleInputValue(++startIndex);
                dummyLeg.elbowRadius = GetDoubleInputValue(++startIndex);
                dummyLeg.faceToCenter = GetDoubleInputValue(++startIndex);
                dummyLeg.isStanchion = (int)GetDoubleInputValue(++startIndex);
                try
                {
                    dummyLeg.repadShape = GetStringInputValue(++startIndex);
                }
                catch
                {
                    dummyLeg.repadShape = "";
                }
                dummyLeg.minLen = GetDoubleInputValue(++startIndex);
                dummyLeg.maxLen = GetDoubleInputValue(++startIndex);
            }
            catch
            {

                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadDummyLegData, "Error in LoadDummyLegData");
                }
            }
            endIndex = startIndex;
            return dummyLeg;
        }

        /// <summary>
        /// Defines the inputs required to construct ouputs of a StrutA. 
        /// </summary>
        public struct StrutAInputs
        {
            /// <summary>
            /// Length of this part, meaning the distance between Port1 and Port2.
            /// </summary>
            public double length;
            /// <summary>
            /// For variable length struts, which of the five shapes stretches. 0 means none of the segments are variable length
            /// 0 – None,1 – Shape 1,2 – Shape 2,3 – Shape 3,4 – Shape 4, 5 – Shape 5
            /// </summary>
            public int stretchShape;
            /// <summary>
            /// Determines graphic shape use for the Rod End.
            /// </summary>
            public int rodEndType;
            /// <summary>
            /// Sets the thickness of the rod end.
            /// </summary>
            public double thickness1;
            /// <summary>
            /// sets the length from the base of the spade to the port location, 
            /// </summary>
            public double length1;
            /// <summary>
            /// Sets the outside diameter of the rod ends.
            /// </summary>
            public double diameter1;
            /// <summary>
            /// if positive, creates a double spade end, with two identical spades separated by the gap
            /// </summary>
            public double gap1;
            /// <summary>
            /// Rotation angle of Rod End, Shape1, AND the port, around the longitudinal axis, in degrees.
            /// </summary>
            public double angle1;
            /// <summary>
            ///The Nut input parameter type.
            /// </summary>
            public NutInputs shape1;
            /// <summary>
            ///The Nut input parameter type.
            /// </summary>
            public NutInputs shape2;
            /// <summary>
            ///The Nut input parameter type.
            /// </summary>
            public NutInputs shape3;
            /// <summary>
            ///The Nut input parameter type.
            /// </summary>
            public NutInputs shape4;
            /// <summary>
            ///The Nut input parameter type.
            /// </summary>
            public NutInputs shape5;
            /// <summary>
            ///The Nut input parameter type.
            /// </summary>
            public NutInputs shape6;
            /// <summary>
            /// X coordinate for start position of the CENTER of the SIDE nut shape 
            /// </summary>
            public double loc1X;
            /// <summary>
            /// Y coordinate for start position of the CENTER of the SIDE nut shape 
            /// </summary>
            public double loc1Y;
            /// <summary>
            /// Z coordinate for start position of the CENTER of the SIDE nut shape 
            /// </summary>
            public double loc1Z;
            /// <summary>
            /// Direction that the SIDE nut shape is oriented, relative to the Loc1 start position.
            /// </summary>
            public int direction1;
        }
        /// <summary>
        /// This property adds inputs for StrutA.User symbol calls this property AdditionalInputs
        /// to define additional inputs. The list of inputs returned by this method will be the inputs for the user symbol in addition
        /// to the inputs that are already defined as member variables.
        /// </summary>
        ///<code>
        /// public override IEnumerable<Input> AdditionalInputs
        /// {
        ///     get
        ///     {
        ///         int endIndex;
        ///         additionalInputs = new List(Input)();
        ///         //Example , I have added the nut with staring index 3.
        ///         AddStrutAInputs(3, out endIndex, additionalInputs);
        ///         return additionalInputs; 
        ///    }
        /// }
        ///</code>
        public void AddStrutAInputs(int startIndex, out int endIndex, List<Input> additionalInputs)
        {
            try
            {
                additionalInputs.Add((Input)new InputDouble(startIndex, "Length", "Length", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "StretchShape", "StretchShape", 3, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "RodEnd1Type", "RodEnd1Type", 2, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Thickness1", "Thickness1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Length1", "Length1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Diameter1", "Diameter1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Gap1", "Gap1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Angle1", "Angle1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Loc1X", "Loc1X", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Loc1Y", "Loc1Y", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Loc1Z", "Loc1Z", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Direction1", "Direction1", 0, false));
                //endIndex = startIndex;
                AddNutInputs(startIndex, 6, out endIndex, additionalInputs);
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrStrutBAdditionalInputs, "Error in adding StrutA inputs.");
                endIndex = startIndex;
            }
        }
        /// <summary>
        /// Adds the StrutA outputs.User symbol calls this method during AdditionalOutputs
        /// to define additional outputs for an aspect. The list of outputs returned by this method will be the outputs for the aspect
        /// in addition to the outputs that are already defined as attributes on the aspect.
        /// </summary>
        /// <param name="additionalOutputs">The additional outputs.</param>
        ///<code>
        ///public override IEnumerable<OutputDefinition> AdditionalOutputs(string aspectName)
        ///{
        ///    List<OutputDefinition> additionalOutputs = new List<OutputDefinition>();
        ///    if (aspectName == "Symbolic")
        ///    {
        ///       AddStrutAOutputs(additionalOutputs);
        ///    }
        ///    return additionalOutputs;
        ///}
        ///</code> 
        public void AddStrutAOutputs(List<OutputDefinition> additionalOutputs)
        {
            try
            {
                additionalOutputs.Add(new OutputDefinition("Strut" + "End1", "Strut" + "End1"));
                additionalOutputs.Add(new OutputDefinition("Strut" + "End2", "Strut" + "End2"));

                for (int i = 1; i <= 6; i++)
                {
                    additionalOutputs.Add(new OutputDefinition("Strut" + "Shape" + i, "Strut" + "Shape" + i));
                }
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrStrutBAdditionalOutputs, "Error in adding StrutA outputs.");
            }
        }
        /// <summary>
        /// This method will be called by user symbol to get value of an input(in this case, StrutA input structure)during construction of outputs. 
        /// Given the start index, this method will return the value of the StrutBData struct object.
        /// </summary>
        /// <param name="startIndex">The start index.</param>
        /// <returns></returns>
        ///<code>
        ///NutInputs nut = LoadStrutAData(3);
        ///</code>
        public StrutAInputs LoadStrutAData(int startIndex, out int endIndex)
        {
            StrutAInputs strutA = new StrutAInputs();
            try
            {
                strutA.length = GetDoubleInputValue(startIndex);
                strutA.stretchShape = (int)GetDoubleInputValue(++startIndex);
                strutA.rodEndType = (int)GetDoubleInputValue(++startIndex);
                if (strutA.rodEndType < 1 || strutA.rodEndType > 5)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvRodEndTypeeCodeListValue, "RodEndType code list value should be between 1 and 5");
                    endIndex = startIndex;
                }
                strutA.thickness1 = GetDoubleInputValue(++startIndex);
                strutA.length1 = GetDoubleInputValue(++startIndex);
                strutA.diameter1 = GetDoubleInputValue(++startIndex);
                if (strutA.rodEndType == 2 || strutA.rodEndType == 3 || strutA.rodEndType == 4 || strutA.rodEndType == 5)
                {
                    if (strutA.thickness1 == 0)
                    {
                        RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidThickness1NZero, "Thickness1 value should not be equal to zero");
                        endIndex = startIndex;
                    }
                    if (strutA.diameter1 <= 0)
                    {
                        RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidDiameter1NGZero, "Diameter1 value should be greater than zero");
                        endIndex = startIndex;
                    }
                }
                strutA.gap1 = GetDoubleInputValue(++startIndex);
                strutA.angle1 = GetDoubleInputValue(++startIndex);
                strutA.loc1X = GetDoubleInputValue(++startIndex);
                strutA.loc1Y = GetDoubleInputValue(++startIndex);
                strutA.loc1Z = GetDoubleInputValue(++startIndex);
                strutA.direction1 = (int)GetDoubleInputValue(++startIndex);

                //Nuts
                strutA.shape1 = LoadNutData(++startIndex, out endIndex);
                startIndex = endIndex;
                strutA.shape2 = LoadNutData(++startIndex, out endIndex);
                startIndex = endIndex;
                strutA.shape3 = LoadNutData(++startIndex, out endIndex);
                startIndex = endIndex;
                strutA.shape4 = LoadNutData(++startIndex, out endIndex);
                startIndex = endIndex;
                strutA.shape5 = LoadNutData(++startIndex, out endIndex);
                startIndex = endIndex;
                strutA.shape6 = LoadNutData(++startIndex, out endIndex);
                startIndex = endIndex;
            }
            catch (SmartPartSymbolException hgrEx)
            {
                throw hgrEx;
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadStrutAData, "Error in loading StrutA data");
            }
            endIndex = startIndex;
            return strutA;
        }
        /// <summary>
        ///Create the graphical representation of a StrutA.  Specify the inputs and StringMatrix.
        /// </summary>
        ///<param name="strutA">Structure for specifying the inputs for the StrutA -StrutAinputs </param>
        ///<param name="matrix">string to specify the position and oreintation the graphics - String.</param>
        /// <param name="outputs">Collection of declared outputs, which is indexed by the name of the outputs declared as defining SymbolOutputs on the AspectDefinition field- OutputDictionary</param>
        /// <param name="outputName">Output that this graphic is being placed on-String</param>
        /// <param name="outputName">Set Postion for Snubbers</param>
        ///<code>
        /// AddStrutA(strutA, matrix, m_PhysicalAspect.Outputs, "Strut",setposition);
        ///</code>
        public void AddStrutA(ref StrutAInputs strutA, Matrix4X4 matrix, OutputDictionary outputs, String outputName, double setposition = 0)
        {
            try
            {
                SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();
                Line3d line;
                double curZpos = 0, eyeLength = 0;
                Matrix4X4 arcMatrix = new Matrix4X4();
                Collection<ICurve> curveCollection = new Collection<ICurve>();
                if (strutA.rodEndType == 2)   //Eye end
                {
                    symbolGeometryHelper.ActivePosition = new Position(0, 0, -strutA.thickness1 / 2);
                    symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(0, 0, 1).GetOrthogonalVector());
                    Projection3d cylinder = (Projection3d)symbolGeometryHelper.CreateCylinder(null, strutA.diameter1 / 2, strutA.thickness1);
                    arcMatrix.Rotate(Math.PI / 2, new Vector(1, 0, 0));
                    arcMatrix.Rotate(strutA.angle1, new Vector(0, 0, 1), new Position(0, 0, 0));
                    cylinder.Transform(arcMatrix);
                    cylinder.Transform(matrix);
                    outputs.Add(outputName + "End1", cylinder);

                    curZpos = strutA.diameter1 / 2;
                    eyeLength = strutA.diameter1 / 2;
                }
                else if (strutA.rodEndType == 3)   //Spade end
                {
                    curZpos = strutA.length1;
                    if (strutA.gap1 > 0)
                    {

                        symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        Arc3d arc = symbolGeometryHelper.CreateArc(null, strutA.diameter1 / 2, Math.PI);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.Rotate(Math.PI, new Vector(0, 0, 1));
                        arcMatrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                        arcMatrix.Rotate(Math.PI / 2, new Vector(1, 0, 0));
                        arcMatrix.Translate(new Vector(-strutA.thickness1 - strutA.gap1 / 2, 0, 0));
                        arcMatrix.Rotate(Math.PI / 2, new Vector(0, 0, 1), new Position(0, 0, 0));
                        arcMatrix.Rotate(strutA.angle1 * Math.PI / 180, new Vector(0, 0, 1), new Position(0, 0, 0));
                        arc.Transform(arcMatrix);
                        curveCollection.Add(arc);

                        line = new Line3d(new Position(-strutA.diameter1 / 2, -strutA.thickness1 - strutA.gap1 / 2, 0), new Position(-strutA.diameter1 / 2, -strutA.thickness1 - strutA.gap1 / 2, strutA.length1));
                        arcMatrix = new Matrix4X4();
                        arcMatrix.Rotate(strutA.angle1 / 180 * Math.PI, new Vector(0, 0, 1));
                        line.Transform(arcMatrix);
                        curveCollection.Add(line);

                        line = new Line3d(new Position(-strutA.diameter1 / 2, -strutA.thickness1 - strutA.gap1 / 2, strutA.length1), new Position(strutA.diameter1 / 2, -strutA.thickness1 - strutA.gap1 / 2, strutA.length1));
                        arcMatrix = new Matrix4X4();
                        arcMatrix.Rotate(strutA.angle1 / 180 * Math.PI, new Vector(0, 0, 1));
                        line.Transform(arcMatrix);
                        curveCollection.Add(line);

                        line = new Line3d(new Position(strutA.diameter1 / 2, -strutA.thickness1 - strutA.gap1 / 2, strutA.length1), new Position(strutA.diameter1 / 2, -strutA.thickness1 - strutA.gap1 / 2, 0));
                        arcMatrix = new Matrix4X4();
                        arcMatrix.Rotate(strutA.angle1 / 180 * Math.PI, new Vector(0, 0, 1));
                        line.Transform(arcMatrix);
                        curveCollection.Add(line);


                        arcMatrix = new Matrix4X4();
                        arcMatrix.Rotate(strutA.angle1 / 180 * Math.PI, new Vector(0, 0, 1));
                        Projection3d end1 = new Projection3d(new ComplexString3d(curveCollection), arcMatrix.Transform(new Vector(0, strutA.thickness1, 0)), strutA.thickness1, true);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.Transform(new Vector(0, strutA.thickness1, 0));
                        end1.Transform(arcMatrix);
                        end1.Transform(matrix);
                        outputs.Add(outputName + "End1", end1);

                        curveCollection = new Collection<ICurve>();
                        symbolGeometryHelper = new SymbolGeometryHelper();
                        Arc3d arc1 = symbolGeometryHelper.CreateArc(null, strutA.diameter1 / 2, Math.PI);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.Rotate(Math.PI, new Vector(0, 0, 1));
                        arcMatrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                        arcMatrix.Rotate(Math.PI / 2, new Vector(1, 0, 0));
                        arcMatrix.Translate(new Vector(strutA.gap1 / 2, 0, 0));
                        arcMatrix.Rotate(Math.PI / 2, new Vector(0, 0, 1), new Position(0, 0, 0));
                        arcMatrix.Rotate(strutA.angle1 * Math.PI / 180, new Vector(0, 0, 1), new Position(0, 0, 0));
                        arc1.Transform(arcMatrix);
                        curveCollection.Add(arc1);

                        line = new Line3d(new Position(-strutA.diameter1 / 2, strutA.gap1 / 2, 0), new Position(-strutA.diameter1 / 2, strutA.gap1 / 2, strutA.length1));
                        arcMatrix = new Matrix4X4();
                        arcMatrix.Rotate(strutA.angle1 / 180 * Math.PI, new Vector(0, 0, 1));
                        line.Transform(arcMatrix);
                        curveCollection.Add(line);

                        line = new Line3d(new Position(-strutA.diameter1 / 2, strutA.gap1 / 2, strutA.length1), new Position(strutA.diameter1 / 2, strutA.gap1 / 2, strutA.length1));
                        arcMatrix = new Matrix4X4();
                        arcMatrix.Rotate(strutA.angle1 / 180 * Math.PI, new Vector(0, 0, 1));
                        line.Transform(arcMatrix);
                        curveCollection.Add(line);

                        line = new Line3d(new Position(strutA.diameter1 / 2, strutA.gap1 / 2, strutA.length1), new Position(strutA.diameter1 / 2, strutA.gap1 / 2, 0));
                        arcMatrix = new Matrix4X4();
                        arcMatrix.Rotate(strutA.angle1 / 180 * Math.PI, new Vector(0, 0, 1));
                        line.Transform(arcMatrix);
                        curveCollection.Add(line);


                        arcMatrix = new Matrix4X4();
                        arcMatrix.Rotate(strutA.angle1 / 180 * Math.PI, new Vector(0, 0, 1));
                        Projection3d end2 = new Projection3d(new ComplexString3d(curveCollection), arcMatrix.Transform(new Vector(0, strutA.thickness1, 0)), strutA.thickness1, true);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.Transform(new Vector(0, strutA.thickness1, 0));
                        end2.Transform(arcMatrix);
                        end2.Transform(matrix);
                        outputs.Add(outputName + "End2", end2);
                    }
                    else
                    {
                        symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        Arc3d arc = symbolGeometryHelper.CreateArc(null, strutA.diameter1 / 2, Math.PI);
                        arcMatrix = new Matrix4X4();
                        arcMatrix.Rotate(Math.PI, new Vector(0, 0, 1));
                        arcMatrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                        arcMatrix.Rotate(Math.PI / 2, new Vector(1, 0, 0));
                        arcMatrix.Translate(new Vector(-strutA.thickness1 / 2, 0, 0));
                        arcMatrix.Rotate(Math.PI / 2, new Vector(0, 0, 1), new Position(0, 0, 0));
                        arcMatrix.Rotate(strutA.angle1 * Math.PI / 180, new Vector(0, 0, 1), new Position(0, 0, 0));
                        arc.Transform(arcMatrix);
                        curveCollection.Add(arc);

                        line = new Line3d(new Position(-strutA.diameter1 / 2, -strutA.thickness1 / 2, 0), new Position(-strutA.diameter1 / 2, -strutA.thickness1 / 2, strutA.length1));
                        arcMatrix = new Matrix4X4();
                        arcMatrix.Rotate(strutA.angle1 / 180 * Math.PI, new Vector(0, 0, 1));
                        line.Transform(arcMatrix);
                        curveCollection.Add(line);

                        line = new Line3d(new Position(-strutA.diameter1 / 2, -strutA.thickness1 / 2, strutA.length1), new Position(strutA.diameter1 / 2, -strutA.thickness1 / 2, strutA.length1));
                        arcMatrix = new Matrix4X4();
                        arcMatrix.Rotate(strutA.angle1 / 180 * Math.PI, new Vector(0, 0, 1));
                        line.Transform(arcMatrix);
                        curveCollection.Add(line);

                        line = new Line3d(new Position(strutA.diameter1 / 2, -strutA.thickness1 / 2, strutA.length1), new Position(strutA.diameter1 / 2, -strutA.thickness1 / 2, 0));
                        arcMatrix = new Matrix4X4();
                        arcMatrix.Rotate(strutA.angle1 / 180 * Math.PI, new Vector(0, 0, 1));
                        line.Transform(arcMatrix);
                        curveCollection.Add(line);

                        arcMatrix = new Matrix4X4();
                        arcMatrix.Rotate(strutA.angle1 / 180 * Math.PI, new Vector(0, 0, 1));
                        Projection3d end1 = new Projection3d(new ComplexString3d(curveCollection), arcMatrix.Transform(new Vector(0, strutA.thickness1, 0)), strutA.thickness1, true);
                        end1.Transform(matrix);
                        outputs.Add(outputName + "End1", end1);
                    }
                }

                else if (strutA.rodEndType == 4 || strutA.rodEndType == 5)   //Bolt or Nut (Female) end
                {
                    Vector normal = new Position(0, 0, 0).Subtract(new Position(0, 0, -strutA.thickness1));
                    symbolGeometryHelper.ActivePosition = new Position(0, 0, -strutA.thickness1);
                    symbolGeometryHelper.SetOrientation(normal, normal.GetOrthogonalVector());
                    Projection3d end1 = (Projection3d)symbolGeometryHelper.CreateCylinder(null, strutA.diameter1 / 2, normal.Length);
                    end1.Transform(matrix);
                    outputs.Add(outputName + "End1", end1);
                }
                strutA.shape4.ShapeLength = strutA.shape4.ShapeLength + setposition; //handled for Snubbers

                if (strutA.stretchShape == 1)    //Shape 1
                    strutA.shape1.ShapeLength = strutA.length - strutA.length1 - strutA.shape2.ShapeLength - strutA.shape3.ShapeLength - strutA.shape4.ShapeLength - strutA.shape5.ShapeLength - eyeLength;
                if (strutA.stretchShape == 2)   //Shape 2
                    strutA.shape2.ShapeLength = strutA.length - strutA.length1 - strutA.shape1.ShapeLength - strutA.shape3.ShapeLength - strutA.shape4.ShapeLength - strutA.shape5.ShapeLength - eyeLength;
                if (strutA.stretchShape == 3)  //Shape 3
                    strutA.shape3.ShapeLength = strutA.length - strutA.length1 - strutA.shape1.ShapeLength - strutA.shape2.ShapeLength - strutA.shape4.ShapeLength - strutA.shape5.ShapeLength - eyeLength;
                if (strutA.stretchShape == 4)   //Shape 4
                    strutA.shape4.ShapeLength = strutA.length - strutA.length1 - strutA.shape1.ShapeLength - strutA.shape3.ShapeLength - strutA.shape2.ShapeLength - strutA.shape5.ShapeLength - eyeLength;
                if (strutA.stretchShape == 5)    //Shape 5
                    strutA.shape5.ShapeLength = strutA.length - strutA.length1 - strutA.shape1.ShapeLength - strutA.shape3.ShapeLength - strutA.shape4.ShapeLength - strutA.shape2.ShapeLength - eyeLength;

                Double dOffsetZ;
                if (strutA.rodEndType == 2 & strutA.shape1.ShapeWidth1 < strutA.diameter1)
                {
                    dOffsetZ = (strutA.diameter1 / 2) - Math.Sqrt(((strutA.diameter1 / 2 * strutA.diameter1 / 2) - (strutA.shape1.ShapeWidth1 / 2 * strutA.shape1.ShapeWidth1 / 2)));
                    strutA.shape1.ShapeLength = strutA.shape1.ShapeLength + dOffsetZ;
                }
                else
                    dOffsetZ = 0;

                curZpos = curZpos - dOffsetZ;
                arcMatrix = new Matrix4X4();
                arcMatrix.Translate(new Vector(0, 0, curZpos));
                arcMatrix.Rotate(strutA.angle1 * Math.PI / 180, new Vector(0, 0, 1), new Position(0, 0, 0));
                arcMatrix.MultiplyMatrix(matrix);
                MakeShape(strutA.shape1, arcMatrix, outputs, ref curZpos, outputName + "Shape1");

                arcMatrix = new Matrix4X4();
                arcMatrix.Translate(new Vector(0, 0, curZpos));
                arcMatrix.MultiplyMatrix(matrix);
                MakeShape(strutA.shape2, arcMatrix, outputs, ref curZpos, outputName + "Shape2");

                arcMatrix = new Matrix4X4();
                arcMatrix.Translate(new Vector(0, 0, curZpos));
                arcMatrix.MultiplyMatrix(matrix);
                MakeShape(strutA.shape3, arcMatrix, outputs, ref curZpos, outputName + "Shape3");

                arcMatrix = new Matrix4X4();
                arcMatrix.Translate(new Vector(0, 0, curZpos));
                arcMatrix.MultiplyMatrix(matrix);
                MakeShape(strutA.shape4, arcMatrix, outputs, ref curZpos, outputName + "Shape4");

                arcMatrix = new Matrix4X4();
                arcMatrix.Translate(new Vector(0, 0, curZpos));
                arcMatrix.MultiplyMatrix(matrix);
                MakeShape(strutA.shape5, arcMatrix, outputs, ref curZpos, outputName + "Shape5");

                arcMatrix = new Matrix4X4();
                if (strutA.direction1 == 0)  //+X
                    arcMatrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));
                if (strutA.direction1 == 1)  //-X
                    arcMatrix.Rotate(-Math.PI / 2, new Vector(0, 1, 0));
                if (strutA.direction1 == 2)  //+Y
                    arcMatrix.Rotate(-Math.PI / 2, new Vector(1, 0, 0));
                if (strutA.direction1 == 3)  //-Y
                    arcMatrix.Rotate(Math.PI / 2, new Vector(1, 0, 0));
                if (strutA.direction1 == 4)  //+Z
                    arcMatrix = new Matrix4X4();
                if (strutA.direction1 == 5)  //-Z
                    arcMatrix.Rotate(Math.PI, new Vector(1, 0, 0));

                arcMatrix.Translate(new Vector(strutA.loc1X, strutA.loc1Y, strutA.loc1Z));
                arcMatrix.MultiplyMatrix(matrix);
                AddNut(strutA.shape6, arcMatrix, outputs, outputName + "Shape6");
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddStrutAMethod, "Error in AddStrutA.");
                }
            }
        }
        /// <summary>
        /// Would provide the shape(hex or round etc) for nut depending on condition
        /// </summary>
        ///<param name="myShape">Structure for specifying the inputs for the Nut -NutInputs </param>
        ///<param name="matrix">string to specify the position and oreintation the graphics - String.</param>
        /// <param name="outputs">Collection of declared outputs, which is indexed by the name of the outputs declared as defining SymbolOutputs on the AspectDefinition field- OutputDictionary</param>
        /// <param name="outputName">Output that this graphic is being placed on-String</param>
        ///<code>
        /// MakeShape(strutA.shape5, arcMatrix, outputs,ref curZpos, outputName + "Shape5");
        ///</code>
        public void MakeShape(NutInputs myShape, Matrix4X4 matrix, OutputDictionary outputs, ref Double curZpos, String name)
        {
            try
            {
                if (myShape.ShapeType != 0 & HgrCompareDoubleService.cmpdbl(myShape.ShapeWidth1, 0) == false & HgrCompareDoubleService.cmpdbl(myShape.ShapeWidth2, 0) == false & HgrCompareDoubleService.cmpdbl(myShape.ShapeLength, 0) == false)
                {
                    AddNut(myShape, matrix, outputs, name);
                    curZpos = curZpos + myShape.ShapeLength;
                }
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrMakeShapeMethod, "Error in MakeShape");
                }
            }
        }

        /// <summary>
        /// Defines the inputs for the Constant shape.
        /// </summary>
        public struct ConstantInputs
        {
            /// <summary>
            /// Attribute used to specify RodDiameter
            /// </summary>
            public double rodDiameter;
            /// <summary>
            /// Attribute used to specify HoleDiameter
            /// </summary>
            public double holeDiameter;
            /// <summary>
            /// Attribute used to specify Gap1
            /// </summary>
            public double gap1;
            /// <summary>
            /// Attribute used to specify LugHoleOffset
            /// </summary>
            public double lugHoleOffset;
            /// <summary>
            /// Attribute used to specify Length
            /// </summary>
            public double length;
            /// <summary>
            /// Attribute used to specify Offset1
            /// </summary>
            public double offset1;
            /// <summary>
            /// Attribute used to specify Offset2
            /// </summary>
            public double offset2;
            /// <summary>
            /// Attribute used to specify Offset3
            /// </summary>
            public double offset3;
            /// <summary>
            ///Attribute used to specify Offset4
            /// </summary>
            public double offset4;
            /// <summary>
            ///Attribute used to specify Offset5
            /// </summary>
            public double offset5;
            /// <summary>
            ///Attribute used to specify Offset6
            /// </summary>
            public double offset6;
            /// <summary>
            /// Attribute used to specify Length1
            /// </summary>
            public double length1;
            /// <summary>
            /// Attribute used to specify Length2
            /// </summary>
            public double length2;
            /// <summary>
            /// Attribute used to specify Plate1Offset
            /// </summary>
            public double plate1Offset;
            /// <summary>
            /// Attribute used to specify Plate2Offset
            /// </summary>
            public double plate2Offset;
            /// <summary>
            /// Attribute used to specify Plate3Offset
            /// </summary>
            public double plate3Offset;
            /// <summary>
            /// Attribute used to specify Plate4Offset
            /// </summary>
            public double plate4Offset;
            /// <summary>
            /// Attribute used to specify FrameOffset
            /// </summary>
            public double frameOffset;
            /// <summary>
            /// Attribute used to specify Lever2Offset
            /// </summary>
            public double lever2Offset;
            /// <summary>
            /// Attribute used to specify CaseCLOffset
            /// </summary>
            public double caseCLOffset;
            /// <summary>
            /// Attribute used to specify PivotOffset
            /// </summary>
            public double pivotOffset;
            /// <summary>
            ///Attribute used to specify TopOffset
            /// </summary>
            public double topOffset;
            /// <summary>
            ///Attribute used to specify Offset5
            /// </summary>
            public double topSpacing;
            /// <summary>
            ///Attribute used to specify FrameSpacing
            /// </summary>
            public double frameSpacing;
            /// <summary>
            /// Attribute used to specify UpThrustSpacing
            /// </summary>
            public double upThrustSpacing;
            /// <summary>
            /// Attribute used to specify LeverSpacing
            /// </summary>
            public double leverSpacing;
            /// <summary>
            /// Attribute used to specify GussetSpacing
            /// </summary>
            public double gussetSpacing;
            /// <summary>
            /// Attribute used to specify ColumnSpacing
            /// </summary>
            public double columnSpacing;
            /// <summary>
            /// Attribute used to specify CCMin
            /// </summary>
            public double cCMin;
            /// <summary>
            /// Attribute used to specify CCMax
            /// </summary>
            public double cCMax;
            /// <summary>
            /// Attribute used to specify AngleHigh
            /// </summary>
            public double angleHigh;
            /// <summary>
            /// Attribute used to specify AngleLow
            /// </summary>
            public double angleLow;
            /// <summary>
            /// Attribute used to specify RodTakeOutHigh
            /// </summary>
            public double rodTakeOutHigh;
            /// <summary>
            ///Attribute used to specify RodTakeOutLow
            /// </summary>
            public double rodTakeOutLow;
            /// <summary>
            ///Attribute used to specify Gap2
            /// </summary>
            public double gap2;
            /// <summary>
            /// Attribute used to specify PlateInputs
            /// </summary>
            public PlateInputs plate1;
            /// <summary>
            /// Attribute used to specify PlateInputs
            /// </summary>
            public PlateInputs plate2;
            /// <summary>
            /// Attribute used to specify PlateInputs
            /// </summary>
            public PlateInputs plate3;
            /// <summary>
            /// Attribute used to specify PlateInputs
            /// </summary>
            public PlateInputs plate4;
            /// <summary>
            /// Attribute used to specify NutInputs
            /// </summary>
            public NutInputs casing;
            /// <summary>
            /// Attribute used to specify PlateInputs
            /// </summary>
            public PlateInputs frame;
            /// <summary>
            /// Attribute used to specify PlateInputs
            /// </summary>
            public PlateInputs upThrustPlate;
            /// <summary>
            /// Attribute used to specify PlateInputs
            /// </summary>
            public PlateInputs lever;
            /// <summary>
            /// Attribute used to specify PlateInputs
            /// </summary>
            public PlateInputs earPlate;
            /// <summary>
            /// Attribute used to specify PlateInputs
            /// </summary>
            public PlateInputs gussetPlate;
            /// <summary>
            /// Attribute used to specify PinInputs
            /// </summary>
            public PinInputs pivotPin;
            /// <summary>
            /// Attribute used to specify Rod1Inputs
            /// </summary>
            public Rod1Inputs column;
            /// <summary>
            /// Attribute used to specify PlateInputs
            /// </summary>
            public PlateInputs columnPlate;
            /// <summary>
            /// Attribute used to specify PinInputs
            /// </summary>
            public PinInputs columnPin;
            /// <summary>
            /// Attribute used to specify NutInputs
            /// </summary>
            public NutInputs columnEnd;
            /// <summary>
            /// Attribute used to specify ClevisInputs
            /// </summary>
            public ClevisInputs clevis;
            /// <summary>
            /// Attribute used to specify TurnbuckleInputs
            /// </summary>
            public TurnbuckleInputs turnbuckle;
            /// <summary>
            /// Attribute used to specify NutInputs
            /// </summary>
            public NutInputs nut;
            /// <summary>
            /// Attribute used to specify PlateInputs
            /// </summary>
            public PlateInputs lug;
            /// <summary>
            /// Attribute used to specify PlateInputs
            /// </summary>
            public PlateInputs lug2;
            /// <summary>
            /// Attribute used to specify PinInputs
            /// </summary>
            public PinInputs pin;
            /// <summary>
            /// Attribute used to specify PinInputs
            /// </summary>
            public PinInputs pin2;
            /// <summary>
            /// Attribute used to specify SteelMember
            /// </summary>
            public SteelMember steel;
            /// <summary>
            ///Attribute used to specify TopAttachment
            /// </summary>
            public string topAttachment;
            /// <summary>
            ///Attribute used to specify StructAttachment
            /// </summary>
            public string structAttachment;
        }
        /// <summary>
        /// Loads the values associated to the given shape into the WBABoltInputs UDT. This is done by querying the database for the given name.
        /// </summary>
        /// <param name="refShapeName">Part Name of the auxiliary table</param>
        /// <returns></returns>
        ///<code>
        ///WBABoltInputs wbaBoltInputs  = LoadWBABoltDataByQuery(refShapeName);
        ///</code>
        public WBABoltInputs LoadWBABoltDataByQuery(string refShapeName)
        {
            WBABoltInputs wbaBoltInputs = new WBABoltInputs();
            try
            {

                if (!(refShapeName == "" || refShapeName == "No Value" || refShapeName == null))
                {
                    Catalog m_oPlantCatalog = MiddleServiceProvider.SiteMgr.ActiveSite.ActivePlant.PlantCatalog;
                    BusinessObject wbaBoltAuxTable = m_oPlantCatalog.GetNamedObject(refShapeName);
                    try
                    {
                        wbaBoltInputs.Gap1 = (double)((PropertyValueDouble)wbaBoltAuxTable.GetPropertyValue("IJUAhsGap1", "Gap1")).PropValue;
                    }
                    catch
                    {
                        wbaBoltInputs.Gap1 = 0;
                    }
                    try
                    {
                        wbaBoltInputs.Thickness1 = (double)((PropertyValueDouble)wbaBoltAuxTable.GetPropertyValue("IJUAhsThickness1", "Thickness1")).PropValue;
                    }
                    catch
                    {
                        wbaBoltInputs.Thickness1 = 0;
                    }
                    try
                    {
                        wbaBoltInputs.Height1 = (double)((PropertyValueDouble)wbaBoltAuxTable.GetPropertyValue("IJUAhsHeight1", "Height1")).PropValue;
                    }
                    catch
                    {
                        wbaBoltInputs.Height1 = 0;
                    }
                    try
                    {
                        wbaBoltInputs.Width1 = (double)((PropertyValueDouble)wbaBoltAuxTable.GetPropertyValue("IJUAhsWidth1", "Width1")).PropValue;
                    }
                    catch
                    {
                        wbaBoltInputs.Width1 = 0;
                    }
                    try
                    {
                        wbaBoltInputs.Offset1 = (double)((PropertyValueDouble)wbaBoltAuxTable.GetPropertyValue("IJUAhsOffset1", "Offset1")).PropValue;
                    }
                    catch
                    {
                        wbaBoltInputs.Offset1 = 0;
                    }
                    try
                    {
                        wbaBoltInputs.Width2 = (double)((PropertyValueDouble)wbaBoltAuxTable.GetPropertyValue("IJUAhsWidth2", "Width2")).PropValue;
                    }
                    catch
                    {
                        wbaBoltInputs.Width2 = 0;
                    }
                    try
                    {
                        wbaBoltInputs.Length2 = (double)((PropertyValueDouble)wbaBoltAuxTable.GetPropertyValue("IJUAhsLength2", "Length2")).PropValue;
                    }
                    catch
                    {
                        wbaBoltInputs.Length2 = 0;
                    }
                    try
                    {
                        wbaBoltInputs.Thickness2 = (double)((PropertyValueDouble)wbaBoltAuxTable.GetPropertyValue("IJUAhsThickness2", "Thickness2")).PropValue;
                    }
                    catch
                    {
                        wbaBoltInputs.Thickness2 = 0;
                    }
                    try
                    {
                        wbaBoltInputs.Offset2 = (double)((PropertyValueDouble)wbaBoltAuxTable.GetPropertyValue("IJUAhsOffset2", "Offset2")).PropValue;
                    }
                    catch
                    {
                        wbaBoltInputs.Offset2 = 0;
                    }
                    try
                    {
                        wbaBoltInputs.Gap2 = (double)((PropertyValueDouble)wbaBoltAuxTable.GetPropertyValue("IJUAhsGap2", "Gap2")).PropValue;
                    }
                    catch
                    {
                        wbaBoltInputs.Gap2 = 0;
                    }
                    try
                    {
                        wbaBoltInputs.Width3 = (double)((PropertyValueDouble)wbaBoltAuxTable.GetPropertyValue("IJUAhsWidth3", "Width3")).PropValue;
                    }
                    catch
                    {
                        wbaBoltInputs.Width3 = 0;
                    }
                    try
                    {
                        wbaBoltInputs.Length3 = (double)((PropertyValueDouble)wbaBoltAuxTable.GetPropertyValue("IJUAhsLength3", "Length3")).PropValue;
                    }
                    catch
                    {
                        wbaBoltInputs.Length3 = 0;
                    }
                    try
                    {
                        wbaBoltInputs.Thickness3 = (double)((PropertyValueDouble)wbaBoltAuxTable.GetPropertyValue("IJUAhsThickness3", "Thickness3")).PropValue;
                    }
                    catch
                    {
                        wbaBoltInputs.Thickness3 = 0;
                    }
                    try
                    {
                        wbaBoltInputs.Offset3 = (double)((PropertyValueDouble)wbaBoltAuxTable.GetPropertyValue("IJUAhsOffset3", "Offset3")).PropValue;
                    }
                    catch
                    {
                        wbaBoltInputs.Offset3 = 0;
                    }
                    try
                    {
                        wbaBoltInputs.Pin1Diameter = (double)((PropertyValueDouble)wbaBoltAuxTable.GetPropertyValue("IJUAhsPin1", "Pin1Diameter")).PropValue;
                    }
                    catch
                    {
                        wbaBoltInputs.Pin1Diameter = 0;
                    }
                    try
                    {
                        wbaBoltInputs.Pin1Length = (double)((PropertyValueDouble)wbaBoltAuxTable.GetPropertyValue("IJUAhsPin1", "Pin1Length")).PropValue;
                    }
                    catch
                    {
                        wbaBoltInputs.Pin1Length = 0;
                    }
                    try
                    {
                        wbaBoltInputs.Height2 = (double)((PropertyValueDouble)wbaBoltAuxTable.GetPropertyValue("IJUAhsHeight2", "Height2")).PropValue;
                    }
                    catch
                    {
                        wbaBoltInputs.Height2 = 0;
                    }
                    try
                    {
                        wbaBoltInputs.TLCornerType = (int)((PropertyValueCodelist)wbaBoltAuxTable.GetPropertyValue("IJUAhsTLCorner", "TLCornerType")).PropValue;
                    }
                    catch
                    {
                        wbaBoltInputs.TLCornerType = 0;
                    }
                    try
                    {
                        wbaBoltInputs.TLCornerX = (double)((PropertyValueDouble)wbaBoltAuxTable.GetPropertyValue("IJUAhsTLCorner", "TLCornerX")).PropValue;
                    }
                    catch
                    {
                        wbaBoltInputs.TLCornerX = 0;
                    }
                    try
                    {
                        wbaBoltInputs.TLCornerY = (double)((PropertyValueDouble)wbaBoltAuxTable.GetPropertyValue("IJUAhsTLCorner", "TLCornerY")).PropValue;
                    }
                    catch
                    {
                        wbaBoltInputs.TLCornerY = 0;
                    }
                    try
                    {
                        wbaBoltInputs.TLCornerRadius = (double)((PropertyValueDouble)wbaBoltAuxTable.GetPropertyValue("IJUAhsTLCorner", "TLCornerRadius")).PropValue;
                    }
                    catch
                    {
                        wbaBoltInputs.TLCornerRadius = 0;
                    }
                    try
                    {
                        wbaBoltInputs.TRCornerType = (int)((PropertyValueCodelist)wbaBoltAuxTable.GetPropertyValue("IJUAhsTRCorner", "TRCornerType")).PropValue;
                    }
                    catch
                    {
                        wbaBoltInputs.TRCornerType = 0;
                    }
                    try
                    {
                        wbaBoltInputs.TRCornerX = (double)((PropertyValueDouble)wbaBoltAuxTable.GetPropertyValue("IJUAhsTRCorner", "TRCornerX")).PropValue;
                    }
                    catch
                    {
                        wbaBoltInputs.TRCornerX = 0;
                    }
                    try
                    {
                        wbaBoltInputs.TRCornerY = (double)((PropertyValueDouble)wbaBoltAuxTable.GetPropertyValue("IJUAhsTRCorner", "TRCornerY")).PropValue;
                    }
                    catch
                    {
                        wbaBoltInputs.TRCornerY = 0;
                    }
                    try
                    {
                        wbaBoltInputs.TRCornerRadius = (double)((PropertyValueDouble)wbaBoltAuxTable.GetPropertyValue("IJUAhsTRCorner", "TRCornerRadius")).PropValue;
                    }
                    catch
                    {
                        wbaBoltInputs.TRCornerRadius = 0;
                    }
                }
            }
            catch
            {

                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadWBABoltDataByQuery, "Error in LoadWBABoltDataByQuery method.");
                }
            }
            return wbaBoltInputs;
        }
        /// <summary>
        /// Loads the values associated to the given shape into the ROD UDT. This is done by querying the database for the given name.
        /// </summary>
        /// <param name="refShapeName">part name of the auxiliary table</param>
        /// <returns></returns>
        ///<code>
        ///TurnbuckleInputs turnbuckleInputs  = LoadTurnbuckleByQuery(refShapeName);
        ///</code>
        public TurnbuckleInputs LoadTurnbuckleDataByQuery(string refShapeName)
        {
            TurnbuckleInputs turnbuckleInputs = new TurnbuckleInputs();
            try
            {

                if (!(refShapeName == "" || refShapeName == "No Value" || refShapeName == null))
                {
                    Catalog m_oPlantCatalog = MiddleServiceProvider.SiteMgr.ActiveSite.ActivePlant.PlantCatalog;
                    BusinessObject turnbuckleAuxTable = m_oPlantCatalog.GetNamedObject(refShapeName);

                    ReadOnlyCollection<PropertyValue> turnbuckleProperties = turnbuckleAuxTable.GetAllProperties();
                    string strCurrentAttr = string.Empty;
                    foreach (PropertyValue property in turnbuckleProperties)
                    {
                        if (!(String.IsNullOrEmpty(property.PropertyInfo.Name)))
                        {
                            strCurrentAttr = property.PropertyInfo.InterfaceInfo.Name + ":" + property.PropertyInfo.Name;
                            switch (strCurrentAttr)
                            {

                                case ("IJUAhsOpening1:Opening1"):
                                    GetDoublePropertyValue(property, ref turnbuckleInputs.Opening1);
                                    break;
                                case ("IJUAhsLength2:Length2"):
                                    GetDoublePropertyValue(property, ref turnbuckleInputs.Length2);
                                    break;
                                case ("IJUAhsWidth2:Width2"):
                                    GetDoublePropertyValue(property, ref turnbuckleInputs.Width2);
                                    break;
                                case ("IJUAhsThickness2:Thickness2"):
                                    GetDoublePropertyValue(property, ref turnbuckleInputs.Thickness2);
                                    break;
                                case ("IJUAhsOpening2:Opening2"):
                                    GetDoublePropertyValue(property, ref turnbuckleInputs.Opening2);
                                    break;
                                case ("IJUAhsDiameter1:Diameter1"):
                                    GetDoublePropertyValue(property, ref turnbuckleInputs.Diameter1);
                                    break;

                            }
                        }
                    }
                }

                turnbuckleInputs.Nut = LoadNutDataByQuery(refShapeName, 1);
            }
            catch
            {

                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadTurnbuckleByQuery, "Error in LoadTurnbuckleByQuery.");
                }
            }
            return turnbuckleInputs;
        }
        /// <summary>
        /// Loads the values associated to the given shape into the ROD UDT. This is done by querying the database for the given name.
        /// </summary>
        /// <param name="refShapeName">part name of the auxiliary table</param>
        /// <returns></returns>
        ///<code>
        ///Rod1Inputs rodInputs  = LoadRodDataByQuery(refShapeName);
        ///</code>
        public Rod1Inputs LoadRodDataByQuery(string refShapeName)
        {
            Rod1Inputs rodInputs = new Rod1Inputs();
            try
            {

                if (!(refShapeName == "" || refShapeName == "No Value" || refShapeName == null))
                {
                    Catalog m_oPlantCatalog = MiddleServiceProvider.SiteMgr.ActiveSite.ActivePlant.PlantCatalog;
                    BusinessObject rodAuxTable = m_oPlantCatalog.GetNamedObject(refShapeName);
                    ReadOnlyCollection<PropertyValue> rodProperties = rodAuxTable.GetAllProperties();
                    string strCurrentAttr = string.Empty;
                    foreach (PropertyValue property in rodProperties)
                    {
                        if (!(String.IsNullOrEmpty(property.PropertyInfo.Name)))
                        {
                            strCurrentAttr = property.PropertyInfo.InterfaceInfo.Name + ":" + property.PropertyInfo.Name;
                            switch (strCurrentAttr)
                            {

                                case ("IJUAhsRodDiameter:RodDiameter"):
                                    GetDoublePropertyValue(property, ref rodInputs.rodDiameter);
                                    break;
                                case ("IJUAhsLength:Length"):
                                    GetDoublePropertyValue(property, ref rodInputs.length);
                                    break;
                                case ("IJUAhsRodEnd1:RodEnd1Type"):
                                    GetIntPropertyValue(property, ref rodInputs.rodEnd1Type);
                                    break;
                                case ("IJUAhsRodEnd2:RodEnd2Type"):
                                    GetIntPropertyValue(property, ref rodInputs.rodEnd2Type);
                                    break;
                                case ("IJUAhsRodCenterType:RodCenterType"):
                                    GetIntPropertyValue(property, ref rodInputs.rodCenterType);
                                    break;
                                case ("IJUAhsOffset1:Offset1"):
                                    GetDoublePropertyValue(property, ref rodInputs.offset1);
                                    break;
                                case ("IJUAhsThickness1:Thickness1"):
                                    GetDoublePropertyValue(property, ref rodInputs.thickness1);
                                    break;
                                case ("IJUAhsDiameter1:Diameter1"):
                                    GetDoublePropertyValue(property, ref rodInputs.diameter1);
                                    break;
                                case ("IJUAhsOverLength1:OverLength1"):
                                    GetDoublePropertyValue(property, ref rodInputs.overLength1);
                                    break;
                                case ("IJUAhsOverLength2:Overlength2"):
                                    GetDoublePropertyValue(property, ref rodInputs.overLength2);
                                    break;
                                case ("IJUAhsLength1:Length1"):
                                    GetDoublePropertyValue(property, ref rodInputs.length1);
                                    break;
                            }
                        }
                    }
                }
            }
            catch
            {

                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadRodDataByQuery, "Error in LoadRodDataByQuery.");
                }
            }
            return rodInputs;
        }

        /// <summary>
        /// This method will be called by user symbol to get value of an input(in this case, Constant input structure)during construction of outputs. 
        /// This method will return the value of the ConstantInputs for Size Table.
        /// </summary>
        /// <param name="sizeTableName">Table name of the auxiliary table.</param>
        /// <param name="size">Get Size</param>
        /// <returns></returns>
        /// <code>
        /// currentAttributes = GetConstantSizeRowProperties(sizeTableName, size);
        /// </code>
        public ReadOnlyCollection<PropertyValue> GetConstantSizeRowProperties(string sizeTableName, string size, double load)
        {
            ReadOnlyCollection<PropertyValue> constantSizeRowProperties = null;
            try
            {
                CatalogBaseHelper catalogBaseHelper = new CatalogBaseHelper();
                IEnumerable<PropertyValue> minSizeAttribute = null, maxSizeAttribute = null, attrMinLoadValue = null, attrMaxLoadValue = null;
                double minSizeValue = 0, maxSizeValue = 0, minLoadValue = 0, maxLoadValue = 0;
                Boolean checkForMinLoad = false, checkForMaxLoad = false, canthisItembeseleted = true;

                if (!(string.IsNullOrEmpty(sizeTableName) || sizeTableName.Equals("No Value")))
                {
                    if (String.IsNullOrEmpty(previousSizeTableName) || !previousSizeTableName.Equals(sizeTableName))
                    {
                        PartClass ConstantAuxTable = (PartClass)catalogBaseHelper.GetPartClass(sizeTableName);
                        sizeParts = ConstantAuxTable.GetRelationship("PartClassContainsClassItems", "ClassItem").TargetObjects;
                    }
                    double dlocalSize = Convert.ToDouble(size);
                    foreach (BusinessObject part in sizeParts)
                    {
                        ReadOnlyCollection<PropertyValue> sizeProperties = part.GetAllProperties();
                        IEnumerable<PropertyValue> minAttributesCol = sizeProperties.Where(property => property.PropertyInfo.InterfaceInfo.Name == "IJUAhsMinSize");
                        if (minAttributesCol.Count<PropertyValue>() > 0)
                            minSizeAttribute = minAttributesCol.Where(property => property.PropertyInfo.Name == "MinSize");
                        IEnumerable<PropertyValue> maxAttributesCol = sizeProperties.Where(property => property.PropertyInfo.InterfaceInfo.Name == "IJUAhsMaxSize");
                        if (maxAttributesCol.Count<PropertyValue>() > 0)
                            maxSizeAttribute = maxAttributesCol.Where(property => property.PropertyInfo.Name == "MaxSize");
                        //For MinLoad
                        IEnumerable<PropertyValue> attrColMinLoadVal = sizeProperties.Where(property => property.PropertyInfo.InterfaceInfo.Name == "IJUAhsMinLoad");
                        if (!(attrColMinLoadVal == null))
                        {
                            if (attrColMinLoadVal.Count<PropertyValue>() > 0)
                            {
                                attrMinLoadValue = attrColMinLoadVal.Where(property => property.PropertyInfo.Name == "MinLoad");
                                minLoadValue = (double)((PropertyValueDouble)attrMinLoadValue.ElementAt<PropertyValue>(0)).PropValue;
                                checkForMinLoad = true;
                            }
                        }
                        //For MaxLoad
                        IEnumerable<PropertyValue> attrColMaxLoadVal = sizeProperties.Where(property => property.PropertyInfo.InterfaceInfo.Name == "IJUAhsMaxLoad");
                        if (!(attrColMaxLoadVal == null))
                        {
                            if (attrColMaxLoadVal.Count<PropertyValue>() > 0)
                            {
                                attrMaxLoadValue = attrColMaxLoadVal.Where(property => property.PropertyInfo.Name == "MaxLoad");
                                maxLoadValue = (double)((PropertyValueDouble)attrMaxLoadValue.ElementAt<PropertyValue>(0)).PropValue;
                                checkForMaxLoad = true;
                            }
                        }
                        //conditional check  with the retrieved values..
                        canthisItembeseleted = true;

                        minSizeValue = Convert.ToDouble(((PropertyValueString)minSizeAttribute.ElementAt<PropertyValue>(0)).PropValue);
                        maxSizeValue = Convert.ToDouble(((PropertyValueString)maxSizeAttribute.ElementAt<PropertyValue>(0)).PropValue);
                        if ((minSizeValue <= dlocalSize) && (maxSizeValue >= dlocalSize))
                        {
                            if (checkForMinLoad)
                            {
                                if (!(minLoadValue <= load))
                                    canthisItembeseleted = false;
                            }
                            if (canthisItembeseleted == true)
                            {
                                if (checkForMaxLoad)
                                {
                                    if (!(maxLoadValue >= load))
                                        canthisItembeseleted = false;
                                }
                            }

                        }
                        else
                            canthisItembeseleted = false;
                        if (canthisItembeseleted)
                        {
                            constantSizeRowProperties = sizeProperties;
                            break;
                        }
                    }
                }
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrGetConstantSizeRowProperties, "Error in GetConstantSizeRowProperties Method.");
                }
            }
            return constantSizeRowProperties;
        }

        /// <summary>
        /// This method will be called by user symbol to get value of an input(in this case, Constant input structure)during construction of outputs. 
        /// This method will return the value of the ConstantInputs for Travel Table.
        /// </summary>
        /// <param name="travelTableName">Table name of the auxiliary table.</param>
        /// <param name="size">Get Size</param>
        /// <param name="totalTravel">Get TotalTravel</param>
        /// <param name="load">Get Load</param>
        /// <returns></returns>
        /// <code>
        /// currentAttributes = GetConstantTravelRowAttributes(travelTableName, size, totalTravel, load);
        /// </code>
        public ReadOnlyCollection<PropertyValue> GetConstantTravelRowAttributes(string travelTableName, string size, double totalTravel, double load)
        {
            ReadOnlyCollection<PropertyValue> constantTravelRowProperties = null;
            try
            {
                CatalogBaseHelper catalogBaseHelper = new CatalogBaseHelper();
                IEnumerable<PropertyValue> attrMinTravelVlaue = null, attrMaxTravelVlaue = null, attrMinLoadValue = null, attrMaxLoadValue = null, attrMinSizeValue = null, attrMaxSizeValue = null;
                double minSizeValue = 0, maxSizeValue = 0, minTravelVlaue = 0, maxTravelVlaue = 0, minLoadValue = 0, maxLoadValue = 0;
                Boolean checkForMinSize = false, checkForMaxSize = false, checkForMinLoad = false, checkForMaxLoad = false, canthisItembeseleted = true;
                if (!(string.IsNullOrEmpty(travelTableName) || travelTableName.Equals("No Value")))
                {
                    if (String.IsNullOrEmpty(previousTravelTableName) || !previousTravelTableName.Equals(travelTableName))
                    {
                        PartClass ConstantAuxTable = (PartClass)catalogBaseHelper.GetPartClass(travelTableName);
                        travelParts = ConstantAuxTable.GetRelationship("PartClassContainsClassItems", "ClassItem").TargetObjects;
                    }
                    double dlocalSize = Convert.ToDouble(size);
                    foreach (BusinessObject part in travelParts)
                    {
                        ReadOnlyCollection<PropertyValue> travelProperties = part.GetAllProperties();
                        //For MinTT
                        IEnumerable<PropertyValue> attrColMinTravelVlaue = travelProperties.Where(property => property.PropertyInfo.InterfaceInfo.Name == "IJUAhsMinTT");
                        if (attrColMinTravelVlaue.Count<PropertyValue>() > 0)
                            attrMinTravelVlaue = attrColMinTravelVlaue.Where(property => property.PropertyInfo.Name == "MinTT");
                        //For MaxTT
                        IEnumerable<PropertyValue> attrColMaxTravelVlaue = travelProperties.Where(property => property.PropertyInfo.InterfaceInfo.Name == "IJUAhsMaxTT");
                        if (attrColMaxTravelVlaue.Count<PropertyValue>() > 0)
                            attrMaxTravelVlaue = attrColMaxTravelVlaue.Where(property => property.PropertyInfo.Name == "MaxTT");
                        //For MinLoad
                        IEnumerable<PropertyValue> attrColMinLoadVal = travelProperties.Where(property => property.PropertyInfo.InterfaceInfo.Name == "IJUAhsMinLoad");
                        if (!(attrColMinLoadVal == null))
                        {
                            if (attrColMinLoadVal.Count<PropertyValue>() > 0)
                            {
                                attrMinLoadValue = attrColMinLoadVal.Where(property => property.PropertyInfo.Name == "MinLoad");
                                minLoadValue = (double)((PropertyValueDouble)attrMinLoadValue.ElementAt<PropertyValue>(0)).PropValue;
                                checkForMinLoad = true;
                            }
                        }
                        //For MaxLoad
                        IEnumerable<PropertyValue> attrColMaxLoadVal = travelProperties.Where(property => property.PropertyInfo.InterfaceInfo.Name == "IJUAhsMaxLoad");
                        if (!(attrColMaxLoadVal == null))
                        {
                            if (attrColMaxLoadVal.Count<PropertyValue>() > 0)
                            {
                                attrMaxLoadValue = attrColMaxLoadVal.Where(property => property.PropertyInfo.Name == "MaxLoad");
                                maxLoadValue = (double)((PropertyValueDouble)attrMaxLoadValue.ElementAt<PropertyValue>(0)).PropValue;
                                checkForMaxLoad = true;
                            }
                        }
                        //For MinSize
                        IEnumerable<PropertyValue> attrColMinSizeval = travelProperties.Where(property => property.PropertyInfo.InterfaceInfo.Name == "IJUAhsMinSize");
                        if (!(attrColMinSizeval == null))
                        {
                            if (attrColMinSizeval.Count<PropertyValue>() > 0)
                            {
                                attrMinSizeValue = attrColMinSizeval.Where(property => property.PropertyInfo.Name == "MinSize");
                                minSizeValue = Convert.ToDouble(((PropertyValueString)attrMinSizeValue.ElementAt<PropertyValue>(0)).PropValue);
                                checkForMinSize = true;
                            }
                        }
                        //For MaxSize
                        IEnumerable<PropertyValue> attrColMaxSizeval = travelProperties.Where(property => property.PropertyInfo.InterfaceInfo.Name == "IJUAhsMaxSize");
                        if (!(attrColMaxSizeval == null))
                        {
                            if (attrColMaxSizeval.Count<PropertyValue>() > 0)
                            {
                                attrMaxSizeValue = attrColMaxSizeval.Where(property => property.PropertyInfo.Name == "MaxSize");
                                maxSizeValue = Convert.ToDouble(((PropertyValueString)attrMaxSizeValue.ElementAt<PropertyValue>(0)).PropValue);
                                checkForMaxSize = true;
                            }
                        }
                        //conditional check  with the retrieved values..
                        canthisItembeseleted = true;
                        minTravelVlaue = (double)((PropertyValueDouble)attrMinTravelVlaue.ElementAt<PropertyValue>(0)).PropValue;
                        maxTravelVlaue = (double)((PropertyValueDouble)attrMaxTravelVlaue.ElementAt<PropertyValue>(0)).PropValue;

                        if ((minTravelVlaue <= totalTravel) && (maxTravelVlaue >= totalTravel))
                        {
                            if (checkForMinLoad)
                            {
                                if (!(minLoadValue <= load))
                                    canthisItembeseleted = false;
                            }
                            if (canthisItembeseleted == true)
                            {
                                if (checkForMaxLoad)
                                {
                                    if (!(maxLoadValue >= load))
                                        canthisItembeseleted = false;
                                }
                            }
                            if (canthisItembeseleted == true)
                            {
                                if (checkForMinSize)
                                {
                                    if (!(minSizeValue <= Convert.ToDouble(size)))
                                        canthisItembeseleted = false;
                                }
                            }
                            if (canthisItembeseleted == true)
                            {
                                if (checkForMaxSize)
                                {
                                    if (!(maxSizeValue >= Convert.ToDouble(size)))
                                        canthisItembeseleted = false;
                                }
                            }
                        }
                        else
                            canthisItembeseleted = false;
                        if (canthisItembeseleted)
                        {
                            constantTravelRowProperties = travelProperties;
                            break;
                        }
                    }
                }
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrGetConstantTravelRowAttributes, "Error in GetConstantTravelRowAttributes Method.");
                }
            }
            return constantTravelRowProperties;
        }

        /// <summary>
        /// This method will be called by user symbol to get value of an input(in this case, Constant input structure)during construction of outputs. 
        /// This method will return the value of the ConstantInputs for Load table.
        /// </summary>
        /// <param name="loadTableName">Table name of the auxiliary table.</param>
        /// <param name="load">Get Load</param>
        /// <returns></returns>
        /// <code>
        /// currentAttributes = GetConstantLoadAttributes(loadTableName, load);
        /// </code>
        public ReadOnlyCollection<PropertyValue> GetConstantLoadAttributes(string loadTableName, double load)
        {
            ReadOnlyCollection<PropertyValue> constantLoadRowProperties = null;
            try
            {
                CatalogBaseHelper catalogBaseHelper = new CatalogBaseHelper();
                IEnumerable<PropertyValue> minLoadAttribute = null, maxLoadAttribute = null;
                double minLoadValue, maxLoadValue;
                if (!(string.IsNullOrEmpty(loadTableName) || loadTableName.Equals("No Value")))
                {
                    if (String.IsNullOrEmpty(previousLoadTableName) || !previousLoadTableName.Equals(loadTableName))
                    {
                        PartClass ConstantAuxTable = (PartClass)catalogBaseHelper.GetPartClass(loadTableName);
                        loadParts = ConstantAuxTable.GetRelationship("PartClassContainsClassItems", "ClassItem").TargetObjects;
                    }
                    foreach (BusinessObject part in loadParts)
                    {
                        ReadOnlyCollection<PropertyValue> loadProperties = part.GetAllProperties();
                        IEnumerable<PropertyValue> minAttributesCol = loadProperties.Where(property => property.PropertyInfo.InterfaceInfo.Name == "IJUAhsMinLoad");
                        if (minAttributesCol.Count<PropertyValue>() > 0)
                            minLoadAttribute = minAttributesCol.Where(property => property.PropertyInfo.Name == "MinLoad");
                        IEnumerable<PropertyValue> maxAttributesCol = loadProperties.Where(property => property.PropertyInfo.InterfaceInfo.Name == "IJUAhsMaxLoad");
                        if (maxAttributesCol.Count<PropertyValue>() > 0)
                            maxLoadAttribute = maxAttributesCol.Where(property => property.PropertyInfo.Name == "MaxLoad");
                        minLoadValue = (double)((PropertyValueDouble)minLoadAttribute.ElementAt<PropertyValue>(0)).PropValue;
                        maxLoadValue = (double)((PropertyValueDouble)maxLoadAttribute.ElementAt<PropertyValue>(0)).PropValue;
                        if (minLoadValue <= load && maxLoadValue >= load)
                        {
                            constantLoadRowProperties = loadProperties;
                            break;
                        }
                    }
                }
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrGetConstantLoadAttributes, "Error in GetConstantLoadAttributes Method.");
                }
            }
            return constantLoadRowProperties;
        }

        /// <summary>
        /// This method will be called by user symbol to get value of an input(in this case, Constant input structure)during construction of outputs. 
        /// This method will return the value of the ConstantInputs struct object.
        /// </summary>
        /// <param name="sizeTableName">Table name of the auxiliary table.</param>
        /// <param name="travelTableName">Table name of the auxiliary table.</param>
        /// <param name="loadTableName">Table name of the auxiliary table.</param>
        /// <param name="size">Get Size</param>
        /// <param name="totalTravel">Get TotalTravel</param>
        /// <param name="load">Get Load</param>
        /// <returns></returns>
        /// <code>
        /// constant = LoadConstantData(sizeTable, travelTable, loadTable, size, Math.Round(totalTravelInUnits, 1), load);
        /// </code>
        public ConstantInputs LoadConstantData(string sizeTableName, string travelTableName, string loadTableName, string size, double totalTravel, double load)
        {
            ConstantInputs constant = new ConstantInputs();
            try
            {
                ReadOnlyCollection<PropertyValue> currentAttributes = null;
                string plate1Shape = string.Empty, plate2Shape = string.Empty, plate3Shape = string.Empty, plate4Shape = string.Empty, casingShape = string.Empty, frameShape = string.Empty, upThrustShape = string.Empty;
                string leverShape = string.Empty, earPlateShape = string.Empty, pivotPinShape = string.Empty, gussetShape = string.Empty, columnPinShape = string.Empty, columnShape = string.Empty, columnEndShape = string.Empty;
                string clevisShape = string.Empty, turnbuckleShape = string.Empty, columnPlateShape = string.Empty, nutShape = string.Empty, lugShape = string.Empty, lug2Shape = string.Empty, pinShape = string.Empty, pin2Shape = string.Empty, strCurrentAttr = string.Empty;
                if (previousLoadTableName == null)
                    previousLoadTableName = string.Empty;
                if (previousTravelTableName == null)
                    previousTravelTableName = string.Empty;
                if (previousSizeTableName == null)
                    previousSizeTableName = string.Empty;
                if (isSpringPlacedFirstTime)
                {
                    loadAttributes = GetConstantLoadAttributes(loadTableName, load);
                    travelAttributes = GetConstantTravelRowAttributes(travelTableName, size, totalTravel, load);
                    sizeAttributes = GetConstantSizeRowProperties(sizeTableName, size, load);
                    isSpringPlacedFirstTime = false;
                }
                else
                {
                    if (!previousLoadTableName.Equals(loadTableName) || HgrCompareDoubleService.cmpdbl(load, previousLoad) == false)
                        loadAttributes = GetConstantLoadAttributes(loadTableName, load);
                    if (!previousTravelTableName.Equals(travelTableName) || HgrCompareDoubleService.cmpdbl(load, previousLoad) == false || HgrCompareDoubleService.cmpdbl(totalTravel, previousTotalTravel) == false || !(size.Equals(previousSize)))
                        travelAttributes = GetConstantTravelRowAttributes(travelTableName, size, totalTravel, load);
                    if (!previousSizeTableName.Equals(sizeTableName) || !(size.Equals(previousSize)) || HgrCompareDoubleService.cmpdbl(load, previousLoad) == false)
                    {
                        sizeAttributes = GetConstantSizeRowProperties(sizeTableName, size, load);
                        if (sizeAttributes == null)
                        {
                            RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrDataOutsideRange, "Given Value must be between the Minimum and Maximum Range.");
                        }
                    }
                }
                for (int tableNumber = 1; tableNumber <= 3; tableNumber++)
                {
                    if (tableNumber == 1)
                        currentAttributes = loadAttributes;
                    else if (tableNumber == 2)
                        currentAttributes = travelAttributes;
                    else if (tableNumber == 3)
                        currentAttributes = sizeAttributes;

                    if (!(currentAttributes == null))
                    {
                        foreach (PropertyValue prop in currentAttributes)
                        {
                            if (!(String.IsNullOrEmpty(prop.PropertyInfo.Name)))
                            {
                                strCurrentAttr = prop.PropertyInfo.InterfaceInfo.Name + ":" + prop.PropertyInfo.Name;
                                switch (strCurrentAttr)
                                {
                                    //Dimensions
                                    case ("IJUAhsLength:Length"):
                                        GetDoublePropertyValue(prop, ref constant.length);
                                        break;
                                    case ("IJUAhsLength2:Length2"):
                                        GetDoublePropertyValue(prop, ref constant.length2);
                                        break;
                                    case ("IJUAhsOffset1:Offset1"):
                                        GetDoublePropertyValue(prop, ref constant.offset1);
                                        break;
                                    case ("IJUAhsOffset2:Offset2"):
                                        GetDoublePropertyValue(prop, ref constant.offset2);
                                        break;
                                    case ("IJUAhsOffset3:Offset3"):
                                        GetDoublePropertyValue(prop, ref constant.offset3);
                                        break;
                                    case ("IJUAhsOffset4:Offset4"):
                                        GetDoublePropertyValue(prop, ref constant.offset4);
                                        break;
                                    case ("IJUAhsOffset5:Offset5"):
                                        GetDoublePropertyValue(prop, ref constant.offset5);
                                        break;
                                    case ("IJUAhsOffset6:Offset6"):
                                        GetDoublePropertyValue(prop, ref constant.offset6);
                                        break;
                                    case ("IJUAhsPlate1Offset:Plate1Offset"):
                                        GetDoublePropertyValue(prop, ref constant.plate1Offset);
                                        break;
                                    case ("IJUAhsPlate2Offset:Plate2Offset"):
                                        GetDoublePropertyValue(prop, ref constant.plate2Offset);
                                        break;
                                    case ("IJUAhsPlate3Offset:Plate3Offset"):
                                        GetDoublePropertyValue(prop, ref constant.plate3Offset);
                                        break;
                                    case ("IJUAhsPlate4Offset:Plate4Offset"):
                                        GetDoublePropertyValue(prop, ref constant.plate4Offset);
                                        break;
                                    case ("IJUAhsFrameOffset:FrameOffset"):
                                        GetDoublePropertyValue(prop, ref constant.frameOffset);
                                        break;
                                    case ("IJUAhsLever2Offset:Lever2Offset"):
                                        GetDoublePropertyValue(prop, ref constant.lever2Offset);
                                        break;
                                    case ("IJUAhsCaseCLOffset:CaseCLOffset"):
                                        GetDoublePropertyValue(prop, ref constant.caseCLOffset);
                                        break;
                                    case ("IJUAhsPivotOffset:PivotOffset"):
                                        GetDoublePropertyValue(prop, ref constant.pivotOffset);
                                        break;
                                    case ("IJUAhsTopOffset:TopOffset"):
                                        GetDoublePropertyValue(prop, ref constant.topOffset);
                                        break;
                                    case ("IJUAhsTopSpacing:TopSpacing"):
                                        GetDoublePropertyValue(prop, ref constant.topSpacing);
                                        break;
                                    case ("IJUAhsFrameSpacing:FrameSpacing"):
                                        GetDoublePropertyValue(prop, ref constant.frameSpacing);
                                        break;
                                    case ("IJUAhsUpThSpacing:UpThrustSpacing"):
                                        GetDoublePropertyValue(prop, ref constant.upThrustSpacing);
                                        break;
                                    case ("IJUAhsLeverSpacing:LeverSpacing"):
                                        GetDoublePropertyValue(prop, ref constant.leverSpacing);
                                        break;
                                    case ("IJUAhsGussetSpacing:GussetSpacing"):
                                        GetDoublePropertyValue(prop, ref constant.gussetSpacing);
                                        break;
                                    case ("IJUAhsColumnSpacing:ColumnSpacing"):
                                        GetDoublePropertyValue(prop, ref constant.columnSpacing);
                                        break;
                                    case ("IJUAhsAngleHigh:AngleHigh"):
                                        GetDoublePropertyValue(prop, ref constant.angleHigh);
                                        break;
                                    case ("IJUAhsAngleLow:AngleLow"):
                                        GetDoublePropertyValue(prop, ref constant.angleLow);
                                        break;
                                    case ("IJUAhsRodTakeOutHigh:RodTakeOutHigh"):
                                        GetDoublePropertyValue(prop, ref constant.rodTakeOutHigh);
                                        break;
                                    case ("IJUAhsRodTakeOutLow:RodTakeOutLow"):
                                        GetDoublePropertyValue(prop, ref constant.rodTakeOutLow);
                                        break;
                                    case ("IJUAhsRodDiameter:RodDiameter"):
                                        GetDoublePropertyValue(prop, ref constant.rodDiameter);
                                        break;
                                    case ("IJUAhsHoleDiameter:HoleDiameter"):
                                        GetDoublePropertyValue(prop, ref constant.holeDiameter);
                                        break;
                                    case ("IJUAhsGap1:Gap1"):
                                        GetDoublePropertyValue(prop, ref constant.gap1);
                                        break;
                                    case ("IJUAhsGap2:Gap2"):
                                        GetDoublePropertyValue(prop, ref constant.gap2);
                                        break;
                                    case ("IJUAhsLugHoleOffset:LugHoleOffset"):
                                        GetDoublePropertyValue(prop, ref constant.lugHoleOffset);
                                        break;
                                    case ("IJUAhsCCMin:CCMin"):
                                        GetDoublePropertyValue(prop, ref constant.cCMin);
                                        break;
                                    case ("IJUAhsCCMax:CCMax"):
                                        GetDoublePropertyValue(prop, ref  constant.cCMax);
                                        break;

                                    //Frame and Casing Shapes
                                    case ("IJUAhsPlate1Shape:Plate1Shape"):
                                        GetStringPropertyValue(prop, ref plate1Shape);
                                        constant.plate1 = LoadPlateDataByQuery(plate1Shape);
                                        break;
                                    case ("IJUAhsPlate2Shape:Plate2Shape"):
                                        GetStringPropertyValue(prop, ref plate2Shape);
                                        constant.plate2 = LoadPlateDataByQuery(plate2Shape);
                                        break;
                                    case ("IJUAhsPlate3Shape:Plate3Shape"):
                                        GetStringPropertyValue(prop, ref plate3Shape);
                                        constant.plate3 = LoadPlateDataByQuery(plate3Shape);
                                        break;
                                    case ("IJUAhsPlate4Shape:Plate4Shape"):
                                        GetStringPropertyValue(prop, ref plate4Shape);
                                        constant.plate4 = LoadPlateDataByQuery(plate4Shape);
                                        break;
                                    case ("IJUAhsCasingShape:CasingShape"):
                                        GetStringPropertyValue(prop, ref casingShape);
                                        constant.casing = LoadNutDataByQuery(casingShape, 1);
                                        break;
                                    case ("IJUAhsFrameShape:FrameShape"):
                                        GetStringPropertyValue(prop, ref frameShape);
                                        constant.frame = LoadPlateDataByQuery(frameShape);
                                        break;
                                    case ("IJUAhsUpThShape:UpThrustShape"):
                                        GetStringPropertyValue(prop, ref upThrustShape);
                                        constant.upThrustPlate = LoadPlateDataByQuery(upThrustShape);
                                        break;
                                    case ("IJUAhsLeverShape:LeverShape"):
                                        GetStringPropertyValue(prop, ref leverShape);
                                        constant.lever = LoadPlateDataByQuery(leverShape);
                                        break;
                                    case ("IJUAhsEarPlateShape:EarPlateShape"):
                                        GetStringPropertyValue(prop, ref earPlateShape);
                                        constant.earPlate = LoadPlateDataByQuery(earPlateShape);
                                        break;
                                    case ("IJUAhsPivotPinShape:PivotPinShape"):
                                        GetStringPropertyValue(prop, ref pivotPinShape);
                                        constant.pivotPin = LoadPinDataByQuery(pivotPinShape);
                                        break;
                                    case ("IJUAhsGussetShape:GussetShape"):
                                        GetStringPropertyValue(prop, ref gussetShape);
                                        constant.gussetPlate = LoadPlateDataByQuery(gussetShape);
                                        break;

                                    //Load Column Shapes
                                    case ("IJUAhsColumnPinShape:ColumnPinShape"):
                                        GetStringPropertyValue(prop, ref columnPinShape);
                                        constant.columnPin = LoadPinDataByQuery(columnPinShape);
                                        break;
                                    case ("IJUAhsColumnShape:ColumnShape"):
                                        GetStringPropertyValue(prop, ref columnShape);
                                        constant.column = LoadRodDataByQuery(columnShape);
                                        break;
                                    case ("IJUAhsColumnEndShape:ColumnEndShape"):
                                        GetStringPropertyValue(prop, ref columnEndShape);
                                        constant.columnEnd = LoadNutDataByQuery(columnEndShape, 1);
                                        break;
                                    case ("IJUAhsClevisShape:ClevisShape"):
                                        GetStringPropertyValue(prop, ref clevisShape);
                                        constant.clevis = LoadClevisDataByQuery(clevisShape);
                                        break;
                                    case ("IJUAhsTurnbuckleShape:TurnbuckleShape"):
                                        GetStringPropertyValue(prop, ref turnbuckleShape);
                                        constant.turnbuckle = LoadTurnbuckleDataByQuery(turnbuckleShape);
                                        break;
                                    case ("IJUAhsColumnPlateShape:ColumnPlateShape"):
                                        GetStringPropertyValue(prop, ref columnPlateShape);
                                        constant.columnPlate = LoadPlateDataByQuery(columnPlateShape);
                                        break;

                                    //Top Shapes
                                    case ("IJUAhsNutShape:NutShape"):
                                        GetStringPropertyValue(prop, ref nutShape);
                                        constant.nut = LoadNutDataByQuery(nutShape, 1);
                                        break;
                                    case ("IJUAhsLugShape:LugShape"):
                                        GetStringPropertyValue(prop, ref lugShape);
                                        constant.lug = LoadPlateDataByQuery(lugShape);
                                        break;
                                    case ("IJUAhsLug2Shape:Lug2Shape"):
                                        GetStringPropertyValue(prop, ref lug2Shape);
                                        constant.lug2 = LoadPlateDataByQuery(lug2Shape);
                                        break;
                                    case ("IJUAhsPinShape:PinShape"):
                                        GetStringPropertyValue(prop, ref pinShape);
                                        constant.pin = LoadPinDataByQuery(pinShape);
                                        break;
                                    case ("IJUAhsPin2Shape:Pin2Shape"):
                                        GetStringPropertyValue(prop, ref pin2Shape);
                                        constant.pin2 = LoadPinDataByQuery(pin2Shape);
                                        break;
                                    case ("IJUAhsTopAttachment:TopAttachment"):
                                        GetStringPropertyValue(prop, ref constant.topAttachment);
                                        break;
                                    case ("IJUAhsStructAttachment:StructAttachment"):
                                        GetStringPropertyValue(prop, ref constant.structAttachment);
                                        break;
                                    case ("IJUAhsSteelStandard:SteelStandard"):
                                        constant.steel.sectionStandard = Convert.ToString((int)((PropertyValueCodelist)prop).PropValue);
                                        break;
                                    case ("IJUAhsSectionType:SectionType"):
                                        GetStringPropertyValue(prop, ref constant.steel.sectionType);
                                        break;
                                    case ("IJUAhsSecName:SecName"):
                                        GetStringPropertyValue(prop, ref constant.steel.sectionName);
                                        break;
                                }
                            }
                        }
                    }
                }
                previousLoad = load;
                previousLoadTableName = loadTableName;
                previousSize = size;
                previousSizeTableName = sizeTableName;
                previousTotalTravel = totalTravel;
                previousTravelTableName = travelTableName;
            }
            catch (SmartPartSymbolException hgrEx)
            {
                throw hgrEx;
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadRefData, "Error in LoadConstantData Method.");
                }
            }
            return constant;
        }
        /// <summary>
        /// This method will be called by user symbol to get value of an input(in this case, Pin input structure)during construction of outputs. 
        /// This method will return the value of the PinInputs struct object.
        /// </summary>
        /// <param name="refShapeName">part name of the auxiliary table.</param>
        /// <returns></returns>
        /// <code>
        /// pin = LoadPinDataByQuery(refShapeName);
        /// </code>
        public PinInputs LoadPinDataByQuery(string refShapeName)
        {
            PinInputs pin = new PinInputs();
            try
            {
                if (!(refShapeName == "" || refShapeName == "No Value" || refShapeName == null))
                {
                    Catalog m_oPlantCatalog = MiddleServiceProvider.SiteMgr.ActiveSite.ActivePlant.PlantCatalog;
                    BusinessObject pinAuxTable = m_oPlantCatalog.GetNamedObject(refShapeName);
                    ReadOnlyCollection<PropertyValue> pinProperties = pinAuxTable.GetAllProperties();
                    string strCurrentAttr = string.Empty;
                    foreach (PropertyValue property in pinProperties)
                    {
                        if (!(String.IsNullOrEmpty(property.PropertyInfo.Name)))
                        {
                            strCurrentAttr = property.PropertyInfo.InterfaceInfo.Name + ":" + property.PropertyInfo.Name;
                            switch (strCurrentAttr)
                            {

                                case ("IJUAhsPin1:Pin1Diameter"):
                                    GetDoublePropertyValue(property, ref pin.PinDiameter);
                                    break;
                                case ("IJUAhsPin1:Pin1Length"):
                                    GetDoublePropertyValue(property, ref pin.PinLength);
                                    break;
                                case ("IJUAhsCotter1:CotterDia"):
                                    GetDoublePropertyValue(property, ref pin.CotterDiameter);
                                    break;
                                case ("IJUAhsCotter1:CotterLength"):
                                    GetDoublePropertyValue(property, ref pin.CotterLength);
                                    break;
                                case ("IJUAhsCotter1:CotterOffset"):
                                    GetDoublePropertyValue(property, ref pin.CotterOffset);
                                    break;
                            }
                        }
                    }

                }
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadPinDataByQuery, "Error occured in LoadPinDataByQuery Method.");
                }
            }
            return pin;
        }
        /// <summary>
        /// This method will be called by user symbol to get value of an input(in this case, Clevis input structure)during construction of outputs. 
        /// This method will return the value of the ClevisInputs struct object.
        /// </summary>
        /// <param name="refShapeName">part name of the auxiliary table.</param>
        /// <returns></returns>
        ///<code>
        ///clevis = LoadClevisDataByQuery(refShapeName);
        ///</code>
        public ClevisInputs LoadClevisDataByQuery(string refShapeName)
        {
            ClevisInputs clevis = new ClevisInputs();
            try
            {
                if (!(refShapeName == "" || refShapeName == "No Value" || refShapeName == null))
                {
                    Catalog m_oPlantCatalog = MiddleServiceProvider.SiteMgr.ActiveSite.ActivePlant.PlantCatalog;
                    BusinessObject clevisAuxTable = m_oPlantCatalog.GetNamedObject(refShapeName);
                    ReadOnlyCollection<PropertyValue> clevisProperties = clevisAuxTable.GetAllProperties();
                    string strCurrentAttr = string.Empty;
                    foreach (PropertyValue property in clevisProperties)
                    {
                        if (!(String.IsNullOrEmpty(property.PropertyInfo.Name)))
                        {
                            strCurrentAttr = property.PropertyInfo.InterfaceInfo.Name + ":" + property.PropertyInfo.Name;
                            switch (strCurrentAttr)
                            {

                                case ("IJUAhsOpening1:Opening1"):
                                    GetDoublePropertyValue(property, ref clevis.Opening1);
                                    break;
                                case ("IJUAhsShape1:Shape1Type"):
                                    GetIntPropertyValue(property, ref clevis.nut.ShapeType);
                                    break;
                                case ("IJUAhsShape1:Shape1Width1"):
                                    GetDoublePropertyValue(property, ref clevis.nut.ShapeWidth1);
                                    break;
                                case ("IJUAhsShape1:Shape1Width2"):
                                    GetDoublePropertyValue(property, ref clevis.nut.ShapeWidth2);
                                    break;
                                case ("IJUAhsShape1:Shape1Length"):
                                    GetDoublePropertyValue(property, ref clevis.nut.ShapeLength);
                                    break;
                                case ("IJUAhsDiameter2:Diameter2"):
                                    GetDoublePropertyValue(property, ref clevis.Diameter2);
                                    break;
                                case ("IJUAhsThickness2:Thickness2"):
                                    GetDoublePropertyValue(property, ref clevis.Thickness2);
                                    break;
                                case ("IJUAhsWidth3:Width3"):
                                    GetDoublePropertyValue(property, ref clevis.Width3);
                                    break;
                                case ("IJUAhsThickness3:Thickness3"):
                                    GetDoublePropertyValue(property, ref clevis.thickness3);
                                    break;
                                case ("IJUAhsGap3:Gap3"):
                                    GetDoublePropertyValue(property, ref clevis.Gap3);
                                    break;
                                case ("IJUAhsGap2:Gap2"):
                                    GetDoublePropertyValue(property, ref clevis.Gap2);
                                    break;
                                case ("IJUAhsOverLength1:OverLength1"):
                                    GetDoublePropertyValue(property, ref clevis.OverLength1);
                                    break;
                                case ("IJUAhsOverLength2:OverLength2"):
                                    GetDoublePropertyValue(property, ref clevis.OverLength2);
                                    break;
                                case ("IJUAhsPin1:Pin1Diameter"):
                                    GetDoublePropertyValue(property, ref clevis.Pin1Diameter);
                                    break;
                                case ("IJUAhsPin1:Pin1Length"):
                                    GetDoublePropertyValue(property, ref clevis.Pin1Length);
                                    break;
                            }
                        }
                    }
                }
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadClevisDataByQuery, "Error occured in LoadClevisDataByQuery Method.");
                }
            }
            return clevis;
        }
        /// <summary>
        /// This method will be called to get UOMFormat of given Unittype and PrecisionType
        /// </summary>
        /// <param name="unit">type of Unit</param>
        /// <param name="precisionType">type of precision</param>
        /// <returns></returns>
        ///<code>
        ///GetUOMFormat(UnitType.Force, (PrecisionType)collection[0])
        ///</code>
        public UOMFormat GetUOMFormat(UnitType unit, PrecisionType precisionType)
        {
            UOMFormat uomFormat = MiddleServiceProvider.UOMMgr.GetDefaultUnitFormat(unit);
            uomFormat.PrecisionType = precisionType;
            if (uomFormat.PrecisionType == PrecisionType.PRECISIONTYPE_FRACTIONAL)
                uomFormat.FractionalPrecision = uomFormat.FractionalPrecision;
            if (uomFormat.PrecisionType == PrecisionType.PRECISIONTYPE_DECIMAL)
                uomFormat.DecimalPrecision = uomFormat.DecimalPrecision;
            return uomFormat;
        }
        /// <summary>
        /// This method will be called to check property is available on the support component and return its value.
        /// </summary>
        /// <param name="occurrenceAttributeInfo">Property Value in IEnumerable PropertyValue Collection</param>
        /// <param name="propertyValue">Returns the Property Value.</param>
        /// <returns></returns>
        /// <code>
        /// GetStringPropertyValue(occurrenceAttributeInfo, ref strheight1)
        /// </code>
        public void GetStringPropertyValue(PropertyValue occurrenceAttributeInfo, ref string propertyValue)
        {
            try
            {
                string previousPropertyValue = propertyValue;
                propertyValue = (string)((PropertyValueString)occurrenceAttributeInfo).PropValue;
                if (propertyValue != null)
                {
                    previousPropertyValue = propertyValue;
                }
                propertyValue = previousPropertyValue;
            }
            catch
            { }
        }
        /// <summary>
        /// This method will return the value of the SmartShapeType Value.
        /// </summary>
        /// <param name="refShapeName">Part Name of the auxiliary table.</param>
        /// <returns></returns>
        /// <code>
        /// int smartShapeType = GetSmartShapeType(refShapeName);
        /// </code>
        public int GetSmartShapeType(string refShapeName)
        {
            int smartShapeType = 5;
            try
            {

                if (!(refShapeName == "" || refShapeName == "No Value" || refShapeName == null))
                {
                    Catalog m_oPlantCatalog = MiddleServiceProvider.SiteMgr.ActiveSite.ActivePlant.PlantCatalog;
                    BusinessObject shapeTypeAuxTable = m_oPlantCatalog.GetNamedObject(refShapeName);

                    smartShapeType = (int)((PropertyValueCodelist)shapeTypeAuxTable.GetPropertyValue("IJUAhsSmartShapeType", "SmartShapeType")).PropValue;
                }
            }
            catch
            {

                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrGetSmartShapeType, "Error in GetSmartShapeType method.");
                }
            }
            return smartShapeType;
        }
        /// <summary>
        /// This method will be called to check property is available on the support component and return its value.
        /// </summary>
        /// <param name="occurrenceAttributeInfo">Property Value in IEnumerable PropertyValue Collection</param>
        /// <param name="propertyValue">Returns the Property Value.</param>
        /// <returns></returns>
        /// <code>
        /// GetDoublePropertyValue(occurrenceAttributeInfo, ref height1)
        /// </code>
        public void GetIntPropertyValue(PropertyValue occurrenceAttributeInfo, ref int propertyValue)
        {
            try
            {
                propertyValue = (int)((PropertyValueCodelist)occurrenceAttributeInfo).PropValue;
            }
            catch
            { }
        }
        /// <summary>
        /// Adds the plate outputs.
        /// </summary>       
        /// <param name="noofPlate">Number Of Plates</param>
        /// <param name="additionalOutputs">The additional outputs.</param>
        /// <code>
        ///  List<OutputDefinition> additionalOutputs = new List<OutputDefinition>();
        ///  AddPlateOutputs(3, additionalOutputs);
        /// </code>
        public void AddPlateOutputs(int noofPlate, List<OutputDefinition> additionalOutputs)
        {
            try
            {
                for (int i = 1; i <= noofPlate; i++)
                {
                    additionalOutputs.Add(new OutputDefinition("Plate" + i, "Plate" + i));
                }
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrPlateAdditionalOutputs, "Error in AddPlateOutputs.");
            }
        }
        /// <summary>
        /// This method will be called to check property is available on the support component and return its value.
        /// </summary>
        /// <param name="occurrenceAttributeInfo">Property Value in IEnumerable PropertyValue Collection</param>
        /// <param name="propertyValue">Returns the Property Value.</param>
        /// <returns></returns>
        /// <code>
        /// GetDoublePropertyValue(occurrenceAttributeInfo, ref height1)
        /// </code>
        public void GetDoublePropertyValue(PropertyValue occurrenceAttributeInfo, ref double propertyValue)
        {
            try
            {
                propertyValue = (double)((PropertyValueDouble)occurrenceAttributeInfo).PropValue;
            }
            catch
            { }
        }
        /// <summary>
        /// Adds the Turnbuckle outputs.User symbol calls this method during AdditionalOutputs
        /// to define additional outputs for an aspect. The list of outputs returned by this method will be the outputs for the aspect
        /// in addition to the outputs that are already defined as attributes on the aspect.
        /// </summary>
        /// <param name="additionalOutputs">The additional outputs.</param>
        ///<code>
        ///public override IEnumerable<OutputDefinition> AdditionalOutputs(string aspectName)
        ///{
        ///    List<OutputDefinition> additionalOutputs = new List<OutputDefinition>();
        ///    if (aspectName == "Symbolic")
        ///    {
        ///       AddTurnbuckleOutputs(additionalOutputs,output);
        ///    }
        ///    return additionalOutputs;
        ///}
        ///</code> 
        public void AddTurnbuckleOutputs(List<OutputDefinition> additionalOutputs, string output)
        {
            try
            {
                // Outputs for the turnbuckle
                additionalOutputs.Add(new OutputDefinition(output + "SideBlock1", output + "SideBlock1"));
                additionalOutputs.Add(new OutputDefinition(output + "SideBlock2", output + "SideBlock2"));
                additionalOutputs.Add(new OutputDefinition(output + "CenterTube", output + "CenterTube"));
                // Outputs for the imbeded Nuts
                additionalOutputs.Add(new OutputDefinition(output + "Nut1", output + "Nut1"));
                additionalOutputs.Add(new OutputDefinition(output + "Nut2", output + "Nut2"));
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrTurnbuckleAdditionalOutputs, "Error in AddTurnbuckleOutputs.");
            }
        }
        /// <summary>
        /// Adds the Shield outputs.
        /// </summary>       
        /// <param name="aspectName">Name of the aspect.</param>
        /// <param name="additionalOutputs">The additional outputs.</param>
        /// <code>
        ///  List<OutputDefinition> additionalOutputs = new List<OutputDefinition>();
        ///  AddShieldOutputs(additionalOutputs,output);
        /// </code>
        public void AddShieldOutputs(List<OutputDefinition> additionalOutputs, string output)
        {
            Type myType = this.GetType();
            try
            {   //Outputs
                additionalOutputs.Add(new OutputDefinition(output + "PLT1", output + "PLT1"));
                additionalOutputs.Add(new OutputDefinition(output + "PLT2", output + "PLT2"));
                for (int i = 0; i <= 8; i++)
                {
                    additionalOutputs.Add(new OutputDefinition(output + "Num" + i + "PLT1", output + "Num" + i + "PLT1"));
                    additionalOutputs.Add(new OutputDefinition(output + "Num" + i + "PLT2", output + "Num" + i + "PLT2"));
                }
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddShieldOutputs, "Error in AddShieldOutputs.");
                }
            }
        }
        /// <summary>
        /// Adds the Rod outputs.User symbol calls this method during AdditionalOutputs
        /// to define additional outputs for an aspect. The list of outputs returned by this method will be the outputs for the aspect
        /// in addition to the outputs that are already defined as attributes on the aspect.
        /// </summary>
        /// <param name="outputName">Output Name.</param>
        /// <param name="additionalOutputs">The additional outputs.</param>
        ///<code>
        ///public override IEnumerable<OutputDefinition> AdditionalOutputs(string aspectName)
        ///{
        ///    List<OutputDefinition> additionalOutputs = new List<OutputDefinition>();
        ///    if (aspectName == "Symbolic")
        ///    {
        ///       AddRod1Outputs("Column",additionalOutputs);
        ///    }
        ///    return additionalOutputs;
        ///}
        ///</code> 
        public void AddRod1Outputs(string outputName, List<OutputDefinition> additionalOutputs)
        {
            try
            {
                additionalOutputs.Add(new OutputDefinition(outputName + "ROD", outputName + "ROD"));
                additionalOutputs.Add(new OutputDefinition(outputName + "EndType1", outputName + "EndType1"));
                additionalOutputs.Add(new OutputDefinition(outputName + "EndType2", outputName + "EndType2"));
                additionalOutputs.Add(new OutputDefinition(outputName + "CenterType1", outputName + "CenterType1"));
                additionalOutputs.Add(new OutputDefinition(outputName + "CenterType2", outputName + "CenterType2"));
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddRod1Outputs, "Error in AddRod1Outputs.");
                }
            }
        }
        public void AddGroutInputs(int startIndex, out int endIndex, List<Input> additionalInputs)
        {
            try
            {
                additionalInputs.Add((Input)new InputDouble(startIndex, "ShapeType", "ShapeType", 1, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "BottomWidth1", "BottomWidth1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "BottomWidth2", "BottomWidth2", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "TopWidth1", "TopWidth1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "TopWidth2", "TopWidth2", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "GroutHeight", "GroutHeight", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "GroutDensity", "GroutDensity", 0, true));
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrGroutAdditionalInputs, "Error in Adding Grout Inputs.");
            }
            endIndex = startIndex;
        }
        public GroutInputs LoadGroutData(int startIndex, out int endIndex)
        {
            GroutInputs groutInputs = new GroutInputs();
            try
            {
                groutInputs.ShapeType = (int)GetDoubleInputValue(startIndex);
                groutInputs.BottomWidth1 = GetDoubleInputValue(++startIndex);
                groutInputs.BottomWidth2 = GetDoubleInputValue(++startIndex);
                groutInputs.TopWidth1 = GetDoubleInputValue(++startIndex);
                groutInputs.TopWidth2 = GetDoubleInputValue(++startIndex);
                groutInputs.GroutHeight = GetDoubleInputValue(++startIndex);
                groutInputs.GroutDensity = GetDoubleInputValue(++startIndex);
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadGroutData, "Error occured in LoadGroutData Method.");
                }
            }
            endIndex = startIndex;
            return groutInputs;
        }


        public void AddGroutOutputs(List<OutputDefinition> additionalOutputs)
        {
            try
            {
                additionalOutputs.Add(new OutputDefinition("Grout", "Grout"));
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrGroutAdditionalOutputs, "Error in Adding Grout Inputs.");
            }
        }

        public void AddGroutCircular(GroutInputs grout, OutputDictionary outputs, String outputName)
        {
            try
            {
                SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();

                Circle3d oBaseCircle = new Circle3d(new Position(0, 0, 0), new Vector(0, 0, 1), grout.BottomWidth1 / 2);
                Circle3d oTopCircle = new Circle3d(new Position(0, 0, grout.GroutHeight), new Vector(0, 0, 1), grout.TopWidth1 / 2);

                Collection<ICurve> oElements = new Collection<ICurve>();

                //ComplexString3d complexString = CreChamBoxLine(new Position(0, 0, 0), 0, 0, true);
                oElements.Add(oBaseCircle);
                ComplexString3d oBase = new ComplexString3d(oElements);
                oElements.Clear();
                oElements.Add(oTopCircle);
                ComplexString3d oTop = new ComplexString3d(oElements);

                Ruled3d oEccentricCone = new Ruled3d(OccurrenceConnection, oBase, oTop, true);
                outputs.Add(outputName, oEccentricCone);

            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddGroutCircular, "Error in Adding Grout Circular.");
            }
        }

        public void AddGrout(GroutInputs grout, OutputDictionary outputs, String outputName)
        {
            try
            {
                SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();

                if (grout.BottomWidth2 <= 0)
                    grout.BottomWidth2 = grout.BottomWidth1;
                else if (grout.BottomWidth1 <= 0)
                    grout.BottomWidth1 = grout.BottomWidth2;

                if (grout.TopWidth2 <= 0)
                    grout.TopWidth2 = grout.TopWidth1;
                else if (grout.TopWidth1 <= 0)
                    grout.TopWidth1 = grout.TopWidth2;


                if (HgrCompareDoubleService.cmpdbl(grout.BottomWidth1, 0) == false && HgrCompareDoubleService.cmpdbl(grout.GroutHeight, 0) == false && HgrCompareDoubleService.cmpdbl(grout.TopWidth1, 0) == false)
                {

                    switch (grout.ShapeType)
                    {

                        case 1:
                            AddGroutCircular(grout, outputs, outputName);
                            break;
                        case 2:
                            Ruled3d trapezoid = symbolGeometryHelper.CreateTrapezoid(OccurrenceConnection, grout.BottomWidth1, grout.BottomWidth2, grout.TopWidth1, grout.TopWidth2, grout.GroutHeight, true);
                            outputs.Add(outputName, trapezoid);
                            break;
                    }
                }

                if (grout.BottomWidth1 <= 0 && grout.BottomWidth2 <= 0)
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrGroutBottomWidth1, "BottomWidth is not declared properly.");
                if (grout.TopWidth1 <= 0 && grout.TopWidth2 <= 0)
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrGroutTopWidth1, "TopWidth is not declared properly.");
                if (grout.GroutHeight <= 0)
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrGroutHeight, "GroutHeight is not declared properly.");

            }
            catch (SmartPartSymbolException hgrEx)
            {
                throw hgrEx;
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddGrout, "Error in Add Grout.");
            }

        }

        /// <summary>
        /// Defines the Pipe R-Pad input parameter type.
        /// </summary>
        public struct PipeRPadInputs
        {
            /// <summary>
            /// Outside diameter of the pipe the r-pad is welded to.
            /// </summary>
            public double PipeOD;
            /// <summary>
            /// The width of the r-pad plate
            /// </summary>
            public double Width;
            /// <summary>
            /// The length of the r-pad plate  
            /// </summary>
            public double Length;
            /// <summary>
            /// The thickness of the r-pad plate
            /// </summary>
            public double Thickness;
        }

        /// <summary>
        /// Adds the PipeRPad inputs.
        /// </summary>        
        /// <param name="startIndex">The start index.</param>
        /// <param name="endIndex">The end index.</param>
        /// <param name="additionalInputs">The additional inputs.</param>
        /// <code>
        /// int endIndex;
        /// List<Input> additionalInputs = new List<Input>();
        /// AddPipeRPadInputs(2, out endIndex, additionalInputs);
        /// </code>
        public void AddPipeRPadInputs(int startIndex, out int endIndex, List<Input> additionalInputs)
        {
            try
            {
                additionalInputs.Add(new InputDouble(startIndex, "PipeOD", "PipeOD", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Thickness1", "Thickness1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Length1", "Length1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Width1", "Width1", 0, false));
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddPipeRPadInputs, "Error in adding Pipe R-Pad inputs");
                }
            }
            endIndex = ++startIndex;
        }

        /// <summary>
        /// Adds the PipeRPad outputs.User symbol calls this method during AdditionalOutputs
        /// to define additional outputs for an aspect. The list of outputs returned by this method will be the outputs for the aspect
        /// in addition to the outputs that are already defined as attributes on the aspect.
        /// </summary>
        /// <param name="outputName">Output Name.</param>
        /// <param name="additionalOutputs">The additional outputs.</param>
        ///<code>
        ///public override IEnumerable<OutputDefinition> AdditionalOutputs(string aspectName)
        ///{
        ///    List<OutputDefinition> additionalOutputs = new List<OutputDefinition>();
        ///    if (aspectName == "Symbolic")
        ///    {
        ///       AddPipeRPadOutputs("RPad",additionalOutputs);
        ///    }
        ///    return additionalOutputs;
        ///}
        ///</code> 
        public void AddPipeRPadOutputs(string outputName, List<OutputDefinition> additionalOutputs)
        {
            try
            {
                additionalOutputs.Add(new OutputDefinition(outputName + "Outside", outputName + "Outside"));
                additionalOutputs.Add(new OutputDefinition(outputName + "Inside", outputName + "Inside"));
                additionalOutputs.Add(new OutputDefinition(outputName + "Edge", outputName + "Edge"));
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddPipeRPadOutputs, "Error in AddPipeRPadOutputs.");
                }
            }
        }

        /// <summary>
        /// Loads the PipeRPad data.
        /// </summary>        
        /// <param name="startIndex">The start index.</param>
        ///  <code>
        ///  PipeRPadInputs pipeRPad = LoadPipeRPadData(2);
        /// </code>
        /// <returns>PipeRPadInputs</returns>
        public PipeRPadInputs LoadPipeRPadData(int startIndex)
        {
            PipeRPadInputs rpad = new PipeRPadInputs();
            try
            {
                rpad.PipeOD = GetDoubleInputValue(startIndex);
                if (rpad.PipeOD == 0)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidPipeOD, "PipeOD value should not be zero");
                }
                rpad.Thickness = GetDoubleInputValue(++startIndex);
                rpad.Length = GetDoubleInputValue(++startIndex);
                rpad.Width = GetDoubleInputValue(++startIndex);
            }
            catch (SmartPartSymbolException hgrEx)
            {
                throw hgrEx;
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadPipeRPadData, "Error in LoadPipeRPadData");
                }
            }
            return rpad;
        }

        /// <summary>
        /// Create the graphical representation of a pipe r-pad.
        /// </summary>
        /// <param name="RPad">Structure for specifying the inputs for the Pipe R-Pad.</param>
        /// <param name="strMatrix">Matrix to specify the position and oreintation the graphics - Matrix4X4.</param>
        /// <param name="Outputcoll">Collection of declared outputs, which is indexed by the name of the outputs declared as defining SymbolOutputs on the AspectDefinition field- OutputDictionary.</param>
        /// <param name="output">OutputName that this graphic is being placed on-String.</param>
        ///<code>
        /// Matrix4X4 matrix = new Matrix4X4();
        /// matrix.SetIdentity();
        /// AddPipeRPad(RPad, matrix, m_oSymbolic.Outputs, "RPad");
        ///</code>
        public void AddPipeRPad(PipeRPadInputs RPad, Matrix4X4 matrix, OutputDictionary outputs, String output)
        {
            try
            {

                if (RPad.Thickness > 0 && RPad.Length > 0 && RPad.Width > 0)
                {
                    SP3DConnection connection = MiddleServiceProvider.SiteMgr.ActiveSite.ActivePlant.PlantModel;

                    // Set the Angle to step, in radians, around the perimeter of the pad
                    // Must be a factor of 180 degrees (PI)
                    // Decrese the Step Angle Size to Increase Accuracy of the Surface
                    Double stepAngle = Math.PI / 12;

                    // Create the Points on the Inside Curve
                    Collection<Position> insideBoundaryCurvePoints;
                    insideBoundaryCurvePoints = CreatePointsOnPipeCurve(stepAngle, RPad.Width, RPad.Length, RPad.Thickness, RPad.PipeOD / 2, true);

                    // Create the Points on the Outside Curve
                    Collection<Position> outsideBoundaryCurvePoints;
                    outsideBoundaryCurvePoints = CreatePointsOnPipeCurve(stepAngle, RPad.Width, RPad.Length, RPad.Thickness, RPad.PipeOD / 2, false);

                    // Create the inside surface boundary curve from the inside curve points
                    BSplineCurve3d insideBoundaryCurve = new BSplineCurve3d(4, insideBoundaryCurvePoints, new Vector(0, 0, 0), new Vector(0, 0, 0), false, false);

                    // Create the outside surface boundary curve from the outside curve points
                    BSplineCurve3d outsideBoundaryCurve = new BSplineCurve3d(4, outsideBoundaryCurvePoints, new Vector(0, 0, 0), new Vector(0, 0, 0), false, false);

                    // Create the Inside Surface
                    double arcAngle = (RPad.Width / 2) / (RPad.PipeOD / 2 + RPad.Thickness);
                    double startZ = (RPad.PipeOD / 2) * Math.Cos(arcAngle);
                    double endZ = startZ;
                    double startY = (RPad.PipeOD / 2) * Math.Sin(arcAngle);
                    double endY = -startY;

                    Arc3d insideArc = new Arc3d(new Position(-RPad.Length, 0, 0), new Vector(1, 0, 0), new Position(-RPad.Length, startY, startZ), new Position(-RPad.Length, endY, endZ));
                    Projection3d insideProjection = new Projection3d(insideArc, new Vector(1, 0, 0), RPad.Length * 2, false);
                    BSplineSurface3d insideSurface = new BSplineSurface3d(connection, insideProjection);
                    ComplexString3d insideBoundary = new ComplexString3d(insideBoundaryCurve, 0.0000001);
                    insideSurface.AddBoundary(insideBoundary);

                    // Create the Outside Surface
                    startZ = (RPad.PipeOD / 2 + RPad.Thickness) * Math.Cos(arcAngle);
                    endZ = startZ;

                    startY = (RPad.PipeOD / 2 + RPad.Thickness) * Math.Sin(arcAngle);
                    endY = -startY;

                    Arc3d outsideArc = new Arc3d(new Position(-RPad.Length, 0, 0), new Vector(1, 0, 0), new Position(-RPad.Length, startY, startZ), new Position(-RPad.Length, endY, endZ));
                    Projection3d outsideProjection = new Projection3d(outsideArc, new Vector(1, 0, 0), RPad.Length * 2, false);
                    BSplineSurface3d outsideSurface = new BSplineSurface3d(connection, outsideProjection);
                    ComplexString3d outsideBoundary = new ComplexString3d(outsideBoundaryCurve, 0.0000001);
                    outsideSurface.AddBoundary(outsideBoundary);

                    // Create the Edge
                    Ruled3d edgeSurface = new Ruled3d(connection, insideBoundaryCurve, outsideBoundaryCurve, false);

                    // Transform the surfaces by the specified Matrix
                    insideSurface.Transform(matrix);
                    outsideSurface.Transform(matrix);
                    edgeSurface.Transform(matrix);

                    // Add the top and bottom surfaces as outputs
                    outputs.Add(output + "Outside", outsideSurface);
                    outputs.Add(output + "Inside", insideSurface);
                    outputs.Add(output + "Edge", edgeSurface);
                }
                else
                {
                    //If both the Round End and the Side Blocks have not been drawn, warn the user.
                    ToDoListMessage = new ToDoListMessage(ToDoMessageTypes.ToDoMessageWarning, SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidRPadDimension, "Invalid R-Pad Dimensions"));
                }
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddPipeRPad, "Error in AddPipeRPad");
                }
            }
        }

        private Collection<Position> CreatePointsOnPipeCurve(double stepAngle, double width, double length, double thickness, double pipeRadius, bool isInnerCurve)
        {
            // Calculate the number of segments
            int segmentCount = (int)((2 * Math.PI) / stepAngle);

            // Calculate the number of points on the curve
            int curvePointCount = segmentCount + 1;

            // Curve Radius
            double curveRadius;
            if (isInnerCurve)
                curveRadius = pipeRadius;
            else
                curveRadius = pipeRadius + thickness;

            SP3DConnection connection = MiddleServiceProvider.SiteMgr.ActiveSite.ActivePlant.PlantModel;

            // Create Points on Curve
            Collection<Position> CurvePoints = new Collection<Position>();

            for (int i = 0; i < curvePointCount; i++)
            {
                double padAlpha = i * stepAngle;
                double padW = (width / 2) * Math.Cos(padAlpha);
                double padL = (length / 2) * Math.Sin(padAlpha);
                double pipeAngle = padW / (pipeRadius + thickness);

                double padX = padL;
                double padZ = curveRadius * Math.Cos(pipeAngle);
                double padY = curveRadius * Math.Sin(pipeAngle);

                CurvePoints.Add(new Position(padX, padY, padZ));
            }

            return CurvePoints;
        }
        /// <summary>
        /// Defines the Elbow R-Pad input parameter type.
        /// </summary>
        public struct ElbowRPadInputs
        {
            /// <summary>
            /// Outside diameter of the elbow the r-pad is welded to.
            /// </summary>
            public double PipeOD;
            /// <summary>
            /// Bend radius of the elbow the r-pad is welded to.
            /// </summary>
            public double ElbowRadius;
            /// <summary>
            /// Face to center of the elbow the r-pad is welded to.
            /// </summary>
            public double FaceToCenter;
            /// <summary>
            /// Bend angle of the elbow the r-pad is welded to.
            /// </summary>
            public double BendAngle;
            /// <summary>
            /// The width of the r-pad plate
            /// </summary>
            public double Width;
            /// <summary>
            /// The length of the r-pad plate  
            /// </summary>
            public double Length;
            /// <summary>
            /// The thickness of the r-pad plate
            /// </summary>
            public double Thickness;
        }

        /// <summary>
        /// Adds the ElbowRPad inputs.
        /// </summary>        
        /// <param name="startIndex">The start index.</param>
        /// <param name="endIndex">The end index.</param>
        /// <param name="additionalInputs">The additional inputs.</param>
        /// <code>
        /// int endIndex;
        /// List<Input> additionalInputs = new List<Input>();
        /// AddElbowRPadInputs(2, out endIndex, additionalInputs);
        /// </code>
        public void AddElbowRPadInputs(int startIndex, out int endIndex, List<Input> additionalInputs)
        {
            try
            {
                additionalInputs.Add(new InputDouble(startIndex, "PipeOD", "PipeOD", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "ElbowRadius", "ElbowRadius", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "FaceToCenter", "FaceToCenter", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "BendAngle", "BendAngle", 90, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Thickness1", "Thickness1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Length1", "Length1", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Width1", "Width1", 0, false));
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddElbowRPadInputs, "Error in adding Elbow R-Pad inputs");
                }
            }
            endIndex = ++startIndex;
        }
        /// <summary>
        /// Adds the ElbowRPad outputs.User symbol calls this method during AdditionalOutputs
        /// to define additional outputs for an aspect. The list of outputs returned by this method will be the outputs for the aspect
        /// in addition to the outputs that are already defined as attributes on the aspect.
        /// </summary>
        /// <param name="outputName">Output Name.</param>
        /// <param name="additionalOutputs">The additional outputs.</param>
        ///<code>
        ///public override IEnumerable<OutputDefinition> AdditionalOutputs(string aspectName)
        ///{
        ///    List<OutputDefinition> additionalOutputs = new List<OutputDefinition>();
        ///    if (aspectName == "Symbolic")
        ///    {
        ///       AddElbowRPadOutputs("RPad",additionalOutputs);
        ///    }
        ///    return additionalOutputs;
        ///}
        ///</code> 
        ///
        public void AddElbowRPadOutputs(string outputName, List<OutputDefinition> additionalOutputs)
        {
            try
            {
                additionalOutputs.Add(new OutputDefinition(outputName + "Outside", outputName + "Outside"));
                additionalOutputs.Add(new OutputDefinition(outputName + "Inside", outputName + "Inside"));
                additionalOutputs.Add(new OutputDefinition(outputName + "Edge", outputName + "Edge"));
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddElbowRPadOutputs, "Error in AddElbowRPadOutputs.");
                }
            }
        }

        /// <summary>
        /// Loads the ElbowRPad data.
        /// </summary>        
        /// <param name="startIndex">The start index.</param>
        ///  <code>
        ///  ElbowRPadInputs elbowRPad = LoadElbowRPadData(2);
        /// </code>
        /// <returns>PipeRPadInputs</returns>
        public ElbowRPadInputs LoadElbowRPadData(int startIndex)
        {
            ElbowRPadInputs rpad = new ElbowRPadInputs();
            try
            {
                rpad.PipeOD = GetDoubleInputValue(startIndex);
                if (rpad.PipeOD == 0)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidPipeOD, "PipeOD value should not be zero");
                }
                rpad.ElbowRadius = GetDoubleInputValue(++startIndex);
                rpad.FaceToCenter = GetDoubleInputValue(++startIndex);
                rpad.BendAngle = GetDoubleInputValue(++startIndex);
                rpad.Thickness = GetDoubleInputValue(++startIndex);
                rpad.Length = GetDoubleInputValue(++startIndex);
                rpad.Width = GetDoubleInputValue(++startIndex);
            }
            catch (SmartPartSymbolException hgrEx)
            {
                throw hgrEx;
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadElbowRPadData, "Error in LoadElbowRPadData");
                }
            }
            return rpad;
        }

        /// <summary>
        /// Create the graphical representation of a elbow r-pad.
        /// </summary>
        /// <param name="RPad">Structure for specifying the inputs for the Elbow R-Pad.</param>
        /// <param name="strMatrix">Matrix to specify the position and oreintation the graphics - Matrix4X4.</param>
        /// <param name="Outputcoll">Collection of declared outputs, which is indexed by the name of the outputs declared as defining SymbolOutputs on the AspectDefinition field- OutputDictionary.</param>
        /// <param name="output">OutputName that this graphic is being placed on-String.</param>
        ///<code>
        /// Matrix4X4 matrix = new Matrix4X4();
        /// matrix.SetIdentity();
        /// AddElbowRPad(RPad, matrix, m_oSymbolic.Outputs, "RPad");
        ///</code>
        public void AddElbowRPad(ElbowRPadInputs RPad, Matrix4X4 matrix, OutputDictionary outputs, String output)
        {
            try
            {

                if (RPad.Thickness > 0 && RPad.Length > 0 && RPad.Width > 0)
                {
                    SP3DConnection connection = MiddleServiceProvider.SiteMgr.ActiveSite.ActivePlant.PlantModel;

                    // Set the Angle to step, in radians, around the perimeter of the pad
                    // Must be a factor of 180 degrees (PI)
                    // Decrese the Step Angle Size to Increase Accuracy of the Surface
                    Double stepAngle = Math.PI / 12;

                    // Create the Points on the Inside Curve
                    Collection<Position> insideBoundaryCurvePoints;
                    insideBoundaryCurvePoints = CreatePointsOnElbowCurve(stepAngle, RPad.Width, RPad.Length, RPad.Thickness, RPad.PipeOD / 2, RPad.ElbowRadius, RPad.BendAngle, true);

                    // Create the Points on the Outside Curve
                    Collection<Position> outsideBoundaryCurvePoints;
                    outsideBoundaryCurvePoints = CreatePointsOnElbowCurve(stepAngle, RPad.Width, RPad.Length, RPad.Thickness, RPad.PipeOD / 2, RPad.ElbowRadius, RPad.BendAngle, false);

                    // Create the inside surface boundary curve from the inside curve points
                    BSplineCurve3d insideBoundaryCurve = new BSplineCurve3d(4, insideBoundaryCurvePoints, new Vector(0, 0, 0), new Vector(0, 0, 0), false, false);

                    // Create the outside surface boundary curve from the outside curve points
                    BSplineCurve3d outsideBoundaryCurve = new BSplineCurve3d(4, outsideBoundaryCurvePoints, new Vector(0, 0, 0), new Vector(0, 0, 0), false, false);

                    // Create the Inside Surface
                    double arcAngle = (RPad.Width / 2) / (RPad.PipeOD / 2 + RPad.Thickness);
                    double startX = (RPad.PipeOD / 2) * Math.Cos(arcAngle);
                    double endX = startX;
                    double startY = -(RPad.PipeOD / 2) * Math.Sin(arcAngle);
                    double endY = -startY;

                    Arc3d insideArc = new Arc3d(new Position(RPad.ElbowRadius, 0, 0), new Vector(0, 0, 1), new Position(RPad.ElbowRadius + startX, startY, 0), new Position(RPad.ElbowRadius + endX, endY, 0));
                    Revolution3d insideRevolution = new Revolution3d(insideArc, new Vector(0, -1, 0), new Position(0, 0, 0), Math.PI / 2, false);
                    BSplineSurface3d insideSurface = new BSplineSurface3d(connection, insideRevolution);
                    ComplexString3d insideBoundary = new ComplexString3d(insideBoundaryCurve, 0.0000001);
                    insideSurface.AddBoundary(insideBoundary);

                    // Create the Outside Surface
                    startX = (RPad.PipeOD / 2 + RPad.Thickness) * Math.Cos(arcAngle);
                    endX = startX;

                    startY = -(RPad.PipeOD / 2 + RPad.Thickness) * Math.Sin(arcAngle);
                    endY = -startY;

                    Arc3d outsideArc = new Arc3d(new Position(RPad.ElbowRadius, 0, 0), new Vector(0, 0, 1), new Position(RPad.ElbowRadius + startX, startY, 0), new Position(RPad.ElbowRadius + endX, endY, 0));
                    Revolution3d outsideRevolution = new Revolution3d(outsideArc, new Vector(0, -1, 0), new Position(0, 0, 0), Math.PI / 2, false);
                    BSplineSurface3d outsideSurface = new BSplineSurface3d(connection, outsideRevolution);
                    ComplexString3d outsideBoundary = new ComplexString3d(outsideBoundaryCurve, 0.0000001);
                    outsideSurface.AddBoundary(outsideBoundary);

                    // Create the Edge
                    Ruled3d edgeSurface = new Ruled3d(connection, insideBoundaryCurve, outsideBoundaryCurve, false);

                    // Transform the Surfaces to the Symbol Origin
                    Matrix4X4 originMatrix = new Matrix4X4();
                    originMatrix.SetIdentity();
                    originMatrix.Translate(new Vector(-RPad.ElbowRadius, 0, -RPad.ElbowRadius * Math.Tan(RPad.BendAngle / 2)));

                    insideSurface.Transform(originMatrix);
                    outsideSurface.Transform(originMatrix);
                    edgeSurface.Transform(originMatrix);

                    // Transform the surfaces by the specified Matrix
                    insideSurface.Transform(matrix);
                    outsideSurface.Transform(matrix);
                    edgeSurface.Transform(matrix);

                    // Add the top and bottom surfaces as outputs
                    outputs.Add(output + "Outside", outsideSurface);
                    outputs.Add(output + "Inside", insideSurface);
                    outputs.Add(output + "Edge", edgeSurface);
                }
                else
                {
                    //If both the Round End and the Side Blocks have not been drawn, warn the user.
                    ToDoListMessage = new ToDoListMessage(ToDoMessageTypes.ToDoMessageWarning, SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidRPadDimension, "Invalid R-Pad Dimensions"));
                }
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddElbowRPad, "Error in AddElbowRPad");
                }
            }
        }

        private Collection<Position> CreatePointsOnElbowCurve(double stepAngle, double width, double length, double thickness, double pipeRadius, double bendRadius, double bendAngle, bool isInnerCurve)
        {
            // Calculate the number of segments
            int segmentCount = (int)((2 * Math.PI) / stepAngle);

            // Calculate the number of points on the curve
            int curvePointCount = segmentCount + 1;

            // Calculate the mid Angle
            double midAngle = bendAngle / 2;

            // Rotation and Translation Vectors in Pipe Cross Section
            Vector pipeRotate = new Vector(0, 0, 1);
            Vector pipeTranslate;
            if (isInnerCurve)
                pipeTranslate = new Vector(pipeRadius, 0, 0);
            else
                pipeTranslate = new Vector(pipeRadius + thickness, 0, 0);

            // Rotation and Translation Vectors for Elbow
            Vector elbowRotate = new Vector(0, -1, 0);
            Vector elbowTranslate = new Vector(bendRadius, 0, 0);

            SP3DConnection connection = MiddleServiceProvider.SiteMgr.ActiveSite.ActivePlant.PlantModel;

            // Create Points on Curve
            Collection<Position> CurvePoints = new Collection<Position>();

            for (int i = 0; i < curvePointCount; i++)
            {
                double padAlpha = i * stepAngle;
                double padW = (width / 2) * Math.Cos(padAlpha);
                double padL = (length / 2) * Math.Sin(padAlpha);

                double elbowAngle = padL / (bendRadius + pipeRadius + thickness);
                double pipeAngle = padW / (pipeRadius + thickness);

                Matrix4X4 elbowMatrix = new Matrix4X4();
                elbowMatrix.SetIdentity();
                elbowMatrix.Translate(elbowTranslate);
                elbowMatrix.Rotate(midAngle + elbowAngle, elbowRotate, new Position(0, 0, 0));

                Matrix4X4 pipeMatrix = new Matrix4X4();
                pipeMatrix.SetIdentity();
                pipeMatrix.Translate(pipeTranslate);
                pipeMatrix.Rotate(pipeAngle, pipeRotate, new Position(0, 0, 0));

                Matrix4X4 curveTransform = new Matrix4X4();
                curveTransform.SetIdentity();

                Point3d curvePoint = new Point3d(0, 0, 0);
                curvePoint.Transform(pipeMatrix);
                curvePoint.Transform(elbowMatrix);

                CurvePoints.Add(new Position(curvePoint.X, curvePoint.Y, curvePoint.Z));
            }

            return CurvePoints;
        }
        /// <summary>
        /// Create the graphical representation of a EyeNut
        /// </summary>        
        /// <param name="eyeNut">Structure for specifying the inputs for the EyeNut -EyeNutInputs.</param>
        /// <param name="outputs">Collection of declared outputs, which is indexed by the name of the outputs declared as defining SymbolOutputs on the AspectDefinition field- OutputDictionary.</param>
        /// <param name="outputName">OutputName that this graphic is being placed on-String.</param>
        /// <param name="objectColl">ArrayList that Gives ObjectCollection out</param>
        /// <param name="strMatrix">Matrix to specify the position and orientation the graphics - Matrix4X4.</param>
        ///<code>
        ///        ArrayList objColl;
        ///            AddEyeNutwithLocation(eyeNut, outputs, outputName + "EyeNut",out objColl,matrix);
        ///            foreach (string item in objColl)
        ///            {
        ///                geometry3d = (Geometry3d)outputs[item];
        ///                geometry3d.Transform(matrix);
        ///            }
        ///</code>
        public void AddEyeNutwithLocation(EyeNutInputs eyeNut, OutputDictionary outputs, String outputName, out ArrayList objectColl, Matrix4X4 matrix)
        {
            objectColl = new ArrayList();
            try
            {
                int objectCount = 0;
                Matrix4X4 nutMatrix = new Matrix4X4();
                nutMatrix.Origin = new Position(0, 0, eyeNut.OverLength1);
                AddNut(eyeNut.Nut, nutMatrix, outputs, outputName + "Nut1");
                ++objectCount;
                objectColl.Add(outputName + "Nut1");
                Collection<ICurve> curveCollection = new Collection<ICurve>();

                Circle3d circle = new Circle3d(new Position(-(eyeNut.InnerWidth1 / 2 + eyeNut.Thickness1 / 2), 0, eyeNut.OverLength1), new Vector(0, 0, 1), eyeNut.Thickness1 / 2);
                ++objectCount;
                outputs.Add(outputName + "TOP_CYL_1", circle);
                objectColl.Add(outputName + "TOP_CYL_1");


                Line3d line1 = new Line3d(new Position(-(eyeNut.InnerWidth1 / 2 + eyeNut.Thickness1 / 2), 0, eyeNut.OverLength1), new Position(-(eyeNut.InnerWidth2 / 2 + eyeNut.Thickness1 / 2), 0, eyeNut.OverLength1 - eyeNut.InnerLength1));
                curveCollection.Add(line1);
                ++objectCount;
                outputs.Add(outputName + "TOP_CYL_2", line1);
                objectColl.Add(outputName + "TOP_CYL_2");

                EllipticalArc3d ellipticalArc = new EllipticalArc3d(new Position(0, 0, -(eyeNut.InnerLength1 - eyeNut.OverLength1)), new Vector(0, -1, 0), new Vector(-(eyeNut.InnerWidth2 / 2 + eyeNut.Thickness1 / 2), 0, 0), ((eyeNut.InnerLength2 - eyeNut.InnerLength1 + eyeNut.Thickness1 / 2) / (eyeNut.InnerWidth2 / 2 + eyeNut.Thickness1 / 2)), 0, -Math.PI);
                curveCollection.Add(ellipticalArc);
                ++objectCount;
                outputs.Add(outputName + "BOT_CYL_1", ellipticalArc);
                objectColl.Add(outputName + "BOT_CYL_1");

                Line3d line2 = new Line3d(new Position((eyeNut.InnerWidth1 / 2 + eyeNut.Thickness1 / 2), 0, eyeNut.OverLength1), new Position((eyeNut.InnerWidth2 / 2 + eyeNut.Thickness1 / 2), 0, eyeNut.OverLength1 - eyeNut.InnerLength1));
                curveCollection.Add(line2);
                ++objectCount;
                outputs.Add(outputName + "BOT_CYL_2", line2);
                objectColl.Add(outputName + "BOT_CYL_2");

                ComplexString3d lineString = new ComplexString3d(curveCollection);

                Position stNorm = null;
                Position enNorm = new Position(eyeNut.InnerWidth1 / 2 + eyeNut.Thickness1 / 2, 0, eyeNut.OverLength1);
                Vector stNormVector = null;
                Vector enNormVector = new Vector(0, 0, 1);
                Collection<Surface3d> eyeNutSurfaces = new Collection<Surface3d>();

                eyeNutSurfaces = Surface3d.GetSweepSurfacesFromCurve(OccurrenceConnection, lineString, circle, (SurfaceSweepOptions)2, stNorm, stNormVector, enNorm, enNormVector);
                foreach (Surface3d item in eyeNutSurfaces)
                {
                    ++objectCount;
                    outputs.Add(outputName + "EyeNut" + objectCount, item);
                    objectColl.Add(outputName + "EyeNut" + objectCount);
                }

                Geometry3d geometry3d;
                foreach (string item in objectColl)
                {
                    geometry3d = (Geometry3d)outputs[item];
                    geometry3d.Transform(matrix);
                }
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddEyeNutMethod, "Error in AddEyeNut");
                }
            }
        }
        /// <summary>
        /// Loads the values associated to the given shape into the WBAHole UDT. This is done by querying the database for the given name.
        /// </summary>
        /// <param name=refShapeName>Name of the UBolt-String.</param>
        /// <returns></returns>
        ///<code>
        ///WBAHoleInputs WBAHoleInputs  = LoadWBAHoleDataByQuery();
        ///</code>
        public WBAHoleInputs LoadWBAHoleDataByQuery(string refShapeName)
        {
            WBAHoleInputs WBAHoleInputs = new WBAHoleInputs();
            try
            {

                if (!(refShapeName == "" || refShapeName == "No Value"))
                {
                    Catalog m_oPlantCatalog = MiddleServiceProvider.SiteMgr.ActiveSite.ActivePlant.PlantCatalog;
                    BusinessObject WBAHoleAuxTable = m_oPlantCatalog.GetNamedObject(refShapeName);
                    WBAHoleInputs.WBAHoleConfig = (int)((PropertyValueCodelist)WBAHoleAuxTable.GetPropertyValue("IJUAhsWBAHoleConfig", "WBAHoleConfig")).PropValue;
                    try
                    {
                        WBAHoleInputs.Height1 = (double)((PropertyValueDouble)WBAHoleAuxTable.GetPropertyValue("IJUAhsHeight1", "Height1")).PropValue;
                    }
                    catch { WBAHoleInputs.Height1 = 0; }
                    try
                    {
                        WBAHoleInputs.Thickness1 = (double)((PropertyValueDouble)WBAHoleAuxTable.GetPropertyValue("IJUAhsThickness1", "Thickness1")).PropValue;
                    }
                    catch { WBAHoleInputs.Thickness1 = 0; }
                    try
                    {
                        WBAHoleInputs.Width1 = (double)((PropertyValueDouble)WBAHoleAuxTable.GetPropertyValue("IJUAhsWidth1", "Width1")).PropValue;
                    }
                    catch { WBAHoleInputs.Width1 = 0; }
                    try
                    {
                        WBAHoleInputs.Gap1 = (double)((PropertyValueDouble)WBAHoleAuxTable.GetPropertyValue("IJUAhsGap1", "Gap1")).PropValue;
                    }
                    catch { WBAHoleInputs.Gap1 = 0; }
                    try
                    {
                        WBAHoleInputs.Offset1 = (double)((PropertyValueDouble)WBAHoleAuxTable.GetPropertyValue("IJUAhsOffset1", "Offset1")).PropValue;
                    }
                    catch { WBAHoleInputs.Offset1 = 0; }
                    try
                    {
                        WBAHoleInputs.Offset2 = (double)((PropertyValueDouble)WBAHoleAuxTable.GetPropertyValue("IJUAhsOffset2", "Offset2")).PropValue;
                    }
                    catch { WBAHoleInputs.Offset2 = 0; }
                    try
                    {
                        WBAHoleInputs.Width2 = (double)((PropertyValueDouble)WBAHoleAuxTable.GetPropertyValue("IJUAhsWidth2", "Width2")).PropValue;
                    }
                    catch { WBAHoleInputs.Width2 = 0; }
                    try
                    {
                        WBAHoleInputs.Length1 = (double)((PropertyValueDouble)WBAHoleAuxTable.GetPropertyValue("IJUAhsLength1", "Length1")).PropValue;
                    }
                    catch { WBAHoleInputs.Length1 = 0; }
                    try
                    {
                        WBAHoleInputs.Thickness2 = (double)((PropertyValueDouble)WBAHoleAuxTable.GetPropertyValue("IJUAhsThickness2", "Thickness2")).PropValue;
                    }
                    catch { WBAHoleInputs.Thickness2 = 0; }
                    try
                    {
                        WBAHoleInputs.Width3 = (double)((PropertyValueDouble)WBAHoleAuxTable.GetPropertyValue("IJUAhsWidth3", "Width3")).PropValue;
                    }
                    catch { WBAHoleInputs.Width3 = 0; }
                    try
                    {
                        WBAHoleInputs.Length2 = (double)((PropertyValueDouble)WBAHoleAuxTable.GetPropertyValue("IJUAhsLength2", "Length2")).PropValue;
                    }
                    catch { WBAHoleInputs.Length2 = 0; }
                    try
                    {
                        WBAHoleInputs.Thickness3 = (double)((PropertyValueDouble)WBAHoleAuxTable.GetPropertyValue("IJUAhsThickness3", "Thickness3")).PropValue;
                    }
                    catch { WBAHoleInputs.Thickness3 = 0; }
                    try
                    {
                        WBAHoleInputs.Width4 = (double)((PropertyValueDouble)WBAHoleAuxTable.GetPropertyValue("IJUAhsWidth4", "Width4")).PropValue;
                    }
                    catch { WBAHoleInputs.Width4 = 0; }
                    try
                    {
                        WBAHoleInputs.Length3 = (double)((PropertyValueDouble)WBAHoleAuxTable.GetPropertyValue("IJUAhsLength3", "Length3")).PropValue;
                    }
                    catch { WBAHoleInputs.Length3 = 0; }
                    try
                    {
                        WBAHoleInputs.Thickness4 = (double)((PropertyValueDouble)WBAHoleAuxTable.GetPropertyValue("IJUAhsThickness4", "Thickness4")).PropValue;
                    }
                    catch { WBAHoleInputs.Thickness4 = 0; }
                    try
                    {
                        WBAHoleInputs.Offset3 = (double)((PropertyValueDouble)WBAHoleAuxTable.GetPropertyValue("IJUAhsOffset3", "Offset3")).PropValue;
                    }
                    catch { WBAHoleInputs.Offset3 = 0; }
                    try
                    {
                        WBAHoleInputs.SimpShapeType = (int)((PropertyValueCodelist)WBAHoleAuxTable.GetPropertyValue("IJUAhsSimpShapeType", "SimpShapeType")).PropValue;
                    }
                    catch { WBAHoleInputs.SimpShapeType = 0; }
                    try
                    {
                        WBAHoleInputs.Width5 = (double)((PropertyValueDouble)WBAHoleAuxTable.GetPropertyValue("IJUAhsWidth5", "Width5")).PropValue;
                    }
                    catch { WBAHoleInputs.Width5 = 0; }
                    try
                    {
                        WBAHoleInputs.Thickness5 = (double)((PropertyValueDouble)WBAHoleAuxTable.GetPropertyValue("IJUAhsThickness5", "Thickness5")).PropValue;
                    }
                    catch { WBAHoleInputs.Thickness5 = 0; }
                    try
                    {
                        WBAHoleInputs.ShapeType = (int)((PropertyValueCodelist)WBAHoleAuxTable.GetPropertyValue("IJUAhsShapeType", "SimpShapeType")).PropValue;
                    }
                    catch { WBAHoleInputs.ShapeType = 0; }

                }
                return WBAHoleInputs;
            }
            catch
            {

                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadWBAHoleDataByQuery, "Error in LoadWBAHoleDataByQuery");
                }
                return WBAHoleInputs;
            }
        }
        /// <summary>
        /// Loads the values associated to the given shape into the Swivel UDT. This is done by querying the database for the given name.
        /// </summary>
        /// <param name=SwivelName>Name of the UBolt-String.</param>
        /// <returns></returns>
        ///<code>
        ///SwivelInputs SwivelInputs  = LoadSwivelDataByQuery();
        ///</code>
        public SwivelInputs LoadSwivelDataByQuery(string refShapeName)
        {
            SwivelInputs SwivelInputs = new SwivelInputs();
            try
            {

                if (!(refShapeName == "" || refShapeName == "No Value"))
                {
                    Catalog m_oPlantCatalog = MiddleServiceProvider.SiteMgr.ActiveSite.ActivePlant.PlantCatalog;
                    BusinessObject SwivelAuxTable = m_oPlantCatalog.GetNamedObject(refShapeName);
                    try
                    {
                        SwivelInputs.RodDiameter = (double)((PropertyValueDouble)SwivelAuxTable.GetPropertyValue("IJUAhsRodDiameter", "RodDiameter")).PropValue;
                    }
                    catch { SwivelInputs.RodDiameter = 0; }
                    try
                    {
                        SwivelInputs.RodTakeOut = (double)((PropertyValueDouble)SwivelAuxTable.GetPropertyValue("IJUAhsRodTakeOut", "RodTakeOut")).PropValue;
                    }
                    catch { SwivelInputs.RodTakeOut = 0; }
                    try
                    {
                        SwivelInputs.PipeOD = (double)((PropertyValueDouble)SwivelAuxTable.GetPropertyValue("IJOAhsPipeOD", "PipeOD")).PropValue;
                    }
                    catch { SwivelInputs.PipeOD = 0; }
                    try
                    {
                        SwivelInputs.Width1 = (double)((PropertyValueDouble)SwivelAuxTable.GetPropertyValue("IJUAhsWidth1", "Width1")).PropValue;
                    }
                    catch { SwivelInputs.Width1 = 0; }
                    try
                    {
                        SwivelInputs.Width2 = (double)((PropertyValueDouble)SwivelAuxTable.GetPropertyValue("IJUAhsWidth2", "Width2")).PropValue;
                    }
                    catch { SwivelInputs.Width2 = 0; }
                    try
                    {
                        SwivelInputs.Width3 = (double)((PropertyValueDouble)SwivelAuxTable.GetPropertyValue("IJUAhsWidth3", "Width3")).PropValue;
                    }
                    catch { SwivelInputs.Width3 = 0; }
                    try
                    {
                        SwivelInputs.Thickness1 = (double)((PropertyValueDouble)SwivelAuxTable.GetPropertyValue("IJUAhsThickness1", "Thickness1")).PropValue;
                    }
                    catch { SwivelInputs.Thickness1 = 0; }
                    try
                    {
                        SwivelInputs.Height1 = (double)((PropertyValueDouble)SwivelAuxTable.GetPropertyValue("IJUAhsHeight1", "Height1")).PropValue;
                    }
                    catch { SwivelInputs.Height1 = 0; }
                    try
                    {
                        SwivelInputs.Diameter1 = (double)((PropertyValueDouble)SwivelAuxTable.GetPropertyValue("IJUAhsDiameter1", "Diameter1")).PropValue;
                    }
                    catch { SwivelInputs.Diameter1 = 0; }
                    try
                    {
                        SwivelInputs.Gap1 = (double)((PropertyValueDouble)SwivelAuxTable.GetPropertyValue("IJUAhsGap1", "Gap1")).PropValue;
                    }
                    catch { SwivelInputs.Gap1 = 0; }
                    try
                    {
                        SwivelInputs.Width4 = (double)((PropertyValueDouble)SwivelAuxTable.GetPropertyValue("IJUAhsWidth4", "Width4")).PropValue;
                    }
                    catch { SwivelInputs.Width4 = 0; }
                    try
                    {
                        SwivelInputs.Thickness2 = (double)((PropertyValueDouble)SwivelAuxTable.GetPropertyValue("IJUAhsThickness2", "Thickness2")).PropValue;
                    }
                    catch { SwivelInputs.Thickness2 = 0; }
                    try
                    {
                        SwivelInputs.Height2 = (double)((PropertyValueDouble)SwivelAuxTable.GetPropertyValue("IJUAhsHeight2", "Height2")).PropValue;
                    }
                    catch { SwivelInputs.Height2 = 0; }
                    try
                    {
                        SwivelInputs.Diameter2 = (double)((PropertyValueDouble)SwivelAuxTable.GetPropertyValue("IJUAhsDiameter2", "Diameter2")).PropValue;
                    }
                    catch { SwivelInputs.Diameter2 = 0; }
                    try
                    {
                        SwivelInputs.Pin1Diameter = (double)((PropertyValueDouble)SwivelAuxTable.GetPropertyValue("IJUAhsPin1", "Pin1Diameter")).PropValue;
                    }
                    catch { SwivelInputs.Pin1Diameter = 0; }
                    try
                    {
                        SwivelInputs.Pin1Length = (double)((PropertyValueDouble)SwivelAuxTable.GetPropertyValue("IJUAhsPin1", "Pin1Length")).PropValue;
                    }
                    catch { SwivelInputs.Pin1Length = 0; }
                    try
                    {
                        SwivelInputs.Height3 = (double)((PropertyValueDouble)SwivelAuxTable.GetPropertyValue("IJUAhsHeight3", "Height3")).PropValue;
                    }
                    catch { SwivelInputs.Height3 = 0; }

                }
                return SwivelInputs;
            }
            catch
            {

                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadSwivelDataByQuery, "Error in LoadSwivelDataByQuery");
                }
                return SwivelInputs;
            }
        }
        /// <summary>
        /// Loads the values associated to the given shape into the ClevisHanger UDT. This is done by querying the database for the given name.
        /// </summary>        
        /// <param name="refShapeName">The name of Sheet in excel workbook</param>
        /// /// <code>
        ///  ClevisHangerInputs ClevisHanger = LoadClevisHangerDataByQuery(refShapeName);
        /// </code>
        public ClevisHangerInputs LoadClevisHangerDataByQuery(string refShapeName)
        {
            ClevisHangerInputs ClevisHanger = new ClevisHangerInputs();
            try
            {
                if (!(refShapeName == "" || refShapeName == "No Value" || refShapeName == null))
                {
                    Catalog m_oPlantCatalog = MiddleServiceProvider.SiteMgr.ActiveSite.ActivePlant.PlantCatalog;
                    BusinessObject ClevisHangerAuxTable = m_oPlantCatalog.GetNamedObject(refShapeName);

                    try
                    {
                        ClevisHanger.Angle1 = (double)((PropertyValueDouble)ClevisHangerAuxTable.GetPropertyValue("IJOAhsAngle1", "Angle1")).PropValue;
                    }
                    catch
                    {
                        ClevisHanger.Angle1 = 0;
                    }
                    try
                    {
                        ClevisHanger.ClevisTopShp = (int)((PropertyValueCodelist)ClevisHangerAuxTable.GetPropertyValue("IJUAhsClevisTopShp", "ClevisTopShp")).PropValue;
                    }
                    catch
                    {
                        ClevisHanger.ClevisTopShp = 0;
                    }
                    try
                    {
                        ClevisHanger.ClevisBotShp = (int)((PropertyValueCodelist)ClevisHangerAuxTable.GetPropertyValue("IJUAhsClevisBotShp", "ClevisBotShp")).PropValue;
                    }
                    catch
                    {
                        ClevisHanger.ClevisBotShp = 0;
                    }
                    try
                    {
                        ClevisHanger.RodTakeOut = (double)((PropertyValueDouble)ClevisHangerAuxTable.GetPropertyValue("IJUAhsRodTakeOut", "RodTakeOut")).PropValue;
                    }
                    catch
                    {
                        ClevisHanger.RodTakeOut = 0;
                    }
                    try
                    {
                        ClevisHanger.Height1 = (double)((PropertyValueDouble)ClevisHangerAuxTable.GetPropertyValue("IJUAhsHeight1", "Height1")).PropValue;
                    }
                    catch
                    {
                        ClevisHanger.Height1 = 0;
                    }
                    try
                    {
                        ClevisHanger.Diameter1 = (double)((PropertyValueDouble)ClevisHangerAuxTable.GetPropertyValue("IJUAhsDiameter1", "Diameter1")).PropValue;
                    }
                    catch
                    {
                        ClevisHanger.Diameter1 = 0;
                    }
                    try
                    {
                        ClevisHanger.Width1 = (double)((PropertyValueDouble)ClevisHangerAuxTable.GetPropertyValue("IJUAhsWidth1", "Width1")).PropValue;
                    }
                    catch
                    {
                        ClevisHanger.Width1 = 0;
                    }
                    try
                    {
                        ClevisHanger.Thickness1 = (double)((PropertyValueDouble)ClevisHangerAuxTable.GetPropertyValue("IJUAhsThickness1", "Thickness1")).PropValue;
                    }
                    catch
                    {
                        ClevisHanger.Thickness1 = 0;
                    }
                    try
                    {
                        ClevisHanger.Width2 = (double)((PropertyValueDouble)ClevisHangerAuxTable.GetPropertyValue("IJUAhsWidth2", "Width2")).PropValue;
                    }
                    catch
                    {
                        ClevisHanger.Width2 = 0;
                    }
                    try
                    {
                        ClevisHanger.Thickness2 = (double)((PropertyValueDouble)ClevisHangerAuxTable.GetPropertyValue("IJUAhsThickness2", "Thickness2")).PropValue;
                    }
                    catch
                    {
                        ClevisHanger.Thickness2 = 0;
                    }
                    try
                    {
                        ClevisHanger.Pin1Diameter = (double)((PropertyValueDouble)ClevisHangerAuxTable.GetPropertyValue("IJUAhsPin1", "Pin1Diameter")).PropValue;
                    }
                    catch
                    {
                        ClevisHanger.Pin1Diameter = 0;
                    }
                    try
                    {
                        ClevisHanger.Pin1Length = (double)((PropertyValueDouble)ClevisHangerAuxTable.GetPropertyValue("IJUAhsPin1", "Pin1Length")).PropValue;
                    }
                    catch
                    {
                        ClevisHanger.Pin1Length = 0;
                    }
                    try
                    {
                        ClevisHanger.Height2 = (double)((PropertyValueDouble)ClevisHangerAuxTable.GetPropertyValue("IJUAhsHeight2", "Height2")).PropValue;
                    }
                    catch
                    {
                        ClevisHanger.Height2 = 0;
                    }
                    try
                    {
                        ClevisHanger.Height3 = (int)((PropertyValueCodelist)ClevisHangerAuxTable.GetPropertyValue("IJUAhsHeight3", "Height3")).PropValue;
                    }
                    catch
                    {
                        ClevisHanger.Height3 = 0;
                    }

                    try
                    {
                        ClevisHanger.Height4 = (double)((PropertyValueDouble)ClevisHangerAuxTable.GetPropertyValue("IJUAhsHeight4", "Height4")).PropValue;
                    }
                    catch
                    {
                        ClevisHanger.Height4 = 0;
                    }
                    try
                    {
                        ClevisHanger.Length1 = (double)((PropertyValueDouble)ClevisHangerAuxTable.GetPropertyValue("IJUAhsLength1", "Length1")).PropValue;
                    }
                    catch
                    {
                        ClevisHanger.Length1 = 0;
                    }
                    try
                    {
                        ClevisHanger.Length2 = (double)((PropertyValueDouble)ClevisHangerAuxTable.GetPropertyValue("IJUAhsLength2", "Length2")).PropValue;
                    }
                    catch
                    {
                        ClevisHanger.Length2 = 0;
                    }
                    try
                    {
                        ClevisHanger.Length3 = (double)((PropertyValueDouble)ClevisHangerAuxTable.GetPropertyValue("IJUAhsLength3", "Length3")).PropValue;
                    }
                    catch
                    {
                        ClevisHanger.Length3 = 0;
                    }
                    try
                    {
                        ClevisHanger.Height5 = (double)((PropertyValueDouble)ClevisHangerAuxTable.GetPropertyValue("IJUAhsHeight5", "Height5")).PropValue;
                    }
                    catch
                    {
                        ClevisHanger.Height5 = 0;
                    }
                    try
                    {
                        ClevisHanger.Height6 = (double)((PropertyValueDouble)ClevisHangerAuxTable.GetPropertyValue("IJUAhsHeight6", "Height6")).PropValue;
                    }
                    catch
                    {
                        ClevisHanger.Height6 = 0;
                    }
                    try
                    {
                        ClevisHanger.Height7 = (double)((PropertyValueDouble)ClevisHangerAuxTable.GetPropertyValue("IJUAhsHeight7", "Height7")).PropValue;
                    }
                    catch
                    {
                        ClevisHanger.Height7 = 0;
                    }
                    try
                    {
                        ClevisHanger.Thickness3 = (double)((PropertyValueDouble)ClevisHangerAuxTable.GetPropertyValue("IJUAhsThickness3", "Thickness3")).PropValue;
                    }
                    catch
                    {
                        ClevisHanger.Thickness3 = 0;
                    }
                    try
                    {
                        ClevisHanger.Height8 = (double)((PropertyValueDouble)ClevisHangerAuxTable.GetPropertyValue("IJUAhsHeight8", "Height8")).PropValue;
                    }
                    catch
                    {
                        ClevisHanger.Height8 = 0;
                    }
                    try
                    {
                        ClevisHanger.Thickness4 = (double)((PropertyValueDouble)ClevisHangerAuxTable.GetPropertyValue("IJUAhsThickness4", "Thickness4")).PropValue;
                    }
                    catch
                    {
                        ClevisHanger.Thickness4 = 0;
                    }
                    try
                    {
                        ClevisHanger.Pin2Diameter = (double)((PropertyValueDouble)ClevisHangerAuxTable.GetPropertyValue("IJUAhsPin2", "Pin2Diameter")).PropValue;
                    }
                    catch
                    {
                        ClevisHanger.Pin2Diameter = 0;
                    }
                    try
                    {
                        ClevisHanger.Pin2Length = (double)((PropertyValueDouble)ClevisHangerAuxTable.GetPropertyValue("IJUAhsPin2", "Pin2Length")).PropValue;
                    }
                    catch
                    {
                        ClevisHanger.Pin2Length = 0;
                    }
                    try
                    {
                        ClevisHanger.Diameter2 = (double)((PropertyValueDouble)ClevisHangerAuxTable.GetPropertyValue("IJUAhsDiameter2", "Diameter2")).PropValue;
                    }
                    catch
                    {
                        ClevisHanger.Diameter2 = 0;
                    }
                }

            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadClevisHangerDataByQuery, "Error in LoadClevisHangerDataByQuery");
                }
            }
            return ClevisHanger;
        }
        /// <summary>
        /// Adds the SpreaderBeam inputs.
        /// </summary>
        /// <param name="startIndex">The start index.</param>
        /// <param name="endIndex">The end index.</param>
        /// <param name="additionalInputs">The additional inputs.</param>
        /// <code>
        /// int endIndex;
        /// List<Input> additionalInputs = new List<Input>();
        /// AddSpreaderBeamInputs(2, out endIndex, additionalInputs);
        /// </code>

        public void AddSpreaderBeamInputs(int startIndex, out int endIndex, List<Input> additionalInputs)
        {
            try
            {
                additionalInputs.Add((Input)new InputDouble(startIndex, "Diameter1", "Diameter1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "ShoeHeight", "ShoeHeight", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "TopPlacementType", "TopPlacementType", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "BotPlacementType", "BotPlacementType", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "TopAtt", "TopAtt", 0, false));
                additionalInputs.Add((Input)new InputString(++startIndex, "TopShape", "TopShape", "", false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "MiddleAtt", "MiddleAtt", 0, false));
                additionalInputs.Add((Input)new InputString(++startIndex, "MiddleShape", "MiddleShape", "", false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "BottomAtt", "BottomAtt", 0, false));
                additionalInputs.Add((Input)new InputString(++startIndex, "BottomShape", "BottomShape", "", false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "TopCon", "TopCon", 0, false));
                additionalInputs.Add((Input)new InputString(++startIndex, "TopConShape", "TopConShape", "", false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "MiddleCon", "MiddleCon", 0, false));
                additionalInputs.Add((Input)new InputString(++startIndex, "MidConShape", "MidConShape", "", false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "BottomCon", "BottomCon", 0, false));
                additionalInputs.Add((Input)new InputString(++startIndex, "BotConShape", "BotConShape", "", false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "TopOffsetDef", "TopOffsetDef", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "TopOff1", "TopOff1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "TopOff2", "TopOff2", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "BotOffsetDef", "BotOffsetDef", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "BottomOff1", "BottomOff1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "BottomOff2", "BottomOff2", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "MiddleOffsetDef", "MiddleOffsetDef", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "MiddleOff", "MiddleOff", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "TopAtt1Orient", "TopAtt1Orient", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "MidAtt1Orient", "MidAtt1Orient", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "BotAtt1Orient", "BotAtt1Orient", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "TopAtt2Orient", "TopAtt2Orient", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "MidAtt2Orient", "MidAtt2Orient", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "BotAtt2Orient", "BotAtt2Orient", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "TopCon1Rot", "TopCon1Rot", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "TopCon2Rot", "TopCon2Rot", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "MidCon1Rot", "MidCon1Rot", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "MidCon2Rot", "MidCon2Rot", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "BotCon1Rot", "BotCon1Rot", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "BotCon2Rot", "BotCon2Rot", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Length", "Length", 0, false));
                additionalInputs.Add((Input)new InputString(++startIndex, "SteelName", "SteelName", "", false));
                additionalInputs.Add((Input)new InputString(++startIndex, "SteelType", "SteelType", "", false));
                additionalInputs.Add((Input)new InputString(++startIndex, "SteelStandard", "SteelStandard", "", false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "SteelAngle", "SteelAngle", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "SteelCpoint", "SteelCpoint", 0, false));
                additionalInputs.Add((Input)new InputString(++startIndex, "Stiffener", "Stiffener", "", false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Multi1Qty", "Multi1Qty", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Multi1LocateBy", "Multi1LocateBy", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Multi1Location", "Multi1Location", 0, false));
                additionalInputs.Add((Input)new InputString(++startIndex, "EndPlateShape", "EndPlateShape", "", false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "EndPlateVerticalOffset", "EndPlateVerticalOffset", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "BBGap", "BBGap", 0, true));

            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddSpreaderBeamInputs, "Error in AddSpreaderBeamInputs");
            }
            endIndex = startIndex;
        }

        /// <summary>
        /// Loads the SpreaderBeam data.
        /// </summary>
        /// <param name="startIndex">The start index.</param>
        ///  <code>
        ///  SpreaderBeamInputs SpreaderBeam = LoadSpreaderBeamData(2);
        /// </code>
        /// <returns></returns>
        public SpreaderBeamInputs LoadSpreaderBeamData(int startIndex)
        {
            SpreaderBeamInputs SpreaderBeam = new SpreaderBeamInputs();
            try
            {
                SpreaderBeam.Diameter1 = GetDoubleorDefaultValue(startIndex);
                SpreaderBeam.ShoeHeight = GetDoubleorDefaultValue(++startIndex);
                SpreaderBeam.TopPlacementType = Convert.ToInt32(GetDoubleorDefaultValue(++startIndex));
                SpreaderBeam.BotPlacementType = Convert.ToInt32(GetDoubleorDefaultValue(++startIndex));
                SpreaderBeam.TopAtt = Convert.ToInt32(GetDoubleorDefaultValue(++startIndex));
                SpreaderBeam.TopShape = GetStringeorDefaultValue(++startIndex);
                SpreaderBeam.MiddleAtt = Convert.ToInt32(GetDoubleorDefaultValue(++startIndex));
                SpreaderBeam.MiddleShape = GetStringeorDefaultValue(++startIndex);
                SpreaderBeam.BottomAtt = Convert.ToInt32(GetDoubleorDefaultValue(++startIndex));
                SpreaderBeam.BottomShape = GetStringeorDefaultValue(++startIndex);
                SpreaderBeam.TopCon = Convert.ToInt32(GetDoubleorDefaultValue(++startIndex));
                SpreaderBeam.TopConShape = GetStringeorDefaultValue(++startIndex);
                SpreaderBeam.MiddleCon = Convert.ToInt32(GetDoubleorDefaultValue(++startIndex));
                SpreaderBeam.MidConShape = GetStringeorDefaultValue(++startIndex);
                SpreaderBeam.BottomCon = Convert.ToInt32(GetDoubleorDefaultValue(++startIndex));
                SpreaderBeam.BotConShape = GetStringeorDefaultValue(++startIndex);
                SpreaderBeam.TopOffsetDef = Convert.ToInt32(GetDoubleorDefaultValue(++startIndex));
                SpreaderBeam.TopOff1 = GetDoubleorDefaultValue(++startIndex);
                SpreaderBeam.TopOff2 = GetDoubleorDefaultValue(++startIndex);
                SpreaderBeam.BotOffsetDef = Convert.ToInt32(GetDoubleorDefaultValue(++startIndex));
                SpreaderBeam.BottomOff1 = GetDoubleorDefaultValue(++startIndex);
                SpreaderBeam.BottomOff2 = GetDoubleorDefaultValue(++startIndex);
                SpreaderBeam.MiddleOffsetDef = Convert.ToInt32(GetDoubleorDefaultValue(++startIndex));
                SpreaderBeam.MiddleOff = GetDoubleorDefaultValue(++startIndex);
                SpreaderBeam.TopAtt1Orient = Convert.ToInt32(GetDoubleorDefaultValue(++startIndex));
                SpreaderBeam.MidAtt1Orient = Convert.ToInt32(GetDoubleorDefaultValue(++startIndex));
                SpreaderBeam.BotAtt1Orient = Convert.ToInt32(GetDoubleorDefaultValue(++startIndex));
                SpreaderBeam.TopAtt2Orient = Convert.ToInt32(GetDoubleorDefaultValue(++startIndex));
                SpreaderBeam.MidAtt2Orient = Convert.ToInt32(GetDoubleorDefaultValue(++startIndex));
                SpreaderBeam.BotAtt2Orient = Convert.ToInt32(GetDoubleorDefaultValue(++startIndex));
                SpreaderBeam.TopCon1Rot = Convert.ToInt32(GetDoubleorDefaultValue(++startIndex));
                SpreaderBeam.TopCon2Rot = Convert.ToInt32(GetDoubleorDefaultValue(++startIndex));
                SpreaderBeam.MidCon1Rot = Convert.ToInt32(GetDoubleorDefaultValue(++startIndex));
                SpreaderBeam.MidCon2Rot = Convert.ToInt32(GetDoubleorDefaultValue(++startIndex));
                SpreaderBeam.BotCon1Rot = Convert.ToInt32(GetDoubleorDefaultValue(++startIndex));
                SpreaderBeam.BotCon2Rot = Convert.ToInt32(GetDoubleorDefaultValue(++startIndex));
                SpreaderBeam.Length = GetDoubleorDefaultValue(++startIndex);
                SpreaderBeam.SteelName = GetStringeorDefaultValue(++startIndex);
                SpreaderBeam.SteelType = GetStringeorDefaultValue(++startIndex);
                SpreaderBeam.SteelStandard = GetStringeorDefaultValue(++startIndex);
                SpreaderBeam.SteelAngle = GetDoubleorDefaultValue(++startIndex);
                SpreaderBeam.SteelCpoint = Convert.ToInt32(GetDoubleorDefaultValue(++startIndex));
                SpreaderBeam.Stiffener = GetStringeorDefaultValue(++startIndex);
                SpreaderBeam.Multi1Qty = GetDoubleorDefaultValue(++startIndex);
                SpreaderBeam.Multi1LocateBy = GetDoubleorDefaultValue(++startIndex);
                SpreaderBeam.Multi1Location = GetDoubleorDefaultValue(++startIndex);
                SpreaderBeam.SpreaderBeamEndPlate = GetStringeorDefaultValue(++startIndex);
                SpreaderBeam.EndPlateVerticalOffset = GetDoubleorDefaultValue(++startIndex);
                SpreaderBeam.BBGap = GetDoubleorDefaultValue(++startIndex);

                return SpreaderBeam;

            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadSpreaderBeamData, "Error in LoadSpreaderBeamData");
                }
                return SpreaderBeam;
            }
        }
        /// <summary>
        /// Create the graphical representation of insulation of a DummyLeg.
        /// </summary>
        /// <param name="dummyLegShape">The dummy leg shape.</param>
        /// <param name="pipeOD">The pipe OD.</param>
        /// <param name="elbowRadius">The elbow radius.</param>
        /// <param name="offset1">The offset1.</param>
        /// <param name="matrix">matrix to specify the position and oreintation the graphics - matrix.</param>
        /// <param name="outputs">Collection of declared outputs, which is indexed by the name of the outputs declared as defining SymbolOutputs on the AspectDefinition field- OutputDictionary</param>
        /// <param name="outputName">Output that this graphic is being placed on-String</param>
        /// <param name="fixedlength">if set to <c>true</c> [fixedlength].</param>
        /// <param name="insulationThickness">Insulation Thickness of the Dummyleg.</param>
        /// <param name="insulationLength">Insulation Length of the Dummyleg.</param>
        /// <code>
        /// AddDummyLegShape(botDummyShape, botDummyShape.diameter, dummyLeg.elbowRadius, dummyLeg.offset1, matrix, m_Symbolic.Outputs, "DummyStanchBot", fixedLength,insulationThickness,insulationLength);
        ///   </code>
        public void AddDummyLegInsulationShape(DummyLegShapeInputs dummyLegShape, double pipeOD, double elbowRadius, double offset1, Matrix4X4 matrix, OutputDictionary outputs, String outputName, bool fixedlength, double insulationThickness, ref double insulationLength, double runInsulationThickness = 0)
        {
            try
            {
                Surface3d surface;
                Collection<ICurve> iJElements = new Collection<ICurve>();
                GeometryIntersectionType intersection = new GeometryIntersectionType();
                double insulationThickness1 = 0;
                double shapeLocation = 0;

                if (dummyLegShape.dummyWidth + 2 * insulationThickness >= pipeOD + 2 * runInsulationThickness)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrDummyInsulationThick, "The given value of Dummyleg Insulation Thickess cannot be applied as it exceeds the total Outer Diameter of the Pipe ");
                }

                else if ((HgrCompareDoubleService.cmpdbl(insulationThickness, 0) == false && !(insulationLength < insulationThickness)))
                {
                    if (Math.Abs(dummyLegShape.dummyHeight) < (pipeOD / 2.0) || Math.Abs(dummyLegShape.dummyHeight) < (elbowRadius + pipeOD / 2.0))
                    {
                        dummyLegShape.dummyHeight = -(elbowRadius + pipeOD);
                    }

                    double pi = 4 * Math.Atan(1);
                    SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();
                    if (fixedlength == false)
                    {
                        insulationThickness1 = -insulationThickness;
                    }
                    else
                    {
                        insulationThickness1 = insulationThickness;
                    }

                    //Transient Pipe Shape
                    if (HgrCompareDoubleService.cmpdbl(elbowRadius, 0) == true)    //Straight Pipe
                    {
                        //Creating Transient Pipe shape
                        symbolGeometryHelper = new SymbolGeometryHelper();
                        double cylWidth = Math.Max((pipeOD + 2 * insulationThickness), pipeOD + 2 * runInsulationThickness) * 2;

                        Circle3d cir1 = new Circle3d(new Position(-cylWidth / 2 - offset1, 0, 0), new Vector(1, 0, 0), (dummyLegShape.diameter / 2) + runInsulationThickness);
                        Projection3d pro = new Projection3d(cir1, new Vector(1, 0, 0), cylWidth, false);
                        surface = pro;
                    }
                    else  //Elbow Pipe
                    {
                        Matrix4X4 elbowMatrix = new Matrix4X4();
                        elbowMatrix.SetIdentity();
                        if (fixedlength == true)
                        {
                            elbowMatrix.Rotate(Math.PI, new Vector(1, 0, 0));
                        }

                        if (pipeOD <= dummyLegShape.dummyWidth)
                        {
                            pipeOD = dummyLegShape.dummyWidth + 0.001;
                        }

                        Revolution3d bend = new Revolution3d(new Circle3d(new Position(0, 0, 0), new Vector(0, 0, 1), pipeOD / 2 + runInsulationThickness), new Vector(0, -1, 0), new Position(-elbowRadius, 0, 0), Math.PI / 2, true);
                        bend.Transform(elbowMatrix);
                        surface = bend;

                    }

                    if (pipeOD / 2 + elbowRadius + insulationLength > Math.Abs(dummyLegShape.dummyHeight))
                    {
                        insulationLength = Math.Abs(dummyLegShape.dummyHeight) - pipeOD / 2 - elbowRadius;
                        ToDoListMessage = new ToDoListMessage(ToDoMessageTypes.ToDoMessageWarning, SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidInsulationLength, "Length of the insulation exceeds the DummyLength. Resetting it to maximum length."));
                    }

                    //DummyLeg
                    if (dummyLegShape.dummyShape == 1)           //Cylinder
                    {
                        //Creating Transient Dummy shape
                        symbolGeometryHelper = new SymbolGeometryHelper();
                        dummyLegShape.dummyWidth = dummyLegShape.dummyWidth + 2 * insulationThickness;

                        Circle3d cir1 = new Circle3d(new Position(-offset1, 0, insulationThickness1), new Vector(0, 0, 1), dummyLegShape.dummyWidth / 2);
                        Projection3d pro1 = new Projection3d(cir1, new Vector(0, 0, -1), 3 * dummyLegShape.dummyHeight + insulationThickness1, false);


                        if (fixedlength == false)
                            shapeLocation = insulationLength + pipeOD / 2 + elbowRadius;
                        else
                            shapeLocation = -(insulationLength + pipeOD / 2 + elbowRadius);

                        if ((insulationLength + pipeOD / 2 + elbowRadius) > Math.Abs(dummyLegShape.dummyHeight))
                        {
                            shapeLocation = -dummyLegShape.dummyHeight;
                        }
                        Circle3d cir = new Circle3d(new Position(-offset1, 0, shapeLocation), new Vector(0, 0, 1), dummyLegShape.dummyWidth / 2.0);  //Creating TransientDummyLeg Bottom curve
                        ICurve curve1 = cir;

                        //Getting bottom curve from the intersection of Stanchion and Pipe Transient shape
                        try
                        {
                            surface.Intersect((ISurface)pro1, out iJElements, out intersection);
                            ICurve curve2;
                            if (iJElements.Count == 1)
                            {   // Only One InterSection Curve
                                curve2 = (ICurve)iJElements.First();
                            }
                            else
                            {   // Multiple Intersection Curves - Get the Bottom One
                                curve2 = (ICurve)iJElements.First();
                                for (int i = 1; i < iJElements.Count; i++)
                                {
                                    ICurve tempCurve = (ICurve)iJElements[i];
                                    if (tempCurve.Centroid.Z < curve2.Centroid.Z)
                                    {
                                        curve2 = tempCurve;
                                    }
                                }
                            }
                            //Creating DummyLeg Shape by joining DummyTopCurve and DummyBotCurve
                            Ruled3d rule = new Ruled3d(curve1, curve2, true);
                            rule.Transform(matrix);
                            outputs.Add(outputName + "Shape", rule);
                        }
                        catch
                        {
                            // Unable to Intersect the Curves - Default to a projection with no trim
                            double projectionHeight;
                            double startHeight;
                            if (offset1 >= 0)
                            {
                                projectionHeight = dummyLegShape.dummyHeight - elbowRadius;
                                startHeight = elbowRadius;
                            }
                            else
                            {
                                projectionHeight = dummyLegShape.dummyHeight;
                                startHeight = 0;
                            }

                            Projection3d defaultProj = new Projection3d(new Circle3d(new Position(-offset1, 0, -startHeight), new Vector(0, 0, 1), dummyLegShape.dummyWidth / 2), new Vector(0, 0, -1), projectionHeight, true);
                            defaultProj.Transform(matrix);
                            outputs.Add(outputName + "Shape", defaultProj);
                        }
                    }
                    else if (dummyLegShape.dummyShape == 2) //Square or Rectangle
                    {
                        if (dummyLegShape.dummyDepth <= 0) //Square
                        {
                            dummyLegShape.dummyDepth = dummyLegShape.dummyWidth;
                        }

                        dummyLegShape.dummyDepth = dummyLegShape.dummyDepth + 2 * insulationThickness;
                        dummyLegShape.dummyWidth = dummyLegShape.dummyWidth + 2 * insulationThickness;
                        //Getting bottom curve from the intersection of Stanchion and Pipe Transient shape
                        Projection3d pro = new Projection3d(CreChamBoxLine(new Position(-offset1, 0, 0), dummyLegShape.dummyDepth, dummyLegShape.dummyWidth, true), new Vector(0, 0, -1), dummyLegShape.dummyHeight, true);

                        if (fixedlength == false)
                            shapeLocation = insulationLength + pipeOD / 2 + elbowRadius;
                        else
                            shapeLocation = -(insulationLength + pipeOD / 2 + elbowRadius);

                        if ((insulationLength + pipeOD / 2 + elbowRadius) > Math.Abs(dummyLegShape.dummyHeight))
                        {
                            if (fixedlength == false)
                                shapeLocation = dummyLegShape.dummyHeight;
                            else
                                shapeLocation = -dummyLegShape.dummyHeight;
                        }


                        ComplexString3d complexstring1 = CreChamBoxLine(new Position(-offset1, 0, shapeLocation), dummyLegShape.dummyDepth, dummyLegShape.dummyWidth, false);
                        Curve3d curve2 = (Curve3d)complexstring1;

                        //Getting bottom curve from the intersection of Stanchion and Pipe Transient shape
                        try
                        {
                            surface.Intersect((ISurface)pro, out iJElements, out intersection);
                            ICurve curve1;
                            if (iJElements.Count == 1)
                            {   // Only One InterSection Curve
                                curve1 = (ICurve)iJElements.First();
                            }
                            else
                            {   // Multiple Intersection Curves - Get the Bottom One
                                curve1 = (ICurve)iJElements.First();
                                for (int i = 1; i < iJElements.Count; i++)
                                {
                                    ICurve tempCurve = (ICurve)iJElements[i];
                                    if (tempCurve.Centroid.Z < curve1.Centroid.Z)
                                    {
                                        curve1 = tempCurve;
                                    }
                                }
                            }
                            //Creating DummyLeg Shape by joining curve1 and curve2
                            Ruled3d rule = new Ruled3d(curve1, curve2, true);
                            rule.Transform(matrix);
                            outputs.Add(outputName + "Shape", rule);
                        }
                        catch
                        {
                            // Unable to Intersect the Curves - Default to a projection with no trim
                            double projectionHeight;
                            double startHeight;
                            if (offset1 >= 0)
                            {
                                projectionHeight = dummyLegShape.dummyHeight - elbowRadius;
                                startHeight = elbowRadius;
                            }
                            else
                            {
                                projectionHeight = dummyLegShape.dummyHeight;
                                startHeight = 0;
                            }

                            Projection3d defaultProj = new Projection3d(CreChamBoxLine(new Position(-offset1, 0, -startHeight), dummyLegShape.dummyDepth, dummyLegShape.dummyWidth, true), new Vector(0, 0, -1), projectionHeight, true);
                            defaultProj.Transform(matrix);
                            outputs.Add(outputName + "Shape", defaultProj);
                        }
                    }
                    else if (dummyLegShape.dummyShape == 3) //Steel Standard Shape
                    {
                        RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrSteelDummy, "DummyLeg shape cannot be created for standard steel");
                    }
                }//if close
                else if (insulationLength < runInsulationThickness)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInsulationDummy, "Insulation Length cannot be less than Run Insulation thickness");
                }

            }
            catch (SmartPartSymbolException hgrEx)
            {
                throw hgrEx;
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddDummyLegShape, "Error in AddDummyLegShape");
                }
            }

        }
        /// <summary>
        /// Loads the values associated to the given shape into the Hole PlateInputs type 
        /// This is done by querying the database for the given name.
        /// </summary>
        /// <param name="startIndex">refShapeName</param>
        /// <returns></returns>
        ///<code>
        ///PlateInputs plate = LoadHolePlateDataByQuery(blockClamp.MidPlateTopShape);
        ///</code>
        public PlateInputs LoadHolePlateDataByQuery(string refShapeName)
        {
            PlateInputs plate = new PlateInputs();
            try
            {
                if (!(refShapeName == string.Empty || refShapeName == "No Value" || refShapeName == null))
                {
                    Catalog plantCatalog = MiddleServiceProvider.SiteMgr.ActiveSite.ActivePlant.PlantCatalog;
                    BusinessObject plateAuxilaryTable = plantCatalog.GetNamedObject(refShapeName);
                    // Basic Plate Dimensions
                    GetDoublePropertyValue(plateAuxilaryTable, "IJUAhsHole1", "Hole1Diameter", ref plate.Hole1Diameter);
                    GetDoublePropertyValue(plateAuxilaryTable, "IJUAhsHole1", "Hole1HInset", ref plate.Hole1HInset);
                    GetDoublePropertyValue(plateAuxilaryTable, "IJUAhsHole1", "Hole1VInset", ref plate.Hole1VInset);
                    GetDoublePropertyValue(plateAuxilaryTable, "IJUAhsWidth1", "Width1", ref  plate.width1);
                    GetDoublePropertyValue(plateAuxilaryTable, "IJUAhsLength1", "Length1", ref plate.length1);
                    GetDoublePropertyValue(plateAuxilaryTable, "IJUAhsThickness1", "Thickness1", ref plate.thickness1);

                    // Top Left Corner
                    GetCodeListValue(plateAuxilaryTable, "IJUAhsTLCorner", "TLCornerType", ref plate.tlCornerType);
                    GetDoublePropertyValue(plateAuxilaryTable, "IJUAhsTLCorner", "TLCornerX", ref plate.tlCornerX);
                    GetDoublePropertyValue(plateAuxilaryTable, "IJUAhsTLCorner", "TLCornerY", ref plate.tlCornerY);
                    GetDoublePropertyValue(plateAuxilaryTable, "IJUAhsTLCorner", "TLCornerRadius", ref plate.tlCornerRad);

                    // Top Right Corner
                    GetCodeListValue(plateAuxilaryTable, "IJUAhsTRCorner", "TRCornerType", ref plate.trCornerType);
                    GetDoublePropertyValue(plateAuxilaryTable, "IJUAhsTRCorner", "TRCornerX", ref plate.trCornerX);
                    GetDoublePropertyValue(plateAuxilaryTable, "IJUAhsTRCorner", "TRCornerY", ref plate.trCornerY);
                    GetDoublePropertyValue(plateAuxilaryTable, "IJUAhsTRCorner", "TRCornerRadius", ref plate.trCornerRad);

                    //Bottom Left Corner
                    GetCodeListValue(plateAuxilaryTable, "IJUAhsBLCorner", "BLCornerType", ref plate.blCornerType);
                    GetDoublePropertyValue(plateAuxilaryTable, "IJUAhsBLCorner", "BLCornerX", ref plate.blCornerX);
                    GetDoublePropertyValue(plateAuxilaryTable, "IJUAhsBLCorner", "BLCornerY", ref plate.blCornerY);
                    GetDoublePropertyValue(plateAuxilaryTable, "IJUAhsBLCorner", "BLCornerRadius", ref plate.blCornerRad);

                    // Bottom Right Corner                   
                    GetCodeListValue(plateAuxilaryTable, "IJUAhsBRCorner", "BRCornerType", ref plate.brCornerType);
                    GetDoublePropertyValue(plateAuxilaryTable, "IJUAhsBRCorner", "BRCornerX", ref plate.brCornerX);
                    GetDoublePropertyValue(plateAuxilaryTable, "IJUAhsBRCorner", "BRCornerY", ref plate.brCornerY);
                    GetDoublePropertyValue(plateAuxilaryTable, "IJUAhsBRCorner", "BRCornerRadius", ref plate.brCornerRad);

                    // Curved End                    
                    GetDoublePropertyValue(plateAuxilaryTable, "IJUAhsCurvedEnd", "CurvedEndRad", ref plate.curvedEndRad);
                    GetDoublePropertyValue(plateAuxilaryTable, "IJUAhsCurvedEnd", "CurvedEndX", ref plate.curvedEndX);
                    GetDoublePropertyValue(plateAuxilaryTable, "IJUAhsCurvedEnd", "CurvedEndY", ref plate.curvedEndY);

                }

                return plate;
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadPlateDataByQuery, "Error in LoadHolePlateDataByQuery");
                }
                return plate;
            }
        }
        /// <summary>
        /// Adds the plate with hole.
        /// </summary>
        /// <param name="connection">The connection.</param>
        /// <param name="plate">My plate shape.</param>
        /// <param name="matrix">The matrix.</param>
        /// <param name="outputs">The outputs.</param>
        /// <param name="outputName">Name of the output.</param>
        /// <code>
        ///  matrix = new Matrix4X4();
        ///  matrix.Origin = new Position(0, 0, 0);
        ///  AddPlateShapeWithHole(plate, matrix, m_PhysicalAspect.Outputs, "Plate");
        /// </code>
        public void AddPlateShapeWithHole(PlateInputs plate, Matrix4X4 matrix, OutputDictionary outputs, String outputName)
        {
            try
            {
                Double dCurvedEndAlpha = 0;    // for curved top edge
                int iCount;  // point counter
                int nPts;    // number of points to use in the extrusion
                StringBuilder sError = new StringBuilder();
                if (plate.width1 <= 0 || plate.length1 <= 0 || HgrCompareDoubleService.cmpdbl(plate.thickness1, 0) == true)
                {
                    sError.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidRectangularNotchsizes, "Either Width, Length or Thickness wasn't valid. Can't create a plate graphic shape"));
                    return;
                }


                // Figure out the number of vertices and the eight tangent points based on the input parameters for the four corners.
                //
                // +-------TL----TR--------+
                // |                       |
                // |                      RT
                // |                       |
                // LT                      |
                // |                       |
                // |                       |
                // LB                      |
                // |                       |
                // |                      RB
                // |                       |
                // |                       |
                // +-------BL-------BR-----+
                //
                Double TopLeftX;
                Double TopLeftY;
                Double TopRightX;
                Double TopRightY;
                Double LeftTopX;
                Double LeftTopY;
                Double RightTopX;
                Double RightTopY;
                Double LeftBottomX;
                Double LeftBottomY;
                Double RightBottomX;
                Double RightBottomY;
                Double BottomLeftX;
                Double BottomLeftY;
                Double BottomRightX;
                Double BottomRightY;

                Double CurvedEndLeftX;
                Double CurvedEndRightX;
                int CurvedEndpts;

                Double dAngleNotchStartPtX;
                Double dAngleNotchStartPtY;
                Double dAngleNotchEndPtX;
                Double dAngleNotchEndPtY;

                // Initialize them to the four corners defined by Width1 and Length
                // These won't change
                TopLeftY = plate.length1;
                TopRightY = plate.length1;
                BottomLeftY = 0;
                BottomRightY = 0;
                LeftTopX = 0;
                LeftBottomX = 0;
                RightTopX = plate.width1;
                RightBottomX = plate.width1;

                // These will change based on the corner specifications - this is redundant as they all get set later.
                TopLeftX = 0;
                TopRightX = plate.width1;
                BottomLeftX = 0;
                BottomRightX = plate.width1;
                LeftTopY = plate.length1;
                LeftBottomY = 0;
                RightTopY = plate.length1;
                RightBottomY = 0;

                CurvedEndLeftX = 0;
                CurvedEndRightX = 0;

                //Initialize point count to 1 for each corner
                CurvedEndpts = 0;
                // Clockwise starting with the Top Right
                // 1 = Top Right
                // 2 = Bottom Right
                // 3 = Bottom Left
                // 4 = Top Left
                // This is the order in which we will draw the corner graphics later
                // so let's start thinking in this order right now!
                PlateCorner[] corner = new PlateCorner[4];
                int ID;
                Collection<ICurve> curveColl = new Collection<ICurve>();
                SymbolGeometryHelper symbolGeomHlpr = new SymbolGeometryHelper();
                Matrix4X4 matrix1 = new Matrix4X4();
                for (ID = 0; ID < 4; ID++)
                {
                    corner[ID].Points = 1;
                    switch (ID)
                    {
                        case 0:
                            corner[ID].name = "Top Right";
                            corner[ID].startX = plate.width1;
                            corner[ID].startY = plate.length1;
                            corner[ID].dirX = -1;
                            corner[ID].dirY = -1;
                            corner[ID].CornerType = plate.trCornerType;
                            corner[ID].CornerX = plate.trCornerX;
                            corner[ID].CornerY = plate.trCornerY;
                            corner[ID].CornerRad = plate.trCornerRad;
                            corner[ID].pointX = plate.width1;
                            corner[ID].pointY = plate.length1;
                            break;
                        case 1:
                            corner[ID].name = "Bottom Right";
                            corner[ID].startX = plate.width1;
                            corner[ID].startY = 0;
                            corner[ID].dirX = -1;
                            corner[ID].dirY = 1;
                            corner[ID].CornerType = plate.brCornerType;
                            corner[ID].CornerX = plate.brCornerX;
                            corner[ID].CornerY = plate.brCornerY;
                            corner[ID].CornerRad = plate.brCornerRad;
                            corner[ID].pointX = plate.width1;
                            corner[ID].pointY = 0;
                            break;
                        case 2:
                            corner[ID].name = "Bottom Left";
                            corner[ID].startX = 0;
                            corner[ID].startY = 0;
                            corner[ID].dirX = 1;
                            corner[ID].dirY = 1;
                            corner[ID].CornerType = plate.blCornerType;
                            corner[ID].CornerX = plate.blCornerX;
                            corner[ID].CornerY = plate.blCornerY;
                            corner[ID].CornerRad = plate.blCornerRad;
                            corner[ID].pointX = 0;
                            corner[ID].pointY = 0;
                            break;
                        case 3:
                            corner[ID].name = "Top Left";
                            corner[ID].startX = 0;
                            corner[ID].startY = plate.length1;
                            corner[ID].dirX = 1;
                            corner[ID].dirY = -1;
                            corner[ID].CornerType = plate.tlCornerType;
                            corner[ID].CornerX = plate.tlCornerX;
                            corner[ID].CornerY = plate.tlCornerY;
                            corner[ID].CornerRad = plate.tlCornerRad;
                            corner[ID].pointX = 0;
                            corner[ID].pointY = plate.length1;
                            break;
                    }


                    // Figure out how many vertices are needed in this corner
                    // Figure out what tangent points are used for this corner type

                    switch (corner[ID].CornerType)
                    {
                        case 0:
                            // None - do nothing
                            break;

                        case 1:
                            // Rectangular Notch - specify size of notch as X and Y distances from corner, radius is ignored                
                            // Valid notch?
                            if (corner[ID].CornerX <= 0 || corner[ID].CornerX >= plate.width1 || corner[ID].CornerY <= 0 || corner[ID].CornerY >= plate.length1)
                            {
                                // Not valid. Treat as no shape
                                corner[ID].CornerX = 0;
                                corner[ID].CornerY = 0;
                                corner[ID].CornerRad = 0;
                                corner[ID].CornerType = 0; // None
                                sError.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidRectangularNotchsizes, "Rectangular Notch sizes invalid - ignoring corner type -" + corner[ID].name));
                                goto label1;
                            }

                            // Now have valid notch - set the corner points
                            corner[ID].pointX = corner[ID].startX + corner[ID].dirX * corner[ID].CornerX;
                            corner[ID].pointY = corner[ID].startY + corner[ID].dirY * corner[ID].CornerY;
                            corner[ID].Points = 3;
                            break;
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            //2 - AngleXYChamfer  Angled Notch - X and Y chamfer sizes
                            //3 - AngleXYEdges    Angled Notch - X and Y edge sizes
                            //4 - AngleXwithAngle Angled Notch - X notch size and angle
                            //5 - AngleYwithAngle Angled Notch - Y notch size and angle
                            // Convert all to the same as 2, XY Chamfer

                            if (corner[ID].CornerType == 3)  //3 - AngleXYEdges - convert from edges to chamfer sizes
                            {
                                corner[ID].CornerX = plate.width1 - corner[ID].CornerX;
                                corner[ID].CornerY = plate.length1 - corner[ID].CornerY;
                            }

                            if (corner[ID].CornerType == 4)  //4 - AngleXwithAngle
                            {
                                // The Y should contain an angle, in degrees. Calculate Y from X and this angle
                                // First, massage the angle value if necessary - here's why:
                                // 1. angles are entered in XLS in the X, Y attributes
                                // 2. these attributes have distance units of mm in the CustomInterfaces sheet
                                // 3. these attributes are then stored in the database in the standard db length units of meters.
                                // 4. an angle of 30 is stored in the db as 0.030m, which makes for bloody small angles in this function
                                // 5. so, if the angle is tiny, multiply it by 1000 to get back to the original number from the XLS
                                // 6. if the angle is NOT tiny, leave it alone as it is already valid.
                                if (corner[ID].CornerY > Common.Middle.Math3d.DistanceTolerance && corner[ID].CornerY <= 0.361)
                                    corner[ID].CornerY = corner[ID].CornerY * 1000;

                                corner[ID].Beta = corner[ID].CornerY;
                                corner[ID].CornerY = corner[ID].CornerX * Common.Middle.Math3d.TanDeg(corner[ID].Beta);
                            }

                            if (corner[ID].CornerType == 5)  //5 - AngleYwithAngle
                            {
                                // The X should contain an angle, in degrees. Calculate X from Y and this angle
                                // First, massage the angle value if necessary - see comment above for corner type 4
                                if (corner[ID].CornerX > Common.Middle.Math3d.DistanceTolerance && corner[ID].CornerX <= 0.361)
                                    corner[ID].CornerX = corner[ID].CornerX * 1000;

                                corner[ID].Alpha = corner[ID].CornerX;
                                corner[ID].CornerX = corner[ID].CornerY * Common.Middle.Math3d.TanDeg(corner[ID].Alpha);
                            }

                            // Valid notch?
                            if (corner[ID].CornerX <= 0 || corner[ID].CornerY <= 0)
                            {
                                // Not valid, notch must have positive sizes to be visible. Treat as None for top corner
                                corner[ID].CornerX = 0;
                                corner[ID].CornerY = 0;
                                corner[ID].CornerRad = 0;
                                corner[ID].CornerType = 0; // None
                                sError.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidAngledNotchsizes, "Angled Notch sizes invalid - ignoring corner type-" + corner[ID].name));
                                goto label1;
                            }

                            // Since the angle notch can be radiused, we need to consider the rounding radius and check the dimensions
                            if (corner[ID].CornerRad > 0)
                            {
                                corner[ID].Alpha = Math.Atan(corner[ID].CornerX / corner[ID].CornerY); // checked earlier so we know CornerY is not zero
                                corner[ID].Beta = Math.Atan(corner[ID].CornerY / corner[ID].CornerX); // checked earlier so we know CornerX is not zero
                                iCount = 4; // each corner will require 4 points but don't set it yet as we have more validity checking to do

                                corner[ID].RoundedX = true;
                                corner[ID].RoundedY = true;

                                // If the notch starts exactly on a corner, don't round it.
                                if (Math.Abs(corner[ID].CornerX - plate.width1) < Common.Middle.Math3d.DistanceTolerance)
                                {
                                    iCount = iCount - 1;
                                    corner[ID].RoundedX = false;
                                }
                                if (Math.Abs(corner[ID].CornerY - plate.length1) < Common.Middle.Math3d.DistanceTolerance)
                                {
                                    iCount = iCount - 1;
                                    corner[ID].RoundedY = false;
                                }

                                // If the notch starts exactly in BOTH corners, we can ignore the specified radius since neither end
                                // of the notch will be rounded.
                                if (iCount == 2)
                                {
                                    corner[ID].CornerRad = 0;
                                }
                            }
                            else
                            {
                                corner[ID].Alpha = 0;
                                corner[ID].Beta = 0;
                                iCount = 2; // each corner will require 2 points but don't set it yet as we have more validity checking to do
                            }

                            if (corner[ID].RoundedX == true)
                            {
                                // We ARE rounding this end of the notch so check to make sure the rounded corner fits within the plate
                                if (corner[ID].CornerX + corner[ID].CornerRad * Math.Tan(corner[ID].Beta / 2) > plate.width1)
                                {
                                    corner[ID].CornerX = 0;
                                    corner[ID].CornerY = 0;
                                    corner[ID].CornerRad = 0;
                                    corner[ID].CornerType = 0; // None
                                    sError.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidAngledNotchX, "Angled Notch X size with specified radius is larger than plate width - ignoring corner type " + corner[ID].name));
                                    goto label1;
                                }
                            }

                            if (corner[ID].RoundedY == true)
                            {
                                // We ARE rounding this end of the notch so check to make sure the rounded corner fits within the plate
                                if (corner[ID].CornerY + corner[ID].CornerRad * Math.Tan(corner[ID].Alpha / 2) > plate.length1)
                                {
                                    corner[ID].CornerX = 0;
                                    corner[ID].CornerY = 0;
                                    corner[ID].CornerRad = 0;
                                    corner[ID].CornerType = 0; // None
                                    sError.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidAngledNotchY, "Angled Notch Y size with specified radius is larger than plate width - ignoring corner type " + corner[ID].name));
                                    goto label1;
                                }
                            }

                            // Now have valid notch - set the corner points
                            if (corner[ID].RoundedX == true)
                                // Rounded
                                corner[ID].pointX = corner[ID].startX + corner[ID].dirX * (corner[ID].CornerX + corner[ID].CornerRad * Math.Tan(corner[ID].Beta / 2));
                            else
                                // Sharp
                                corner[ID].pointX = corner[ID].startX + corner[ID].dirX * corner[ID].CornerX;

                            if (corner[ID].RoundedY == true)
                                // Rounded
                                corner[ID].pointY = corner[ID].startY + corner[ID].dirY * (corner[ID].CornerY + corner[ID].CornerRad * Math.Tan(corner[ID].Alpha / 2));
                            else
                                // Sharp
                                corner[ID].pointY = corner[ID].startY + corner[ID].dirY * corner[ID].CornerY;

                            corner[ID].Points = iCount;
                            break;
                        case 6:
                            // Round Notch - specify radius of notch, and X and Y offsets from corner

                            // Check if round notch is offset too far off the plate. if (so, ignore it.
                            if (corner[ID].CornerX < 0 && corner[ID].CornerY < 0)
                            {
                                if (Math.Pow((corner[ID].CornerX * corner[ID].CornerX + corner[ID].CornerY * corner[ID].CornerY), 2) >= corner[ID].CornerRad)
                                {
                                    corner[ID].CornerX = 0;
                                    corner[ID].CornerY = 0;
                                    corner[ID].CornerRad = 0;
                                    corner[ID].CornerType = 0; // None
                                    sError.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidRoundNotch, "Round Notch is offset too far off plate, not visible - ignoring corner type " + corner[ID].name));
                                    goto label1;
                                }
                            }

                            if ((corner[ID].CornerX < 0 && Math.Abs(corner[ID].CornerX) >= corner[ID].CornerRad) || (corner[ID].CornerY < 0 && Math.Abs(corner[ID].CornerY) >= corner[ID].CornerRad))
                            {
                                corner[ID].CornerX = 0;
                                corner[ID].CornerY = 0;
                                corner[ID].CornerRad = 0;
                                corner[ID].CornerType = 0; // None
                                sError.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidRoundNotchXorY, "Round Notch X or Y is offset too far off plate, not visible - ignoring corner type " + corner[ID].name));
                                goto label1;
                            }

                            if (corner[ID].CornerRad <= 0)
                            {
                                corner[ID].CornerX = 0;
                                corner[ID].CornerY = 0;
                                corner[ID].CornerRad = 0;
                                corner[ID].CornerType = 0; // None
                                sError.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidRoundNotchRadius, "Round Notch has invalid radius - ignoring corner type " + corner[ID].name));
                                goto label1;
                            }

                            // Calculate the angles for negative offsets, zero for no offset or positive offset
                            if (corner[ID].CornerX < 0)

                                corner[ID].Beta = Math.Asin(Math.Abs(corner[ID].CornerX) / corner[ID].CornerRad); // checked earlier so we know corner[ID].dCornerRad is not zero;
                            else
                                corner[ID].Beta = 0;


                            if (corner[ID].CornerY < 0)
                                corner[ID].Alpha = Math.Asin(Math.Abs(corner[ID].CornerY) / corner[ID].CornerRad); // checked earlier so we know corner[ID].dCornerRad is not zero
                            else
                                corner[ID].Alpha = 0;


                            if (corner[ID].CornerX + corner[ID].CornerRad * Math.Cos(corner[ID].Alpha) > plate.width1)
                            {
                                corner[ID].CornerX = 0;
                                corner[ID].CornerY = 0;
                                corner[ID].CornerType = 0; // None
                                sError.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidRoundCornerRadius, "Round Notch radius with specified offsets is larger than plate width - ignoring corner type " + corner[ID].name));
                                goto label1;
                            }

                            if (corner[ID].CornerY + corner[ID].CornerRad * Math.Cos(corner[ID].Beta) > plate.length1)
                            {
                                corner[ID].CornerX = 0;
                                corner[ID].CornerY = 0;
                                corner[ID].CornerType = 0; // None
                                sError.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidRoundCornerRadius, "Round Notch radius with specified offsets is larger than plate width - ignoring corner type " + corner[ID].name));
                                goto label1;
                            }

                            // How many points in the corners
                            iCount = 2;
                            if (corner[ID].CornerX > 0) iCount = iCount + 1;
                            if (corner[ID].CornerY > 0) iCount = iCount + 1;

                            // Now have valid notch - set the corner points
                            corner[ID].pointX = corner[ID].startX + corner[ID].dirX * (corner[ID].CornerX + corner[ID].CornerRad * Math.Cos(corner[ID].Alpha));
                            corner[ID].pointY = corner[ID].startY + corner[ID].dirY * (corner[ID].CornerY + corner[ID].CornerRad * Math.Cos(corner[ID].Beta));
                            corner[ID].Points = iCount;
                            break;
                        case 7:
                            // Rounded Corner - specify radius of rounding, and X and Y offsets from corner.

                            // Make sure the radius is specified
                            if (corner[ID].CornerRad <= 0)
                            {
                                corner[ID].CornerX = 0;
                                corner[ID].CornerY = 0;
                                corner[ID].CornerRad = 0;
                                corner[ID].CornerType = 0; // None
                                sError.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidRoundCornerRadius, "Rounded Corner has invalid radius - ignoring corner type " + corner[ID].name));
                                goto label1;
                            }

                            // Check if offsets are validly negative
                            if (corner[ID].CornerX > 0)
                            {
                                corner[ID].CornerX = -corner[ID].CornerX;
                                sError.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidRoundTopCornerX, "Rounded Top Corner has positive X offset, not allowed - using negative of value"));
                            }
                            if (corner[ID].CornerY > 0)
                            {
                                corner[ID].CornerY = -corner[ID].CornerY;
                                sError.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidRoundTopCornerY, "Rounded Top Corner has positive Y offset, not allowed - using negative of value"));
                            }

                            // Calculate the angles
                            if (corner[ID].CornerY < 0)

                                corner[ID].Beta = Math.Acos((corner[ID].CornerRad + corner[ID].CornerY) / corner[ID].CornerRad); // checked earlier so we know corner[ID].dCornerRad is not zero
                            else
                                corner[ID].Beta = 0;


                            if (corner[ID].CornerX < 0)

                                corner[ID].Alpha = Math.Acos((corner[ID].CornerRad + corner[ID].CornerX) / corner[ID].CornerRad); // checked earlier so we know corner[ID].dCornerRad is not zero
                            else
                                corner[ID].Alpha = 0;


                            // Check if the offset rounding will still be visible on the plate
                            if (corner[ID].CornerRad * Math.Sin(corner[ID].Beta) > corner[ID].CornerRad + corner[ID].CornerX || corner[ID].CornerRad * Math.Sin(corner[ID].Alpha) > corner[ID].CornerRad + corner[ID].CornerY)
                            {
                                corner[ID].CornerX = 0;
                                corner[ID].CornerY = 0;
                                corner[ID].CornerRad = 0;
                                corner[ID].CornerType = 0; // None
                                sError.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidRoundCornerOffset, "Rounded Corner with offsets would be off the plate - ignoring " + corner[ID].name));
                                goto label1;
                            }

                            if (corner[ID].CornerRad + corner[ID].CornerX - corner[ID].CornerRad * Math.Sin(corner[ID].Beta) > plate.width1)
                            {
                                corner[ID].CornerX = 0;
                                corner[ID].CornerY = 0;
                                corner[ID].CornerType = 0; // None
                                sError.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidRoundCornerOffset, "Round Corner with offsets larger than plate width - ignoring " + corner[ID].name));
                                goto label1;
                            }

                            if (corner[ID].CornerRad + corner[ID].CornerY - corner[ID].CornerRad * Math.Sin(corner[ID].Alpha) > plate.length1)
                            {
                                corner[ID].CornerX = 0;
                                corner[ID].CornerY = 0;
                                corner[ID].CornerType = 0; // None
                                sError.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidRCOffsettGTPlateWidth, "Round Corner with offsets larger than plate width - ignoring " + corner[ID].name));
                                goto label1;
                            }

                            // Now have valid notch - set the corner points
                            corner[ID].pointX = corner[ID].startX + corner[ID].dirX * (corner[ID].CornerRad + corner[ID].CornerX - corner[ID].CornerRad * Math.Sin(corner[ID].Beta));
                            corner[ID].pointY = corner[ID].startY + corner[ID].dirY * (corner[ID].CornerRad + corner[ID].CornerY - corner[ID].CornerRad * Math.Sin(corner[ID].Alpha));
                            corner[ID].Points = 2;
                            break;
                    }
                label1:
                    switch (ID)
                    {
                        case 0:  // Top Right
                            TopRightX = corner[ID].pointX;
                            RightTopY = corner[ID].pointY;
                            break;
                        case 1:  // Bottom Right
                            BottomRightX = corner[ID].pointX;
                            RightBottomY = corner[ID].pointY;
                            break;
                        case 2:  // Bottom Left
                            BottomLeftX = corner[ID].pointX;
                            LeftBottomY = corner[ID].pointY;
                            break;
                        case 3:  // Top Left
                            TopLeftX = corner[ID].pointX;
                            LeftTopY = corner[ID].pointY;
                            break;
                    }
                }
                // Check if there's a request for a curved notch in the top edge, and if there's room for it
                if (plate.curvedEndRad > 0)
                {
                    // Requested a curved notch in the top edge. Make sure Y offset is not too far off or on to the plate
                    if (Math.Abs(plate.curvedEndY) >= plate.curvedEndRad)
                    {
                        plate.curvedEndRad = 0;
                        plate.curvedEndX = 0;
                        plate.curvedEndY = 0; // None
                        sError.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidCurveEndY, "Curved End Y offset is greater than specified Curved End radius - ignoring Curved End."));
                        goto label2;
                    }

                    dCurvedEndAlpha = Math.Acos(plate.curvedEndY / plate.curvedEndRad);
                    CurvedEndLeftX = plate.width1 / 2 + plate.curvedEndX - plate.curvedEndRad * Math.Sin(dCurvedEndAlpha);
                    CurvedEndRightX = plate.width1 / 2 + plate.curvedEndX + plate.curvedEndRad * Math.Sin(dCurvedEndAlpha);

                    double tempCurvedEndLeftX = Math.Round(CurvedEndLeftX, 10);
                    double tempCurvedEndRightX = Math.Round(CurvedEndRightX, 10);

                    if (Math.Round(tempCurvedEndLeftX, 4) < Math.Round(TopLeftX, 4) || Math.Round(tempCurvedEndRightX, 4) > Math.Round(TopRightX, 4))
                    {
                        plate.curvedEndRad = 0;
                        plate.curvedEndX = 0;
                        plate.curvedEndY = 0; // None
                        CurvedEndRightX = 0;
                        CurvedEndLeftX = 0;
                        sError.Append(SmartPartLocalizer.GetString(SmartPartSymbolResourceIDs.ErrInvalidCurveEnd, "Curved End doesn't fit on remaining top edge - ignoring Curved End."));
                        goto label2;
                    }

                    // We know there will be a curved notch in the top edge. If the end points of the curve
                    // won't exactly match the existing TopLeft and TopRight tangent points, we'll need
                    // extra lines, and thus extra points.
                    if (CurvedEndLeftX > TopLeftX && Math.Abs(CurvedEndLeftX - TopLeftX) > Common.Middle.Math3d.DistanceTolerance)
                        CurvedEndpts = CurvedEndpts + 1;
                    if (CurvedEndRightX < TopRightX && Math.Abs(CurvedEndRightX - TopRightX) > Common.Middle.Math3d.DistanceTolerance)
                        CurvedEndpts = CurvedEndpts + 1;

                }
            label2:
                // ************************************************************************************************************************************    
                // Now, we know how many points to use so we can do our extrusion
                nPts = corner[0].Points + corner[1].Points + corner[2].Points + corner[3].Points + CurvedEndpts;
                // If there are coincident points, we need less pieces in the extrusion
                if (Math.Abs(TopLeftX - TopRightX) < Common.Middle.Math3d.DistanceTolerance)
                    nPts = nPts - 1;
                if (Math.Abs(RightTopY - RightBottomY) < Common.Middle.Math3d.DistanceTolerance)
                    nPts = nPts - 1;
                if (Math.Abs(BottomLeftX - BottomRightX) < Common.Middle.Math3d.DistanceTolerance)
                    nPts = nPts - 1;
                if (Math.Abs(LeftTopY - LeftBottomY) < Common.Middle.Math3d.DistanceTolerance)
                    nPts = nPts - 1;

                iCount = 1;


                // Draw top right corner
                ID = 0;
                switch (corner[ID].CornerType)
                {
                    case 0:
                        // None - do nothing
                        break;
                    case 1:
                        // Rectangular Notch
                        // Draw from TR to inside corner to RT
                        Line3d line = new Line3d(new Position(TopRightX, TopRightY, 0), new Position(TopRightX, RightTopY, 0));
                        curveColl.Add(line);
                        iCount = iCount + 1;
                        line = new Line3d(new Position(TopRightX, RightTopY, 0), new Position(RightTopX, RightTopY, 0));
                        curveColl.Add(line);
                        iCount = iCount + 1;
                        break;
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        if (corner[ID].CornerRad > 0)
                        {
                            // Rounded
                            if (corner[ID].RoundedX == true)
                            {
                                symbolGeomHlpr.ActivePosition = new Position(0, 0, 0);
                                symbolGeomHlpr.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                                Arc3d arc = symbolGeomHlpr.CreateArc(null, corner[ID].CornerRad, (90 - Math3d.Deg(corner[ID].Alpha)) * Math.PI / 180);
                                matrix1 = new Matrix4X4();
                                matrix1.SetIdentity();
                                matrix1.Rotate(Math3d.Deg(corner[ID].Alpha) * Math.PI / 180, new Vector(0, 0, 1));
                                arc.Transform(matrix1);

                                matrix1 = new Matrix4X4();
                                matrix1.SetIdentity();
                                matrix1.Translate(new Vector(TopRightX, TopRightY - corner[ID].CornerRad, 0));
                                arc.Transform(matrix1);

                                curveColl.Add(arc);
                                iCount = iCount + 1;
                                dAngleNotchStartPtX = TopRightX + corner[ID].CornerRad * Math.Sin(corner[ID].Beta);
                                dAngleNotchStartPtY = TopRightY - corner[ID].CornerRad + corner[ID].CornerRad * Math.Cos(corner[ID].Beta);
                            }
                            else
                            {
                                dAngleNotchStartPtX = TopRightX;
                                dAngleNotchStartPtY = TopRightY;
                            }

                            if (corner[ID].RoundedY == true)
                            {
                                dAngleNotchEndPtX = RightTopX - corner[ID].CornerRad + corner[ID].CornerRad * Math.Cos(corner[ID].Alpha);
                                dAngleNotchEndPtY = RightTopY + corner[ID].CornerRad * Math.Sin(corner[ID].Alpha);
                            }
                            else
                            {
                                dAngleNotchEndPtX = RightTopX;
                                dAngleNotchEndPtY = RightTopY;
                            }
                            line = new Line3d(new Position(dAngleNotchStartPtX, dAngleNotchStartPtY, 0), new Position(dAngleNotchEndPtX, dAngleNotchEndPtY, 0));
                            curveColl.Add(line);

                            iCount = iCount + 1;

                            if (corner[ID].RoundedY == true)
                            {
                                symbolGeomHlpr = new SymbolGeometryHelper();
                                symbolGeomHlpr.ActivePosition = new Position(0, 0, 0);
                                symbolGeomHlpr.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                                Arc3d arc = symbolGeomHlpr.CreateArc(null, corner[ID].CornerRad, Math3d.Deg(corner[ID].Alpha) * Math.PI / 180);

                                matrix1 = new Matrix4X4();
                                matrix1.SetIdentity();
                                matrix1.Translate(new Vector(RightTopX - corner[ID].CornerRad, RightTopY, 0));
                                arc.Transform(matrix1);

                                curveColl.Add(arc);
                                iCount = iCount + 1;
                            }

                        }
                        else
                        {
                            // No rounding, just draw one line
                            line = new Line3d(new Position(TopRightX, TopRightY, 0), new Position(RightTopX, RightTopY, 0));
                            curveColl.Add(line);
                            iCount = iCount + 1;
                        }

                        break;
                    case 6:
                        // Round Notch
                        if (corner[ID].CornerY > 0)
                        {
                            line = new Line3d(new Position(TopRightX, TopRightY, 0), new Position(TopRightX, TopRightY - corner[ID].CornerY, 0));
                            curveColl.Add(line);
                            iCount = iCount + 1;
                        }
                        symbolGeomHlpr = new SymbolGeometryHelper();
                        symbolGeomHlpr.ActivePosition = new Position(0, 0, 0);
                        symbolGeomHlpr.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        Arc3d arc1 = symbolGeomHlpr.CreateArc(null, corner[ID].CornerRad, (90 - Math3d.Deg(corner[ID].Alpha) - Math3d.Deg(corner[ID].Beta)) * Math.PI / 180);
                        matrix1 = new Matrix4X4();
                        matrix1.SetIdentity();
                        matrix1.Rotate((180 + Math3d.Deg(corner[ID].Alpha)) * Math.PI / 180, new Vector(0, 0, 1));
                        arc1.Transform(matrix1);

                        matrix1 = new Matrix4X4();
                        matrix1.SetIdentity();
                        matrix1.Translate(new Vector(plate.width1 - corner[ID].CornerX, plate.length1 - corner[ID].CornerY, 0));
                        arc1.Transform(matrix1);
                        curveColl.Add(arc1);
                        iCount = iCount + 1;
                        if (corner[ID].CornerX > 0)
                        {
                            line = new Line3d(new Position(RightTopX - corner[ID].CornerX, RightTopY, 0), new Position(RightTopX, RightTopY, 0));
                            curveColl.Add(line);
                            iCount = iCount + 1;
                        }
                        break;
                    case 7:

                        // Rounded Corner
                        symbolGeomHlpr = new SymbolGeometryHelper();
                        symbolGeomHlpr.ActivePosition = new Position(0, 0, 0);
                        symbolGeomHlpr.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        arc1 = symbolGeomHlpr.CreateArc(null, corner[ID].CornerRad, (90 - Math3d.Deg(corner[ID].Alpha) - Math3d.Deg(corner[ID].Beta)) * Math.PI / 180);
                        matrix1 = new Matrix4X4();
                        matrix1.SetIdentity();
                        matrix1.Rotate((Math3d.Deg(corner[ID].Alpha)) * Math.PI / 180, new Vector(0, 0, 1));
                        arc1.Transform(matrix1);

                        matrix1 = new Matrix4X4();
                        matrix1.SetIdentity();
                        matrix1.Translate(new Vector(plate.width1 - (corner[ID].CornerRad + corner[ID].CornerX), plate.length1 - (corner[ID].CornerRad + corner[ID].CornerY), 0));
                        arc1.Transform(matrix1);
                        curveColl.Add(arc1);
                        iCount = iCount + 1;
                        break;
                }
                // Draw optional line from Top Right corner to Bottom Right corner
                if (Math.Abs(RightTopY - RightBottomY) >= Math3d.DistanceTolerance)
                {
                    Line3d line = new Line3d(new Position(RightTopX, RightTopY, 0), new Position(RightBottomX, RightBottomY, 0));
                    curveColl.Add(line);
                    iCount = iCount + 1;
                }

                // Draw bottom right corner
                ID = 1;
                switch (corner[ID].CornerType)
                {
                    case 0:
                        // None - do nothing
                        break;
                    case 1:
                        // Rectangular Notch
                        // Draw from TR to inside corner to RT
                        Line3d line = new Line3d(new Position(RightBottomX, RightBottomY, 0), new Position(BottomRightX, RightBottomY, 0));
                        curveColl.Add(line);
                        iCount = iCount + 1;
                        line = new Line3d(new Position(BottomRightX, RightBottomY, 0), new Position(BottomRightX, BottomRightY, 0));
                        curveColl.Add(line);
                        iCount = iCount + 1;
                        break;
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        // Angle Notch
                        if (corner[ID].CornerRad > 0)
                        {
                            // Rounded
                            if (corner[ID].RoundedY == true)
                            {
                                symbolGeomHlpr = new SymbolGeometryHelper();
                                symbolGeomHlpr.ActivePosition = new Position(0, 0, 0);
                                symbolGeomHlpr.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                                Arc3d arc1 = symbolGeomHlpr.CreateArc(null, corner[ID].CornerRad, Math3d.Deg(corner[ID].Alpha) * Math.PI / 180);
                                matrix1 = new Matrix4X4();
                                matrix1.SetIdentity();
                                matrix1.Rotate((360 - Math3d.Deg(corner[ID].Alpha)) * Math.PI / 180, new Vector(0, 0, 1));
                                arc1.Transform(matrix1);

                                matrix1 = new Matrix4X4();
                                matrix1.SetIdentity();
                                matrix1.Translate(new Vector(RightBottomX - corner[ID].CornerRad, RightBottomY, 0));
                                arc1.Transform(matrix1);
                                curveColl.Add(arc1);

                                iCount = iCount + 1;

                                dAngleNotchStartPtX = RightBottomX - corner[ID].CornerRad + corner[ID].CornerRad * Math.Cos(corner[ID].Alpha);
                                dAngleNotchStartPtY = RightBottomY - corner[ID].CornerRad * Math.Sin(corner[ID].Alpha);
                            }
                            else
                            {
                                dAngleNotchStartPtX = RightBottomX;
                                dAngleNotchStartPtY = RightBottomY;
                            }

                            if (corner[ID].RoundedX == true)
                            {
                                dAngleNotchEndPtX = BottomRightX + corner[ID].CornerRad * Math.Sin(corner[ID].Beta);
                                dAngleNotchEndPtY = BottomRightY + corner[ID].CornerRad - corner[ID].CornerRad * Math.Cos(corner[ID].Beta);
                            }
                            else
                            {
                                dAngleNotchEndPtX = BottomRightX;
                                dAngleNotchEndPtY = BottomRightY;
                            }
                            line = new Line3d(new Position(dAngleNotchStartPtX, dAngleNotchStartPtY, 0), new Position(dAngleNotchEndPtX, dAngleNotchEndPtY, 0));
                            curveColl.Add(line);
                            iCount = iCount + 1;

                            if (corner[ID].RoundedX == true)
                            {
                                symbolGeomHlpr = new SymbolGeometryHelper();
                                symbolGeomHlpr.ActivePosition = new Position(0, 0, 0);
                                symbolGeomHlpr.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                                Arc3d arc1 = symbolGeomHlpr.CreateArc(null, corner[ID].CornerRad, (90 - Math3d.Deg(corner[ID].Alpha)) * Math.PI / 180);
                                matrix1 = new Matrix4X4();
                                matrix1.SetIdentity();
                                matrix1.Rotate((270) * Math.PI / 180, new Vector(0, 0, 1));
                                arc1.Transform(matrix1);

                                matrix1 = new Matrix4X4();
                                matrix1.SetIdentity();
                                matrix1.Translate(new Vector(BottomRightX, BottomRightY + corner[ID].CornerRad, 0));
                                arc1.Transform(matrix1);

                                curveColl.Add(arc1);
                                iCount = iCount + 1;
                            }
                        }
                        else
                        {
                            line = new Line3d(new Position(RightBottomX, RightBottomY, 0), new Position(BottomRightX, BottomRightY, 0));
                            curveColl.Add(line);
                            iCount = iCount + 1;
                        }
                        break;
                    case 6:
                        // Round Notch
                        if (corner[ID].CornerX > 0)
                        {
                            line = new Line3d(new Position(RightBottomX, RightBottomY, 0), new Position(RightBottomX - corner[ID].CornerX, RightBottomY, 0));
                            curveColl.Add(line);
                            iCount = iCount + 1;
                        }
                        symbolGeomHlpr = new SymbolGeometryHelper();
                        symbolGeomHlpr.ActivePosition = new Position(0, 0, 0);
                        symbolGeomHlpr.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        Arc3d arc = symbolGeomHlpr.CreateArc(null, corner[ID].CornerRad, (90 - Math3d.Deg(corner[ID].Alpha) - Math3d.Deg(corner[ID].Beta)) * Math.PI / 180);
                        matrix1 = new Matrix4X4();
                        matrix1.SetIdentity();
                        matrix1.Rotate((90 + Math3d.Deg(corner[ID].Beta)) * Math.PI / 180, new Vector(0, 0, 1));
                        arc.Transform(matrix1);

                        matrix1 = new Matrix4X4();
                        matrix1.SetIdentity();
                        matrix1.Translate(new Vector(plate.width1 - corner[ID].CornerX, corner[ID].CornerY, 0));
                        arc.Transform(matrix1);

                        curveColl.Add(arc);
                        iCount = iCount + 1;

                        if (corner[ID].CornerY > 0)
                        {
                            line = new Line3d(new Position(BottomRightX, BottomRightY + corner[ID].CornerY, 0), new Position(BottomRightX, BottomRightY, 0));
                            curveColl.Add(line);
                            iCount = iCount + 1;
                        }
                        break;
                    case 7:
                        // Rounded Corner
                        symbolGeomHlpr = new SymbolGeometryHelper();
                        symbolGeomHlpr.ActivePosition = new Position(0, 0, 0);
                        symbolGeomHlpr.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        arc = symbolGeomHlpr.CreateArc(null, corner[ID].CornerRad, (90 - Math3d.Deg(corner[ID].Alpha) - Math3d.Deg(corner[ID].Beta)) * Math.PI / 180);
                        matrix1 = new Matrix4X4();
                        matrix1.SetIdentity();
                        matrix1.Rotate((270 + Math3d.Deg(corner[ID].Beta)) * Math.PI / 180, new Vector(0, 0, 1));
                        arc.Transform(matrix1);

                        matrix1 = new Matrix4X4();
                        matrix1.SetIdentity();
                        matrix1.Translate(new Vector(plate.width1 - (corner[ID].CornerRad + corner[ID].CornerX), corner[ID].CornerRad + corner[ID].CornerY, 0));
                        arc.Transform(matrix1);
                        curveColl.Add(arc);
                        iCount = iCount + 1;
                        break;
                }

                // Draw optional line from Bottom Right corner to Bottom Left corner
                if (Math.Abs(BottomRightX - BottomLeftX) >= Math3d.DistanceTolerance)
                {
                    Line3d line = new Line3d(new Position(BottomRightX, BottomRightY, 0), new Position(BottomLeftX, BottomLeftY, 0));
                    curveColl.Add(line);
                    iCount = iCount + 1;
                }

                // Draw bottom left corner
                ID = 2;
                switch (corner[ID].CornerType)
                {
                    case 0:
                        // None - do nothing
                        break;
                    case 1:
                        // Rectangular Notch
                        // Draw from TR to inside corner to RT
                        Line3d line = new Line3d(new Position(BottomLeftX, BottomLeftY, 0), new Position(BottomLeftX, LeftBottomY, 0));
                        curveColl.Add(line);
                        iCount = iCount + 1;
                        line = new Line3d(new Position(BottomLeftX, LeftBottomY, 0), new Position(LeftBottomX, LeftBottomY, 0));
                        curveColl.Add(line);
                        iCount = iCount + 1;
                        break;
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        // Angle Notch
                        if (corner[ID].CornerRad > 0)
                        {
                            // Rounded
                            if (corner[ID].RoundedX == true)
                            {
                                symbolGeomHlpr = new SymbolGeometryHelper();
                                symbolGeomHlpr.ActivePosition = new Position(0, 0, 0);
                                symbolGeomHlpr.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                                Arc3d arc = symbolGeomHlpr.CreateArc(null, corner[ID].CornerRad, (90 - Common.Middle.Math3d.Deg(corner[ID].Alpha)) * Math.PI / 180);
                                matrix1 = new Matrix4X4();
                                matrix1.SetIdentity();
                                matrix1.Rotate((180 + Math3d.Deg(corner[ID].Alpha)) * Math.PI / 180, new Vector(0, 0, 1));
                                arc.Transform(matrix1);

                                matrix1 = new Matrix4X4();
                                matrix1.SetIdentity();
                                matrix1.Translate(new Vector(BottomLeftX, BottomLeftY + corner[ID].CornerRad, 0));
                                arc.Transform(matrix1);
                                curveColl.Add(arc);
                                iCount = iCount + 1;

                                dAngleNotchStartPtX = BottomLeftX - corner[ID].CornerRad * Math.Sin(corner[ID].Beta);
                                dAngleNotchStartPtY = BottomLeftY + corner[ID].CornerRad - corner[ID].CornerRad * Math.Cos(corner[ID].Beta);
                            }
                            else
                            {
                                dAngleNotchStartPtX = BottomLeftX;
                                dAngleNotchStartPtY = BottomLeftY;
                            }

                            if (corner[ID].RoundedY == true)
                            {
                                dAngleNotchEndPtX = LeftBottomX + corner[ID].CornerRad - corner[ID].CornerRad * Math.Cos(corner[ID].Alpha);
                                dAngleNotchEndPtY = LeftBottomY - corner[ID].CornerRad * Math.Sin(corner[ID].Alpha);
                            }
                            else
                            {
                                dAngleNotchEndPtX = LeftBottomX;
                                dAngleNotchEndPtY = LeftBottomY;
                            }
                            line = new Line3d(new Position(dAngleNotchStartPtX, dAngleNotchStartPtY, 0), new Position(dAngleNotchEndPtX, dAngleNotchEndPtY, 0));
                            curveColl.Add(line);
                            iCount = iCount + 1;

                            if (corner[ID].RoundedY == true)
                            {
                                symbolGeomHlpr = new SymbolGeometryHelper();
                                symbolGeomHlpr.ActivePosition = new Position(0, 0, 0);
                                symbolGeomHlpr.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                                Arc3d arc = symbolGeomHlpr.CreateArc(null, corner[ID].CornerRad, (Common.Middle.Math3d.Deg(corner[ID].Alpha)) * Math.PI / 180);
                                matrix1 = new Matrix4X4();
                                matrix1.SetIdentity();
                                matrix1.Rotate((180) * Math.PI / 180, new Vector(0, 0, 1));
                                arc.Transform(matrix1);

                                matrix1 = new Matrix4X4();
                                matrix1.SetIdentity();
                                matrix1.Translate(new Vector(LeftBottomX + corner[ID].CornerRad, LeftBottomY, 0));
                                arc.Transform(matrix1);
                                curveColl.Add(arc);
                                iCount = iCount + 1;
                            }
                        }
                        else
                        {
                            line = new Line3d(new Position(BottomLeftX, BottomLeftY, 0), new Position(LeftBottomX, LeftBottomY, 0));
                            curveColl.Add(line);
                            iCount = iCount + 1;
                        }
                        break;
                    case 6:
                        // Round Notch
                        if (corner[ID].CornerY > 0)
                        {
                            line = new Line3d(new Position(BottomLeftX, BottomLeftY, 0), new Position(BottomLeftX, BottomLeftY + corner[ID].CornerY, 0));
                            curveColl.Add(line);
                            iCount = iCount + 1;
                        }
                        symbolGeomHlpr = new SymbolGeometryHelper();
                        symbolGeomHlpr.ActivePosition = new Position(0, 0, 0);
                        symbolGeomHlpr.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        Arc3d arc1 = symbolGeomHlpr.CreateArc(null, corner[ID].CornerRad, (90 - Common.Middle.Math3d.Deg(corner[ID].Alpha) - Common.Middle.Math3d.Deg(corner[ID].Beta)) * Math.PI / 180);
                        matrix1 = new Matrix4X4();
                        matrix1.SetIdentity();
                        matrix1.Rotate((Math3d.Deg(corner[ID].Alpha)) * Math.PI / 180, new Vector(0, 0, 1));
                        arc1.Transform(matrix1);

                        matrix1 = new Matrix4X4();
                        matrix1.SetIdentity();
                        matrix1.Translate(new Vector(corner[ID].CornerX, corner[ID].CornerY, 0));
                        arc1.Transform(matrix1);

                        curveColl.Add(arc1);
                        iCount = iCount + 1;

                        if (corner[ID].CornerX > 0)
                        {
                            line = new Line3d(new Position(LeftBottomX + corner[ID].CornerX, LeftBottomY, 0), new Position(LeftBottomX, LeftBottomY, 0));
                            curveColl.Add(line);
                            iCount = iCount + 1;
                        }
                        break;
                    case 7:
                        // Rounded Corner
                        symbolGeomHlpr = new SymbolGeometryHelper();
                        symbolGeomHlpr.ActivePosition = new Position(0, 0, 0);
                        symbolGeomHlpr.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        arc1 = symbolGeomHlpr.CreateArc(null, corner[ID].CornerRad, (90 - Common.Middle.Math3d.Deg(corner[ID].Alpha) - Common.Middle.Math3d.Deg(corner[ID].Beta)) * Math.PI / 180);
                        matrix1 = new Matrix4X4();
                        matrix1.SetIdentity();
                        matrix1.Rotate((180 + Math3d.Deg(corner[ID].Alpha)) * Math.PI / 180, new Vector(0, 0, 1));
                        arc1.Transform(matrix1);

                        matrix1 = new Matrix4X4();
                        matrix1.SetIdentity();
                        matrix1.Translate(new Vector(corner[ID].CornerRad + corner[ID].CornerX, corner[ID].CornerRad + corner[ID].CornerY, 0));
                        arc1.Transform(matrix1);
                        curveColl.Add(arc1);
                        iCount = iCount + 1;
                        break;

                }

                // Draw optional line from Bottom Left corner to Top Left corner
                if (Math.Abs(LeftBottomY - LeftTopY) >= Math3d.DistanceTolerance)
                {
                    Line3d line = new Line3d(new Position(LeftBottomX, LeftBottomY, 0), new Position(LeftTopX, LeftTopY, 0));
                    curveColl.Add(line);
                    iCount = iCount + 1;
                }

                // Draw top left corner

                ID = 3;
                switch (corner[ID].CornerType)
                {
                    case 0:
                        // None - do nothing
                        break;
                    case 1:
                        // Rectangular Notch
                        // Draw from TR to inside corner to RT
                        Line3d line = new Line3d(new Position(LeftTopX, LeftTopY, 0), new Position(TopLeftX, LeftTopY, 0));
                        curveColl.Add(line);
                        iCount = iCount + 1;
                        line = new Line3d(new Position(TopLeftX, LeftTopY, 0), new Position(TopLeftX, TopLeftY, 0));
                        curveColl.Add(line);
                        iCount = iCount + 1;
                        break;
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        // Angle Notch
                        if (corner[ID].CornerRad > 0)
                        {
                            // Rounded
                            if (corner[ID].RoundedY == true)
                            {
                                symbolGeomHlpr = new SymbolGeometryHelper();
                                symbolGeomHlpr.ActivePosition = new Position(0, 0, 0);
                                symbolGeomHlpr.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                                Arc3d arc1 = symbolGeomHlpr.CreateArc(null, corner[ID].CornerRad, (Math3d.Deg(corner[ID].Alpha)) * Math.PI / 180);
                                matrix1 = new Matrix4X4();
                                matrix1.SetIdentity();
                                matrix1.Rotate((180 - Math3d.Deg(corner[ID].Alpha)) * Math.PI / 180, new Vector(0, 0, 1));
                                arc1.Transform(matrix1);

                                matrix1 = new Matrix4X4();
                                matrix1.SetIdentity();
                                matrix1.Translate(new Vector(LeftTopX + corner[ID].CornerRad, LeftTopY, 0));
                                arc1.Transform(matrix1);
                                curveColl.Add(arc1);
                                iCount = iCount + 1;
                                dAngleNotchStartPtX = LeftTopX + corner[ID].CornerRad - corner[ID].CornerRad * Math.Cos(corner[ID].Alpha);
                                dAngleNotchStartPtY = LeftTopY + corner[ID].CornerRad * Math.Sin(corner[ID].Alpha);
                            }
                            else
                            {
                                dAngleNotchStartPtX = LeftTopX;
                                dAngleNotchStartPtY = LeftTopY;
                            }

                            if (corner[ID].RoundedX == true)
                            {
                                dAngleNotchEndPtX = TopLeftX - corner[ID].CornerRad * Math.Sin(corner[ID].Beta);
                                dAngleNotchEndPtY = TopLeftY - corner[ID].CornerRad + corner[ID].CornerRad * Math.Cos(corner[ID].Beta);
                            }
                            else
                            {
                                dAngleNotchEndPtX = TopLeftX;
                                dAngleNotchEndPtY = TopLeftY;
                            }
                            line = new Line3d(new Position(dAngleNotchStartPtX, dAngleNotchStartPtY, 0), new Position(dAngleNotchEndPtX, dAngleNotchEndPtY, 0));
                            curveColl.Add(line);
                            iCount = iCount + 1;

                            if (corner[ID].RoundedX == true)
                            {
                                symbolGeomHlpr = new SymbolGeometryHelper();
                                symbolGeomHlpr.ActivePosition = new Position(0, 0, 0);
                                symbolGeomHlpr.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                                Arc3d arc1 = symbolGeomHlpr.CreateArc(null, corner[ID].CornerRad, (90 - Math3d.Deg(corner[ID].Alpha)) * Math.PI / 180);
                                matrix1 = new Matrix4X4();
                                matrix1.SetIdentity();
                                matrix1.Rotate((90) * Math.PI / 180, new Vector(0, 0, 1));
                                arc1.Transform(matrix1);

                                matrix1 = new Matrix4X4();
                                matrix1.SetIdentity();
                                matrix1.Translate(new Vector(TopLeftX, TopLeftY - corner[ID].CornerRad, 0));
                                arc1.Transform(matrix1);
                                curveColl.Add(arc1);
                                iCount = iCount + 1;
                            }
                        }
                        else
                        {
                            line = new Line3d(new Position(LeftTopX, LeftTopY, 0), new Position(TopLeftX, TopLeftY, 0));
                            curveColl.Add(line);
                            iCount = iCount + 1;
                        }
                        break;
                    case 6:
                        // Round Notch
                        if (corner[ID].CornerX > 0)
                        {
                            line = new Line3d(new Position(LeftTopX, LeftTopY, 0), new Position(LeftTopX + corner[ID].CornerX, LeftTopY, 0));
                            curveColl.Add(line);
                            iCount = iCount + 1;
                        }
                        symbolGeomHlpr = new SymbolGeometryHelper();
                        symbolGeomHlpr.ActivePosition = new Position(0, 0, 0);
                        symbolGeomHlpr.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        Arc3d arc = symbolGeomHlpr.CreateArc(null, corner[ID].CornerRad, (90 - Math3d.Deg(corner[ID].Alpha) - Math3d.Deg(corner[ID].Beta)) * Math.PI / 180);
                        matrix1 = new Matrix4X4();
                        matrix1.SetIdentity();
                        matrix1.Rotate((Math3d.Deg(corner[ID].Beta) + 270) * Math.PI / 180, new Vector(0, 0, 1));
                        arc.Transform(matrix1);

                        matrix1 = new Matrix4X4();
                        matrix1.SetIdentity();
                        matrix1.Translate(new Vector(corner[ID].CornerX, plate.length1 - corner[ID].CornerY, 0));
                        arc.Transform(matrix1);


                        curveColl.Add(arc);
                        iCount = iCount + 1;

                        if (corner[ID].CornerY > 0)
                        {
                            line = new Line3d(new Position(TopLeftX, TopLeftY - corner[ID].CornerY, 0), new Position(TopLeftX, TopLeftY, 0));
                            curveColl.Add(line);
                            iCount = iCount + 1;
                        }
                        break;
                    case 7:
                        // Rounded Corner
                        symbolGeomHlpr = new SymbolGeometryHelper();
                        symbolGeomHlpr.ActivePosition = new Position(0, 0, 0);
                        symbolGeomHlpr.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                        arc = symbolGeomHlpr.CreateArc(null, corner[ID].CornerRad, (90 - Math3d.Deg(corner[ID].Alpha) - Math3d.Deg(corner[ID].Beta)) * Math.PI / 180);
                        matrix1 = new Matrix4X4();
                        matrix1.SetIdentity();
                        matrix1.Rotate((90 + Math3d.Deg(corner[ID].Beta)) * Math.PI / 180, new Vector(0, 0, 1));
                        arc.Transform(matrix1);

                        matrix1 = new Matrix4X4();
                        matrix1.SetIdentity();
                        matrix1.Translate(new Vector(corner[ID].CornerRad + corner[ID].CornerX, plate.length1 - (corner[ID].CornerRad + corner[ID].CornerY), 0));
                        arc.Transform(matrix1);
                        curveColl.Add(arc);
                        iCount = iCount + 1;
                        break;
                }
                // Do we need a curved notch on the end?
                if (plate.curvedEndRad > 0)
                {
                    if (Math.Abs(CurvedEndLeftX - TopLeftX) >= Math3d.DistanceTolerance)
                    {
                        Line3d line = new Line3d(new Position(TopLeftX, TopLeftY, 0), new Position(CurvedEndLeftX, TopLeftY, 0));
                        curveColl.Add(line);
                        iCount = iCount + 1;
                    }
                    symbolGeomHlpr = new SymbolGeometryHelper();
                    symbolGeomHlpr.ActivePosition = new Position(0, 0, 0);
                    symbolGeomHlpr.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    Arc3d arc = symbolGeomHlpr.CreateArc(null, plate.curvedEndRad, (2 * Math3d.Deg(dCurvedEndAlpha)) * Math.PI / 180);
                    matrix1 = new Matrix4X4();
                    matrix1.SetIdentity();
                    matrix1.Rotate((270 - Math3d.Deg(dCurvedEndAlpha)) * Math.PI / 180, new Vector(0, 0, 1));
                    arc.Transform(matrix1);

                    matrix1 = new Matrix4X4();
                    matrix1.SetIdentity();
                    matrix1.Translate(new Vector(plate.width1 / 2.0 + plate.curvedEndX, plate.length1 + plate.curvedEndY, 0));
                    arc.Transform(matrix1);

                    curveColl.Add(arc);
                    iCount = iCount + 1;

                    if (Math.Abs(CurvedEndRightX - TopRightX) >= Math3d.DistanceTolerance)
                    {
                        Line3d line = new Line3d(new Position(CurvedEndRightX, TopRightY, 0), new Position(TopRightX, TopRightY, 0));
                        curveColl.Add(line);
                        iCount = iCount + 1;
                    }
                }
                else
                {
                    // No curved notch.
                    // Draw optional line from Top Left corner to Top Right corner
                    if (Math.Abs(TopLeftX - TopRightX) >= Math3d.DistanceTolerance)
                    {
                        Line3d line = new Line3d(new Position(TopLeftX, TopLeftY, 0), new Position(TopRightX, TopRightY, 0));
                        curveColl.Add(line);
                        iCount = iCount + 1;
                    }
                }

                // Done with iCount, remove the last increment as it was for the "next" object to be added
                iCount = iCount - 1;

                // Make sure outputs match what we expected.
                if (iCount != nPts)
                    sError.Append("iCount of " + iCount + " doesn't match nPts of " + nPts);
                if (sError.Length > 0)
                    ToDoListMessage = new ToDoListMessage(ToDoMessageTypes.ToDoMessageWarning, sError.ToString());

                ComplexString3d complexString = new ComplexString3d(curveColl);

                if (plate.Hole1Diameter > 0)
                {
                    //Error Checking

                    if ((plate.Hole1HInset + (plate.Hole1Diameter / 2)) >= plate.width1)
                    {
                        RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddPlateShapeWithHoleHoleH1Inset, "Error in Hole1HInset input of plate with hole");
                    }
                    if ((plate.Hole1VInset + (plate.Hole1Diameter / 2)) >= plate.length1)
                    {
                        RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddPlateShapeWithHoleHole1VInset, "Error in Hole1VInset input of plate with hole");
                    }
                    if (plate.Hole1Diameter >= plate.width1)
                    {
                        RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddPlateShapeWithHoleHole1Diameter, "Error in Hole1Diameter input of plate with hole");
                    }

                    SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();

                    List<ComplexString3d> Platepipeclamplist = new List<ComplexString3d>();

                    Platepipeclamplist.Add(complexString);

                    Circle3d CircleObj = new Circle3d(new Position(plate.Hole1HInset + (plate.width1 / 2), plate.Hole1VInset + (plate.length1 / 2), 0), new Vector(0, 0, 1), plate.Hole1Diameter / 2);
                    Collection<ICurve> Platepipeclampcurvecollection = new Collection<ICurve>();

                    Platepipeclampcurvecollection.Add(CircleObj);

                    ComplexString3d complexStringplatepipeclamp = new ComplexString3d(Platepipeclampcurvecollection);

                    Platepipeclamplist.Add(complexStringplatepipeclamp);

                    Plane3d platewithhole1 = symbolGeometryHelper.CreatePlaneWithHoles(OccurrenceConnection, Platepipeclamplist);

                    Plane3d platewithhole2 = symbolGeometryHelper.CreatePlaneWithHoles(OccurrenceConnection, Platepipeclamplist);

                    platewithhole1.Transform(matrix);
                    outputs.Add(outputName + "Plane1", platewithhole1);

                    // Get plane normal vector
                    Vector vector1 = new Vector();
                    vector1 = platewithhole1.Normal;

                    if (vector1 != null)
                    {
                        matrix.Translate(new Vector(-plate.thickness1 * vector1.X, -plate.thickness1 * vector1.Y, -plate.thickness1 * vector1.Z));
                    }
                    platewithhole2.Transform(matrix);
                    outputs.Add(outputName + "Plane2", platewithhole2);

                    Collection<ComplexString3d> complexstring1 = new Collection<ComplexString3d>();
                    platewithhole1.GetBoundaries(out complexstring1);

                    ICurve botcurve = null, botplane = null, topcurve = null, topplane = null;
                    if (complexstring1 != null)
                    {

                        topcurve = (ICurve)complexstring1[1];
                        topplane = (ICurve)complexstring1[0];


                    }
                    Collection<ComplexString3d> complexstring2 = new Collection<ComplexString3d>();
                    platewithhole2.GetBoundaries(out complexstring2);
                    if (complexstring2 != null)
                    {
                        botcurve = (ICurve)complexstring2[1];
                        botplane = (ICurve)complexstring2[0];
                    }

                    Ruled3d rule3d = new Ruled3d(botcurve, topcurve, false);
                    Ruled3d rule3d1 = new Ruled3d(botplane, topplane, false);

                    outputs.Add(outputName + "rule3d", rule3d);
                    outputs.Add(outputName + "rule3d1", rule3d1);
                }
                else
                {
                    Projection3d proj = new Projection3d(complexString, new Vector(0, 0, 1), plate.thickness1, true);
                    proj.Transform(matrix);
                    outputs.Add(outputName, proj);
                }
            }
            catch (SmartPartSymbolException hgrEx)
            {
                throw hgrEx;
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddPlateShapeWithHoleMethod, "Error in AddPlateShapewithHole");
                }
            }
        }

        /// <summary>
        /// Defines the inputs for the GripPipeClamp.
        /// </summary>
        public struct GripClampInputs
        {
            public double Diameter1;
            public double Height1;
            public double Height2;
            public double RodDiameter;
            public double Angle1;
            public double Angle2;
            public double Offset1;
            public double Offset2;
            public double Offset3;
            public double Width1;
            public double Thickness1;
            public double Width2;
            public double Thickness2;

        }
        /// <summary>
        /// Loads the GripPipeClamp Data
        /// </summary>
        public GripClampInputs LoadGripClampData(int startIndex, out int endIndex)
        {
            GripClampInputs gripClampInputs = new GripClampInputs();
            try
            {
                gripClampInputs.Diameter1 = GetDoubleInputValue(startIndex);
                gripClampInputs.Height1 = GetDoubleInputValue(++startIndex);
                gripClampInputs.Height2 = GetDoubleInputValue(++startIndex);
                gripClampInputs.RodDiameter = GetDoubleInputValue(++startIndex);
                gripClampInputs.Angle1 = GetDoubleInputValue(++startIndex);
                gripClampInputs.Angle2 = GetDoubleInputValue(++startIndex);
                gripClampInputs.Offset1 = GetDoubleInputValue(++startIndex);
                gripClampInputs.Offset2 = GetDoubleInputValue(++startIndex);
                gripClampInputs.Offset3 = GetDoubleInputValue(++startIndex);
                gripClampInputs.Width1 = GetDoubleInputValue(++startIndex);
                gripClampInputs.Thickness1 = GetDoubleInputValue(++startIndex);
                gripClampInputs.Width2 = GetDoubleInputValue(++startIndex);
                gripClampInputs.Thickness2 = GetDoubleInputValue(++startIndex);

            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadGripclampData, "Error occured in LoadGripclampData Method.");
                }
            }
            endIndex = startIndex;
            return gripClampInputs;
        }

        /// <summary>
        /// Create the graphical representation of a gripclamp
        /// </summary>
        public void AddGripClamp(GripClampInputs gripClampInputs, Matrix4X4 matrix, OutputDictionary outputs, String outputName)
        {

            try
            {
                //=================================================
                // Construction of rodgrippers
                //=================================================
                int index = 0;
                Vector TanDir1; double TanLen1; double Sin1; double Cos1;
                Vector TanDir2; double TanLen2; double Sin2; double Cos2;
                double Outerrad = gripClampInputs.Diameter1 / 2 + gripClampInputs.RodDiameter / 2;

                // arc1
                EllipticalArc3d arc1 = new EllipticalArc3d(new Position(0, 0, 0), new Vector(-1, 0, 0), new Vector(0, -Outerrad, 0), 1, 0, gripClampInputs.Angle1);
                Sin1 = Math.Sin(gripClampInputs.Angle1); 
                Cos1 = Math.Cos(gripClampInputs.Angle1);
                TanDir1 = new Vector(0, Sin1, Cos1);
                TanLen1 = (gripClampInputs.Offset1 - (Outerrad) * Sin1) / Cos1;

                // line1
                Line3d line1 = new Line3d(arc1.EndPoint, TanDir1, TanLen1);

                // arc2
                EllipticalArc3d arc2 = new EllipticalArc3d(new Position(0, 0, 0), new Vector(1, 0, 0), new Vector(0, -Outerrad, 0), 1, 0, gripClampInputs.Angle2);
                Sin2 = Math.Sin(gripClampInputs.Angle2); Cos2 = Math.Cos(gripClampInputs.Angle2);
                TanDir2 = new Vector(0, Sin2, -Cos2);
                TanLen2 = (gripClampInputs.Offset2 - (Outerrad) * Sin2) / Cos2;

                // line1
                Line3d line2 = new Line3d(arc2.EndPoint, TanDir2, TanLen2);

                //Circlel1
                Circle3d circlel1 = new Circle3d(line1.EndPoint, new Vector(0, -Sin1, -Cos1), gripClampInputs.RodDiameter / 2);

                Collection<ICurve> curveCollection = new Collection<ICurve>();

                Line3d l1 = new Line3d(line1.EndPoint, line1.StartPoint); curveCollection.Add(l1);
                Arc3d a = new Arc3d(line1.StartPoint, arc1.StartPoint, arc2.EndPoint); curveCollection.Add(a);
                Line3d l2 = new Line3d(arc2.EndPoint, line2.EndPoint); curveCollection.Add(l2);

                ComplexString3d lineString1 = new ComplexString3d(curveCollection);

                matrix.SetIdentity(); index = 0;
                matrix.Translate(new Vector(gripClampInputs.Width1 / 10, 0, 0));
                Collection<Surface3d> LeftGripSurfaces1 = new Collection<Surface3d>();
                LeftGripSurfaces1 = Surface3d.GetSweepSurfacesFromCurve(lineString1, circlel1, (SurfaceSweepOptions)1);

                foreach (Surface3d item in LeftGripSurfaces1)
                {
                    LeftGripSurfaces1[index].Transform(matrix);
                    outputs.Add(outputName + "leftsweep1" + index, item);
                    ++index;
                }

                matrix.SetIdentity(); index = 0;
                matrix.Translate(new Vector(-gripClampInputs.Width1 / 10, 0, 0));
                Collection<Surface3d> LeftGripSurfaces2 = new Collection<Surface3d>();
                LeftGripSurfaces2 = Surface3d.GetSweepSurfacesFromCurve(lineString1, circlel1, (SurfaceSweepOptions)1);

                foreach (Surface3d item in LeftGripSurfaces2)
                {
                    LeftGripSurfaces2[index].Transform(matrix);
                    outputs.Add(outputName + "leftsweep2" + index, item);
                    ++index;
                }

                matrix.SetIdentity(); index = 0;
                matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                matrix.Translate(new Vector(gripClampInputs.Width1 / 10 + gripClampInputs.RodDiameter + gripClampInputs.Thickness2, 0, 0));
                Collection<Surface3d> rightGripSurfaces1 = new Collection<Surface3d>();
                rightGripSurfaces1 = Surface3d.GetSweepSurfacesFromCurve(lineString1, circlel1, (SurfaceSweepOptions)1);

                foreach (Surface3d item in rightGripSurfaces1)
                {
                    rightGripSurfaces1[index].Transform(matrix);
                    outputs.Add(outputName + "rightsweep1" + index, item);
                    ++index;
                }

                matrix.SetIdentity(); index = 0;
                matrix.Rotate(Math.PI, new Vector(0, 0, 1));
                matrix.Translate(new Vector(-gripClampInputs.Width1 / 10 - gripClampInputs.RodDiameter - gripClampInputs.Thickness2, 0, 0));
                Collection<Surface3d> rightGripSurfaces2 = new Collection<Surface3d>();
                rightGripSurfaces2 = Surface3d.GetSweepSurfacesFromCurve(lineString1, circlel1, (SurfaceSweepOptions)1);

                foreach (Surface3d item in rightGripSurfaces2)
                {
                    rightGripSurfaces2[index].Transform(matrix);
                    outputs.Add(outputName + "rightsweep2" + index, item);
                    ++index;
                }

                //=================================================
                // Construction of Topplate
                //=================================================

                SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();
                symbolGeometryHelper.ActivePosition = new Position(0, 0, gripClampInputs.Diameter1 / 2);
                symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(1, 0, 0));
                Projection3d topPlate = (Projection3d)symbolGeometryHelper.CreateBox(null, gripClampInputs.Height1 - gripClampInputs.Diameter1 / 2, gripClampInputs.Width1, gripClampInputs.Thickness1);
                outputs.Add(outputName + "TopPlate", topPlate);

                //=================================================
                // Construction of Bottomplates
                //=================================================

                matrix = new Matrix4X4();
                matrix.SetIdentity();
                double boltAngle = Math.Asin(gripClampInputs.Width2 / gripClampInputs.Diameter1);

                EllipticalArc3d bota1 = new EllipticalArc3d(new Position(0, 0, 0), new Vector(1, 0, 0), new Vector(0, 0, -gripClampInputs.Diameter1 / 2), 1, 0, boltAngle);
                EllipticalArc3d bota2 = new EllipticalArc3d(new Position(0, 0, 0), new Vector(-1, 0, 0), new Vector(0, 0, -gripClampInputs.Diameter1 / 2), 1, 0, boltAngle);

                Collection<Position> pointsCollection = new Collection<Position>();
                Collection<Position> pointsCollection3 = new Collection<Position>();
                Collection<Position> pointsCollection4 = new Collection<Position>();

                double By = 0.2 * (gripClampInputs.Width2);
                double Bz = -gripClampInputs.Height2 + 0.4 * By;

                pointsCollection.Add(new Position(0, By, Bz));
                pointsCollection.Add(new Position(0, 0, -gripClampInputs.Height2));
                pointsCollection.Add(new Position(0, -By, Bz));

                Line3d botlk1 = new Line3d(new Position(0, By, Bz), new Vector(0, Cos2, Sin2), 0.3);
                Line3d botlv1 = new Line3d(bota1.EndPoint, new Vector(0, 0, -1), 0.3);

                GeometryIntersectionType value;
                botlv1.Intersect(botlk1, out pointsCollection3, out pointsCollection4, out value);
                double BIx = pointsCollection3[0].X;
                double BIy = pointsCollection3[0].Y;
                double BIz = pointsCollection3[0].Z;

                Collection<ICurve> curveCollectionBot = new Collection<ICurve>();

                BSplineCurve3d bottomPlateCurve = new BSplineCurve3d(3, pointsCollection, new Vector(0, -Cos2, -Sin2), new Vector(0, -Cos2, Sin2), false, false); 
                curveCollectionBot.Add(bottomPlateCurve);
                
                Line3d bLeftTanline1 = new Line3d(new Position(0, -By, Bz), new Position(BIx, -BIy, BIz)); 
                curveCollectionBot.Add(bLeftTanline1);
                
                Line3d bLeftVerline1 = new Line3d(new Position(BIx, -BIy, BIz), bota2.EndPoint); 
                curveCollectionBot.Add(bLeftVerline1);
                
                Arc3d bArc = new Arc3d(bota2.EndPoint, bota2.StartPoint, bota1.EndPoint); 
                curveCollectionBot.Add(bArc);
                
                Line3d bRightVerline1 = new Line3d(bota1.EndPoint, pointsCollection3[0]); 
                curveCollectionBot.Add(bRightVerline1);
                
                Line3d bRightTanline1 = new Line3d(pointsCollection3[0], new Position(0, By, Bz)); 
                curveCollectionBot.Add(bRightTanline1);

                ComplexString3d lineStringBot = new ComplexString3d(curveCollectionBot);

                Projection3d botPlateProj1 = new Projection3d(lineStringBot, new Vector(1, 0, 0), gripClampInputs.Thickness2, true);
                matrix.SetIdentity();
                matrix.Translate(new Vector(gripClampInputs.Width1 / 10 + gripClampInputs.RodDiameter / 2, 0, 0));
                botPlateProj1.Transform(matrix);

                Projection3d botPlateProj2 = new Projection3d(lineStringBot, new Vector(-1, 0, 0), gripClampInputs.Thickness2, true);
                matrix.SetIdentity();
                matrix.Translate(new Vector(-gripClampInputs.Width1 / 10 - gripClampInputs.RodDiameter / 2, 0, 0));
                botPlateProj2.Transform(matrix);

                outputs.Add(outputName + "BotPlateProj1", botPlateProj1);
                outputs.Add(outputName + "BotPlateProj2", botPlateProj2);

                //=================================================
                // Construction of Tangentialplates
                //=================================================

                Collection<Position> pointsCollection5 = new Collection<Position>();
                Collection<Position> pointsCollection6 = new Collection<Position>();

                GeometryIntersectionType value2;
                line2.Intersect(botlk1, out pointsCollection5, out pointsCollection6, out value2);

                SymbolGeometryHelper symbolGeometryHelper1 = new SymbolGeometryHelper();
                double tanPlate1Width = (2 * gripClampInputs.RodDiameter + 2 * gripClampInputs.Thickness2 + 0.2 * gripClampInputs.Width1);

                Projection3d tanPlate1 = (Projection3d)symbolGeometryHelper1.CreateBox(null, tanPlate1Width, 2 * gripClampInputs.RodDiameter, gripClampInputs.Thickness2);
                matrix.SetIdentity();
                matrix.Translate(new Vector(pointsCollection5[0].X - tanPlate1Width / 2, pointsCollection5[0].Y, pointsCollection5[0].Z));
                matrix.Rotate(gripClampInputs.Angle2, new Vector(1, 0, 0));
                tanPlate1.Transform(matrix);
                outputs.Add(outputName + "tanPlate1", tanPlate1);

                SymbolGeometryHelper symbolGeometryHelper2 = new SymbolGeometryHelper();
                Projection3d tanPlate2 = (Projection3d)symbolGeometryHelper2.CreateBox(null, gripClampInputs.Width1, 2 * gripClampInputs.RodDiameter, gripClampInputs.Thickness2);
                matrix.SetIdentity();
                matrix.Translate(new Vector(pointsCollection5[0].X - gripClampInputs.Width1 / 2, -pointsCollection5[0].Y, pointsCollection5[0].Z));
                matrix.Rotate(-gripClampInputs.Angle2, new Vector(1, 0, 0));
                tanPlate2.Transform(matrix);
                outputs.Add(outputName + "tanPlate2", tanPlate2);
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddGripclampData, "Error in AddGripclampData");
                }
            }
        }

        /// <summary>
        /// Defines the inputs for the Horizontal Traveler Inputs.
        /// </summary>
        public struct HorizontalTravelerInputs
        {
            public double Thickness1;
            public double Height1;
            public double Width1;
            public double Length1;
            public double Thickness2;
            public double Height2;
            public double Width2;
            public double Width3;
            public double Height3;
            public double Thickness3;
            public double Offset1;
            public double HoleDiameter;
            public int SimpleShapeType;
            public double LugOffset;
        }

        /// <summary>
        /// Defines the inputs for the Horizontal Traveler Inputs.
        /// </summary>
        public struct LugPlateInputs
        {
            public double Thickness1;
            public double Length1;
            public double Width1;
            public double Thickness2;
            public double Height2;
            public double Width2;
            public double Offset1;
            public double HoleDiameter;
            public int TLCornerType;
            public double TLCornerX;
            public double TLCornerY;
            public double TLCornerRadius;
            public int TRCornerType;
            public double TRCornerX;
            public double TRCornerY;
            public double TRCornerRadius;
        }

        /// <summary>
        /// Load Lug Plate Input Data
        /// </summary>
        public LugPlateInputs LoadLugPlateData(int startIndex, out int endIndex)
        {
            LugPlateInputs lugPlateInputs = new LugPlateInputs();
            try
            {
                lugPlateInputs.Thickness1 = GetDoubleInputValue(startIndex);
                lugPlateInputs.Length1 = GetDoubleInputValue(++startIndex);
                lugPlateInputs.Width1 = GetDoubleInputValue(++startIndex);
                lugPlateInputs.Thickness2 = GetDoubleInputValue(++startIndex);
                lugPlateInputs.Height2 = GetDoubleInputValue(++startIndex);
                lugPlateInputs.Width2 = GetDoubleInputValue(++startIndex);
                lugPlateInputs.Offset1 = GetDoubleInputValue(++startIndex);
                lugPlateInputs.HoleDiameter = GetDoubleInputValue(++startIndex);

                lugPlateInputs.TLCornerType = (int)GetDoubleInputValue(++startIndex);
                lugPlateInputs.TLCornerX = GetDoubleInputValue(++startIndex);
                lugPlateInputs.TLCornerY = GetDoubleInputValue(++startIndex);
                lugPlateInputs.TLCornerRadius = GetDoubleInputValue(++startIndex);

                lugPlateInputs.TRCornerType = (int)GetDoubleInputValue(++startIndex);
                lugPlateInputs.TRCornerX = GetDoubleInputValue(++startIndex);
                lugPlateInputs.TRCornerY = GetDoubleInputValue(++startIndex);
                lugPlateInputs.TRCornerRadius = GetDoubleInputValue(++startIndex);
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadLugPlateData, "Error occured in LoadLugPlateData Method.");
                }
            }
            endIndex = startIndex;
            return lugPlateInputs;
        }

        /// <summary>
        /// Load Horizontal Traveler Input Data
        /// </summary>
        public HorizontalTravelerInputs LoadHorizontalTravelerData(int startIndex, out int endIndex)
        {
            HorizontalTravelerInputs horizontalTravelerInputs = new HorizontalTravelerInputs();
            try
            {
                horizontalTravelerInputs.Thickness1 = GetDoubleInputValue(startIndex);
                horizontalTravelerInputs.Height1 = GetDoubleInputValue(++startIndex);
                horizontalTravelerInputs.Width1 = GetDoubleInputValue(++startIndex);
                horizontalTravelerInputs.Length1 = GetDoubleInputValue(++startIndex);
                horizontalTravelerInputs.Thickness2 = GetDoubleInputValue(++startIndex);
                horizontalTravelerInputs.Height2 = GetDoubleInputValue(++startIndex);
                horizontalTravelerInputs.Width2 = GetDoubleInputValue(++startIndex);
                horizontalTravelerInputs.Width3 = GetDoubleInputValue(++startIndex);
                horizontalTravelerInputs.Height3 = GetDoubleInputValue(++startIndex);
                horizontalTravelerInputs.Thickness3 = GetDoubleInputValue(++startIndex);
                horizontalTravelerInputs.Offset1 = GetDoubleInputValue(++startIndex);
                horizontalTravelerInputs.HoleDiameter = GetDoubleInputValue(++startIndex);
                horizontalTravelerInputs.SimpleShapeType = (int)GetDoubleInputValue(++startIndex);
                horizontalTravelerInputs.LugOffset = GetDoubleInputValue(++startIndex);

            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadHorizontalTravelerData, "Error occured in LoadHorizontalTravelerData Method.");
                }
            }
            endIndex = startIndex;
            return horizontalTravelerInputs;
        }

        /// <summary>
        /// Create the graphical representation of Horizontal Traveler Data
        /// </summary>
        public void AddHorizontalTraveler(HorizontalTravelerInputs horizontalTravelerInputs, Matrix4X4 matrix, OutputDictionary outputs, String outputName)
        {
            try
            {
                String[] objectColl = new String[10];
                int objectCount = 0;

                double sideBlock1Thk = horizontalTravelerInputs.Thickness1;
                double sideBlock1Height = horizontalTravelerInputs.Height1;
                double sideBlock1Length = horizontalTravelerInputs.Length1;
                double sideBlockGap = horizontalTravelerInputs.Width1;

                double sideBlock2Thk = horizontalTravelerInputs.Thickness1;
                double sideBlock2Height = horizontalTravelerInputs.Height1;
                double sideBlock2Length = horizontalTravelerInputs.Length1;

                double endPlateHeight = horizontalTravelerInputs.Height2;
                double endPlateThk = horizontalTravelerInputs.Thickness2;
                double endPlateWidth = horizontalTravelerInputs.Width2;

                double lugPlateHeight = horizontalTravelerInputs.Height3;
                double lugPlateWidth = horizontalTravelerInputs.Width3;
                double lugPlateThk = horizontalTravelerInputs.Thickness3;
                double lugPlateOffset = horizontalTravelerInputs.LugOffset;

                int shapeType = horizontalTravelerInputs.SimpleShapeType;

                //Add side plate
                SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();

                if (sideBlock1Thk > 0 && sideBlock1Height > 0 && sideBlock1Length > 0)
                {
                    symbolGeometryHelper.ActivePosition = new Position(-(sideBlockGap - sideBlock1Thk) / 2, 0, sideBlock1Thk - sideBlock1Height);
                    symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(1, 0, 0));

                    BusinessObject sideBlock1 = symbolGeometryHelper.CreateBox(null, sideBlock1Height - sideBlock1Thk, sideBlock1Thk, sideBlock1Length);
                    outputs.Add(outputName + "sideBlock1", sideBlock1);
                    ++objectCount;
                    objectColl[objectCount] = outputName + "sideBlock1";

                    if (sideBlock1Thk > 0 && sideBlock1Height > 0 && sideBlock1Length > 0 && sideBlockGap > 0)
                    {
                        symbolGeometryHelper.ActivePosition = new Position((sideBlockGap - sideBlock1Thk) / 2, 0, sideBlock1Thk - sideBlock2Height);
                        symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(1, 0, 0));

                        BusinessObject sideBlock2 = symbolGeometryHelper.CreateBox(null, sideBlock2Height - sideBlock2Thk, sideBlock2Thk, sideBlock2Length);
                        outputs.Add(outputName + "sideBlock2", sideBlock2);
                        ++objectCount;
                        objectColl[objectCount] = outputName + "sideBlock2";
                    }
                }

                symbolGeometryHelper.ActivePosition = new Position(0, 0, -sideBlock2Height);
                symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(1, 0, 0));

                BusinessObject basePlate = symbolGeometryHelper.CreateBox(null, sideBlock2Thk, sideBlockGap, sideBlock1Length);
                outputs.Add(outputName + "basePlate", basePlate);
                ++objectCount;
                objectColl[objectCount] = outputName + "basePlate";

                if (endPlateHeight > 0 && endPlateThk > 0 && endPlateWidth > 0)
                {
                    symbolGeometryHelper.ActivePosition = new Position(0, (sideBlock1Length + endPlateThk) / 2, -endPlateHeight);
                    symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(1, 0, 0));

                    BusinessObject endPlate1 = symbolGeometryHelper.CreateBox(null, endPlateHeight, endPlateWidth, endPlateThk);
                    outputs.Add(outputName + "endPlate1", endPlate1);
                    ++objectCount;
                    objectColl[objectCount] = outputName + "endPlate1";

                    symbolGeometryHelper.ActivePosition = new Position(0, -(sideBlock1Length + endPlateThk) / 2, -endPlateHeight);
                    symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(1, 0, 0));

                    BusinessObject endPlate2 = symbolGeometryHelper.CreateBox(null, endPlateHeight, endPlateWidth, endPlateThk);
                    outputs.Add(outputName + "endPlate2", endPlate2);
                    ++objectCount;
                    objectColl[objectCount] = outputName + "endPlate2";
                }

                PlateInputs plate = new PlateInputs();
                plate.width1 = lugPlateHeight;
                plate.length1 = lugPlateWidth;
                plate.thickness1 = lugPlateThk;

                if (shapeType == 1)
                {
                    plate.tlCornerType = 7;
                    plate.tlCornerRad = lugPlateWidth / 2;
                    plate.trCornerType = 7;
                    plate.trCornerRad = lugPlateWidth / 2;
                    plate.blCornerType = 7;
                    plate.blCornerRad = lugPlateWidth / 2;
                    plate.brCornerType = 7;
                    plate.brCornerRad = lugPlateWidth / 2;
                }

                Matrix4X4 platematrix = new Matrix4X4();
                platematrix.SetIdentity();
                platematrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));

                platematrix.Translate(new Vector(-lugPlateThk / 2, lugPlateOffset - lugPlateWidth / 2, 0));
                AddPlate(plate, platematrix, outputs, outputName + "lugPlate");
                ++objectCount;
                objectColl[objectCount] = outputName + "lugPlate";
            }

            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddHorizontalTraveler,"Error occured in AddHorizontalTravelerData Method.");
                }
            }
        }

        /// <summary>
        /// Create the graphical representation of Horizontal Traveler Data
        /// </summary>
        public void AddLugPlate(LugPlateInputs lugplateInputs, Matrix4X4 matrix, OutputDictionary outputs, String outputName)
        {
            try
            {
                String[] objectColl = new String[10];
                int objectCount = 0;

                double basePlateThk = lugplateInputs.Thickness1;
                double basePlateLength = lugplateInputs.Length1;
                double basePlateWidth = lugplateInputs.Width1;

                double lugPlateHeight = lugplateInputs.Height2;
                double lugPlateWidth = lugplateInputs.Width2;
                double lugPlateThk = lugplateInputs.Thickness2;

                //Add Base Plate
                SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();

                symbolGeometryHelper.ActivePosition = new Position(0, 0, -basePlateThk);
                symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(1, 0, 0));

                BusinessObject basePlate = symbolGeometryHelper.CreateBox(null, basePlateThk, basePlateWidth, basePlateLength);
                outputs.Add(outputName + "basePlate", basePlate);
                ++objectCount;
                objectColl[objectCount] = outputName + "basePlate";

                PlateInputs plate = new PlateInputs();
                plate.width1 = lugPlateHeight;
                plate.length1 = lugPlateWidth;
                plate.thickness1 = lugPlateThk;
                plate.brCornerType = lugplateInputs.TLCornerType;
                plate.brCornerX = lugplateInputs.TLCornerX;
                plate.brCornerY = lugplateInputs.TLCornerY;
                plate.brCornerRad = lugplateInputs.TLCornerRadius;
                plate.trCornerType = lugplateInputs.TRCornerType;
                plate.trCornerX = lugplateInputs.TRCornerX;
                plate.trCornerY = lugplateInputs.TRCornerY;
                plate.trCornerRad = lugplateInputs.TRCornerRadius;

                Matrix4X4 platematrix = new Matrix4X4();
                platematrix.SetIdentity();
                platematrix.Rotate(Math.PI / 2, new Vector(0, 1, 0));

                platematrix.Translate(new Vector(-lugPlateThk / 2, -lugPlateWidth / 2, -basePlateThk));
                AddPlate(plate, platematrix, outputs, outputName + "lugPlate");
                ++objectCount;
                objectColl[objectCount] = outputName + "lugPlate";
            }

            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddLugPlate, "Error occured in ErrAddLugPlate Method.");
                }
            }
        }

        /// <summary>
        /// Defines the inputs for the Pipe Saddle.
        /// </summary>
        public struct PipeSaddleInputs
        {
            public int BottomShapeType;
            public double Width;
            public double Length;
            public double Height;
            public int Multi1Qty;
            public int Multi1LocateBy;
            public double Multi1Location;
            public double PipeOD;

            /// <summary>
            ///The UBolt input parameter type.
            /// </summary>
            public UBoltInputs UBolt;
            /// <summary>
            ///The Nut1 input parameter type.
            /// </summary>
            public NutInputs Nut1;
            /// <summary>
            ///The Nut2 input parameter type.
            /// </summary>
            public NutInputs Nut2;
            /// <summary>
            ///The Nut3 input parameter type.
            /// </summary>
            public NutInputs Nut3;
            /// <summary>
            ///The Nut4 input parameter type.
            /// </summary>
            public NutInputs Nut4;
            /// <summary>
            ///The Strap input parameter type.
            /// </summary>
            public StrapInputs Strap;
        }

        /// <summary>
        ///Add Pipe Saddle Inputs.
        /// </summary>
        public void AddPipeSaddleInputs(int startIndex, out int endIndex, List<Input> additionalInputs)
        {
            try
            {
                additionalInputs.Add(new InputDouble(++startIndex, "ShapeType", "ShapeType", 1, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Width", "Width", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Length", "Length", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Height", "Height", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Multi1Qty", "Multi1Qty", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Multi1LocateBy", "Multi1LocateBy", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "Multi1Location", "Multi1Location", 0, false));
                additionalInputs.Add(new InputDouble(++startIndex, "PipeOD", "PipeOD", 0, false));

                AddUBoltInputs(++startIndex, out endIndex, additionalInputs);
                startIndex = endIndex;

                AddNutInputs(startIndex, 4, out endIndex, additionalInputs);
                startIndex = endIndex;

                AddStrapInputs(++startIndex, out endIndex, additionalInputs);
                startIndex = endIndex;
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddPipeSaddleInputs, "Error occured in Add PipeSaddleInputs Method.");
            }
            endIndex = startIndex;
        }

        /// <summary>
        /// This method will be called by user symbol to get value of an input during construction of outputs. 
        /// Given the start index, this method will return the value of the Pipe Saddle object.
        /// </summary>
        public PipeSaddleInputs LoadPipeSaddleData(int startIndex)
        {
            PipeSaddleInputs pipeSaddle = new PipeSaddleInputs();
            try
            {
                int endIndex;
                pipeSaddle.BottomShapeType = (int)GetDoubleInputValue(++startIndex);
                pipeSaddle.Width = GetDoubleInputValue(++startIndex);
                pipeSaddle.Length = GetDoubleInputValue(++startIndex);
                pipeSaddle.Height = GetDoubleInputValue(++startIndex);
                pipeSaddle.Multi1Qty = (int)GetDoubleInputValue(++startIndex);
                pipeSaddle.Multi1LocateBy = (int)GetDoubleInputValue(++startIndex);
                pipeSaddle.Multi1Location = GetDoubleInputValue(++startIndex);
                pipeSaddle.PipeOD = GetDoubleInputValue(++startIndex);

                pipeSaddle.UBolt = LoadUBoltData(++startIndex, out endIndex);
                startIndex = endIndex;

                pipeSaddle.Nut1 = LoadNutData(++startIndex, out endIndex);
                startIndex = endIndex;

                pipeSaddle.Nut2 = LoadNutData(++startIndex, out endIndex);
                startIndex = endIndex;

                pipeSaddle.Nut3 = LoadNutData(++startIndex, out endIndex);
                startIndex = endIndex;

                pipeSaddle.Nut4 = LoadNutData(++startIndex, out endIndex);
                startIndex = endIndex;

                pipeSaddle.Strap = LoadStrapData(++startIndex, out endIndex);
                startIndex = endIndex;
            }
            catch
            {
                RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadPipeSaddleData, "Error in Loading PipeSaddle Data.");
            }
            return pipeSaddle;
        }

        /// <summary>
        /// This method will be called by user symbol to create the Pipe Saddle 
        /// </summary>
        public void AddPipeSaddle(PipeSaddleInputs pipeSaddle, Matrix4X4 matrix, OutputDictionary outputs, String outputName)
        {
            try
            {
                int objectCount = 0;
                String[] objectColl = new String[objectCount];
                StringBuilder error = new StringBuilder();
                SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();
                symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(1, 0, 0));
                double[] uboltXLocation = new double[(int)pipeSaddle.Multi1Qty];

                for (int i = 0; i <= pipeSaddle.Multi1Qty - 1; i++)
                {
                    uboltXLocation[i] = MultiPosition(pipeSaddle.Strap.StrapStockWidth, pipeSaddle.Multi1Qty, pipeSaddle.Multi1LocateBy, pipeSaddle.Multi1Location, pipeSaddle.UBolt.UBoltRodDia)[i];
                }

                for (int i = 0; i <= pipeSaddle.Multi1Qty - 1; i++)
                {
                    Matrix4X4 uBoltMatrix = new Matrix4X4();
                    uBoltMatrix.SetIdentity();
                    uBoltMatrix.Translate(new Vector(uboltXLocation[i] - pipeSaddle.Strap.StrapStockWidth / 2, 0, 0));
                    uBoltMatrix.Rotate(Math.PI, new Vector(1, 0, 0));
                    pipeSaddle.PipeOD = pipeSaddle.PipeOD - 0.0001;
                    AddUBolt(pipeSaddle.UBolt, pipeSaddle.PipeOD, uBoltMatrix, outputs, outputName + "UBolt" + (i + 1));
                }

                //Nuts
                for (int i = 0; i <= pipeSaddle.Multi1Qty - 1; i++)
                {
                    //Left Two Nuts

                    Matrix4X4 nutMatrix = new Matrix4X4();
                    nutMatrix.Origin = new Position(uboltXLocation[i] - pipeSaddle.Strap.StrapStockWidth / 2, pipeSaddle.UBolt.UBoltWidth / 2, pipeSaddle.PipeOD / 2 - pipeSaddle.Strap.StrapHeightInside + pipeSaddle.Strap.StrapThickness);
                    AddNut(pipeSaddle.Nut1, nutMatrix, outputs, outputName + "Nut1_" + i);

                    nutMatrix.Origin = new Position(uboltXLocation[i] - pipeSaddle.Strap.StrapStockWidth / 2, pipeSaddle.UBolt.UBoltWidth / 2, pipeSaddle.PipeOD / 2 - pipeSaddle.Strap.StrapHeightInside + pipeSaddle.Strap.StrapThickness + pipeSaddle.Nut1.ShapeLength);
                    AddNut(pipeSaddle.Nut2, nutMatrix, outputs, outputName + "Nut2_" + i);

                    //Right Two Nuts
                    nutMatrix.Origin = new Position(uboltXLocation[i] - pipeSaddle.Strap.StrapStockWidth / 2, -pipeSaddle.UBolt.UBoltWidth / 2, pipeSaddle.PipeOD / 2 - pipeSaddle.Strap.StrapHeightInside + pipeSaddle.Strap.StrapThickness);
                    AddNut(pipeSaddle.Nut3, nutMatrix, outputs, outputName + "Nut3_" + i);

                    nutMatrix.Origin = new Position(uboltXLocation[i] - pipeSaddle.Strap.StrapStockWidth / 2, -pipeSaddle.UBolt.UBoltWidth / 2, pipeSaddle.PipeOD / 2 - pipeSaddle.Strap.StrapHeightInside + pipeSaddle.Strap.StrapThickness + pipeSaddle.Nut1.ShapeLength);
                    AddNut(pipeSaddle.Nut4, nutMatrix, outputs, outputName + "Nut4_" + i);
                }

                //SaddleShape or Shield Shape
                if (pipeSaddle.Strap.StrapWidthWings > 0)
                {
                    AddClampShape(pipeSaddle.PipeOD, pipeSaddle.Strap.StrapThickness, pipeSaddle.Strap.StrapStockWidth, -1, pipeSaddle.Strap.StrapWidthWings / 2, pipeSaddle.Strap.StrapWidthWings / 2, 2 * (pipeSaddle.PipeOD / 2 - pipeSaddle.Strap.StrapHeightInside), 2 * (pipeSaddle.PipeOD / 2 - pipeSaddle.Strap.StrapHeightInside), 180, outputs, outputName, "Nne", 3 * Math.PI / 2, false);
                }
                else
                {
                    ShieldInputs shield = new ShieldInputs();
                    shield.PipeOD = pipeSaddle.PipeOD;
                    shield.Length1 = pipeSaddle.Strap.StrapStockWidth;
                    shield.Width1 = pipeSaddle.Strap.StrapWidthInside / 2;
                    shield.Width2 = pipeSaddle.Strap.StrapWidthInside / 2;
                    shield.Thickness1 = pipeSaddle.Strap.StrapThickness;
                    Matrix4X4 shieldMatrix = new Matrix4X4();
                    shieldMatrix.Origin = new Position(0, 0, 0);
                    shieldMatrix.Rotate((Math.PI), new Vector(1, 0, 0));
                    AddShield(shield, shieldMatrix, outputs, "Shield");
                }

                //DummyShape
                DummyLegShapeInputs topDummyShape = new DummyLegShapeInputs();

                topDummyShape.diameter = pipeSaddle.PipeOD + 2 * pipeSaddle.Strap.StrapThickness;
                topDummyShape.dummyDepth = pipeSaddle.Length;
                topDummyShape.dummyWidth = pipeSaddle.Width;
                topDummyShape.dummyShape = pipeSaddle.BottomShapeType;
                topDummyShape.dummyHeight = pipeSaddle.Height;
                matrix.Rotate((Math.PI), new Vector(1, 0, 0));

                AddDummyLegShape(topDummyShape, topDummyShape.diameter, 0, 0, matrix, outputs, "DummyShape", true);
            }

            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddPipeSaddle, "Error occured AddPipeSaddle Method.");
                }
            }
        }

        /// <summary>
        /// This property adds inputs for Bolt SmartPart.User symbol calls this property.
        /// </summary>
        public void AddBoltSmartpartInputs(int startIndex, out int endIndex, List<Input> additionalInputs)
        {
            try
            {
                additionalInputs.Add((Input)new InputDouble(startIndex, "Shape1Type", "Shape1Type", -1, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Shape1Width1", "Shape1Width1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Shape1Width2", "Shape1Width2", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Thickness1", "Thickness1", 0, false));

                additionalInputs.Add((Input)new InputDouble(++startIndex, "RodDiameter", "RodDiameter", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Length", "Length", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "OverLength1", "OverLength1", 0, false));

                additionalInputs.Add((Input)new InputDouble(++startIndex, "Shape2Type", "Shape2Type", -1, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Shape2Width1", "Shape2Width1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Shape2Width2", "Shape2Width2", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Thickness2", "Thickness2", 0, false));

                additionalInputs.Add((Input)new InputDouble(++startIndex, "Shape3Type", "Shape3Type", -1, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Shape3Width1", "Shape3Width1", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Shape3Width2", "Shape3Width2", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Thickness3", "Thickness3", 0, false));

                additionalInputs.Add((Input)new InputDouble(++startIndex, "TWPlateCount", "TWPlateCount", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "BWPlateCount", "BWPlateCount", 0, false));
                additionalInputs.Add((Input)new InputDouble(++startIndex, "Gap1", "Gap1", 0, false));
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddBoltSmartpartInputs, "Error occured in AddBoltSmartpartInputs Method.");
                }
            }
            endIndex = startIndex;
        }

        /// <summary>
        /// Defines the inputs required to construct ouputs of a BoltSmartpart. 
        /// </summary>
        public struct BoltSmartpartInputs
        {
            /// <summary>
            /// Determines graphic shape used for BoltHead. Codelist hsBHShapeType 1 – Round,2 - Square, 3 - Hex, 4 - Anchor1, 5 - Anchor2
            /// </summary>
            public int shape1Type;
            /// <summary>
            /// The outside dimension of the BoltHead.
            /// </summary>
            public double shape1Width1;
            /// <summary>
            /// The “other” outside dimension of the BoltHead.If zero, negative, or undefined, this attribute is ignored. Also ignored for Hex shape. 
            /// </summary>
            public double shape1Width2;
            /// <summary>
            /// The length of the nut or washer. 
            /// </summary>
            public double thickness1;
            /// <summary>
            /// Outside diameter of rod. 
            /// </summary>
            public double rodDiameter;
            /// <summary>
            /// total length of the Bolt including BoltHead 
            /// </summary>
            public double length;
            /// <summary>
            /// Graphically extends or retracts the visible length of the rod at other end opposite to BoltHead end.
            /// </summary>
            public double overLength1;
            /// <summary>
            /// ShapeType The graphic shape to use for the Nut. Codelist hsShapeType 1 – Round,2 - Square, 3 - Hex. 
            /// </summary>
            public int shape2Type;
            /// <summary>
            /// The outside dimension of the Nut.
            /// </summary>
            public double shape2Width1;
            /// <summary>
            /// The “other” outside dimension of the Nut.If zero, negative, or undefined, this attribute is ignored. Also ignored for Hex shape.   
            /// </summary>
            public double shape2Width2;
            /// <summary>
            /// The length of the Nut.
            /// </summary>
            public double thickness2;
            /// <summary>
            /// ShapeType The graphic shape to use for the washer. Codelist hsShapeType 1 – Round,2 - Square, 3 - Hex. 
            /// </summary>
            public int shape3Type;
            /// <summary>
            ///The outside dimension of the washer.
            /// </summary>
            public double shape3Width1;
            /// <summary>
            /// The “other” outside dimension of the Washer.If zero, negative, or undefined, this attribute is ignored. Also ignored for Hex shape.  
            /// </summary>
            public double shape3Width2;
            /// <summary>
            /// The length of the Nut. 
            /// </summary>
            public double thickness3;
            /// <summary>
            /// No. of washerplates immediately below the BoltHead.
            /// </summary>
            public double tWPlateCount;
            /// <summary>
            /// No. of washerplates immediately above the Nut.
            /// </summary>
            public double bWPlateCount;
            /// <summary>
            /// Gap between top and bottom washerplates.
            /// </summary>
            public double gap1;
        }

        /// <summary>
        /// This method will be called by user symbol to get value of an input(in this case, BoltSmartpart input structure)during construction of outputs. 
        /// Given the start index, this method will return the value of the BoltSmartpartData struct object.
        /// </summary>
        /// <param name="startIndex">The start index.</param>
        /// <returns></returns>
        ///<code>
        ///BoltSmartpartInputs nut = LoadBoltSmartpartData(3);
        ///</code>
        public BoltSmartpartInputs LoadBoltSmartpartData(int startIndex)
        {
            BoltSmartpartInputs BoltSmartpart = new BoltSmartpartInputs();
            try
            {
                BoltSmartpart.shape1Type = (int)GetDoubleInputValue(startIndex);
                BoltSmartpart.shape1Width1 = GetDoubleInputValue(++startIndex);
                BoltSmartpart.shape1Width2 = GetDoubleInputValue(++startIndex);
                BoltSmartpart.thickness1 = GetDoubleInputValue(++startIndex);

                BoltSmartpart.rodDiameter = GetDoubleInputValue(++startIndex);
                BoltSmartpart.length = GetDoubleInputValue(++startIndex);
                BoltSmartpart.overLength1 = GetDoubleInputValue(++startIndex);

                BoltSmartpart.shape2Type = (int)GetDoubleInputValue(++startIndex);
                BoltSmartpart.shape2Width1 = GetDoubleInputValue(++startIndex);
                BoltSmartpart.shape2Width2 = GetDoubleInputValue(++startIndex);
                BoltSmartpart.thickness2 = GetDoubleInputValue(++startIndex);

                BoltSmartpart.shape3Type = (int)GetDoubleInputValue(++startIndex);
                BoltSmartpart.shape3Width1 = GetDoubleInputValue(++startIndex);
                BoltSmartpart.shape3Width2 = GetDoubleInputValue(++startIndex);
                BoltSmartpart.thickness3 = GetDoubleInputValue(++startIndex);
                BoltSmartpart.tWPlateCount = GetDoubleInputValue(++startIndex);
                BoltSmartpart.bWPlateCount = GetDoubleInputValue(++startIndex);
                BoltSmartpart.gap1 = GetDoubleInputValue(++startIndex);
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadBoltSmartpartData, "Error in loading BoltSmartpart data.");
                }
            }
            return BoltSmartpart;
        }

        /// <summary>
        ///Create the graphical representation of a BoltSmartpart.  Specify the inputs and StringMatrix.
        /// </summary>
        ///<param name="boltSmartpartInputsolt">Structure for specifying the inputs for the BoltSmarpart -BoltSmarpartInputs </param>
        ///<param name="matrix">matrix to specify the position and oreintation the graphics - matrix.</param>
        /// <param name="outputs">Collection of declared outputs, which is indexed by the name of the outputs declared as defining SymbolOutputs on the AspectDefinition field- OutputDictionary</param>
        /// <param name="outputName">Output that this graphic is being placed on-String</param>
        ///<code>
        /// AddBoltSmarpart(BoltSmartpartInputs, matrix, m_PhysicalAspect.Outputs, "Bolt");
        ///</code>
        public void AddBoltSmarpart(BoltSmartpartInputs boltSmartpartInputsolt, Matrix4X4 matrix, OutputDictionary outputs, String outputName)
        {
            try
            {
                SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();

                if ( HgrCompareDoubleService.cmpdbl(boltSmartpartInputsolt.rodDiameter, 0) == true)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrInvalidRodDiameter, "RodDiameter should be greater than zero.");
                }

                //This will add the rod, this may be all that is needed but if either BoltHead or Washers or nuts
                //are set to anything other than 0 then we will need to add addtional graphics and make sure that
                //the length of the rod considers the dimensions of the additional ends.
                if (boltSmartpartInputsolt.rodDiameter > 0 &&  HgrCompareDoubleService.cmpdbl(boltSmartpartInputsolt.length + boltSmartpartInputsolt.overLength1, 0) == false)
                {
                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(0, 0, -boltSmartpartInputsolt.overLength1);
                    symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(1, 0, 0));
                    Projection3d rod = (Projection3d)symbolGeometryHelper.CreateCylinder(null, boltSmartpartInputsolt.rodDiameter / 2, (boltSmartpartInputsolt.length + boltSmartpartInputsolt.overLength1 - boltSmartpartInputsolt.thickness1));
                    rod.Transform(matrix);
                    outputs.Add(outputName + "ROD", rod);
                }

                //Add BoltHead
                if (boltSmartpartInputsolt.shape1Type > 0 && boltSmartpartInputsolt.shape1Width1 > 0 && boltSmartpartInputsolt.thickness1 > 0)
                {
                    switch (boltSmartpartInputsolt.shape1Type)
                    {
                        case 1: //Round BoltHead
                            if (boltSmartpartInputsolt.shape1Width2 <= 0 || boltSmartpartInputsolt.shape1Width2.Equals(boltSmartpartInputsolt.shape1Width1))
                            {
                                symbolGeometryHelper = new SymbolGeometryHelper();
                                symbolGeometryHelper.ActivePosition = new Position(0, 0, -boltSmartpartInputsolt.thickness1);
                                symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(0, 1, 0));
                                Projection3d roundBoltHead = symbolGeometryHelper.CreateCylinder(null, boltSmartpartInputsolt.shape1Width1 / 2, boltSmartpartInputsolt.thickness1);
                                roundBoltHead.Transform(matrix);
                                outputs.Add(outputName+"Head", roundBoltHead);
                            }
                            else//Elliptical BoltHead
                            {
                                symbolGeometryHelper = new SymbolGeometryHelper();
                                symbolGeometryHelper.ActivePosition = new Position(0, 0, -boltSmartpartInputsolt.thickness1);
                                symbolGeometryHelper.SetOrientation(new Vector(0, 1, 0), new Vector(1, 0, 0));
                                Ellipse3d curve = (Ellipse3d)symbolGeometryHelper.CreateEllipse(null, boltSmartpartInputsolt.shape1Width2 / 2, boltSmartpartInputsolt.shape1Width1 / 2, 2 * Math.PI);
                                Projection3d ellipticalBoltHead = new Projection3d(curve, new Vector(0, 0, 1), boltSmartpartInputsolt.thickness1, true);
                                ellipticalBoltHead.Transform(matrix);
                                outputs.Add(outputName + "Head", ellipticalBoltHead);
                            }
                            break;
                        case 2://Rectangular BoltHead
                            if (boltSmartpartInputsolt.shape1Width2 <= 0)
                                boltSmartpartInputsolt.shape1Width2 = boltSmartpartInputsolt.shape1Width1;
                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(0, 0, -boltSmartpartInputsolt.thickness1);
                            symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(0, 1, 0));
                            Projection3d squareBoltHead = (Projection3d)symbolGeometryHelper.CreateBox(null, boltSmartpartInputsolt.thickness1, boltSmartpartInputsolt.shape1Width2, boltSmartpartInputsolt.shape1Width1);
                            squareBoltHead.Transform(matrix);
                            outputs.Add(outputName + "Head", squareBoltHead);
                            break;
                        case 3://Hex BoltHead
                            double x, y;
                            y = Math.Sin(60 * Math.PI / 180) * boltSmartpartInputsolt.shape1Width1 / 2;
                            x = Math.Cos(60 * Math.PI / 180) * boltSmartpartInputsolt.shape1Width1 / 2;
                            List<Position> points = new List<Position>();
                            points.Add(new Position(-boltSmartpartInputsolt.shape1Width1 / 2, 0, 0));
                            points.Add((new Position(-x, y, 0)));
                            points.Add((new Position(x, y, 0)));
                            points.Add((new Position(boltSmartpartInputsolt.shape1Width1 / 2, 0, 0)));
                            points.Add((new Position(x, -y, 0)));
                            points.Add((new Position(-x, -y, 0)));
                            points.Add((new Position(-boltSmartpartInputsolt.shape1Width1 / 2, 0, 0)));
                            symbolGeometryHelper = new SymbolGeometryHelper();
                            LineString3d linestring = symbolGeometryHelper.CreateLineString(null, points, true);
                            Projection3d extrusionBH = new Projection3d(linestring, new Vector(0, 0, 1), -boltSmartpartInputsolt.thickness1, true);
                            extrusionBH.Transform(matrix);
                            outputs.Add(outputName + "Head", extrusionBH);
                            break;
                        case 4://Anchor1 BoltHead
                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(0, 0, -boltSmartpartInputsolt.thickness1);
                            symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(0, 1, 0));
                            Cone3d anchor1BoltHead = (Cone3d)symbolGeometryHelper.CreateCone(null, boltSmartpartInputsolt.shape1Width1 / 2, boltSmartpartInputsolt.rodDiameter / 2, boltSmartpartInputsolt.thickness1);
                            anchor1BoltHead.Transform(matrix);
                            outputs.Add(outputName + "Head", anchor1BoltHead);
                            break;
                        case 5://Anchor2 BoltHead
                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(0, 0, -boltSmartpartInputsolt.thickness1 / 2);
                            symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(0, 1, 0));
                            Cone3d anchor2BoltHead1 = (Cone3d)symbolGeometryHelper.CreateCone(null, boltSmartpartInputsolt.shape1Width1 / 2, boltSmartpartInputsolt.rodDiameter / 2, boltSmartpartInputsolt.thickness1 / 2);
                            anchor2BoltHead1.Transform(matrix);
                            outputs.Add(outputName+"Head1", anchor2BoltHead1);
                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(0, 0, -boltSmartpartInputsolt.thickness1);
                            symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(0, 1, 0));
                            Cone3d anchor2BoltHead2 = (Cone3d)symbolGeometryHelper.CreateCone(null, boltSmartpartInputsolt.rodDiameter / 2, boltSmartpartInputsolt.shape1Width1 / 2, boltSmartpartInputsolt.thickness1 / 2);
                            anchor2BoltHead2.Transform(matrix);
                            outputs.Add(outputName+"Head2", anchor2BoltHead2);
                            break;
                    }

                }


                //Add WasherPlates
                //Add Top WasherPlate
                for (int J = 0; J <= boltSmartpartInputsolt.tWPlateCount - 1; J++)
                {
                    if (boltSmartpartInputsolt.shape3Type > 0 && boltSmartpartInputsolt.shape3Width1 > 0 && boltSmartpartInputsolt.thickness3 > 0)
                    {
                        switch (boltSmartpartInputsolt.shape3Type)
                        {
                            case 1: //Round Washer
                                if (boltSmartpartInputsolt.shape3Width2 <= 0 || boltSmartpartInputsolt.shape3Width2.Equals(boltSmartpartInputsolt.shape3Width1))
                                {
                                    symbolGeometryHelper = new SymbolGeometryHelper();
                                    symbolGeometryHelper.ActivePosition = new Position(0, 0, J * boltSmartpartInputsolt.thickness3);
                                    symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(0, 1, 0));
                                    Projection3d roundTopWasher = symbolGeometryHelper.CreateCylinder(null, boltSmartpartInputsolt.shape3Width1 / 2, boltSmartpartInputsolt.thickness3);
                                    roundTopWasher.Transform(matrix);
                                    outputs.Add(outputName + "roundTopWasher" + J, roundTopWasher);
                                }
                                else//Elliptical Washer
                                {
                                    symbolGeometryHelper = new SymbolGeometryHelper();
                                    symbolGeometryHelper.ActivePosition = new Position(0, 0, J * boltSmartpartInputsolt.thickness3);
                                    symbolGeometryHelper.SetOrientation(new Vector(0, 1, 0), new Vector(1, 0, 0));
                                    Ellipse3d curve = (Ellipse3d)symbolGeometryHelper.CreateEllipse(null, boltSmartpartInputsolt.shape3Width2 / 2, boltSmartpartInputsolt.shape3Width1 / 2, 2 * Math.PI);
                                    Projection3d ellipticalTopWasher = new Projection3d(curve, new Vector(0, 0, 1), boltSmartpartInputsolt.thickness3, true);
                                    ellipticalTopWasher.Transform(matrix);
                                    outputs.Add(outputName + "ellipticalTopWasher" + J, ellipticalTopWasher);
                                }
                                break;
                            case 2://Rectangular Washer
                                if (boltSmartpartInputsolt.shape3Width2 <= 0)
                                    boltSmartpartInputsolt.shape3Width2 = boltSmartpartInputsolt.shape3Width1;
                                symbolGeometryHelper = new SymbolGeometryHelper();
                                symbolGeometryHelper.ActivePosition = new Position(0, 0, J * boltSmartpartInputsolt.thickness3);
                                symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(0, 1, 0));
                                Projection3d squareTopWasher = (Projection3d)symbolGeometryHelper.CreateBox(null, boltSmartpartInputsolt.thickness3, boltSmartpartInputsolt.shape3Width2, boltSmartpartInputsolt.shape3Width1);
                                squareTopWasher.Transform(matrix);
                                outputs.Add(outputName + "squareTopWasher" + J, squareTopWasher);
                                break;
                            case 3://Hex Washer
                                double x, y;
                                y = Math.Sin(60 * Math.PI / 180) * boltSmartpartInputsolt.shape3Width1 / 2;
                                x = Math.Cos(60 * Math.PI / 180) * boltSmartpartInputsolt.shape3Width1 / 2;
                                List<Position> points = new List<Position>();
                                points.Add(new Position(-boltSmartpartInputsolt.shape3Width1 / 2, 0, J * boltSmartpartInputsolt.thickness3));
                                points.Add((new Position(-x, y, J * boltSmartpartInputsolt.thickness3)));
                                points.Add((new Position(x, y, J * boltSmartpartInputsolt.thickness3)));
                                points.Add((new Position(boltSmartpartInputsolt.shape3Width1 / 2, 0, J * boltSmartpartInputsolt.thickness3)));
                                points.Add((new Position(x, -y, J * boltSmartpartInputsolt.thickness3)));
                                points.Add((new Position(-x, -y, J * boltSmartpartInputsolt.thickness3)));
                                points.Add((new Position(-boltSmartpartInputsolt.shape3Width1 / 2, 0, J * boltSmartpartInputsolt.thickness3)));
                                symbolGeometryHelper = new SymbolGeometryHelper();
                                LineString3d linestring = symbolGeometryHelper.CreateLineString(null, points, true);
                                Projection3d extrusionTW = new Projection3d(linestring, new Vector(0, 0, 1), boltSmartpartInputsolt.thickness3, true);
                                extrusionTW.Transform(matrix);
                                outputs.Add(outputName + "extrusionTW" + J, extrusionTW);
                                break;
                        }
                    }
                }
                //Add Bottom WasherPlate
                for (int J = 0; J <= boltSmartpartInputsolt.bWPlateCount - 1; J++)
                {
                    if (boltSmartpartInputsolt.shape3Type > 0 && boltSmartpartInputsolt.shape3Width1 > 0 && boltSmartpartInputsolt.thickness3 > 0)
                    {
                        switch (boltSmartpartInputsolt.shape3Type)
                        {
                            case 1: //Round Washer
                                if (boltSmartpartInputsolt.shape3Width2 <= 0 || boltSmartpartInputsolt.shape3Width2.Equals(boltSmartpartInputsolt.shape3Width1))
                                {
                                    symbolGeometryHelper = new SymbolGeometryHelper();
                                    symbolGeometryHelper.ActivePosition = new Position(0, 0, J * boltSmartpartInputsolt.thickness3 + boltSmartpartInputsolt.gap1 + boltSmartpartInputsolt.tWPlateCount * boltSmartpartInputsolt.thickness3);
                                    symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(0, 1, 0));
                                    Projection3d roundBottomWasher = symbolGeometryHelper.CreateCylinder(null, boltSmartpartInputsolt.shape3Width1 / 2, boltSmartpartInputsolt.thickness3);
                                    roundBottomWasher.Transform(matrix);
                                    outputs.Add(outputName + "roundBottomWasher" + J, roundBottomWasher);
                                }
                                else//Elliptical Washer
                                {
                                    symbolGeometryHelper = new SymbolGeometryHelper();
                                    symbolGeometryHelper.ActivePosition = new Position(0, 0, J * boltSmartpartInputsolt.thickness3 + boltSmartpartInputsolt.gap1 + boltSmartpartInputsolt.tWPlateCount * boltSmartpartInputsolt.thickness3);
                                    symbolGeometryHelper.SetOrientation(new Vector(0, 1, 0), new Vector(1, 0, 0));
                                    Ellipse3d curve = (Ellipse3d)symbolGeometryHelper.CreateEllipse(null, boltSmartpartInputsolt.shape3Width2 / 2, boltSmartpartInputsolt.shape3Width1 / 2, 2 * Math.PI);
                                    Projection3d ellipticalBottomWasher = new Projection3d(curve, new Vector(0, 0, 1), boltSmartpartInputsolt.thickness3, true);
                                    ellipticalBottomWasher.Transform(matrix);
                                    outputs.Add(outputName + "ellipticalBottomWasher" + J, ellipticalBottomWasher);
                                }
                                break;
                            case 2://Rectangular Washer
                                if (boltSmartpartInputsolt.shape3Width2 <= 0)
                                    boltSmartpartInputsolt.shape3Width2 = boltSmartpartInputsolt.shape3Width1;
                                symbolGeometryHelper = new SymbolGeometryHelper();
                                symbolGeometryHelper.ActivePosition = new Position(0, 0, J * boltSmartpartInputsolt.thickness3 + boltSmartpartInputsolt.gap1 + boltSmartpartInputsolt.tWPlateCount * boltSmartpartInputsolt.thickness3);
                                symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(0, 1, 0));
                                Projection3d squareBottomWasher = (Projection3d)symbolGeometryHelper.CreateBox(null, boltSmartpartInputsolt.thickness3, boltSmartpartInputsolt.shape3Width2, boltSmartpartInputsolt.shape3Width1);
                                squareBottomWasher.Transform(matrix);
                                outputs.Add(outputName + "squareBottomWasher" + J, squareBottomWasher);
                                break;
                            case 3://Hex Washer
                                double x, y;
                                y = Math.Sin(60 * Math.PI / 180) * boltSmartpartInputsolt.shape3Width1 / 2;
                                x = Math.Cos(60 * Math.PI / 180) * boltSmartpartInputsolt.shape3Width1 / 2;
                                List<Position> points = new List<Position>();
                                points.Add(new Position(-boltSmartpartInputsolt.shape3Width1 / 2, 0, J * boltSmartpartInputsolt.thickness3 + boltSmartpartInputsolt.gap1 + boltSmartpartInputsolt.tWPlateCount * boltSmartpartInputsolt.thickness3));
                                points.Add((new Position(-x, y, J * boltSmartpartInputsolt.thickness3 + boltSmartpartInputsolt.gap1 + boltSmartpartInputsolt.tWPlateCount * boltSmartpartInputsolt.thickness3)));
                                points.Add((new Position(x, y, J * boltSmartpartInputsolt.thickness3 + boltSmartpartInputsolt.gap1 + boltSmartpartInputsolt.tWPlateCount * boltSmartpartInputsolt.thickness3)));
                                points.Add((new Position(boltSmartpartInputsolt.shape3Width1 / 2, 0, J * boltSmartpartInputsolt.thickness3 + boltSmartpartInputsolt.gap1 + boltSmartpartInputsolt.tWPlateCount * boltSmartpartInputsolt.thickness3)));
                                points.Add((new Position(x, -y, J * boltSmartpartInputsolt.thickness3 + boltSmartpartInputsolt.gap1 + boltSmartpartInputsolt.tWPlateCount * boltSmartpartInputsolt.thickness3)));
                                points.Add((new Position(-x, -y, J * boltSmartpartInputsolt.thickness3 + boltSmartpartInputsolt.gap1 + boltSmartpartInputsolt.tWPlateCount * boltSmartpartInputsolt.thickness3)));
                                points.Add((new Position(-boltSmartpartInputsolt.shape3Width1 / 2, 0, J * boltSmartpartInputsolt.thickness3 + boltSmartpartInputsolt.gap1 + boltSmartpartInputsolt.tWPlateCount * boltSmartpartInputsolt.thickness3)));
                                symbolGeometryHelper = new SymbolGeometryHelper();
                                LineString3d linestring = symbolGeometryHelper.CreateLineString(null, points, true);
                                Projection3d extrusionBW = new Projection3d(linestring, new Vector(0, 0, 1), boltSmartpartInputsolt.thickness3, true);
                                extrusionBW.Transform(matrix);
                                outputs.Add(outputName + J + "extrusionBW", extrusionBW);
                                break;
                        }
                    }
                }

                //Add Nut
                if (boltSmartpartInputsolt.shape2Type > 0 && boltSmartpartInputsolt.shape2Width1 > 0 && boltSmartpartInputsolt.thickness2 > 0)
                {
                    switch (boltSmartpartInputsolt.shape2Type)
                    {
                        case 1: //Round Washer
                            if (boltSmartpartInputsolt.shape2Width2 <= 0 || boltSmartpartInputsolt.shape2Width2.Equals(boltSmartpartInputsolt.shape2Width1))
                            {
                                symbolGeometryHelper = new SymbolGeometryHelper();
                                symbolGeometryHelper.ActivePosition = new Position(0, 0, boltSmartpartInputsolt.gap1 + (boltSmartpartInputsolt.tWPlateCount + boltSmartpartInputsolt.bWPlateCount) * boltSmartpartInputsolt.thickness3);
                                symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(0, 1, 0));
                                Projection3d roundBottomNut = symbolGeometryHelper.CreateCylinder(null, boltSmartpartInputsolt.shape2Width1 / 2, boltSmartpartInputsolt.thickness2);
                                roundBottomNut.Transform(matrix);
                                outputs.Add(outputName + "roundBottomNut", roundBottomNut);
                            }
                            else//Elliptical Washer
                            {
                                symbolGeometryHelper = new SymbolGeometryHelper();
                                symbolGeometryHelper.ActivePosition = new Position(0, 0, boltSmartpartInputsolt.gap1 + (boltSmartpartInputsolt.tWPlateCount + boltSmartpartInputsolt.bWPlateCount) * boltSmartpartInputsolt.thickness3);
                                symbolGeometryHelper.SetOrientation(new Vector(0, 1, 0), new Vector(1, 0, 0));
                                Ellipse3d curve = (Ellipse3d)symbolGeometryHelper.CreateEllipse(null, boltSmartpartInputsolt.shape2Width2 / 2, boltSmartpartInputsolt.shape2Width1 / 2, 2 * Math.PI);
                                Projection3d ellipticalBottomNut = new Projection3d(curve, new Vector(0, 0, 1), boltSmartpartInputsolt.thickness2, true);
                                ellipticalBottomNut.Transform(matrix);
                                outputs.Add(outputName + "ellipticalBottomNut", ellipticalBottomNut);
                            }
                            break;
                        case 2://Rectangular Washer
                            if (boltSmartpartInputsolt.shape2Width2 <= 0)
                                boltSmartpartInputsolt.shape2Width2 = boltSmartpartInputsolt.shape2Width1;
                            symbolGeometryHelper = new SymbolGeometryHelper();
                            symbolGeometryHelper.ActivePosition = new Position(0, 0, boltSmartpartInputsolt.gap1 + (boltSmartpartInputsolt.tWPlateCount + boltSmartpartInputsolt.bWPlateCount) * boltSmartpartInputsolt.thickness3);
                            symbolGeometryHelper.SetOrientation(new Vector(0, 0, 1), new Vector(0, 1, 0));
                            Projection3d squareBottomNut = (Projection3d)symbolGeometryHelper.CreateBox(null, boltSmartpartInputsolt.thickness2, boltSmartpartInputsolt.shape2Width2, boltSmartpartInputsolt.shape2Width1);
                            squareBottomNut.Transform(matrix);
                            outputs.Add(outputName + "squareBottomNut", squareBottomNut);
                            break;
                        case 3://Hex Washer
                            double x, y;
                            y = Math.Sin(60 * Math.PI / 180) * boltSmartpartInputsolt.shape2Width1 / 2;
                            x = Math.Cos(60 * Math.PI / 180) * boltSmartpartInputsolt.shape2Width1 / 2;
                            List<Position> points = new List<Position>();
                            points.Add(new Position(-boltSmartpartInputsolt.shape2Width1 / 2, 0, boltSmartpartInputsolt.gap1 + (boltSmartpartInputsolt.tWPlateCount + boltSmartpartInputsolt.bWPlateCount) * boltSmartpartInputsolt.thickness3));
                            points.Add((new Position(-x, y, boltSmartpartInputsolt.gap1 + (boltSmartpartInputsolt.tWPlateCount + boltSmartpartInputsolt.bWPlateCount) * boltSmartpartInputsolt.thickness3)));
                            points.Add((new Position(x, y, boltSmartpartInputsolt.gap1 + (boltSmartpartInputsolt.tWPlateCount + boltSmartpartInputsolt.bWPlateCount) * boltSmartpartInputsolt.thickness3)));
                            points.Add((new Position(boltSmartpartInputsolt.shape2Width1 / 2, 0, boltSmartpartInputsolt.gap1 + (boltSmartpartInputsolt.tWPlateCount + boltSmartpartInputsolt.bWPlateCount) * boltSmartpartInputsolt.thickness3)));
                            points.Add((new Position(x, -y, boltSmartpartInputsolt.gap1 + (boltSmartpartInputsolt.tWPlateCount + boltSmartpartInputsolt.bWPlateCount) * boltSmartpartInputsolt.thickness3)));
                            points.Add((new Position(-x, -y, boltSmartpartInputsolt.gap1 + (boltSmartpartInputsolt.tWPlateCount + boltSmartpartInputsolt.bWPlateCount) * boltSmartpartInputsolt.thickness3)));
                            points.Add((new Position(-boltSmartpartInputsolt.shape2Width1 / 2, 0, boltSmartpartInputsolt.gap1 + (boltSmartpartInputsolt.tWPlateCount + boltSmartpartInputsolt.bWPlateCount) * boltSmartpartInputsolt.thickness3)));
                            symbolGeometryHelper = new SymbolGeometryHelper();
                            LineString3d linestring = symbolGeometryHelper.CreateLineString(null, points, true);
                            Projection3d extrusionNut = new Projection3d(linestring, new Vector(0, 0, 1), boltSmartpartInputsolt.thickness2, true);
                            extrusionNut.Transform(matrix);
                            outputs.Add(outputName + "extrusionNut", extrusionNut);
                            break;
                    }
                }

            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddBoltSmartpart, "Error in Adding BoltSmartpart.");
                }
            }
        }

        /// <summary>
        /// Defines the inputs for the WLA.
        /// </summary>
        public struct PipeLugInputs
        {
            /// <summary>
            /// Specifies the RodDiameter used for AIR.
            /// </summary>
            public double RodDiameter;
            /// <summary>
            /// Specifies the OuterDia of the Pipe where the part is placed.
            /// </summary>
            public double PipeOD;
            /// <summary>
            /// Specifies the distance between the Bottom of WLA and Top Port.
            /// </summary>
            public double RodTakeOut;
            /// <summary>
            /// Specifies the graphic shape used for the top of the lug.
            /// </summary>
            public Boolean IsPerpendicular;
            /// <summary>
            /// Specifies the graphic shape used for the top of the lug.
            /// </summary>
            public int TopShape;
            /// <summary>
            ///Specifies the angle between the top curve start and end point.
            /// </summary>
            public double Angle1;
            /// <summary>
            ///Specifies the top width of the elbow lug.
            /// </summary>
            public double Width1;
            /// <summary>
            ///Specifies the bottom width of the elbow lug.
            /// </summary>
            public double Width2;
            /// <summary>
            ///Specifies the thickness of the lug.
            /// </summary>
            public double Thickness1;
            /// <summary>
            ///Specifies the angle of the left tapered portion.
            /// </summary>
            public double Angle2;
            /// <summary>
            ///Specifies the angle of the right tapered portion.
            /// </summary>
            public double Angle3;
            /// <summary>
            ///Specifies the gap between lug components of a double lug.
            /// </summary>
            public double Gap1;
            /// <summary>
            ///Specifies the offset of the stiffener between the two components of a double lug.
            /// </summary>
            public double StiffenerOffset;
            /// <summary>
            ///Specifies the height of the stiffener between the two components of a double lug.
            /// </summary>
            public double StiffenerHeight;
            /// <summary>
            ///Specifies the length of the stiffener between the two components of a double lug.
            /// </summary>
            public double StiffenerLength;
            /// <summary>
            ///Specifies the distance between the top port and the top of the lug.
            /// </summary>
            public double Offset1;
            /// <summary>
            ///Specifies the length of the chamfered edges.
            /// </summary>
            public double ChamfLength;
            /// <summary>
            /// Diameter of the Pin,If zero or negative, the pin is not drawn.
            /// </summary>
            public double Pin1Diameter;
            /// <summary>
            /// Length of the Pin,If, zero or negative, the pin is not drawn.
            /// </summary>
            public double Pin1Length;
            /// <summary>
            /// Height2 of the Pin.
            /// </summary>
            public double Height2;
        }

        /// <summary>
        /// Load the data for WLA.
        /// </summary>
        public PipeLugInputs LoadPipeLugInputsData(int startIndex)
        {
            PipeLugInputs WLAInputs = new PipeLugInputs();
            try
            {
                WLAInputs.RodDiameter = GetDoubleInputValue(startIndex);
                WLAInputs.PipeOD = GetDoubleInputValue(++startIndex);
                WLAInputs.RodTakeOut = GetDoubleInputValue(++startIndex);
                WLAInputs.IsPerpendicular = Convert.ToBoolean(GetDoubleInputValue(++startIndex));
                WLAInputs.TopShape = (int)GetDoubleInputValue(++startIndex);
                WLAInputs.Angle1 = GetDoubleInputValue(++startIndex);
                WLAInputs.Width1 = GetDoubleInputValue(++startIndex);
                WLAInputs.Width2 = GetDoubleInputValue(++startIndex);
                WLAInputs.Thickness1 = GetDoubleInputValue(++startIndex);
                WLAInputs.Angle2 = GetDoubleInputValue(++startIndex);
                WLAInputs.Angle3 = GetDoubleInputValue(++startIndex);
                WLAInputs.Gap1 = GetDoubleInputValue(++startIndex);
                WLAInputs.StiffenerOffset = GetDoubleInputValue(++startIndex);
                WLAInputs.StiffenerHeight = GetDoubleInputValue(++startIndex);
                WLAInputs.StiffenerLength = GetDoubleInputValue(++startIndex);
                WLAInputs.Offset1 = GetDoubleInputValue(++startIndex);
                WLAInputs.ChamfLength = GetDoubleInputValue(++startIndex);
                WLAInputs.Pin1Diameter = GetDoubleInputValue(++startIndex);
                WLAInputs.Pin1Length = GetDoubleInputValue(++startIndex);
                WLAInputs.Height2 = GetDoubleInputValue(++startIndex);
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadPipeLugInputsData, "Error occured in  LoadWLAInputsData Method.");
                }
            }
            return WLAInputs;
        }

        /// <summary>
        /// Create the graphical representation of Welded Lug.
        /// </summary>
        public void AddWeldingLug(PipeLugInputs pipeLugInputs, Matrix4X4 Matrix, OutputDictionary outputs, String outputName)
        {
            try
            {
                //string error = "";
                const int zeroAngle = 0;
                const int rightAngle = 90;
                const int straightAngle = 180;
                const int reflexAngle = 270;
                SymbolGeometryHelper symbolGeometryHelper = new SymbolGeometryHelper();
                Matrix4X4 matrix = new Matrix4X4();
                
                Line3d leftLine;
                Line3d rightLine;
                Circle3d circle; //Line3d line;
                Collection<ICurve> collection = new Collection<ICurve>();
                Collection<Position> posCollection1 = new Collection<Position>();
                Collection<Position> PosCollection2 = new Collection<Position>();

                //Check the Angles are correct' other wise Throw error
                if (HgrCompareDoubleService.cmpdbl(pipeLugInputs.Angle1*180/Math.PI, 0) == false && pipeLugInputs.TopShape == 1) //For curved
                {
                    if (Math.Round((pipeLugInputs.Angle1*180)/Math.PI, 5) < rightAngle || Math.Round((pipeLugInputs.Angle1*180)/Math.PI, 5) > reflexAngle)
                    {
                        RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAngle1Range, "Angle 1 should be between 90 and 270 degrees. Resetting angle 1 to 180 degrees.");
                        pipeLugInputs.Angle1 = (straightAngle*Math.PI)/180;
                    }
                }
                else if (HgrCompareDoubleService.cmpdbl(pipeLugInputs.Angle1 ,0) ==true && pipeLugInputs.TopShape == 1)
                    //For curved Keep 180 degree as default
                {
                    pipeLugInputs.Angle1 = (straightAngle*Math.PI)/straightAngle;
                }

                int acutAngle = 30;

                if (Math.Round((pipeLugInputs.Angle2*180)/Math.PI, 5) < zeroAngle || Math.Round((pipeLugInputs.Angle2*180)/Math.PI, 5) > acutAngle)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAngle2Range, "Angle 2 should be between 0 and 30 degrees.");
                }
                if (Math.Round((pipeLugInputs.Angle3*180)/Math.PI, 5) < zeroAngle || Math.Round((pipeLugInputs.Angle3*180)/Math.PI, 5) > acutAngle)
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAngle3Range, "Angle 3 should be between 0 and 30 degrees.");
                }

                //Check Width1 and Width2 properties
                if (HgrCompareDoubleService.cmpdbl(pipeLugInputs.Width2, 0)==false && HgrCompareDoubleService.cmpdbl(pipeLugInputs.Width1, 0)==true) //Check Width1 property
                {
                    pipeLugInputs.Width1 = pipeLugInputs.Width2;
                }
                else if (HgrCompareDoubleService.cmpdbl(pipeLugInputs.Width1, 0) == false) //Check Width2 property
                {
                    if (HgrCompareDoubleService.cmpdbl(pipeLugInputs.Width2, 0) == true && HgrCompareDoubleService.cmpdbl(pipeLugInputs.Angle3, 0) == true)
                        pipeLugInputs.Width2 = pipeLugInputs.Width1;
                }
                else if (HgrCompareDoubleService.cmpdbl(pipeLugInputs.Width2, 0) == true && HgrCompareDoubleService.cmpdbl(pipeLugInputs.Width1, 0) == true && HgrCompareDoubleService.cmpdbl(pipeLugInputs.Angle3, 0) == true)
                {
                    pipeLugInputs.Width1 = pipeLugInputs.PipeOD;
                    pipeLugInputs.Width2 = pipeLugInputs.PipeOD;
                }


                //Check the Configuration
                Double horizontalLength1,horizontalLength2,outerRadius,verticalLength1,verticalLength2,angle1,angle2,X,Z,theta,leftNotchAngle,rightNotchAngle,bottomNotchAngle,topCurveAngle,topCurveStartAngle,topCurveEndAngle, VGraLength;
                horizontalLength1 =horizontalLength2 =outerRadius =verticalLength1 =verticalLength2 =angle1 =angle2 =X =Z =theta =leftNotchAngle =rightNotchAngle =bottomNotchAngle =topCurveAngle =topCurveStartAngle =topCurveEndAngle = VGraLength = 0.0;


                //New Code to get the Intersection Point
                Double topLeftLineX,topLeftLineY,topLeftLineZ,topRightLineX,topRightLineY,topRightLineZ,bottomLeftLineX,bottomLeftLineY,bottomLeftLineZ,bottomRightLineX,bottomRightLineY,bottomRightLineZ,bottomChamLineX,bottomChamLineY,bottomChamLineZ,tempX;
                topLeftLineX =topLeftLineY =topLeftLineZ =topRightLineX =topRightLineY =topRightLineZ =bottomLeftLineX =bottomLeftLineY =bottomLeftLineZ =bottomRightLineX =bottomRightLineY =bottomRightLineZ = bottomChamLineX =bottomChamLineY = bottomChamLineZ = tempX = 0.0;

                //Get the Angles
                topCurveAngle = pipeLugInputs.Angle1;
                leftNotchAngle = pipeLugInputs.Angle2;
                rightNotchAngle = pipeLugInputs.Angle3;

                //Check for Graphical Length
                if (HgrCompareDoubleService.cmpdbl(pipeLugInputs.Height2, 0) == false)
                {
                    VGraLength = pipeLugInputs.RodTakeOut - pipeLugInputs.Height2;
                }
                else
                {
                    double T =Math.Sqrt((pipeLugInputs.PipeOD/2*pipeLugInputs.PipeOD/2) -((pipeLugInputs.Gap1/2 + pipeLugInputs.Thickness1)*(pipeLugInputs.Gap1/2 + pipeLugInputs.Thickness1)));
                    VGraLength = T;
                }

                //Top Curve points
                if (pipeLugInputs.TopShape == 1) //Curved
                {
                    if (HgrCompareDoubleService.cmpdbl(topCurveAngle*180/Math.PI,straightAngle) == true) //Angle=180
                        
                    {
                        theta = ((Math.PI) - topCurveAngle)/2;
                        X = pipeLugInputs.Offset1*Math.Cos(theta);
                        Z = (pipeLugInputs.Offset1*Math.Sin(theta));
                        topCurveStartAngle = (Math.PI - topCurveAngle)*180/Math.PI;
                        topCurveEndAngle = (topCurveAngle*180/Math.PI);
                    }
                    else if (Math.Round((topCurveAngle*180)/Math.PI) > straightAngle)
                    {
                        theta = -((Math.PI) - topCurveAngle)/2;
                        X = pipeLugInputs.Offset1*Math.Cos(theta);
                        Z = (pipeLugInputs.Offset1*Math.Sin(theta));
                        topCurveStartAngle = ((topCurveAngle - (Math.PI))/2)*180/Math.PI;
                        topCurveEndAngle = ((Math.PI/2)*180/Math.PI) + topCurveStartAngle;
                    }
                    else
                    {
                        theta = topCurveAngle/2;
                        X = pipeLugInputs.Offset1*Math.Cos(theta);
                        Z = -(pipeLugInputs.Offset1*Math.Sin(theta));
                        topCurveStartAngle = (2*(Math.PI) - topCurveAngle/2)*180/Math.PI;
                        topCurveEndAngle = ((Math.PI) + topCurveAngle/2)*180/Math.PI;
                    }

                    topLeftLineX = -X;
                    topLeftLineY = -pipeLugInputs.Thickness1/2;
                    topLeftLineZ = pipeLugInputs.RodTakeOut + Z;

                    topRightLineX = X;
                    topRightLineY = -pipeLugInputs.Thickness1/2;
                    topRightLineZ = pipeLugInputs.RodTakeOut + Z;
                }
                else
                {
                    topLeftLineX = -pipeLugInputs.Width1/2;
                    topLeftLineY = -pipeLugInputs.Thickness1/2;
                    topRightLineX = pipeLugInputs.Width1/2;
                    topRightLineY = -pipeLugInputs.Thickness1/2;
                    if (pipeLugInputs.TopShape == 2) //Squared
                    {
                        topLeftLineZ = pipeLugInputs.RodTakeOut + pipeLugInputs.Offset1;
                        topRightLineZ = pipeLugInputs.RodTakeOut + pipeLugInputs.Offset1;
                    }
                    else if (pipeLugInputs.TopShape == 3) //Rounded
                    {
                        topLeftLineZ = pipeLugInputs.RodTakeOut + pipeLugInputs.Offset1 - pipeLugInputs.Width1/4;
                        topRightLineZ = pipeLugInputs.RodTakeOut + pipeLugInputs.Offset1 - pipeLugInputs.Width1/4;
                    }
                    else if (pipeLugInputs.TopShape == 4) //Chamfered
                    {
                        X = pipeLugInputs.ChamfLength*Math.Cos((Math.PI)/4); //Chamfer angle is 45 degree
                        Z = pipeLugInputs.ChamfLength*Math.Sin((Math.PI)/4);
                        topLeftLineZ = pipeLugInputs.RodTakeOut + pipeLugInputs.Offset1 - Z;
                        topRightLineZ = pipeLugInputs.RodTakeOut + pipeLugInputs.Offset1 - Z;
                    }
                }

                //Bottom Curve points
                if (pipeLugInputs.IsPerpendicular == false)
                {

                    bottomLeftLineX = -pipeLugInputs.Width2/2;
                    bottomLeftLineY = -pipeLugInputs.Thickness1/2;
                    bottomLeftLineZ = VGraLength;

                    bottomRightLineX = pipeLugInputs.Width2/2;
                    bottomRightLineY = -pipeLugInputs.Thickness1/2;
                    bottomRightLineZ = VGraLength;

                    if (HgrCompareDoubleService.cmpdbl(leftNotchAngle,0) == false)
                    {
                        tempX = topLeftLineZ*Math.Tan(leftNotchAngle);

                        bottomLeftLineX = -pipeLugInputs.Width1/2 - tempX;
                        bottomLeftLineY = -pipeLugInputs.Thickness1/2;
                        bottomLeftLineZ = VGraLength;

                        bottomRightLineX = bottomLeftLineX + pipeLugInputs.Width2;
                        if (HgrCompareDoubleService.cmpdbl(rightNotchAngle, 0) == false) //Override width2 Property if the Right Notch angle is given
                        {
                            tempX = topRightLineZ*Math.Tan(rightNotchAngle);
                            bottomRightLineX = pipeLugInputs.Width1/2 + tempX;
                        }
                        bottomRightLineY = -pipeLugInputs.Thickness1/2;
                        bottomRightLineZ = VGraLength;
                    }

                    //BottomLine                
                    collection.Add(new Line3d(new Position(bottomLeftLineX, bottomLeftLineY, bottomLeftLineZ),new Position(bottomRightLineX, bottomRightLineY, bottomRightLineZ)));
                }

                if (pipeLugInputs.IsPerpendicular == true)
                {
                    if ((pipeLugInputs.Width2 >= pipeLugInputs.PipeOD) && HgrCompareDoubleService.cmpdbl(leftNotchAngle, 0) == true)
                    {
                        bottomLeftLineX = -pipeLugInputs.Width2/2;
                        bottomLeftLineY = -pipeLugInputs.Thickness1/2;
                        bottomLeftLineZ = 0;

                        bottomRightLineX = pipeLugInputs.Width2/2;
                        bottomRightLineY = -pipeLugInputs.Thickness1/2;
                        bottomRightLineZ = 0;

                        //BottomleftLine                
                        collection.Add(new Line3d(new Position(bottomLeftLineX, bottomLeftLineY, bottomLeftLineZ),new Position(-pipeLugInputs.PipeOD/2, bottomLeftLineY, bottomLeftLineZ)));

                        //BottomRightLine                
                        collection.Add(new Line3d(new Position(bottomRightLineX, bottomRightLineY, bottomRightLineZ),new Position(pipeLugInputs.PipeOD/2, bottomRightLineY, bottomRightLineZ)));

                        //BottomCircularArc     
                        collection.Add(new Arc3d(new Position(-pipeLugInputs.PipeOD/2, bottomLeftLineY, bottomLeftLineZ),new Position(0, bottomLeftLineY, pipeLugInputs.PipeOD/2),new Position(pipeLugInputs.PipeOD/2, bottomRightLineY, bottomRightLineZ)));
                    }

                    if ((pipeLugInputs.Width2 < pipeLugInputs.PipeOD) & HgrCompareDoubleService.cmpdbl(leftNotchAngle, 0) == true)
                    {
                        bottomLeftLineX = -pipeLugInputs.Width2/2;
                        bottomLeftLineY = -pipeLugInputs.Thickness1/2;
                        bottomLeftLineZ =(Math.Sqrt((pipeLugInputs.PipeOD*pipeLugInputs.PipeOD) - (pipeLugInputs.Width2*pipeLugInputs.Width2)))/2;

                        bottomRightLineX = pipeLugInputs.Width2/2;
                        bottomRightLineY = -pipeLugInputs.Thickness1/2;
                        bottomRightLineZ = bottomLeftLineZ;

                        //BottomCircularArc     
                        collection.Add(new Arc3d(new Position(bottomLeftLineX, bottomLeftLineY, bottomLeftLineZ),new Position(0, bottomLeftLineY, pipeLugInputs.PipeOD/2),new Position(bottomRightLineX, bottomRightLineY, bottomRightLineZ)));
                    }

                    if (HgrCompareDoubleService.cmpdbl(leftNotchAngle, 0) == false)
                    {
                        leftLine = new Line3d(new Position(topLeftLineX, topLeftLineY, topLeftLineZ),new Vector(-Math.Sin(leftNotchAngle), 0, -Math.Cos(leftNotchAngle)),2*pipeLugInputs.RodTakeOut);
                        rightLine = new Line3d(new Position(topRightLineX, topRightLineY, topRightLineZ),new Vector(Math.Sin(rightNotchAngle), 0, -Math.Cos(rightNotchAngle)),2*pipeLugInputs.RodTakeOut);
                        circle = new Circle3d(new Position(0, 0, pipeLugInputs.PipeOD/2),new Position(0, 0, -pipeLugInputs.PipeOD/2), new Position(pipeLugInputs.PipeOD/2, 0, 0));
                        GeometryIntersectionType geometryIntersectionType = new GeometryIntersectionType();

                        leftLine.Intersect(circle, out posCollection1, out PosCollection2, out geometryIntersectionType);
                        tempX = topRightLineZ*Math.Tan(leftNotchAngle);

                        if (geometryIntersectionType == GeometryIntersectionType.NoSolution)
                        {
                            bottomLeftLineX = -pipeLugInputs.Width1/2 - tempX;
                            bottomLeftLineY = -pipeLugInputs.Thickness1/2;
                            bottomLeftLineZ = 0;

                            bottomRightLineX = pipeLugInputs.Width1/2 + tempX;
                            bottomRightLineY = -pipeLugInputs.Thickness1/2;
                            bottomRightLineZ = 0;

                            //BottomleftLine                
                            collection.Add(new Line3d(new Position(bottomLeftLineX, bottomLeftLineY, bottomLeftLineZ),new Position(-pipeLugInputs.PipeOD/2, bottomLeftLineY, bottomLeftLineZ)));

                            //BottomCircularArc     
                            collection.Add(new Arc3d(new Position(-pipeLugInputs.PipeOD/2, bottomLeftLineY, bottomLeftLineZ),new Position(0, bottomLeftLineY, pipeLugInputs.PipeOD/2),new Position(pipeLugInputs.PipeOD/2, bottomRightLineY, bottomRightLineZ)));

                            //BottomRightLine                
                            collection.Add(new Line3d(new Position(bottomRightLineX, bottomRightLineY, bottomRightLineZ), new Position(pipeLugInputs.PipeOD/2, bottomRightLineY, bottomRightLineZ)));
                        }
                        else
                        {
                            if (posCollection1.Count != 0)
                            {
                                if (posCollection1[0].Z >= posCollection1[1].Z)
                                {
                                    //BottomCircularArc     
                                    collection.Add(new Arc3d(posCollection1[0],new Position(0, bottomLeftLineY, pipeLugInputs.PipeOD/2),new Position(-posCollection1[0].X, posCollection1[0].Y, posCollection1[0].Z)));
                                }
                                else
                                {
                                    //BottomCircularArc     
                                    collection.Add(new Arc3d(posCollection1[1],new Position(0, bottomLeftLineY, pipeLugInputs.PipeOD/2),new Position(-posCollection1[1].X, posCollection1[1].Y, posCollection1[1].Z)));
                                }
                            }
                            else
                            {
                                bottomLeftLineX = -pipeLugInputs.Width1/2 - tempX;
                                bottomLeftLineY = -pipeLugInputs.Thickness1/2;
                                bottomLeftLineZ = 0;

                                bottomRightLineX = pipeLugInputs.Width1/2 + tempX;
                                bottomRightLineX = -pipeLugInputs.Thickness1/2;
                                bottomRightLineZ = 0;

                                //BottomleftLine                
                                collection.Add(new Line3d(new Position(bottomLeftLineX, bottomLeftLineY, bottomLeftLineZ),new Position(bottomRightLineX, bottomRightLineX, bottomRightLineZ)));
                            }
                        }
                    }
                }

                //Draw the Graphics
                if (pipeLugInputs.TopShape == 1) //Rounded
                {
                    symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    matrix.SetIdentity();
                    matrix.Rotate(topCurveStartAngle*Math.PI/180, new Vector(0, 0, 1));
                    Arc3d topArc = symbolGeometryHelper.CreateArc(null, pipeLugInputs.Offset1,(topCurveEndAngle - topCurveStartAngle)*Math.PI/180);topArc.Transform(matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Rotate((Math.PI/2), new Vector(1, 0, 0));
                    topArc.Transform(matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Translate(new Vector(0, -pipeLugInputs.Thickness1/2, pipeLugInputs.RodTakeOut));
                    topArc.Transform(matrix);
                    collection.Add(topArc);
                }
                else if (pipeLugInputs.TopShape == 2) //Squared
                    collection.Add(new Line3d(new Position(topLeftLineX, topLeftLineY, topLeftLineZ), new Position(topRightLineX, topRightLineY, topRightLineZ)));
                else if (pipeLugInputs.TopShape == 3) //Rounded
                {
                    collection.Add(new Line3d(new Position(-pipeLugInputs.Width1/4, -pipeLugInputs.Thickness1/2,pipeLugInputs.RodTakeOut + pipeLugInputs.Offset1),new Position(pipeLugInputs.Width1/4, -pipeLugInputs.Thickness1/2,pipeLugInputs.RodTakeOut + pipeLugInputs.Offset1)));
                    //LeftArc
                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    matrix.SetIdentity();
                    matrix.Rotate(Math.PI/2, new Vector(0, 0, 1));
                    Arc3d leftArc = symbolGeometryHelper.CreateArc(null, pipeLugInputs.Width1/4, Math.PI/2);
                    leftArc.Transform(matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Rotate((Math.PI/2), new Vector(1, 0, 0));
                    leftArc.Transform(matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Translate(new Vector(-pipeLugInputs.Width1/4, -pipeLugInputs.Thickness1/2,
                    pipeLugInputs.RodTakeOut + pipeLugInputs.Offset1 - pipeLugInputs.Width1/4));
                    leftArc.Transform(matrix);
                    collection.Add(leftArc);
                    //RightArc
                    symbolGeometryHelper = new SymbolGeometryHelper();
                    symbolGeometryHelper.ActivePosition = new Position(0, 0, 0);
                    symbolGeometryHelper.SetOrientation(new Vector(1, 0, 0), new Vector(0, 1, 0));
                    Arc3d rightArc = symbolGeometryHelper.CreateArc(null, pipeLugInputs.Width1/4, Math.PI/2);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Rotate((Math.PI/2), new Vector(1, 0, 0));
                    rightArc.Transform(matrix);

                    matrix = new Matrix4X4();
                    matrix.SetIdentity();
                    matrix.Translate(new Vector(pipeLugInputs.Width1/4, -pipeLugInputs.Thickness1/2,pipeLugInputs.RodTakeOut + pipeLugInputs.Offset1 - pipeLugInputs.Width1/4));rightArc.Transform(matrix);
                    collection.Add(rightArc);
                }
                else if (pipeLugInputs.TopShape == 4) //Chamfered
                {
                    //TopLine                    
                    collection.Add(new Line3d( new Position(-pipeLugInputs.Width1/2 + X, -pipeLugInputs.Thickness1/2,pipeLugInputs.RodTakeOut + pipeLugInputs.Offset1),new Position(pipeLugInputs.Width1/2 - X, -pipeLugInputs.Thickness1/2,pipeLugInputs.RodTakeOut + pipeLugInputs.Offset1)));
                    //LeftTaper                    
                    collection.Add(new Line3d(new Position(-pipeLugInputs.Width1/2 + X, -pipeLugInputs.Thickness1/2,pipeLugInputs.RodTakeOut + pipeLugInputs.Offset1),new Position(-pipeLugInputs.Width1/2, -pipeLugInputs.Thickness1/2,pipeLugInputs.RodTakeOut + pipeLugInputs.Offset1 - Z)));
                    //RightTaper                    
                    collection.Add(new Line3d(new Position(pipeLugInputs.Width1/2 - X, -pipeLugInputs.Thickness1/2,pipeLugInputs.RodTakeOut + pipeLugInputs.Offset1),new Position(pipeLugInputs.Width1/2, -pipeLugInputs.Thickness1/2,pipeLugInputs.RodTakeOut + pipeLugInputs.Offset1 - Z)));
                }

                //LeftLine                
                collection.Add(new Line3d(new Position(topLeftLineX, topLeftLineY, topLeftLineZ),new Position(bottomLeftLineX, bottomLeftLineY, bottomLeftLineZ)));

                //RightLine                
                collection.Add(new Line3d(new Position(topRightLineX, topRightLineY, topRightLineZ),new Position(bottomRightLineX, bottomRightLineY, bottomRightLineZ)));

                Projection3d weldingLugShape = new Projection3d(OccurrenceConnection, new ComplexString3d(collection), new Vector(0, 1, 0), pipeLugInputs.Thickness1, true);weldingLugShape.Transform(Matrix);
                outputs.Add(outputName, weldingLugShape);
            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrAddWeldingLug, "Error in Adding Welding Lug.");
                }

            }
        }

        /// <summary>
        /// Defines the inputs for the Insulation.
        /// </summary>
        public struct InsulationInputs
        {
            /// Specifies the OuterDia of the Pipe where the part is placed.
            /// </summary>
            public double PipeOD;
            /// <summary>
            /// Specifies the outer diameter of the insulation.
            /// </summary>
            public double Diameter1;
            /// <summary>
            /// Specifies the length of the insulation.
            /// </summary>
            public double Length;
            /// <summary>
            /// Specifies the width of the cradle.
            /// </summary>
            public double Width1;
            /// <summary>
            ///Specifies the height of the cradle.
            /// </summary>
            public double Height1;
            /// <summary>
            ///Specifies the length of the cradle.
            /// </summary>
            public double Length1;
            /// <summary>
            ///Specifies the width of the straps.
            /// </summary>
            public double Width2;
            /// <summary>
            ///Specifies the thickness of the straps.
            /// </summary>
            public double Thickness2;
            /// <summary>
            ///Specifies the offset from the ends of the insulation.
            /// </summary>
            public double Offset2;
            /// <summary>
            ///Specifies the number of layers of insulation.
            /// </summary>
            public int LayerQty;
            /// <summary>
            ///Specifies the offset for each layer of insulation.
            /// </summary>
            public double Offset1;
        }

        /// <summary>
        /// Load the data for WLA.
        /// </summary>
        public InsulationInputs LoadInsulatInputsData(int startIndex)
        {
            InsulationInputs INSULATInputs = new InsulationInputs();
            try
            {
                INSULATInputs.PipeOD = GetDoubleInputValue(startIndex);
                INSULATInputs.Diameter1 = GetDoubleInputValue(++startIndex);
                INSULATInputs.Length = GetDoubleInputValue(++startIndex);
                INSULATInputs.Width1 = GetDoubleInputValue(++startIndex);
                INSULATInputs.Height1 = GetDoubleInputValue(++startIndex);
                INSULATInputs.Length1 = GetDoubleInputValue(++startIndex);
                INSULATInputs.Width2 = GetDoubleInputValue(++startIndex);
                INSULATInputs.Thickness2 = GetDoubleInputValue(++startIndex);
                INSULATInputs.Offset2 = GetDoubleInputValue(++startIndex);
                INSULATInputs.LayerQty = (int)GetDoubleInputValue(++startIndex);
                INSULATInputs.Offset1 = GetDoubleInputValue(++startIndex);

            }
            catch
            {
                if (base.ToDoListMessage == null) //Check ToDoListMessgae created already or not
                {
                    RaiseSmartPartTDLError(SmartPartSymbolResourceIDs.ErrLoadPipeLugInputsData, "Error occured in  LoadWLAInputsData Method.");
                }
            }
            return INSULATInputs;
        }

        /// <summary>
        /// Raises the TDL and Exception
        /// </summary>
        /// <param name="iMessageID">The Message ID from Resource Identifier.</param>
        /// <param name="sDefaultMessage">TDL Message String.</param>
        ///  RaiseSmartPartTDLError(1, "Default String")
        /// </code>
        public void RaiseSmartPartTDLError(int iMessageID, string sDefaultMessage)
        {
            ToDoListMessage = new ToDoListMessage(ToDoMessageTypes.ToDoMessageError, SmartPartLocalizer.GetString(iMessageID, sDefaultMessage));
            SmartPartSymbolException HgrSupportCompException = new SmartPartSymbolException(iMessageID, sDefaultMessage);
            throw HgrSupportCompException;
        }
    }
}
